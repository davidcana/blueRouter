(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*! bluerouter - v0.1.0 - 2025-01-16 13:31:28 */
/**
 * A namespace.
 * @const
 */
const blueRouter = {};


/** @constructor */
blueRouter.router = function ( userOptions ) {

    // Init options
    this.options = {};
    blueRouter.utils.extend( this.options, blueRouter.defaultOptions, userOptions );
    this.checkOptions();

    // Preload pages if needed
    if ( this.options.preloadPagesOnLoad ){
        let self = this;
        blueRouter.htmlFetcher.loadAllUrls(
            this,
            () => {
                self.init();
            }
        );
        return;
    }

    // Do not preload pages, run init
    this.init();
};

/* Methods */

/** @suppress {missingProperties} */
blueRouter.router.prototype.init = function() {

    // Init some other vars
    this.routesMap = this.createRoutesMap();
    this.stack = [];

    // Add event listeners
    this.addEventListenersForWindow();

    // Navigate to window.location.href or home
    this.navigateUrl(
        this.options.updateOnLoad? window.location.href: '',
        this.options.animateTransitionsOnLoad
    );
};

// Check that mandatory user defined properties are defined
/** @suppress {missingProperties} */
blueRouter.router.prototype.checkOptions = function() {

    let errors = 0;
    let errorMessages = '';

    if ( ! this.options.routes ){
        ++errors;
        errorMessages += 'routes must be defined. ';
    }

    if ( ! this.options.eventsByPage ){
        ++errors;
        errorMessages += 'eventsByPage must be defined. ';
    }

    if ( errors ){
        this.alertError( 'Unable to initalize Blue router. ' + errors + ' errors found: ' + errorMessages );
    }
};

blueRouter.router.prototype.alertError = function( message ){
    alert( message );
    throw message;
};

blueRouter.router.prototype.addEventListenersForWindow = function() {
    /*
    window.onload = () => {
        this.navigateUrl( this.options.updateOnLoad? window.location.href: '', true );
    }
    */
    window.onpopstate = ( e ) => {
        this.navigateUrl( window.location.href, true );
        //this.navigateUrl( e.state[ 'page' ], true );
    };
};

/** @suppress {missingProperties} */
blueRouter.router.prototype.addEventListenersForLinks = function( pageId ) {
    
    let self = this;

    // Add event listeners for a elements
    blueRouter.utils.addEventListenerOnList(
        //document.getElementsByTagName( 'a' ),
        document.getElementById( pageId ).getElementsByTagName( 'a' ),
        'click', 
        (e) => {
            const href = e.target.getAttribute( 'href' );

            // Follow the link if it is external (if it is marked as external in the class list)
            /*
            if ( e.target.classList.contains ( self.options.externalClass ) ){
                return;
            }
            */
            // Follow the link if it is external (if it does not start by !)
            if ( ! href.startsWith( self.options.PAGE_PREFIX ) ){
                return;
            }

            e.preventDefault();
            history.pushState(
                {
                    'page': href
                },
                'page ' + href,
                '#' + href
            );
            self.navigateUrl( href, true );
        }
    );
};

// Create a map with the data in routes, using the path as the key
blueRouter.router.prototype.createRoutesMap = function() {

    const routerMap = {};
    const routes = this.options.routes || [];

    routes.map( routeItem => {
        routerMap[ routeItem.id ] = routeItem;
    });

    return routerMap;
};

/** @suppress {missingProperties} */
blueRouter.router.prototype.getRouteItem = function( pageId ) {

    // Look for the route
    let routeItem = this.routesMap[ pageId ];
    if ( routeItem ){
        return routeItem;
    }

    // No route found, 404 error
    routeItem = this.routesMap[ this.options.PAGE_ID_404_ERROR ];
    if ( routeItem ){
        return routeItem;
    }

    // No 404 page, build a 404 route
    return {
        id: this.options.PAGE_ID_404_ERROR,
        content: '<h3>404 - Page not found: ' + pageId + '</h3>'
    };
    //this.alertError( 'No route found with id ' + pageId + ' and no 404 page found.' );
};

blueRouter.router.prototype.navigateUrl = function( url, mustAnimateByCode ) {
    //alert( 'navigateUrl\nurl: ' + url );

    // Create an url object to make it easy everything
    let urlObject = blueRouter.utils.analizeUrl( url, this.options );

    // Update stack and get currentPageId
    let currentPageId = this.updateStack( urlObject.page );

    // Exit if trying to navigate to current page
    if ( currentPageId == urlObject.page ){
        return;
    }

    // Get the content
    let content = this.getContentForPage( urlObject.page );
    
    // If content is a Promise wait and resolve it
    let self = this;
    if ( content instanceof Promise ){
        content.then( function( text ){
            // Update content of route
            let routeItem = self.getRouteItem( urlObject.page );
            routeItem.content = text;

            // Run doPageTransition
            self.doPageTransition( text, urlObject.page, currentPageId, urlObject, mustAnimateByCode );
        });
        return;
    }

    // content is NOT a Promise: update current page
    this.doPageTransition( content, urlObject.page, currentPageId, urlObject, mustAnimateByCode );
};

blueRouter.router.prototype.updateStack = function( pageId ) {
    
    // If the penultimate element is the pageId then we are going backwards; otherwise we are going forward
    let isBackward = this.stack[ this.stack.length - 2 ] == pageId;

    if ( isBackward ){
        // Is backward
        return this.stack.pop();
    }

    // Is forward
    var currentPageId = this.stack[ this.stack.length - 1 ];
    this.stack.push( pageId );
    return currentPageId;
};

blueRouter.router.prototype.getContentForPage = function( pageId ) {

    // Get the routeItem from the routesMap
    let routeItem = this.getRouteItem( pageId );

    // Get the content of that route
    return this.getContentForRoute( routeItem );
};

blueRouter.router.prototype.getContentForRoute = function( routeItem ) {
    
    // Check keepAlive
    if ( routeItem.keepAlive ){
        let alivePage = document.getElementById( routeItem.id );
        if ( alivePage ){
            return alivePage;
        }
    }

    // Check content
    let content = routeItem.content;
    if ( content ){
        return content;
    }

    // Check url
    let url = routeItem.url;
    if ( url ){
        return blueRouter.htmlFetcher.loadUrl( url );
    }

    return '<div id="error">No content found for route from path ' + routeItem.id + '</div>';
};

/** @suppress {missingProperties} */
blueRouter.router.prototype.doPageTransition = function( content, nextPageId, currentPageId, urlObject, mustAnimateByCode ) {

    // Get mustAnimateOut and mustAnimateIn
    const mustAnimateOut = mustAnimateByCode && !!this.options.animationOut;
    const mustAnimateIn = mustAnimateByCode && !!this.options.animationIn;

    // Get the initEvent
    const initEvent = content instanceof HTMLElement? blueRouter.defaultOptions.EVENT_REINIT: blueRouter.defaultOptions.EVENT_INIT;

    // Run events
    this.runEvent( blueRouter.defaultOptions.EVENT_BEFORE_OUT, currentPageId, {} );

    // Get the currentPage and add next page
    let currentPage = document.getElementsByClassName( 'currentPage' )[0];
    let newPage = this.addNextPage( currentPage, content, nextPageId );

    // Render next page
    this.runRenderRelated( initEvent, nextPageId, urlObject );

    // Define currentPageAnimationendListener and newPageAnimationendListener
    let self = this;
    let currentPageAnimationendListener = () => {
        currentPage.removeEventListener( 'animationend', currentPageAnimationendListener );
        
        // Remove hidden class, add animationIn class
        newPage.classList.remove( 'hidden' );
        if ( mustAnimateIn ){
            newPage.classList.add( this.options.animationIn );
        }

        // Retire current page: save it as an alive page or remove it
        this.retireCurrentPage( currentPageId, currentPage );
        self.runEvent( blueRouter.defaultOptions.EVENT_AFTER_OUT, currentPageId, {} );

        //  Run newPageAnimationendListener if listener of amimationend on newPage was not added
        if ( ! mustAnimateIn ) {
            newPageAnimationendListener();
        }
    };

    let newPageAnimationendListener = () => {
        newPage.removeEventListener( 'animationend', newPageAnimationendListener );

        // Remove nextPage class, add currentPage class, remove animationIn class
        newPage.classList.remove( 'nextPage' );
        newPage.classList.add( 'currentPage' );
        if ( mustAnimateIn ){
            newPage.classList.remove( this.options.animationIn );
        }

        // Run EVENT_INIT or EVENT_REINIT
        self.runEvent( initEvent, nextPageId, urlObject );

        // Run EVENT_MOUNTED
        self.runEvent( blueRouter.defaultOptions.EVENT_MOUNTED, nextPageId, urlObject );
    };

    // Add event listeners
    if ( mustAnimateOut ){
        currentPage.addEventListener( 'animationend', currentPageAnimationendListener );
    }
    if ( mustAnimateIn ){
        newPage.addEventListener( 'animationend', newPageAnimationendListener );
    }

    // Animate!
    if ( mustAnimateOut ){
        currentPage.classList.add( this.options.animationOut );
    } else {
        currentPageAnimationendListener();
    }
};

/** @suppress {missingProperties} */
blueRouter.router.prototype.runRenderRelated = function( initEvent, nextPageId, urlObject ){

    // Run preEvent (EVENT_PRE_INIT or EVENT_PRE_REINIT)
    const preEvent = initEvent ===  this.options.EVENT_INIT?
        this.options.EVENT_PRE_INIT:
        this.options.EVENT_PRE_REINIT

    this.runEvent( preEvent, nextPageId, urlObject );

    // Run render if needed
    const routeItem = this.getRouteItem( nextPageId );
    const renderOption = initEvent ===  this.options.EVENT_INIT?
        this.options.RUN_RENDER_BEFORE_EVENT_INIT:
        this.options.RUN_RENDER_BEFORE_EVENT_REINIT;
    const routeProperty = initEvent ===  this.options.EVENT_INIT?
        'runRenderBeforeInit':
        'runRenderBeforeReinit';
    const mustRunRender = routeItem[ routeProperty ] === undefined?
        renderOption:
        routeItem[ routeProperty ];

    if ( mustRunRender && this.options.renderFunction && blueRouter.utils.isFunction( this.options.renderFunction ) ){
        this.options.renderFunction(
            this.buildPageInstance( nextPageId )
        );
    }
};

blueRouter.router.prototype.buildPageInstance = function( pageId ){

    return {
         'id': pageId,
         'el': document.getElementById( pageId )
    };
};

blueRouter.router.prototype.addNextPage = function( currentPage, content, nextPageId ){

    if ( content instanceof HTMLElement ){
        // content is HTMLElement
        currentPage.insertAdjacentElement(
            'afterend',
            content
        );
        content.classList.add( 'nextPage' );
        content.classList.add( 'hidden' );
        content.classList.remove( 'alive' );

    } else {
        // content must be text
        currentPage.insertAdjacentHTML(
            'afterend',
            '<div class="nextPage hidden page" id="' + nextPageId + '">'
            + content
            + '</div>'
        );
    }

    return document.getElementById( nextPageId );
};

// Retire current page: save it as an alive page or remove it
blueRouter.router.prototype.retireCurrentPage = function( currentPageId, currentPage ){

    let currentRoute = this.getRouteItem( currentPageId );

    // If must keep alive current page, set page and alive as classes removing the rest
    if ( currentRoute && currentRoute.keepAlive){
        currentPage.removeAttribute( 'class' );
        currentPage.classList.add( 'page' );
        currentPage.classList.add( 'alive' );
        return;
    }

    // Do not keep alive current page, so remove it
    currentPage.remove();
};

blueRouter.router.prototype.runEvent = function( eventId, pageId, urlObject ) {

    if ( eventId == blueRouter.defaultOptions.EVENT_INIT ){
        this.addEventListenersForLinks( pageId );
    }

    // Get the page object from options
    /** @suppress {missingProperties} */
    let page = this.options.eventsByPage[ pageId ];

    // If a page is found, run the event handler
    if ( page ){
        let event = {
            params: urlObject.params || {}
        };
        if ( page[ eventId ] && blueRouter.utils.isFunction( page[ eventId ] ) ){
            page[ eventId ]( event );
        }
    }
};


// Default options

blueRouter.defaultOptions = {
    updateOnLoad: true,
    preloadPagesOnLoad: false,

    // Animations
    animationOut: 'slide-out-top',
    //animationOut: false,
    animationIn: 'scale-in-center',
    //animationIn: false,
    animateTransitionsOnLoad: false,
    
    // Misc
    PAGE_PREFIX: '!',

    // Special pages ids
    PAGE_ID_HOME: '[home]',
    PAGE_ID_404_ERROR: '[404]',

    // Events
    EVENT_PRE_INIT: 'preInit',
    EVENT_INIT: 'init',
    EVENT_PRE_REINIT: 'preReinit',
    EVENT_REINIT: 'reinit',
    EVENT_MOUNTED: 'mounted',
    EVENT_BEFORE_OUT: 'beforeOut',
    EVENT_AFTER_OUT: 'afterOut',

    RUN_RENDER_BEFORE_EVENT_INIT: true,
    RUN_RENDER_BEFORE_EVENT_REINIT: false

};


blueRouter.htmlFetcher = {};

blueRouter.htmlFetcher.loadAllUrls = function( router, callback ){

    // Get the routes to use
    const routes = router.options.routes || [];

    // Init the number ot urls to get
    let pending = 0;

    // Iterate urlRoutes and load each routeItem if needed
    routes.map( routeItem => {
        let url = routeItem.url;
        if ( url ){
            ++pending;
            blueRouter.htmlFetcher.loadUrl( url ).then(
                function( text ){
                    // Update content of route
                    routeItem.content = text;

                    // Run callback when all files have been loaded
                    if ( --pending == 0 && callback && blueRouter.utils.isFunction( callback ) ){
                        callback();
                    }
                }
            );
        }
    });
};

/**
 * @param {string} url
 * 
 */
blueRouter.htmlFetcher.loadUrl = async function( url ){

    const response = await fetch( url );

    if ( ! response.ok ) {
        const message = `Error fetching ${url} has occured: ${response.status}`;
        alert ( message );
        throw new Error( message );
    }
  
    const text = await response.text();
    return text;
};

blueRouter.utils = {};

/*
    Builds an object with data about the url. An example:

    url : http://127.0.0.1:9000/samples/sample.html#!about?param1=a&param2=b"

    prepage: http://127.0.0.1:9000/samples/sample.html
    page: about
    params: {
        param1: a
        param2: b
    }
*/
blueRouter.utils.analizeUrl = function( url, options ) {
    
    let result = {};

    // Extract the parts before and after PAGE_PREFIX
    let urlParts = url.split( options.PAGE_PREFIX );
    result.prepage = urlParts[ 0 ];
    let postPath = urlParts[ 1 ] || '';

    // Remove # if present
    if ( result.prepage.endsWith( '#' ) ){
        result.prepage = result.prepage.slice( 0, -1 );
    }

    // Extract the parts before and after ?
    let pathParts = postPath.split( '?' );
    result.page = pathParts[ 0 ];

    // Fix home page
    if ( result.page == '') {
        result.page = options.PAGE_ID_HOME;
    }

    let paramsString = pathParts[ 1 ] || '';

    // Add params
    result.params = {};
    if ( paramsString == '' ){
        return result;
    }
    let vars = paramsString.split( '&' );
    for ( let i = 0; i < vars.length; i++ ) {
        let pair = vars[ i ].split( '=' );
        let paramName = pair[ 0 ];
        let paramValue = pair[ 1 ];
        result.params[ paramName ] = paramValue;
    }

    return result;
};

blueRouter.utils.addEventListenerOnList = function( list, event, fn ) {

    for ( let i = 0, len = list.length; i < len; i++ ) {
        list[ i ].addEventListener( event, fn, false );
    }
};

blueRouter.utils.extend = function( out, from1, from2 ) {
    out = out || {};

    for ( var i = 1; i < arguments.length; i++ ) {
        if ( ! arguments[ i ] ){
            continue;
        }

        for ( var key in arguments[ i ] ) {
            if ( arguments[ i ].hasOwnProperty( key ) ){
                out[ key ] = arguments[ i ][ key ];
            }
        }
    }

    return out;
};

/* formatString */
// Example: itils.formatString( '{0} is dead, but {1} is alive!', 'ASP', 'ASP.NET' )
/**
 * Takes 1 or more strings and do something cool with them.
 * @param {...string|number} format
 */
blueRouter.utils.formatString = function( format ) {
    
    var args = Array.prototype.slice.call( arguments, 1 );
    return format.replace(/{(\d+)}/g, function ( match, number ) {
        return typeof args[ number ] != 'undefined'? args[ number ] : match;
    });
};

blueRouter.utils.isFunction = function isFunction( obj ) {

    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    return typeof obj === "function" && typeof obj.nodeType !== "number";
};
/* end of utils */

// Register blueRouter if we are using Node
if ( typeof module === 'object' && module.exports ) {
    module.exports = blueRouter;
}

},{}],2:[function(require,module,exports){
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.loadjs = factory();
  }
}(this, function() {
/**
 * Global dependencies.
 * @global {Object} document - DOM
 */

var devnull = function() {},
    bundleIdCache = {},
    bundleResultCache = {},
    bundleCallbackQueue = {};


/**
 * Subscribe to bundle load event.
 * @param {string[]} bundleIds - Bundle ids
 * @param {Function} callbackFn - The callback function
 */
function subscribe(bundleIds, callbackFn) {
  // listify
  bundleIds = bundleIds.push ? bundleIds : [bundleIds];

  var depsNotFound = [],
      i = bundleIds.length,
      numWaiting = i,
      fn,
      bundleId,
      r,
      q;

  // define callback function
  fn = function (bundleId, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId);

    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };

  // register callback
  while (i--) {
    bundleId = bundleIds[i];

    // execute callback if in result cache
    r = bundleResultCache[bundleId];
    if (r) {
      fn(bundleId, r);
      continue;
    }

    // add to callback queue
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}


/**
 * Publish bundle load event.
 * @param {string} bundleId - Bundle id
 * @param {string[]} pathsNotFound - List of files not found
 */
function publish(bundleId, pathsNotFound) {
  // exit if id isn't defined
  if (!bundleId) return;

  var q = bundleCallbackQueue[bundleId];

  // cache result
  bundleResultCache[bundleId] = pathsNotFound;

  // exit if queue is empty
  if (!q) return;

  // empty callback queue
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}


/**
 * Execute callbacks.
 * @param {Object or Function} args - The callback args
 * @param {string[]} depsNotFound - List of dependencies not found
 */
function executeCallbacks(args, depsNotFound) {
  // accept function as argument
  if (args.call) args = {success: args};

  // success and error callbacks
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}


/**
 * Load individual file.
 * @param {string} path - The file path
 * @param {Function} callbackFn - The callback function
 */
function loadFile(path, callbackFn, args, numTries) {
  var doc = document,
      async = args.async,
      maxTries = (args.numRetries || 0) + 1,
      beforeCallbackFn = args.before || devnull,
      pathname = path.replace(/[\?|#].*$/, ''),
      pathStripped = path.replace(/^(css|img|module|nomodule)!/, ''),
      isLegacyIECss,
      hasModuleSupport,
      e;

  numTries = numTries || 0;

  if (/(^css!|\.css$)/.test(pathname)) {
    // css
    e = doc.createElement('link');
    e.rel = 'stylesheet';
    e.href = pathStripped;

    // tag IE9+
    isLegacyIECss = 'hideFocus' in e;

    // use preload in IE Edge (to detect load errors)
    if (isLegacyIECss && e.relList) {
      isLegacyIECss = 0;
      e.rel = 'preload';
      e.as = 'style';
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    // image
    e = doc.createElement('img');
    e.src = pathStripped;    
  } else {
    // javascript
    e = doc.createElement('script');
    e.src = pathStripped;
    e.async = async === undefined ? true : async;

    // handle es modules
    // modern browsers:
    //   module: add to dom with type="module"
    //   nomodule: call success() callback without adding to dom
    // legacy browsers:
    //   module: call success() callback without adding to dom
    //   nomodule: add to dom with default type ("text/javascript")
    hasModuleSupport = 'noModule' in e;
    if (/^module!/.test(pathname)) {
      if (!hasModuleSupport) return callbackFn(path, 'l');
      e.type = "module";
    } else if (/^nomodule!/.test(pathname) && hasModuleSupport) return callbackFn(path, 'l');
  }

  e.onload = e.onerror = e.onbeforeload = function (ev) {
    var result = ev.type[0];

    // treat empty stylesheets as failures to get around lack of onerror
    // support in IE9-11
    if (isLegacyIECss) {
      try {
        if (!e.sheet.cssText.length) result = 'e';
      } catch (x) {
        // sheets objects created from load errors don't allow access to
        // `cssText` (unless error is Code:18 SecurityError)
        if (x.code != 18) result = 'e';
      }
    }

    // handle retries in case of load failure
    if (result == 'e') {
      // increment counter
      numTries += 1;

      // exit function and try again
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e.rel == 'preload' && e.as == 'style') {
      // activate preloaded stylesheets
      return e.rel = 'stylesheet'; // jshint ignore:line
    }
    
    // execute callback
    callbackFn(path, result, ev.defaultPrevented);
  };

  // add to document (unless callback returns `false`)
  if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);
}


/**
 * Load multiple files.
 * @param {string[]} paths - The file paths
 * @param {Function} callbackFn - The callback function
 */
function loadFiles(paths, callbackFn, args) {
  // listify paths
  paths = paths.push ? paths : [paths];

  var numWaiting = paths.length,
      x = numWaiting,
      pathsNotFound = [],
      fn,
      i;

  // define callback function
  fn = function(path, result, defaultPrevented) {
    // handle error
    if (result == 'e') pathsNotFound.push(path);

    // handle beforeload event. If defaultPrevented then that means the load
    // will be blocked (ex. Ghostery/ABP on Safari)
    if (result == 'b') {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }

    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  };

  // load scripts
  for (i=0; i < x; i++) loadFile(paths[i], fn, args);
}


/**
 * Initiate script load and register bundle.
 * @param {(string|string[])} paths - The file paths
 * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success
 *   callback or (3) object literal with success/error arguments, numRetries,
 *   etc.
 * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object
 *   literal with success/error arguments, numRetries, etc.
 */
function loadjs(paths, arg1, arg2) {
  var bundleId,
      args;

  // bundleId (if string)
  if (arg1 && arg1.trim) bundleId = arg1;

  // args (default is {})
  args = (bundleId ? arg2 : arg1) || {};

  // throw error if bundle is already defined
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }

  function loadFn(resolve, reject) {
    loadFiles(paths, function (pathsNotFound) {
      // execute callbacks
      executeCallbacks(args, pathsNotFound);
      
      // resolve Promise
      if (resolve) {
        executeCallbacks({success: resolve, error: reject}, pathsNotFound);
      }

      // publish bundle load event
      publish(bundleId, pathsNotFound);
    }, args);
  }
  
  if (args.returnPromise) return new Promise(loadFn);
  else loadFn();
}


/**
 * Execute callbacks when dependencies have been satisfied.
 * @param {(string|string[])} deps - List of bundle ids
 * @param {Object} args - success/error arguments
 */
loadjs.ready = function ready(deps, args) {
  // subscribe to bundle load event
  subscribe(deps, function (depsNotFound) {
    // execute callbacks
    executeCallbacks(args, depsNotFound);
  });

  return loadjs;
};


/**
 * Manually satisfy bundle dependencies.
 * @param {string} bundleId - The bundle id
 */
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};


/**
 * Reset loadjs dependencies statuses
 */
loadjs.reset = function reset() {
  bundleIdCache = {};
  bundleResultCache = {};
  bundleCallbackQueue = {};
};


/**
 * Determine if bundle has already been defined
 * @param String} bundleId - The bundle id
 */
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};


// export
return loadjs;

}));

},{}],3:[function(require,module,exports){
/**
 * Copyright 2015 Tim Down.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


(function(factory,root){if(typeof define=="function"&&define.amd){define(factory);}else if(typeof module!="undefined"&&typeof exports=="object"){module.exports=factory();}else{root.log4javascript=factory();}})(function(){if(!Array.prototype.push){Array.prototype.push=function(){for(var i=0,len=arguments.length;i<len;i++){this[this.length]=arguments[i];}
return this.length;};}
if(!Array.prototype.shift){Array.prototype.shift=function(){if(this.length>0){var firstItem=this[0];for(var i=0,len=this.length-1;i<len;i++){this[i]=this[i+1];}
this.length=this.length-1;return firstItem;}};}
if(!Array.prototype.splice){Array.prototype.splice=function(startIndex,deleteCount){var itemsAfterDeleted=this.slice(startIndex+deleteCount);var itemsDeleted=this.slice(startIndex,startIndex+deleteCount);this.length=startIndex;var argumentsArray=[];for(var i=0,len=arguments.length;i<len;i++){argumentsArray[i]=arguments[i];}
var itemsToAppend=(argumentsArray.length>2)?itemsAfterDeleted=argumentsArray.slice(2).concat(itemsAfterDeleted):itemsAfterDeleted;for(i=0,len=itemsToAppend.length;i<len;i++){this.push(itemsToAppend[i]);}
return itemsDeleted;};}
function isUndefined(obj){return typeof obj=="undefined";}
function EventSupport(){}
EventSupport.prototype={eventTypes:[],eventListeners:{},setEventTypes:function(eventTypesParam){if(eventTypesParam instanceof Array){this.eventTypes=eventTypesParam;this.eventListeners={};for(var i=0,len=this.eventTypes.length;i<len;i++){this.eventListeners[this.eventTypes[i]]=[];}}else{handleError("log4javascript.EventSupport ["+this+"]: setEventTypes: eventTypes parameter must be an Array");}},addEventListener:function(eventType,listener){if(typeof listener=="function"){if(!array_contains(this.eventTypes,eventType)){handleError("log4javascript.EventSupport ["+this+"]: addEventListener: no event called '"+eventType+"'");}
this.eventListeners[eventType].push(listener);}else{handleError("log4javascript.EventSupport ["+this+"]: addEventListener: listener must be a function");}},removeEventListener:function(eventType,listener){if(typeof listener=="function"){if(!array_contains(this.eventTypes,eventType)){handleError("log4javascript.EventSupport ["+this+"]: removeEventListener: no event called '"+eventType+"'");}
array_remove(this.eventListeners[eventType],listener);}else{handleError("log4javascript.EventSupport ["+this+"]: removeEventListener: listener must be a function");}},dispatchEvent:function(eventType,eventArgs){if(array_contains(this.eventTypes,eventType)){var listeners=this.eventListeners[eventType];for(var i=0,len=listeners.length;i<len;i++){listeners[i](this,eventType,eventArgs);}}else{handleError("log4javascript.EventSupport ["+this+"]: dispatchEvent: no event called '"+eventType+"'");}}};var applicationStartDate=new Date();var uniqueId="log4javascript_"+applicationStartDate.getTime()+"_"+
Math.floor(Math.random()*100000000);var emptyFunction=function(){};var newLine="\r\n";var pageLoaded=false;function Log4JavaScript(){}
Log4JavaScript.prototype=new EventSupport();var log4javascript=new Log4JavaScript();log4javascript.version="1.4.13";log4javascript.edition="log4javascript";function toStr(obj){if(obj&&obj.toString){return obj.toString();}else{return String(obj);}}
function getExceptionMessage(ex){if(ex.message){return ex.message;}else if(ex.description){return ex.description;}else{return toStr(ex);}}
function getUrlFileName(url){var lastSlashIndex=Math.max(url.lastIndexOf("/"),url.lastIndexOf("\\"));return url.substr(lastSlashIndex+1);}
function getExceptionStringRep(ex){if(ex){var exStr="Exception: "+getExceptionMessage(ex);try{if(ex.lineNumber){exStr+=" on line number "+ex.lineNumber;}
if(ex.fileName){exStr+=" in file "+getUrlFileName(ex.fileName);}}catch(localEx){logLog.warn("Unable to obtain file and line information for error");}
if(showStackTraces&&ex.stack){exStr+=newLine+"Stack trace:"+newLine+ex.stack;}
return exStr;}
return null;}
function bool(obj){return Boolean(obj);}
function trim(str){return str.replace(/^\s+/,"").replace(/\s+$/,"");}
function splitIntoLines(text){var text2=text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");return text2.split("\n");}
var urlEncode=(typeof window.encodeURIComponent!="undefined")?function(str){return encodeURIComponent(str);}:function(str){return escape(str).replace(/\+/g,"%2B").replace(/"/g,"%22").replace(/'/g,"%27").replace(/\//g,"%2F").replace(/=/g,"%3D");};function array_remove(arr,val){var index=-1;for(var i=0,len=arr.length;i<len;i++){if(arr[i]===val){index=i;break;}}
if(index>=0){arr.splice(index,1);return true;}else{return false;}}
function array_contains(arr,val){for(var i=0,len=arr.length;i<len;i++){if(arr[i]==val){return true;}}
return false;}
function extractBooleanFromParam(param,defaultValue){if(isUndefined(param)){return defaultValue;}else{return bool(param);}}
function extractStringFromParam(param,defaultValue){if(isUndefined(param)){return defaultValue;}else{return String(param);}}
function extractIntFromParam(param,defaultValue){if(isUndefined(param)){return defaultValue;}else{try{var value=parseInt(param,10);return isNaN(value)?defaultValue:value;}catch(ex){logLog.warn("Invalid int param "+param,ex);return defaultValue;}}}
function extractFunctionFromParam(param,defaultValue){if(typeof param=="function"){return param;}else{return defaultValue;}}
function isError(err){return(err instanceof Error);}
if(!Function.prototype.apply){Function.prototype.apply=function(obj,args){var methodName="__apply__";if(typeof obj[methodName]!="undefined"){methodName+=String(Math.random()).substr(2);}
obj[methodName]=this;var argsStrings=[];for(var i=0,len=args.length;i<len;i++){argsStrings[i]="args["+i+"]";}
var script="obj."+methodName+"("+argsStrings.join(",")+")";var returnValue=eval(script);delete obj[methodName];return returnValue;};}
if(!Function.prototype.call){Function.prototype.call=function(obj){var args=[];for(var i=1,len=arguments.length;i<len;i++){args[i-1]=arguments[i];}
return this.apply(obj,args);};}
var logLog={quietMode:false,debugMessages:[],setQuietMode:function(quietMode){this.quietMode=bool(quietMode);},numberOfErrors:0,alertAllErrors:false,setAlertAllErrors:function(alertAllErrors){this.alertAllErrors=alertAllErrors;},debug:function(message){this.debugMessages.push(message);},displayDebug:function(){alert(this.debugMessages.join(newLine));},warn:function(message,exception){},error:function(message,exception){if(++this.numberOfErrors==1||this.alertAllErrors){if(!this.quietMode){var alertMessage="log4javascript error: "+message;if(exception){alertMessage+=newLine+newLine+"Original error: "+getExceptionStringRep(exception);}
alert(alertMessage);}}}};log4javascript.logLog=logLog;log4javascript.setEventTypes(["load","error"]);function handleError(message,exception){logLog.error(message,exception);log4javascript.dispatchEvent("error",{"message":message,"exception":exception});}
log4javascript.handleError=handleError;var enabled=!((typeof log4javascript_disabled!="undefined")&&log4javascript_disabled);log4javascript.setEnabled=function(enable){enabled=bool(enable);};log4javascript.isEnabled=function(){return enabled;};var useTimeStampsInMilliseconds=true;log4javascript.setTimeStampsInMilliseconds=function(timeStampsInMilliseconds){useTimeStampsInMilliseconds=bool(timeStampsInMilliseconds);};log4javascript.isTimeStampsInMilliseconds=function(){return useTimeStampsInMilliseconds;};log4javascript.evalInScope=function(expr){return eval(expr);};var showStackTraces=false;log4javascript.setShowStackTraces=function(show){showStackTraces=bool(show);};var Level=function(level,name){this.level=level;this.name=name;};Level.prototype={toString:function(){return this.name;},equals:function(level){return this.level==level.level;},isGreaterOrEqual:function(level){return this.level>=level.level;}};Level.ALL=new Level(Number.MIN_VALUE,"ALL");Level.TRACE=new Level(10000,"TRACE");Level.DEBUG=new Level(20000,"DEBUG");Level.INFO=new Level(30000,"INFO");Level.WARN=new Level(40000,"WARN");Level.ERROR=new Level(50000,"ERROR");Level.FATAL=new Level(60000,"FATAL");Level.OFF=new Level(Number.MAX_VALUE,"OFF");log4javascript.Level=Level;function Timer(name,level){this.name=name;this.level=isUndefined(level)?Level.INFO:level;this.start=new Date();}
Timer.prototype.getElapsedTime=function(){return new Date().getTime()-this.start.getTime();};var anonymousLoggerName="[anonymous]";var defaultLoggerName="[default]";var nullLoggerName="[null]";var rootLoggerName="root";function Logger(name){this.name=name;this.parent=null;this.children=[];var appenders=[];var loggerLevel=null;var isRoot=(this.name===rootLoggerName);var isNull=(this.name===nullLoggerName);var appenderCache=null;var appenderCacheInvalidated=false;this.addChild=function(childLogger){this.children.push(childLogger);childLogger.parent=this;childLogger.invalidateAppenderCache();};var additive=true;this.getAdditivity=function(){return additive;};this.setAdditivity=function(additivity){var valueChanged=(additive!=additivity);additive=additivity;if(valueChanged){this.invalidateAppenderCache();}};this.addAppender=function(appender){if(isNull){handleError("Logger.addAppender: you may not add an appender to the null logger");}else{if(appender instanceof log4javascript.Appender){if(!array_contains(appenders,appender)){appenders.push(appender);appender.setAddedToLogger(this);this.invalidateAppenderCache();}}else{handleError("Logger.addAppender: appender supplied ('"+
toStr(appender)+"') is not a subclass of Appender");}}};this.removeAppender=function(appender){array_remove(appenders,appender);appender.setRemovedFromLogger(this);this.invalidateAppenderCache();};this.removeAllAppenders=function(){var appenderCount=appenders.length;if(appenderCount>0){for(var i=0;i<appenderCount;i++){appenders[i].setRemovedFromLogger(this);}
appenders.length=0;this.invalidateAppenderCache();}};this.getEffectiveAppenders=function(){if(appenderCache===null||appenderCacheInvalidated){var parentEffectiveAppenders=(isRoot||!this.getAdditivity())?[]:this.parent.getEffectiveAppenders();appenderCache=parentEffectiveAppenders.concat(appenders);appenderCacheInvalidated=false;}
return appenderCache;};this.invalidateAppenderCache=function(){appenderCacheInvalidated=true;for(var i=0,len=this.children.length;i<len;i++){this.children[i].invalidateAppenderCache();}};this.log=function(level,params){if(enabled&&level.isGreaterOrEqual(this.getEffectiveLevel())){var exception;var finalParamIndex=params.length-1;var lastParam=params[finalParamIndex];if(params.length>1&&isError(lastParam)){exception=lastParam;finalParamIndex--;}
var messages=[];for(var i=0;i<=finalParamIndex;i++){messages[i]=params[i];}
var loggingEvent=new LoggingEvent(this,new Date(),level,messages,exception);this.callAppenders(loggingEvent);}};this.callAppenders=function(loggingEvent){var effectiveAppenders=this.getEffectiveAppenders();for(var i=0,len=effectiveAppenders.length;i<len;i++){effectiveAppenders[i].doAppend(loggingEvent);}};this.setLevel=function(level){if(isRoot&&level===null){handleError("Logger.setLevel: you cannot set the level of the root logger to null");}else if(level instanceof Level){loggerLevel=level;}else{handleError("Logger.setLevel: level supplied to logger "+
this.name+" is not an instance of log4javascript.Level");}};this.getLevel=function(){return loggerLevel;};this.getEffectiveLevel=function(){for(var logger=this;logger!==null;logger=logger.parent){var level=logger.getLevel();if(level!==null){return level;}}};this.group=function(name,initiallyExpanded){if(enabled){var effectiveAppenders=this.getEffectiveAppenders();for(var i=0,len=effectiveAppenders.length;i<len;i++){effectiveAppenders[i].group(name,initiallyExpanded);}}};this.groupEnd=function(){if(enabled){var effectiveAppenders=this.getEffectiveAppenders();for(var i=0,len=effectiveAppenders.length;i<len;i++){effectiveAppenders[i].groupEnd();}}};var timers={};this.time=function(name,level){if(enabled){if(isUndefined(name)){handleError("Logger.time: a name for the timer must be supplied");}else if(level&&!(level instanceof Level)){handleError("Logger.time: level supplied to timer "+
name+" is not an instance of log4javascript.Level");}else{timers[name]=new Timer(name,level);}}};this.timeEnd=function(name){if(enabled){if(isUndefined(name)){handleError("Logger.timeEnd: a name for the timer must be supplied");}else if(timers[name]){var timer=timers[name];var milliseconds=timer.getElapsedTime();this.log(timer.level,["Timer "+toStr(name)+" completed in "+milliseconds+"ms"]);delete timers[name];}else{logLog.warn("Logger.timeEnd: no timer found with name "+name);}}};this.assert=function(expr){if(enabled&&!expr){var args=[];for(var i=1,len=arguments.length;i<len;i++){args.push(arguments[i]);}
args=(args.length>0)?args:["Assertion Failure"];args.push(newLine);args.push(expr);this.log(Level.ERROR,args);}};this.toString=function(){return"Logger["+this.name+"]";};}
Logger.prototype={trace:function(){this.log(Level.TRACE,arguments);},debug:function(){this.log(Level.DEBUG,arguments);},info:function(){this.log(Level.INFO,arguments);},warn:function(){this.log(Level.WARN,arguments);},error:function(){this.log(Level.ERROR,arguments);},fatal:function(){this.log(Level.FATAL,arguments);},isEnabledFor:function(level){return level.isGreaterOrEqual(this.getEffectiveLevel());},isTraceEnabled:function(){return this.isEnabledFor(Level.TRACE);},isDebugEnabled:function(){return this.isEnabledFor(Level.DEBUG);},isInfoEnabled:function(){return this.isEnabledFor(Level.INFO);},isWarnEnabled:function(){return this.isEnabledFor(Level.WARN);},isErrorEnabled:function(){return this.isEnabledFor(Level.ERROR);},isFatalEnabled:function(){return this.isEnabledFor(Level.FATAL);}};Logger.prototype.trace.isEntryPoint=true;Logger.prototype.debug.isEntryPoint=true;Logger.prototype.info.isEntryPoint=true;Logger.prototype.warn.isEntryPoint=true;Logger.prototype.error.isEntryPoint=true;Logger.prototype.fatal.isEntryPoint=true;var loggers={};var loggerNames=[];var ROOT_LOGGER_DEFAULT_LEVEL=Level.DEBUG;var rootLogger=new Logger(rootLoggerName);rootLogger.setLevel(ROOT_LOGGER_DEFAULT_LEVEL);log4javascript.getRootLogger=function(){return rootLogger;};log4javascript.getLogger=function(loggerName){if(typeof loggerName!="string"){loggerName=anonymousLoggerName;logLog.warn("log4javascript.getLogger: non-string logger name "+
toStr(loggerName)+" supplied, returning anonymous logger");}
if(loggerName==rootLoggerName){handleError("log4javascript.getLogger: root logger may not be obtained by name");}
if(!loggers[loggerName]){var logger=new Logger(loggerName);loggers[loggerName]=logger;loggerNames.push(loggerName);var lastDotIndex=loggerName.lastIndexOf(".");var parentLogger;if(lastDotIndex>-1){var parentLoggerName=loggerName.substring(0,lastDotIndex);parentLogger=log4javascript.getLogger(parentLoggerName);}else{parentLogger=rootLogger;}
parentLogger.addChild(logger);}
return loggers[loggerName];};var defaultLogger=null;log4javascript.getDefaultLogger=function(){if(!defaultLogger){defaultLogger=createDefaultLogger();}
return defaultLogger;};var nullLogger=null;log4javascript.getNullLogger=function(){if(!nullLogger){nullLogger=new Logger(nullLoggerName);nullLogger.setLevel(Level.OFF);}
return nullLogger;};log4javascript.resetConfiguration=function(){rootLogger.setLevel(ROOT_LOGGER_DEFAULT_LEVEL);loggers={};};var LoggingEvent=function(logger,timeStamp,level,messages,exception){this.logger=logger;this.timeStamp=timeStamp;this.timeStampInMilliseconds=timeStamp.getTime();this.timeStampInSeconds=Math.floor(this.timeStampInMilliseconds/1000);this.milliseconds=this.timeStamp.getMilliseconds();this.level=level;this.messages=messages;this.exception=exception;};LoggingEvent.prototype={getThrowableStrRep:function(){return this.exception?getExceptionStringRep(this.exception):"";},getCombinedMessages:function(){return(this.messages.length==1)?this.messages[0]:this.messages.join(newLine);},toString:function(){return"LoggingEvent["+this.level+"]";}};log4javascript.LoggingEvent=LoggingEvent;var Layout=function(){};Layout.prototype={defaults:{loggerKey:"logger",timeStampKey:"timestamp",millisecondsKey:"milliseconds",levelKey:"level",messageKey:"message",exceptionKey:"exception",urlKey:"url"},loggerKey:"logger",timeStampKey:"timestamp",millisecondsKey:"milliseconds",levelKey:"level",messageKey:"message",exceptionKey:"exception",urlKey:"url",batchHeader:"",batchFooter:"",batchSeparator:"",returnsPostData:false,overrideTimeStampsSetting:false,useTimeStampsInMilliseconds:null,format:function(){handleError("Layout.format: layout supplied has no format() method");},ignoresThrowable:function(){handleError("Layout.ignoresThrowable: layout supplied has no ignoresThrowable() method");},getContentType:function(){return"text/plain";},allowBatching:function(){return true;},setTimeStampsInMilliseconds:function(timeStampsInMilliseconds){this.overrideTimeStampsSetting=true;this.useTimeStampsInMilliseconds=bool(timeStampsInMilliseconds);},isTimeStampsInMilliseconds:function(){return this.overrideTimeStampsSetting?this.useTimeStampsInMilliseconds:useTimeStampsInMilliseconds;},getTimeStampValue:function(loggingEvent){return this.isTimeStampsInMilliseconds()?loggingEvent.timeStampInMilliseconds:loggingEvent.timeStampInSeconds;},getDataValues:function(loggingEvent,combineMessages){var dataValues=[[this.loggerKey,loggingEvent.logger.name],[this.timeStampKey,this.getTimeStampValue(loggingEvent)],[this.levelKey,loggingEvent.level.name],[this.urlKey,window.location.href],[this.messageKey,combineMessages?loggingEvent.getCombinedMessages():loggingEvent.messages]];if(!this.isTimeStampsInMilliseconds()){dataValues.push([this.millisecondsKey,loggingEvent.milliseconds]);}
if(loggingEvent.exception){dataValues.push([this.exceptionKey,getExceptionStringRep(loggingEvent.exception)]);}
if(this.hasCustomFields()){for(var i=0,len=this.customFields.length;i<len;i++){var val=this.customFields[i].value;if(typeof val==="function"){val=val(this,loggingEvent);}
dataValues.push([this.customFields[i].name,val]);}}
return dataValues;},setKeys:function(loggerKey,timeStampKey,levelKey,messageKey,exceptionKey,urlKey,millisecondsKey){this.loggerKey=extractStringFromParam(loggerKey,this.defaults.loggerKey);this.timeStampKey=extractStringFromParam(timeStampKey,this.defaults.timeStampKey);this.levelKey=extractStringFromParam(levelKey,this.defaults.levelKey);this.messageKey=extractStringFromParam(messageKey,this.defaults.messageKey);this.exceptionKey=extractStringFromParam(exceptionKey,this.defaults.exceptionKey);this.urlKey=extractStringFromParam(urlKey,this.defaults.urlKey);this.millisecondsKey=extractStringFromParam(millisecondsKey,this.defaults.millisecondsKey);},setCustomField:function(name,value){var fieldUpdated=false;for(var i=0,len=this.customFields.length;i<len;i++){if(this.customFields[i].name===name){this.customFields[i].value=value;fieldUpdated=true;}}
if(!fieldUpdated){this.customFields.push({"name":name,"value":value});}},hasCustomFields:function(){return(this.customFields.length>0);},formatWithException:function(loggingEvent){var formatted=this.format(loggingEvent);if(loggingEvent.exception&&this.ignoresThrowable()){formatted+=loggingEvent.getThrowableStrRep();}
return formatted;},toString:function(){handleError("Layout.toString: all layouts must override this method");}};log4javascript.Layout=Layout;var Appender=function(){};Appender.prototype=new EventSupport();Appender.prototype.layout=new PatternLayout();Appender.prototype.threshold=Level.ALL;Appender.prototype.loggers=[];Appender.prototype.doAppend=function(loggingEvent){if(enabled&&loggingEvent.level.level>=this.threshold.level){this.append(loggingEvent);}};Appender.prototype.append=function(loggingEvent){};Appender.prototype.setLayout=function(layout){if(layout instanceof Layout){this.layout=layout;}else{handleError("Appender.setLayout: layout supplied to "+
this.toString()+" is not a subclass of Layout");}};Appender.prototype.getLayout=function(){return this.layout;};Appender.prototype.setThreshold=function(threshold){if(threshold instanceof Level){this.threshold=threshold;}else{handleError("Appender.setThreshold: threshold supplied to "+
this.toString()+" is not a subclass of Level");}};Appender.prototype.getThreshold=function(){return this.threshold;};Appender.prototype.setAddedToLogger=function(logger){this.loggers.push(logger);};Appender.prototype.setRemovedFromLogger=function(logger){array_remove(this.loggers,logger);};Appender.prototype.group=emptyFunction;Appender.prototype.groupEnd=emptyFunction;Appender.prototype.toString=function(){handleError("Appender.toString: all appenders must override this method");};log4javascript.Appender=Appender;function SimpleLayout(){this.customFields=[];}
SimpleLayout.prototype=new Layout();SimpleLayout.prototype.format=function(loggingEvent){return loggingEvent.level.name+" - "+loggingEvent.getCombinedMessages();};SimpleLayout.prototype.ignoresThrowable=function(){return true;};SimpleLayout.prototype.toString=function(){return"SimpleLayout";};log4javascript.SimpleLayout=SimpleLayout;function NullLayout(){this.customFields=[];}
NullLayout.prototype=new Layout();NullLayout.prototype.format=function(loggingEvent){return loggingEvent.messages;};NullLayout.prototype.ignoresThrowable=function(){return true;};NullLayout.prototype.formatWithException=function(loggingEvent){var messages=loggingEvent.messages,ex=loggingEvent.exception;return ex?messages.concat([ex]):messages;};NullLayout.prototype.toString=function(){return"NullLayout";};log4javascript.NullLayout=NullLayout;function XmlLayout(combineMessages){this.combineMessages=extractBooleanFromParam(combineMessages,true);this.customFields=[];}
XmlLayout.prototype=new Layout();XmlLayout.prototype.isCombinedMessages=function(){return this.combineMessages;};XmlLayout.prototype.getContentType=function(){return"text/xml";};XmlLayout.prototype.escapeCdata=function(str){return str.replace(/\]\]>/,"]]>]]&gt;<![CDATA[");};XmlLayout.prototype.format=function(loggingEvent){var layout=this;var i,len;function formatMessage(message){message=(typeof message==="string")?message:toStr(message);return"<log4javascript:message><![CDATA["+
layout.escapeCdata(message)+"]]></log4javascript:message>";}
var str="<log4javascript:event logger=\""+loggingEvent.logger.name+"\" timestamp=\""+this.getTimeStampValue(loggingEvent)+"\"";if(!this.isTimeStampsInMilliseconds()){str+=" milliseconds=\""+loggingEvent.milliseconds+"\"";}
str+=" level=\""+loggingEvent.level.name+"\">"+newLine;if(this.combineMessages){str+=formatMessage(loggingEvent.getCombinedMessages());}else{str+="<log4javascript:messages>"+newLine;for(i=0,len=loggingEvent.messages.length;i<len;i++){str+=formatMessage(loggingEvent.messages[i])+newLine;}
str+="</log4javascript:messages>"+newLine;}
if(this.hasCustomFields()){for(i=0,len=this.customFields.length;i<len;i++){str+="<log4javascript:customfield name=\""+
this.customFields[i].name+"\"><![CDATA["+
this.customFields[i].value.toString()+"]]></log4javascript:customfield>"+newLine;}}
if(loggingEvent.exception){str+="<log4javascript:exception><![CDATA["+
getExceptionStringRep(loggingEvent.exception)+"]]></log4javascript:exception>"+newLine;}
str+="</log4javascript:event>"+newLine+newLine;return str;};XmlLayout.prototype.ignoresThrowable=function(){return false;};XmlLayout.prototype.toString=function(){return"XmlLayout";};log4javascript.XmlLayout=XmlLayout;function escapeNewLines(str){return str.replace(/\r\n|\r|\n/g,"\\r\\n");}
function JsonLayout(readable,combineMessages){this.readable=extractBooleanFromParam(readable,false);this.combineMessages=extractBooleanFromParam(combineMessages,true);this.batchHeader=this.readable?"["+newLine:"[";this.batchFooter=this.readable?"]"+newLine:"]";this.batchSeparator=this.readable?","+newLine:",";this.setKeys();this.colon=this.readable?": ":":";this.tab=this.readable?"\t":"";this.lineBreak=this.readable?newLine:"";this.customFields=[];}
JsonLayout.prototype=new Layout();JsonLayout.prototype.isReadable=function(){return this.readable;};JsonLayout.prototype.isCombinedMessages=function(){return this.combineMessages;};JsonLayout.prototype.format=function(loggingEvent){var layout=this;var dataValues=this.getDataValues(loggingEvent,this.combineMessages);var str="{"+this.lineBreak;var i,len;function formatValue(val,prefix,expand){var formattedValue;var valType=typeof val;if(val instanceof Date){formattedValue=String(val.getTime());}else if(expand&&(val instanceof Array)){formattedValue="["+layout.lineBreak;for(var i=0,len=val.length;i<len;i++){var childPrefix=prefix+layout.tab;formattedValue+=childPrefix+formatValue(val[i],childPrefix,false);if(i<val.length-1){formattedValue+=",";}
formattedValue+=layout.lineBreak;}
formattedValue+=prefix+"]";}else if(valType!=="number"&&valType!=="boolean"){formattedValue="\""+escapeNewLines(toStr(val).replace(/\"/g,"\\\""))+"\"";}else{formattedValue=val;}
return formattedValue;}
for(i=0,len=dataValues.length-1;i<=len;i++){str+=this.tab+"\""+dataValues[i][0]+"\""+this.colon+formatValue(dataValues[i][1],this.tab,true);if(i<len){str+=",";}
str+=this.lineBreak;}
str+="}"+this.lineBreak;return str;};JsonLayout.prototype.ignoresThrowable=function(){return false;};JsonLayout.prototype.toString=function(){return"JsonLayout";};JsonLayout.prototype.getContentType=function(){return"application/json";};log4javascript.JsonLayout=JsonLayout;function HttpPostDataLayout(){this.setKeys();this.customFields=[];this.returnsPostData=true;}
HttpPostDataLayout.prototype=new Layout();HttpPostDataLayout.prototype.allowBatching=function(){return false;};HttpPostDataLayout.prototype.format=function(loggingEvent){var dataValues=this.getDataValues(loggingEvent);var queryBits=[];for(var i=0,len=dataValues.length;i<len;i++){var val=(dataValues[i][1]instanceof Date)?String(dataValues[i][1].getTime()):dataValues[i][1];queryBits.push(urlEncode(dataValues[i][0])+"="+urlEncode(val));}
return queryBits.join("&");};HttpPostDataLayout.prototype.ignoresThrowable=function(loggingEvent){return false;};HttpPostDataLayout.prototype.toString=function(){return"HttpPostDataLayout";};log4javascript.HttpPostDataLayout=HttpPostDataLayout;function formatObjectExpansion(obj,depth,indentation){var objectsExpanded=[];function doFormat(obj,depth,indentation){var i,len,childDepth,childIndentation,childLines,expansion,childExpansion;if(!indentation){indentation="";}
function formatString(text){var lines=splitIntoLines(text);for(var j=1,jLen=lines.length;j<jLen;j++){lines[j]=indentation+lines[j];}
return lines.join(newLine);}
if(obj===null){return"null";}else if(typeof obj=="undefined"){return"undefined";}else if(typeof obj=="string"){return formatString(obj);}else if(typeof obj=="object"&&array_contains(objectsExpanded,obj)){try{expansion=toStr(obj);}catch(ex){expansion="Error formatting property. Details: "+getExceptionStringRep(ex);}
return expansion+" [already expanded]";}else if((obj instanceof Array)&&depth>0){objectsExpanded.push(obj);expansion="["+newLine;childDepth=depth-1;childIndentation=indentation+"  ";childLines=[];for(i=0,len=obj.length;i<len;i++){try{childExpansion=doFormat(obj[i],childDepth,childIndentation);childLines.push(childIndentation+childExpansion);}catch(ex){childLines.push(childIndentation+"Error formatting array member. Details: "+
getExceptionStringRep(ex)+"");}}
expansion+=childLines.join(","+newLine)+newLine+indentation+"]";return expansion;}else if(Object.prototype.toString.call(obj)=="[object Date]"){return obj.toString();}else if(typeof obj=="object"&&depth>0){objectsExpanded.push(obj);expansion="{"+newLine;childDepth=depth-1;childIndentation=indentation+"  ";childLines=[];for(i in obj){try{childExpansion=doFormat(obj[i],childDepth,childIndentation);childLines.push(childIndentation+i+": "+childExpansion);}catch(ex){childLines.push(childIndentation+i+": Error formatting property. Details: "+
getExceptionStringRep(ex));}}
expansion+=childLines.join(","+newLine)+newLine+indentation+"}";return expansion;}else{return formatString(toStr(obj));}}
return doFormat(obj,depth,indentation);}
var SimpleDateFormat;(function(){var regex=/('[^']*')|(G+|y+|M+|w+|W+|D+|d+|F+|E+|a+|H+|k+|K+|h+|m+|s+|S+|Z+)|([a-zA-Z]+)|([^a-zA-Z']+)/;var monthNames=["January","February","March","April","May","June","July","August","September","October","November","December"];var dayNames=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var TEXT2=0,TEXT3=1,NUMBER=2,YEAR=3,MONTH=4,TIMEZONE=5;var types={G:TEXT2,y:YEAR,M:MONTH,w:NUMBER,W:NUMBER,D:NUMBER,d:NUMBER,F:NUMBER,E:TEXT3,a:TEXT2,H:NUMBER,k:NUMBER,K:NUMBER,h:NUMBER,m:NUMBER,s:NUMBER,S:NUMBER,Z:TIMEZONE};var ONE_DAY=24*60*60*1000;var ONE_WEEK=7*ONE_DAY;var DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK=1;var newDateAtMidnight=function(year,month,day){var d=new Date(year,month,day,0,0,0);d.setMilliseconds(0);return d;};Date.prototype.getDifference=function(date){return this.getTime()-date.getTime();};Date.prototype.isBefore=function(d){return this.getTime()<d.getTime();};Date.prototype.getUTCTime=function(){return Date.UTC(this.getFullYear(),this.getMonth(),this.getDate(),this.getHours(),this.getMinutes(),this.getSeconds(),this.getMilliseconds());};Date.prototype.getTimeSince=function(d){return this.getUTCTime()-d.getUTCTime();};Date.prototype.getPreviousSunday=function(){var midday=new Date(this.getFullYear(),this.getMonth(),this.getDate(),12,0,0);var previousSunday=new Date(midday.getTime()-this.getDay()*ONE_DAY);return newDateAtMidnight(previousSunday.getFullYear(),previousSunday.getMonth(),previousSunday.getDate());};Date.prototype.getWeekInYear=function(minimalDaysInFirstWeek){if(isUndefined(this.minimalDaysInFirstWeek)){minimalDaysInFirstWeek=DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK;}
var previousSunday=this.getPreviousSunday();var startOfYear=newDateAtMidnight(this.getFullYear(),0,1);var numberOfSundays=previousSunday.isBefore(startOfYear)?0:1+Math.floor(previousSunday.getTimeSince(startOfYear)/ONE_WEEK);var numberOfDaysInFirstWeek=7-startOfYear.getDay();var weekInYear=numberOfSundays;if(numberOfDaysInFirstWeek<minimalDaysInFirstWeek){weekInYear--;}
return weekInYear;};Date.prototype.getWeekInMonth=function(minimalDaysInFirstWeek){if(isUndefined(this.minimalDaysInFirstWeek)){minimalDaysInFirstWeek=DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK;}
var previousSunday=this.getPreviousSunday();var startOfMonth=newDateAtMidnight(this.getFullYear(),this.getMonth(),1);var numberOfSundays=previousSunday.isBefore(startOfMonth)?0:1+Math.floor(previousSunday.getTimeSince(startOfMonth)/ONE_WEEK);var numberOfDaysInFirstWeek=7-startOfMonth.getDay();var weekInMonth=numberOfSundays;if(numberOfDaysInFirstWeek>=minimalDaysInFirstWeek){weekInMonth++;}
return weekInMonth;};Date.prototype.getDayInYear=function(){var startOfYear=newDateAtMidnight(this.getFullYear(),0,1);return 1+Math.floor(this.getTimeSince(startOfYear)/ONE_DAY);};SimpleDateFormat=function(formatString){this.formatString=formatString;};SimpleDateFormat.prototype.setMinimalDaysInFirstWeek=function(days){this.minimalDaysInFirstWeek=days;};SimpleDateFormat.prototype.getMinimalDaysInFirstWeek=function(){return isUndefined(this.minimalDaysInFirstWeek)?DEFAULT_MINIMAL_DAYS_IN_FIRST_WEEK:this.minimalDaysInFirstWeek;};var padWithZeroes=function(str,len){while(str.length<len){str="0"+str;}
return str;};var formatText=function(data,numberOfLetters,minLength){return(numberOfLetters>=4)?data:data.substr(0,Math.max(minLength,numberOfLetters));};var formatNumber=function(data,numberOfLetters){var dataString=""+data;return padWithZeroes(dataString,numberOfLetters);};SimpleDateFormat.prototype.format=function(date){var formattedString="";var result;var searchString=this.formatString;while((result=regex.exec(searchString))){var quotedString=result[1];var patternLetters=result[2];var otherLetters=result[3];var otherCharacters=result[4];if(quotedString){if(quotedString=="''"){formattedString+="'";}else{formattedString+=quotedString.substring(1,quotedString.length-1);}}else if(otherLetters){}else if(otherCharacters){formattedString+=otherCharacters;}else if(patternLetters){var patternLetter=patternLetters.charAt(0);var numberOfLetters=patternLetters.length;var rawData="";switch(patternLetter){case"G":rawData="AD";break;case"y":rawData=date.getFullYear();break;case"M":rawData=date.getMonth();break;case"w":rawData=date.getWeekInYear(this.getMinimalDaysInFirstWeek());break;case"W":rawData=date.getWeekInMonth(this.getMinimalDaysInFirstWeek());break;case"D":rawData=date.getDayInYear();break;case"d":rawData=date.getDate();break;case"F":rawData=1+Math.floor((date.getDate()-1)/7);break;case"E":rawData=dayNames[date.getDay()];break;case"a":rawData=(date.getHours()>=12)?"PM":"AM";break;case"H":rawData=date.getHours();break;case"k":rawData=date.getHours()||24;break;case"K":rawData=date.getHours()%12;break;case"h":rawData=(date.getHours()%12)||12;break;case"m":rawData=date.getMinutes();break;case"s":rawData=date.getSeconds();break;case"S":rawData=date.getMilliseconds();break;case"Z":rawData=date.getTimezoneOffset();break;}
switch(types[patternLetter]){case TEXT2:formattedString+=formatText(rawData,numberOfLetters,2);break;case TEXT3:formattedString+=formatText(rawData,numberOfLetters,3);break;case NUMBER:formattedString+=formatNumber(rawData,numberOfLetters);break;case YEAR:if(numberOfLetters<=3){var dataString=""+rawData;formattedString+=dataString.substr(2,2);}else{formattedString+=formatNumber(rawData,numberOfLetters);}
break;case MONTH:if(numberOfLetters>=3){formattedString+=formatText(monthNames[rawData],numberOfLetters,numberOfLetters);}else{formattedString+=formatNumber(rawData+1,numberOfLetters);}
break;case TIMEZONE:var isPositive=(rawData>0);var prefix=isPositive?"-":"+";var absData=Math.abs(rawData);var hours=""+Math.floor(absData/60);hours=padWithZeroes(hours,2);var minutes=""+(absData%60);minutes=padWithZeroes(minutes,2);formattedString+=prefix+hours+minutes;break;}}
searchString=searchString.substr(result.index+result[0].length);}
return formattedString;};})();log4javascript.SimpleDateFormat=SimpleDateFormat;function PatternLayout(pattern){if(pattern){this.pattern=pattern;}else{this.pattern=PatternLayout.DEFAULT_CONVERSION_PATTERN;}
this.customFields=[];}
PatternLayout.TTCC_CONVERSION_PATTERN="%r %p %c - %m%n";PatternLayout.DEFAULT_CONVERSION_PATTERN="%m%n";PatternLayout.ISO8601_DATEFORMAT="yyyy-MM-dd HH:mm:ss,SSS";PatternLayout.DATETIME_DATEFORMAT="dd MMM yyyy HH:mm:ss,SSS";PatternLayout.ABSOLUTETIME_DATEFORMAT="HH:mm:ss,SSS";PatternLayout.prototype=new Layout();PatternLayout.prototype.format=function(loggingEvent){var regex=/%(-?[0-9]+)?(\.?[0-9]+)?([acdfmMnpr%])(\{([^\}]+)\})?|([^%]+)/;var formattedString="";var result;var searchString=this.pattern;while((result=regex.exec(searchString))){var matchedString=result[0];var padding=result[1];var truncation=result[2];var conversionCharacter=result[3];var specifier=result[5];var text=result[6];if(text){formattedString+=""+text;}else{var replacement="";switch(conversionCharacter){case"a":case"m":var depth=0;if(specifier){depth=parseInt(specifier,10);if(isNaN(depth)){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character '"+conversionCharacter+"' - should be a number");depth=0;}}
var messages=(conversionCharacter==="a")?loggingEvent.messages[0]:loggingEvent.messages;for(var i=0,len=messages.length;i<len;i++){if(i>0&&(replacement.charAt(replacement.length-1)!==" ")){replacement+=" ";}
if(depth===0){replacement+=messages[i];}else{replacement+=formatObjectExpansion(messages[i],depth);}}
break;case"c":var loggerName=loggingEvent.logger.name;if(specifier){var precision=parseInt(specifier,10);var loggerNameBits=loggingEvent.logger.name.split(".");if(precision>=loggerNameBits.length){replacement=loggerName;}else{replacement=loggerNameBits.slice(loggerNameBits.length-precision).join(".");}}else{replacement=loggerName;}
break;case"d":var dateFormat=PatternLayout.ISO8601_DATEFORMAT;if(specifier){dateFormat=specifier;if(dateFormat=="ISO8601"){dateFormat=PatternLayout.ISO8601_DATEFORMAT;}else if(dateFormat=="ABSOLUTE"){dateFormat=PatternLayout.ABSOLUTETIME_DATEFORMAT;}else if(dateFormat=="DATE"){dateFormat=PatternLayout.DATETIME_DATEFORMAT;}}
replacement=(new SimpleDateFormat(dateFormat)).format(loggingEvent.timeStamp);break;case"f":if(this.hasCustomFields()){var fieldIndex=0;if(specifier){fieldIndex=parseInt(specifier,10);if(isNaN(fieldIndex)){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character 'f' - should be a number");}else if(fieldIndex===0){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character 'f' - must be greater than zero");}else if(fieldIndex>this.customFields.length){handleError("PatternLayout.format: invalid specifier '"+
specifier+"' for conversion character 'f' - there aren't that many custom fields");}else{fieldIndex=fieldIndex-1;}}
var val=this.customFields[fieldIndex].value;if(typeof val=="function"){val=val(this,loggingEvent);}
replacement=val;}
break;case"n":replacement=newLine;break;case"p":replacement=loggingEvent.level.name;break;case"r":replacement=""+loggingEvent.timeStamp.getDifference(applicationStartDate);break;case"%":replacement="%";break;default:replacement=matchedString;break;}
var l;if(truncation){l=parseInt(truncation.substr(1),10);var strLen=replacement.length;if(l<strLen){replacement=replacement.substring(strLen-l,strLen);}}
if(padding){if(padding.charAt(0)=="-"){l=parseInt(padding.substr(1),10);while(replacement.length<l){replacement+=" ";}}else{l=parseInt(padding,10);while(replacement.length<l){replacement=" "+replacement;}}}
formattedString+=replacement;}
searchString=searchString.substr(result.index+result[0].length);}
return formattedString;};PatternLayout.prototype.ignoresThrowable=function(){return true;};PatternLayout.prototype.toString=function(){return"PatternLayout";};log4javascript.PatternLayout=PatternLayout;function AlertAppender(){}
AlertAppender.prototype=new Appender();AlertAppender.prototype.layout=new SimpleLayout();AlertAppender.prototype.append=function(loggingEvent){alert(this.getLayout().formatWithException(loggingEvent));};AlertAppender.prototype.toString=function(){return"AlertAppender";};log4javascript.AlertAppender=AlertAppender;function BrowserConsoleAppender(){}
BrowserConsoleAppender.prototype=new log4javascript.Appender();BrowserConsoleAppender.prototype.layout=new NullLayout();BrowserConsoleAppender.prototype.threshold=Level.DEBUG;BrowserConsoleAppender.prototype.append=function(loggingEvent){var appender=this;var getFormattedMessage=function(concatenate){var formattedMessage=appender.getLayout().formatWithException(loggingEvent);return(typeof formattedMessage=="string")?(concatenate?formattedMessage:[formattedMessage]):(concatenate?formattedMessage.join(" "):formattedMessage);};var console=window.console;if(console&&console.log){var consoleMethodName;if(console.debug&&Level.DEBUG.isGreaterOrEqual(loggingEvent.level)){consoleMethodName="debug";}else if(console.info&&Level.INFO.equals(loggingEvent.level)){consoleMethodName="info";}else if(console.warn&&Level.WARN.equals(loggingEvent.level)){consoleMethodName="warn";}else if(console.error&&loggingEvent.level.isGreaterOrEqual(Level.ERROR)){consoleMethodName="error";}else{consoleMethodName="log";}
if(typeof console[consoleMethodName].apply=="function"){console[consoleMethodName].apply(console,getFormattedMessage(false));}else{console[consoleMethodName](getFormattedMessage(true));}}else if((typeof opera!="undefined")&&opera.postError){opera.postError(getFormattedMessage(true));}};BrowserConsoleAppender.prototype.group=function(name){if(window.console&&window.console.group){window.console.group(name);}};BrowserConsoleAppender.prototype.groupEnd=function(){if(window.console&&window.console.groupEnd){window.console.groupEnd();}};BrowserConsoleAppender.prototype.toString=function(){return"BrowserConsoleAppender";};log4javascript.BrowserConsoleAppender=BrowserConsoleAppender;var xhrFactory=function(){return new XMLHttpRequest();};var xmlHttpFactories=[xhrFactory,function(){return new ActiveXObject("Msxml2.XMLHTTP");},function(){return new ActiveXObject("Microsoft.XMLHTTP");}];var withCredentialsSupported=false;var getXmlHttp=function(errorHandler){var xmlHttp=null,factory;for(var i=0,len=xmlHttpFactories.length;i<len;i++){factory=xmlHttpFactories[i];try{xmlHttp=factory();withCredentialsSupported=(factory==xhrFactory&&("withCredentials"in xmlHttp));getXmlHttp=factory;return xmlHttp;}catch(e){}}
if(errorHandler){errorHandler();}else{handleError("getXmlHttp: unable to obtain XMLHttpRequest object");}};function isHttpRequestSuccessful(xmlHttp){return isUndefined(xmlHttp.status)||xmlHttp.status===0||(xmlHttp.status>=200&&xmlHttp.status<300)||xmlHttp.status==1223;}
function AjaxAppender(url,withCredentials){var appender=this;var isSupported=true;if(!url){handleError("AjaxAppender: URL must be specified in constructor");isSupported=false;}
var timed=this.defaults.timed;var waitForResponse=this.defaults.waitForResponse;var batchSize=this.defaults.batchSize;var timerInterval=this.defaults.timerInterval;var requestSuccessCallback=this.defaults.requestSuccessCallback;var failCallback=this.defaults.failCallback;var postVarName=this.defaults.postVarName;var sendAllOnUnload=this.defaults.sendAllOnUnload;var contentType=this.defaults.contentType;var sessionId=null;var queuedLoggingEvents=[];var queuedRequests=[];var headers=[];var sending=false;var initialized=false;function checkCanConfigure(configOptionName){if(initialized){handleError("AjaxAppender: configuration option '"+
configOptionName+"' may not be set after the appender has been initialized");return false;}
return true;}
this.getSessionId=function(){return sessionId;};this.setSessionId=function(sessionIdParam){sessionId=extractStringFromParam(sessionIdParam,null);this.layout.setCustomField("sessionid",sessionId);};this.setLayout=function(layoutParam){if(checkCanConfigure("layout")){this.layout=layoutParam;if(sessionId!==null){this.setSessionId(sessionId);}}};this.isTimed=function(){return timed;};this.setTimed=function(timedParam){if(checkCanConfigure("timed")){timed=bool(timedParam);}};this.getTimerInterval=function(){return timerInterval;};this.setTimerInterval=function(timerIntervalParam){if(checkCanConfigure("timerInterval")){timerInterval=extractIntFromParam(timerIntervalParam,timerInterval);}};this.isWaitForResponse=function(){return waitForResponse;};this.setWaitForResponse=function(waitForResponseParam){if(checkCanConfigure("waitForResponse")){waitForResponse=bool(waitForResponseParam);}};this.getBatchSize=function(){return batchSize;};this.setBatchSize=function(batchSizeParam){if(checkCanConfigure("batchSize")){batchSize=extractIntFromParam(batchSizeParam,batchSize);}};this.isSendAllOnUnload=function(){return sendAllOnUnload;};this.setSendAllOnUnload=function(sendAllOnUnloadParam){if(checkCanConfigure("sendAllOnUnload")){sendAllOnUnload=extractBooleanFromParam(sendAllOnUnloadParam,sendAllOnUnload);}};this.setRequestSuccessCallback=function(requestSuccessCallbackParam){requestSuccessCallback=extractFunctionFromParam(requestSuccessCallbackParam,requestSuccessCallback);};this.setFailCallback=function(failCallbackParam){failCallback=extractFunctionFromParam(failCallbackParam,failCallback);};this.getPostVarName=function(){return postVarName;};this.setPostVarName=function(postVarNameParam){if(checkCanConfigure("postVarName")){postVarName=extractStringFromParam(postVarNameParam,postVarName);}};this.getHeaders=function(){return headers;};this.addHeader=function(name,value){if(name.toLowerCase()=="content-type"){contentType=value;}else{headers.push({name:name,value:value});}};function sendAll(){if(isSupported&&enabled){sending=true;var currentRequestBatch;if(waitForResponse){if(queuedRequests.length>0){currentRequestBatch=queuedRequests.shift();sendRequest(preparePostData(currentRequestBatch),sendAll);}else{sending=false;if(timed){scheduleSending();}}}else{while((currentRequestBatch=queuedRequests.shift())){sendRequest(preparePostData(currentRequestBatch));}
sending=false;if(timed){scheduleSending();}}}}
this.sendAll=sendAll;function sendAllRemaining(){var sendingAnything=false;if(isSupported&&enabled){var actualBatchSize=appender.getLayout().allowBatching()?batchSize:1;var currentLoggingEvent;var batchedLoggingEvents=[];while((currentLoggingEvent=queuedLoggingEvents.shift())){batchedLoggingEvents.push(currentLoggingEvent);if(queuedLoggingEvents.length>=actualBatchSize){queuedRequests.push(batchedLoggingEvents);batchedLoggingEvents=[];}}
if(batchedLoggingEvents.length>0){queuedRequests.push(batchedLoggingEvents);}
sendingAnything=(queuedRequests.length>0);waitForResponse=false;timed=false;sendAll();}
return sendingAnything;}
this.sendAllRemaining=sendAllRemaining;function preparePostData(batchedLoggingEvents){var formattedMessages=[];var currentLoggingEvent;var postData="";while((currentLoggingEvent=batchedLoggingEvents.shift())){formattedMessages.push(appender.getLayout().formatWithException(currentLoggingEvent));}
if(batchedLoggingEvents.length==1){postData=formattedMessages.join("");}else{postData=appender.getLayout().batchHeader+
formattedMessages.join(appender.getLayout().batchSeparator)+
appender.getLayout().batchFooter;}
if(contentType==appender.defaults.contentType){postData=appender.getLayout().returnsPostData?postData:urlEncode(postVarName)+"="+urlEncode(postData);if(postData.length>0){postData+="&";}
postData+="layout="+urlEncode(appender.getLayout().toString());}
return postData;}
function scheduleSending(){window.setTimeout(sendAll,timerInterval);}
function xmlHttpErrorHandler(){var msg="AjaxAppender: could not create XMLHttpRequest object. AjaxAppender disabled";handleError(msg);isSupported=false;if(failCallback){failCallback(msg);}}
function sendRequest(postData,successCallback){try{var xmlHttp=getXmlHttp(xmlHttpErrorHandler);if(isSupported){xmlHttp.onreadystatechange=function(){if(xmlHttp.readyState==4){if(isHttpRequestSuccessful(xmlHttp)){if(requestSuccessCallback){requestSuccessCallback(xmlHttp);}
if(successCallback){successCallback(xmlHttp);}}else{var msg="AjaxAppender.append: XMLHttpRequest request to URL "+
url+" returned status code "+xmlHttp.status;handleError(msg);if(failCallback){failCallback(msg);}}
xmlHttp.onreadystatechange=emptyFunction;xmlHttp=null;}};xmlHttp.open("POST",url,true);if(withCredentials&&withCredentialsSupported){xmlHttp.withCredentials=true;}
try{for(var i=0,header;header=headers[i++];){xmlHttp.setRequestHeader(header.name,header.value);}
xmlHttp.setRequestHeader("Content-Type",contentType);}catch(headerEx){var msg="AjaxAppender.append: your browser's XMLHttpRequest implementation"+" does not support setRequestHeader, therefore cannot post data. AjaxAppender disabled";handleError(msg);isSupported=false;if(failCallback){failCallback(msg);}
return;}
xmlHttp.send(postData);}}catch(ex){var errMsg="AjaxAppender.append: error sending log message to "+url;handleError(errMsg,ex);isSupported=false;if(failCallback){failCallback(errMsg+". Details: "+getExceptionStringRep(ex));}}}
this.append=function(loggingEvent){if(isSupported){if(!initialized){init();}
queuedLoggingEvents.push(loggingEvent);var actualBatchSize=this.getLayout().allowBatching()?batchSize:1;if(queuedLoggingEvents.length>=actualBatchSize){var currentLoggingEvent;var batchedLoggingEvents=[];while((currentLoggingEvent=queuedLoggingEvents.shift())){batchedLoggingEvents.push(currentLoggingEvent);}
queuedRequests.push(batchedLoggingEvents);if(!timed&&(!waitForResponse||(waitForResponse&&!sending))){sendAll();}}}};function init(){initialized=true;if(sendAllOnUnload){var oldBeforeUnload=window.onbeforeunload;window.onbeforeunload=function(){if(oldBeforeUnload){oldBeforeUnload();}
sendAllRemaining();};}
if(timed){scheduleSending();}}}
AjaxAppender.prototype=new Appender();AjaxAppender.prototype.defaults={waitForResponse:false,timed:false,timerInterval:1000,batchSize:1,sendAllOnUnload:false,requestSuccessCallback:null,failCallback:null,postVarName:"data",contentType:"application/x-www-form-urlencoded"};AjaxAppender.prototype.layout=new HttpPostDataLayout();AjaxAppender.prototype.toString=function(){return"AjaxAppender";};log4javascript.AjaxAppender=AjaxAppender;function setCookie(name,value,days,path){var expires;path=path?"; path="+path:"";if(days){var date=new Date();date.setTime(date.getTime()+(days*24*60*60*1000));expires="; expires="+date.toGMTString();}else{expires="";}
document.cookie=escape(name)+"="+escape(value)+expires+path;}
function getCookie(name){var nameEquals=escape(name)+"=";var ca=document.cookie.split(";");for(var i=0,len=ca.length;i<len;i++){var c=ca[i];while(c.charAt(0)===" "){c=c.substring(1,c.length);}
if(c.indexOf(nameEquals)===0){return unescape(c.substring(nameEquals.length,c.length));}}
return null;}
function getBaseUrl(){var scripts=document.getElementsByTagName("script");for(var i=0,len=scripts.length;i<len;++i){if(scripts[i].src.indexOf("log4javascript")!=-1){var lastSlash=scripts[i].src.lastIndexOf("/");return(lastSlash==-1)?"":scripts[i].src.substr(0,lastSlash+1);}}
return null;}
function isLoaded(win){try{return bool(win.loaded);}catch(ex){return false;}}
var ConsoleAppender;(function(){var getConsoleHtmlLines=function(){return['<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">','<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">','<head>','<title>log4javascript</title>','<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />','<!-- Make IE8 behave like IE7, having gone to all the trouble of making IE work -->','<meta http-equiv="X-UA-Compatible" content="IE=7" />','<script type="text/javascript">var isIe = false, isIePre7 = false;</script>','<!--[if IE]><script type="text/javascript">isIe = true</script><![endif]-->','<!--[if lt IE 7]><script type="text/javascript">isIePre7 = true</script><![endif]-->','<script type="text/javascript">','//<![CDATA[','var loggingEnabled=true;var logQueuedEventsTimer=null;var logEntries=[];var logEntriesAndSeparators=[];var logItems=[];var renderDelay=100;var unrenderedLogItemsExist=false;var rootGroup,currentGroup=null;var loaded=false;var currentLogItem=null;var logMainContainer;function copyProperties(obj,props){for(var i in props){obj[i]=props[i];}}','function LogItem(){}','LogItem.prototype={mainContainer:null,wrappedContainer:null,unwrappedContainer:null,group:null,appendToLog:function(){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].appendToLog();}','this.group.update();},doRemove:function(doUpdate,removeFromGroup){if(this.rendered){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].remove();}','this.unwrappedElementContainer=null;this.wrappedElementContainer=null;this.mainElementContainer=null;}','if(this.group&&removeFromGroup){this.group.removeChild(this,doUpdate);}','if(this===currentLogItem){currentLogItem=null;}},remove:function(doUpdate,removeFromGroup){this.doRemove(doUpdate,removeFromGroup);},render:function(){},accept:function(visitor){visitor.visit(this);},getUnwrappedDomContainer:function(){return this.group.unwrappedElementContainer.contentDiv;},getWrappedDomContainer:function(){return this.group.wrappedElementContainer.contentDiv;},getMainDomContainer:function(){return this.group.mainElementContainer.contentDiv;}};LogItem.serializedItemKeys={LOG_ENTRY:0,GROUP_START:1,GROUP_END:2};function LogItemContainerElement(){}','LogItemContainerElement.prototype={appendToLog:function(){var insertBeforeFirst=(newestAtTop&&this.containerDomNode.hasChildNodes());if(insertBeforeFirst){this.containerDomNode.insertBefore(this.mainDiv,this.containerDomNode.firstChild);}else{this.containerDomNode.appendChild(this.mainDiv);}}};function SeparatorElementContainer(containerDomNode){this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.className="separator";this.mainDiv.innerHTML="&nbsp;";}','SeparatorElementContainer.prototype=new LogItemContainerElement();SeparatorElementContainer.prototype.remove=function(){this.mainDiv.parentNode.removeChild(this.mainDiv);this.mainDiv=null;};function Separator(){this.rendered=false;}','Separator.prototype=new LogItem();copyProperties(Separator.prototype,{render:function(){var containerDomNode=this.group.contentDiv;if(isIe){this.unwrappedElementContainer=new SeparatorElementContainer(this.getUnwrappedDomContainer());this.wrappedElementContainer=new SeparatorElementContainer(this.getWrappedDomContainer());this.elementContainers=[this.unwrappedElementContainer,this.wrappedElementContainer];}else{this.mainElementContainer=new SeparatorElementContainer(this.getMainDomContainer());this.elementContainers=[this.mainElementContainer];}','this.content=this.formattedMessage;this.rendered=true;}});function GroupElementContainer(group,containerDomNode,isRoot,isWrapped){this.group=group;this.containerDomNode=containerDomNode;this.isRoot=isRoot;this.isWrapped=isWrapped;this.expandable=false;if(this.isRoot){if(isIe){this.contentDiv=logMainContainer.appendChild(document.createElement("div"));this.contentDiv.id=this.isWrapped?"log_wrapped":"log_unwrapped";}else{this.contentDiv=logMainContainer;}}else{var groupElementContainer=this;this.mainDiv=document.createElement("div");this.mainDiv.className="group";this.headingDiv=this.mainDiv.appendChild(document.createElement("div"));this.headingDiv.className="groupheading";this.expander=this.headingDiv.appendChild(document.createElement("span"));this.expander.className="expander unselectable greyedout";this.expander.unselectable=true;var expanderText=this.group.expanded?"-":"+";this.expanderTextNode=this.expander.appendChild(document.createTextNode(expanderText));this.headingDiv.appendChild(document.createTextNode(" "+this.group.name));this.contentDiv=this.mainDiv.appendChild(document.createElement("div"));var contentCssClass=this.group.expanded?"expanded":"collapsed";this.contentDiv.className="groupcontent "+contentCssClass;this.expander.onclick=function(){if(groupElementContainer.group.expandable){groupElementContainer.group.toggleExpanded();}};}}','GroupElementContainer.prototype=new LogItemContainerElement();copyProperties(GroupElementContainer.prototype,{toggleExpanded:function(){if(!this.isRoot){var oldCssClass,newCssClass,expanderText;if(this.group.expanded){newCssClass="expanded";oldCssClass="collapsed";expanderText="-";}else{newCssClass="collapsed";oldCssClass="expanded";expanderText="+";}','replaceClass(this.contentDiv,newCssClass,oldCssClass);this.expanderTextNode.nodeValue=expanderText;}},remove:function(){if(!this.isRoot){this.headingDiv=null;this.expander.onclick=null;this.expander=null;this.expanderTextNode=null;this.contentDiv=null;this.containerDomNode=null;this.mainDiv.parentNode.removeChild(this.mainDiv);this.mainDiv=null;}},reverseChildren:function(){var node=null;var childDomNodes=[];while((node=this.contentDiv.firstChild)){this.contentDiv.removeChild(node);childDomNodes.push(node);}','while((node=childDomNodes.pop())){this.contentDiv.appendChild(node);}},update:function(){if(!this.isRoot){if(this.group.expandable){removeClass(this.expander,"greyedout");}else{addClass(this.expander,"greyedout");}}},clear:function(){if(this.isRoot){this.contentDiv.innerHTML="";}}});function Group(name,isRoot,initiallyExpanded){this.name=name;this.group=null;this.isRoot=isRoot;this.initiallyExpanded=initiallyExpanded;this.elementContainers=[];this.children=[];this.expanded=initiallyExpanded;this.rendered=false;this.expandable=false;}','Group.prototype=new LogItem();copyProperties(Group.prototype,{addChild:function(logItem){this.children.push(logItem);logItem.group=this;},render:function(){if(isIe){var unwrappedDomContainer,wrappedDomContainer;if(this.isRoot){unwrappedDomContainer=logMainContainer;wrappedDomContainer=logMainContainer;}else{unwrappedDomContainer=this.getUnwrappedDomContainer();wrappedDomContainer=this.getWrappedDomContainer();}','this.unwrappedElementContainer=new GroupElementContainer(this,unwrappedDomContainer,this.isRoot,false);this.wrappedElementContainer=new GroupElementContainer(this,wrappedDomContainer,this.isRoot,true);this.elementContainers=[this.unwrappedElementContainer,this.wrappedElementContainer];}else{var mainDomContainer=this.isRoot?logMainContainer:this.getMainDomContainer();this.mainElementContainer=new GroupElementContainer(this,mainDomContainer,this.isRoot,false);this.elementContainers=[this.mainElementContainer];}','this.rendered=true;},toggleExpanded:function(){this.expanded=!this.expanded;for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].toggleExpanded();}},expand:function(){if(!this.expanded){this.toggleExpanded();}},accept:function(visitor){visitor.visitGroup(this);},reverseChildren:function(){if(this.rendered){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].reverseChildren();}}},update:function(){var previouslyExpandable=this.expandable;this.expandable=(this.children.length!==0);if(this.expandable!==previouslyExpandable){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].update();}}},flatten:function(){var visitor=new GroupFlattener();this.accept(visitor);return visitor.logEntriesAndSeparators;},removeChild:function(child,doUpdate){array_remove(this.children,child);child.group=null;if(doUpdate){this.update();}},remove:function(doUpdate,removeFromGroup){for(var i=0,len=this.children.length;i<len;i++){this.children[i].remove(false,false);}','this.children=[];this.update();if(this===currentGroup){currentGroup=this.group;}','this.doRemove(doUpdate,removeFromGroup);},serialize:function(items){items.push([LogItem.serializedItemKeys.GROUP_START,this.name]);for(var i=0,len=this.children.length;i<len;i++){this.children[i].serialize(items);}','if(this!==currentGroup){items.push([LogItem.serializedItemKeys.GROUP_END]);}},clear:function(){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].clear();}}});function LogEntryElementContainer(){}','LogEntryElementContainer.prototype=new LogItemContainerElement();copyProperties(LogEntryElementContainer.prototype,{remove:function(){this.doRemove();},doRemove:function(){this.mainDiv.parentNode.removeChild(this.mainDiv);this.mainDiv=null;this.contentElement=null;this.containerDomNode=null;},setContent:function(content,wrappedContent){if(content===this.formattedMessage){this.contentElement.innerHTML="";this.contentElement.appendChild(document.createTextNode(this.formattedMessage));}else{this.contentElement.innerHTML=content;}},setSearchMatch:function(isMatch){var oldCssClass=isMatch?"searchnonmatch":"searchmatch";var newCssClass=isMatch?"searchmatch":"searchnonmatch";replaceClass(this.mainDiv,newCssClass,oldCssClass);},clearSearch:function(){removeClass(this.mainDiv,"searchmatch");removeClass(this.mainDiv,"searchnonmatch");}});function LogEntryWrappedElementContainer(logEntry,containerDomNode){this.logEntry=logEntry;this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.appendChild(document.createTextNode(this.logEntry.formattedMessage));this.mainDiv.className="logentry wrapped "+this.logEntry.level;this.contentElement=this.mainDiv;}','LogEntryWrappedElementContainer.prototype=new LogEntryElementContainer();LogEntryWrappedElementContainer.prototype.setContent=function(content,wrappedContent){if(content===this.formattedMessage){this.contentElement.innerHTML="";this.contentElement.appendChild(document.createTextNode(this.formattedMessage));}else{this.contentElement.innerHTML=wrappedContent;}};function LogEntryUnwrappedElementContainer(logEntry,containerDomNode){this.logEntry=logEntry;this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.className="logentry unwrapped "+this.logEntry.level;this.pre=this.mainDiv.appendChild(document.createElement("pre"));this.pre.appendChild(document.createTextNode(this.logEntry.formattedMessage));this.pre.className="unwrapped";this.contentElement=this.pre;}','LogEntryUnwrappedElementContainer.prototype=new LogEntryElementContainer();LogEntryUnwrappedElementContainer.prototype.remove=function(){this.doRemove();this.pre=null;};function LogEntryMainElementContainer(logEntry,containerDomNode){this.logEntry=logEntry;this.containerDomNode=containerDomNode;this.mainDiv=document.createElement("div");this.mainDiv.className="logentry nonielogentry "+this.logEntry.level;this.contentElement=this.mainDiv.appendChild(document.createElement("span"));this.contentElement.appendChild(document.createTextNode(this.logEntry.formattedMessage));}','LogEntryMainElementContainer.prototype=new LogEntryElementContainer();function LogEntry(level,formattedMessage){this.level=level;this.formattedMessage=formattedMessage;this.rendered=false;}','LogEntry.prototype=new LogItem();copyProperties(LogEntry.prototype,{render:function(){var logEntry=this;var containerDomNode=this.group.contentDiv;if(isIe){this.formattedMessage=this.formattedMessage.replace(/\\r\\n/g,"\\r");this.unwrappedElementContainer=new LogEntryUnwrappedElementContainer(this,this.getUnwrappedDomContainer());this.wrappedElementContainer=new LogEntryWrappedElementContainer(this,this.getWrappedDomContainer());this.elementContainers=[this.unwrappedElementContainer,this.wrappedElementContainer];}else{this.mainElementContainer=new LogEntryMainElementContainer(this,this.getMainDomContainer());this.elementContainers=[this.mainElementContainer];}','this.content=this.formattedMessage;this.rendered=true;},setContent:function(content,wrappedContent){if(content!=this.content){if(isIe&&(content!==this.formattedMessage)){content=content.replace(/\\r\\n/g,"\\r");}','for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].setContent(content,wrappedContent);}','this.content=content;}},getSearchMatches:function(){var matches=[];var i,len;if(isIe){var unwrappedEls=getElementsByClass(this.unwrappedElementContainer.mainDiv,"searchterm","span");var wrappedEls=getElementsByClass(this.wrappedElementContainer.mainDiv,"searchterm","span");for(i=0,len=unwrappedEls.length;i<len;i++){matches[i]=new Match(this.level,null,unwrappedEls[i],wrappedEls[i]);}}else{var els=getElementsByClass(this.mainElementContainer.mainDiv,"searchterm","span");for(i=0,len=els.length;i<len;i++){matches[i]=new Match(this.level,els[i]);}}','return matches;},setSearchMatch:function(isMatch){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].setSearchMatch(isMatch);}},clearSearch:function(){for(var i=0,len=this.elementContainers.length;i<len;i++){this.elementContainers[i].clearSearch();}},accept:function(visitor){visitor.visitLogEntry(this);},serialize:function(items){items.push([LogItem.serializedItemKeys.LOG_ENTRY,this.level,this.formattedMessage]);}});function LogItemVisitor(){}','LogItemVisitor.prototype={visit:function(logItem){},visitParent:function(logItem){if(logItem.group){logItem.group.accept(this);}},visitChildren:function(logItem){for(var i=0,len=logItem.children.length;i<len;i++){logItem.children[i].accept(this);}},visitLogEntry:function(logEntry){this.visit(logEntry);},visitSeparator:function(separator){this.visit(separator);},visitGroup:function(group){this.visit(group);}};function GroupFlattener(){this.logEntriesAndSeparators=[];}','GroupFlattener.prototype=new LogItemVisitor();GroupFlattener.prototype.visitGroup=function(group){this.visitChildren(group);};GroupFlattener.prototype.visitLogEntry=function(logEntry){this.logEntriesAndSeparators.push(logEntry);};GroupFlattener.prototype.visitSeparator=function(separator){this.logEntriesAndSeparators.push(separator);};window.onload=function(){if(location.search){var queryBits=unescape(location.search).substr(1).split("&"),nameValueBits;for(var i=0,len=queryBits.length;i<len;i++){nameValueBits=queryBits[i].split("=");if(nameValueBits[0]=="log4javascript_domain"){document.domain=nameValueBits[1];break;}}}','logMainContainer=$("log");if(isIePre7){addClass(logMainContainer,"oldIe");}','rootGroup=new Group("root",true);rootGroup.render();currentGroup=rootGroup;setCommandInputWidth();setLogContainerHeight();toggleLoggingEnabled();toggleSearchEnabled();toggleSearchFilter();toggleSearchHighlight();applyFilters();checkAllLevels();toggleWrap();toggleNewestAtTop();toggleScrollToLatest();renderQueuedLogItems();loaded=true;$("command").value="";$("command").autocomplete="off";$("command").onkeydown=function(evt){evt=getEvent(evt);if(evt.keyCode==10||evt.keyCode==13){evalCommandLine();stopPropagation(evt);}else if(evt.keyCode==27){this.value="";this.focus();}else if(evt.keyCode==38&&commandHistory.length>0){currentCommandIndex=Math.max(0,currentCommandIndex-1);this.value=commandHistory[currentCommandIndex];moveCaretToEnd(this);}else if(evt.keyCode==40&&commandHistory.length>0){currentCommandIndex=Math.min(commandHistory.length-1,currentCommandIndex+1);this.value=commandHistory[currentCommandIndex];moveCaretToEnd(this);}};$("command").onkeypress=function(evt){evt=getEvent(evt);if(evt.keyCode==38&&commandHistory.length>0&&evt.preventDefault){evt.preventDefault();}};$("command").onkeyup=function(evt){evt=getEvent(evt);if(evt.keyCode==27&&evt.preventDefault){evt.preventDefault();this.focus();}};document.onkeydown=function keyEventHandler(evt){evt=getEvent(evt);switch(evt.keyCode){case 69:if(evt.shiftKey&&(evt.ctrlKey||evt.metaKey)){evalLastCommand();cancelKeyEvent(evt);return false;}','break;case 75:if(evt.shiftKey&&(evt.ctrlKey||evt.metaKey)){focusSearch();cancelKeyEvent(evt);return false;}','break;case 40:case 76:if(evt.shiftKey&&(evt.ctrlKey||evt.metaKey)){focusCommandLine();cancelKeyEvent(evt);return false;}','break;}};setTimeout(setLogContainerHeight,20);setShowCommandLine(showCommandLine);doSearch();};window.onunload=function(){if(mainWindowExists()){appender.unload();}','appender=null;};function toggleLoggingEnabled(){setLoggingEnabled($("enableLogging").checked);}','function setLoggingEnabled(enable){loggingEnabled=enable;}','var appender=null;function setAppender(appenderParam){appender=appenderParam;}','function setShowCloseButton(showCloseButton){$("closeButton").style.display=showCloseButton?"inline":"none";}','function setShowHideButton(showHideButton){$("hideButton").style.display=showHideButton?"inline":"none";}','var newestAtTop=false;function LogItemContentReverser(){}','LogItemContentReverser.prototype=new LogItemVisitor();LogItemContentReverser.prototype.visitGroup=function(group){group.reverseChildren();this.visitChildren(group);};function setNewestAtTop(isNewestAtTop){var oldNewestAtTop=newestAtTop;var i,iLen,j,jLen;newestAtTop=Boolean(isNewestAtTop);if(oldNewestAtTop!=newestAtTop){var visitor=new LogItemContentReverser();rootGroup.accept(visitor);if(currentSearch){var currentMatch=currentSearch.matches[currentMatchIndex];var matchIndex=0;var matches=[];var actOnLogEntry=function(logEntry){var logEntryMatches=logEntry.getSearchMatches();for(j=0,jLen=logEntryMatches.length;j<jLen;j++){matches[matchIndex]=logEntryMatches[j];if(currentMatch&&logEntryMatches[j].equals(currentMatch)){currentMatchIndex=matchIndex;}','matchIndex++;}};if(newestAtTop){for(i=logEntries.length-1;i>=0;i--){actOnLogEntry(logEntries[i]);}}else{for(i=0,iLen=logEntries.length;i<iLen;i++){actOnLogEntry(logEntries[i]);}}','currentSearch.matches=matches;if(currentMatch){currentMatch.setCurrent();}}else if(scrollToLatest){doScrollToLatest();}}','$("newestAtTop").checked=isNewestAtTop;}','function toggleNewestAtTop(){var isNewestAtTop=$("newestAtTop").checked;setNewestAtTop(isNewestAtTop);}','var scrollToLatest=true;function setScrollToLatest(isScrollToLatest){scrollToLatest=isScrollToLatest;if(scrollToLatest){doScrollToLatest();}','$("scrollToLatest").checked=isScrollToLatest;}','function toggleScrollToLatest(){var isScrollToLatest=$("scrollToLatest").checked;setScrollToLatest(isScrollToLatest);}','function doScrollToLatest(){var l=logMainContainer;if(typeof l.scrollTop!="undefined"){if(newestAtTop){l.scrollTop=0;}else{var latestLogEntry=l.lastChild;if(latestLogEntry){l.scrollTop=l.scrollHeight;}}}}','var closeIfOpenerCloses=true;function setCloseIfOpenerCloses(isCloseIfOpenerCloses){closeIfOpenerCloses=isCloseIfOpenerCloses;}','var maxMessages=null;function setMaxMessages(max){maxMessages=max;pruneLogEntries();}','var showCommandLine=false;function setShowCommandLine(isShowCommandLine){showCommandLine=isShowCommandLine;if(loaded){$("commandLine").style.display=showCommandLine?"block":"none";setCommandInputWidth();setLogContainerHeight();}}','function focusCommandLine(){if(loaded){$("command").focus();}}','function focusSearch(){if(loaded){$("searchBox").focus();}}','function getLogItems(){var items=[];for(var i=0,len=logItems.length;i<len;i++){logItems[i].serialize(items);}','return items;}','function setLogItems(items){var loggingReallyEnabled=loggingEnabled;loggingEnabled=true;for(var i=0,len=items.length;i<len;i++){switch(items[i][0]){case LogItem.serializedItemKeys.LOG_ENTRY:log(items[i][1],items[i][2]);break;case LogItem.serializedItemKeys.GROUP_START:group(items[i][1]);break;case LogItem.serializedItemKeys.GROUP_END:groupEnd();break;}}','loggingEnabled=loggingReallyEnabled;}','function log(logLevel,formattedMessage){if(loggingEnabled){var logEntry=new LogEntry(logLevel,formattedMessage);logEntries.push(logEntry);logEntriesAndSeparators.push(logEntry);logItems.push(logEntry);currentGroup.addChild(logEntry);if(loaded){if(logQueuedEventsTimer!==null){clearTimeout(logQueuedEventsTimer);}','logQueuedEventsTimer=setTimeout(renderQueuedLogItems,renderDelay);unrenderedLogItemsExist=true;}}}','function renderQueuedLogItems(){logQueuedEventsTimer=null;var pruned=pruneLogEntries();var initiallyHasMatches=currentSearch?currentSearch.hasMatches():false;for(var i=0,len=logItems.length;i<len;i++){if(!logItems[i].rendered){logItems[i].render();logItems[i].appendToLog();if(currentSearch&&(logItems[i]instanceof LogEntry)){currentSearch.applyTo(logItems[i]);}}}','if(currentSearch){if(pruned){if(currentSearch.hasVisibleMatches()){if(currentMatchIndex===null){setCurrentMatchIndex(0);}','displayMatches();}else{displayNoMatches();}}else if(!initiallyHasMatches&&currentSearch.hasVisibleMatches()){setCurrentMatchIndex(0);displayMatches();}}','if(scrollToLatest){doScrollToLatest();}','unrenderedLogItemsExist=false;}','function pruneLogEntries(){if((maxMessages!==null)&&(logEntriesAndSeparators.length>maxMessages)){var numberToDelete=logEntriesAndSeparators.length-maxMessages;var prunedLogEntries=logEntriesAndSeparators.slice(0,numberToDelete);if(currentSearch){currentSearch.removeMatches(prunedLogEntries);}','var group;for(var i=0;i<numberToDelete;i++){group=logEntriesAndSeparators[i].group;array_remove(logItems,logEntriesAndSeparators[i]);array_remove(logEntries,logEntriesAndSeparators[i]);logEntriesAndSeparators[i].remove(true,true);if(group.children.length===0&&group!==currentGroup&&group!==rootGroup){array_remove(logItems,group);group.remove(true,true);}}','logEntriesAndSeparators=array_removeFromStart(logEntriesAndSeparators,numberToDelete);return true;}','return false;}','function group(name,startExpanded){if(loggingEnabled){initiallyExpanded=(typeof startExpanded==="undefined")?true:Boolean(startExpanded);var newGroup=new Group(name,false,initiallyExpanded);currentGroup.addChild(newGroup);currentGroup=newGroup;logItems.push(newGroup);if(loaded){if(logQueuedEventsTimer!==null){clearTimeout(logQueuedEventsTimer);}','logQueuedEventsTimer=setTimeout(renderQueuedLogItems,renderDelay);unrenderedLogItemsExist=true;}}}','function groupEnd(){currentGroup=(currentGroup===rootGroup)?rootGroup:currentGroup.group;}','function mainPageReloaded(){currentGroup=rootGroup;var separator=new Separator();logEntriesAndSeparators.push(separator);logItems.push(separator);currentGroup.addChild(separator);}','function closeWindow(){if(appender&&mainWindowExists()){appender.close(true);}else{window.close();}}','function hide(){if(appender&&mainWindowExists()){appender.hide();}}','var mainWindow=window;var windowId="log4javascriptConsoleWindow_"+new Date().getTime()+"_"+(""+Math.random()).substr(2);function setMainWindow(win){mainWindow=win;mainWindow[windowId]=window;if(opener&&closeIfOpenerCloses){pollOpener();}}','function pollOpener(){if(closeIfOpenerCloses){if(mainWindowExists()){setTimeout(pollOpener,500);}else{closeWindow();}}}','function mainWindowExists(){try{return(mainWindow&&!mainWindow.closed&&mainWindow[windowId]==window);}catch(ex){}','return false;}','var logLevels=["TRACE","DEBUG","INFO","WARN","ERROR","FATAL"];function getCheckBox(logLevel){return $("switch_"+logLevel);}','function getIeWrappedLogContainer(){return $("log_wrapped");}','function getIeUnwrappedLogContainer(){return $("log_unwrapped");}','function applyFilters(){for(var i=0;i<logLevels.length;i++){if(getCheckBox(logLevels[i]).checked){addClass(logMainContainer,logLevels[i]);}else{removeClass(logMainContainer,logLevels[i]);}}','updateSearchFromFilters();}','function toggleAllLevels(){var turnOn=$("switch_ALL").checked;for(var i=0;i<logLevels.length;i++){getCheckBox(logLevels[i]).checked=turnOn;if(turnOn){addClass(logMainContainer,logLevels[i]);}else{removeClass(logMainContainer,logLevels[i]);}}}','function checkAllLevels(){for(var i=0;i<logLevels.length;i++){if(!getCheckBox(logLevels[i]).checked){getCheckBox("ALL").checked=false;return;}}','getCheckBox("ALL").checked=true;}','function clearLog(){rootGroup.clear();currentGroup=rootGroup;logEntries=[];logItems=[];logEntriesAndSeparators=[];doSearch();}','function toggleWrap(){var enable=$("wrap").checked;if(enable){addClass(logMainContainer,"wrap");}else{removeClass(logMainContainer,"wrap");}','refreshCurrentMatch();}','var searchTimer=null;function scheduleSearch(){try{clearTimeout(searchTimer);}catch(ex){}','searchTimer=setTimeout(doSearch,500);}','function Search(searchTerm,isRegex,searchRegex,isCaseSensitive){this.searchTerm=searchTerm;this.isRegex=isRegex;this.searchRegex=searchRegex;this.isCaseSensitive=isCaseSensitive;this.matches=[];}','Search.prototype={hasMatches:function(){return this.matches.length>0;},hasVisibleMatches:function(){if(this.hasMatches()){for(var i=0;i<this.matches.length;i++){if(this.matches[i].isVisible()){return true;}}}','return false;},match:function(logEntry){var entryText=String(logEntry.formattedMessage);var matchesSearch=false;if(this.isRegex){matchesSearch=this.searchRegex.test(entryText);}else if(this.isCaseSensitive){matchesSearch=(entryText.indexOf(this.searchTerm)>-1);}else{matchesSearch=(entryText.toLowerCase().indexOf(this.searchTerm.toLowerCase())>-1);}','return matchesSearch;},getNextVisibleMatchIndex:function(){for(var i=currentMatchIndex+1;i<this.matches.length;i++){if(this.matches[i].isVisible()){return i;}}','for(i=0;i<=currentMatchIndex;i++){if(this.matches[i].isVisible()){return i;}}','return-1;},getPreviousVisibleMatchIndex:function(){for(var i=currentMatchIndex-1;i>=0;i--){if(this.matches[i].isVisible()){return i;}}','for(var i=this.matches.length-1;i>=currentMatchIndex;i--){if(this.matches[i].isVisible()){return i;}}','return-1;},applyTo:function(logEntry){var doesMatch=this.match(logEntry);if(doesMatch){logEntry.group.expand();logEntry.setSearchMatch(true);var logEntryContent;var wrappedLogEntryContent;var searchTermReplacementStartTag="<span class=\\\"searchterm\\\">";var searchTermReplacementEndTag="<"+"/span>";var preTagName=isIe?"pre":"span";var preStartTag="<"+preTagName+" class=\\\"pre\\\">";var preEndTag="<"+"/"+preTagName+">";var startIndex=0;var searchIndex,matchedText,textBeforeMatch;if(this.isRegex){var flags=this.isCaseSensitive?"g":"gi";var capturingRegex=new RegExp("("+this.searchRegex.source+")",flags);var rnd=(""+Math.random()).substr(2);var startToken="%%s"+rnd+"%%";var endToken="%%e"+rnd+"%%";logEntryContent=logEntry.formattedMessage.replace(capturingRegex,startToken+"$1"+endToken);logEntryContent=escapeHtml(logEntryContent);var result;var searchString=logEntryContent;logEntryContent="";wrappedLogEntryContent="";while((searchIndex=searchString.indexOf(startToken,startIndex))>-1){var endTokenIndex=searchString.indexOf(endToken,searchIndex);matchedText=searchString.substring(searchIndex+startToken.length,endTokenIndex);textBeforeMatch=searchString.substring(startIndex,searchIndex);logEntryContent+=preStartTag+textBeforeMatch+preEndTag;logEntryContent+=searchTermReplacementStartTag+preStartTag+matchedText+','preEndTag+searchTermReplacementEndTag;if(isIe){wrappedLogEntryContent+=textBeforeMatch+searchTermReplacementStartTag+','matchedText+searchTermReplacementEndTag;}','startIndex=endTokenIndex+endToken.length;}','logEntryContent+=preStartTag+searchString.substr(startIndex)+preEndTag;if(isIe){wrappedLogEntryContent+=searchString.substr(startIndex);}}else{logEntryContent="";wrappedLogEntryContent="";var searchTermReplacementLength=searchTermReplacementStartTag.length+','this.searchTerm.length+searchTermReplacementEndTag.length;var searchTermLength=this.searchTerm.length;var searchTermLowerCase=this.searchTerm.toLowerCase();var logTextLowerCase=logEntry.formattedMessage.toLowerCase();while((searchIndex=logTextLowerCase.indexOf(searchTermLowerCase,startIndex))>-1){matchedText=escapeHtml(logEntry.formattedMessage.substr(searchIndex,this.searchTerm.length));textBeforeMatch=escapeHtml(logEntry.formattedMessage.substring(startIndex,searchIndex));var searchTermReplacement=searchTermReplacementStartTag+','preStartTag+matchedText+preEndTag+searchTermReplacementEndTag;logEntryContent+=preStartTag+textBeforeMatch+preEndTag+searchTermReplacement;if(isIe){wrappedLogEntryContent+=textBeforeMatch+searchTermReplacementStartTag+','matchedText+searchTermReplacementEndTag;}','startIndex=searchIndex+searchTermLength;}','var textAfterLastMatch=escapeHtml(logEntry.formattedMessage.substr(startIndex));logEntryContent+=preStartTag+textAfterLastMatch+preEndTag;if(isIe){wrappedLogEntryContent+=textAfterLastMatch;}}','logEntry.setContent(logEntryContent,wrappedLogEntryContent);var logEntryMatches=logEntry.getSearchMatches();this.matches=this.matches.concat(logEntryMatches);}else{logEntry.setSearchMatch(false);logEntry.setContent(logEntry.formattedMessage,logEntry.formattedMessage);}','return doesMatch;},removeMatches:function(logEntries){var matchesToRemoveCount=0;var currentMatchRemoved=false;var matchesToRemove=[];var i,iLen,j,jLen;for(i=0,iLen=this.matches.length;i<iLen;i++){for(j=0,jLen=logEntries.length;j<jLen;j++){if(this.matches[i].belongsTo(logEntries[j])){matchesToRemove.push(this.matches[i]);if(i===currentMatchIndex){currentMatchRemoved=true;}}}}','var newMatch=currentMatchRemoved?null:this.matches[currentMatchIndex];if(currentMatchRemoved){for(i=currentMatchIndex,iLen=this.matches.length;i<iLen;i++){if(this.matches[i].isVisible()&&!array_contains(matchesToRemove,this.matches[i])){newMatch=this.matches[i];break;}}}','for(i=0,iLen=matchesToRemove.length;i<iLen;i++){array_remove(this.matches,matchesToRemove[i]);matchesToRemove[i].remove();}','if(this.hasVisibleMatches()){if(newMatch===null){setCurrentMatchIndex(0);}else{var newMatchIndex=0;for(i=0,iLen=this.matches.length;i<iLen;i++){if(newMatch===this.matches[i]){newMatchIndex=i;break;}}','setCurrentMatchIndex(newMatchIndex);}}else{currentMatchIndex=null;displayNoMatches();}}};function getPageOffsetTop(el,container){var currentEl=el;var y=0;while(currentEl&&currentEl!=container){y+=currentEl.offsetTop;currentEl=currentEl.offsetParent;}','return y;}','function scrollIntoView(el){var logContainer=logMainContainer;if(!$("wrap").checked){var logContainerLeft=logContainer.scrollLeft;var logContainerRight=logContainerLeft+logContainer.offsetWidth;var elLeft=el.offsetLeft;var elRight=elLeft+el.offsetWidth;if(elLeft<logContainerLeft||elRight>logContainerRight){logContainer.scrollLeft=elLeft-(logContainer.offsetWidth-el.offsetWidth)/2;}}','var logContainerTop=logContainer.scrollTop;var logContainerBottom=logContainerTop+logContainer.offsetHeight;var elTop=getPageOffsetTop(el)-getToolBarsHeight();var elBottom=elTop+el.offsetHeight;if(elTop<logContainerTop||elBottom>logContainerBottom){logContainer.scrollTop=elTop-(logContainer.offsetHeight-el.offsetHeight)/2;}}','function Match(logEntryLevel,spanInMainDiv,spanInUnwrappedPre,spanInWrappedDiv){this.logEntryLevel=logEntryLevel;this.spanInMainDiv=spanInMainDiv;if(isIe){this.spanInUnwrappedPre=spanInUnwrappedPre;this.spanInWrappedDiv=spanInWrappedDiv;}','this.mainSpan=isIe?spanInUnwrappedPre:spanInMainDiv;}','Match.prototype={equals:function(match){return this.mainSpan===match.mainSpan;},setCurrent:function(){if(isIe){addClass(this.spanInUnwrappedPre,"currentmatch");addClass(this.spanInWrappedDiv,"currentmatch");var elementToScroll=$("wrap").checked?this.spanInWrappedDiv:this.spanInUnwrappedPre;scrollIntoView(elementToScroll);}else{addClass(this.spanInMainDiv,"currentmatch");scrollIntoView(this.spanInMainDiv);}},belongsTo:function(logEntry){if(isIe){return isDescendant(this.spanInUnwrappedPre,logEntry.unwrappedPre);}else{return isDescendant(this.spanInMainDiv,logEntry.mainDiv);}},setNotCurrent:function(){if(isIe){removeClass(this.spanInUnwrappedPre,"currentmatch");removeClass(this.spanInWrappedDiv,"currentmatch");}else{removeClass(this.spanInMainDiv,"currentmatch");}},isOrphan:function(){return isOrphan(this.mainSpan);},isVisible:function(){return getCheckBox(this.logEntryLevel).checked;},remove:function(){if(isIe){this.spanInUnwrappedPre=null;this.spanInWrappedDiv=null;}else{this.spanInMainDiv=null;}}};var currentSearch=null;var currentMatchIndex=null;function doSearch(){var searchBox=$("searchBox");var searchTerm=searchBox.value;var isRegex=$("searchRegex").checked;var isCaseSensitive=$("searchCaseSensitive").checked;var i;if(searchTerm===""){$("searchReset").disabled=true;$("searchNav").style.display="none";removeClass(document.body,"searching");removeClass(searchBox,"hasmatches");removeClass(searchBox,"nomatches");for(i=0;i<logEntries.length;i++){logEntries[i].clearSearch();logEntries[i].setContent(logEntries[i].formattedMessage,logEntries[i].formattedMessage);}','currentSearch=null;setLogContainerHeight();}else{$("searchReset").disabled=false;$("searchNav").style.display="block";var searchRegex;var regexValid;if(isRegex){try{searchRegex=isCaseSensitive?new RegExp(searchTerm,"g"):new RegExp(searchTerm,"gi");regexValid=true;replaceClass(searchBox,"validregex","invalidregex");searchBox.title="Valid regex";}catch(ex){regexValid=false;replaceClass(searchBox,"invalidregex","validregex");searchBox.title="Invalid regex: "+(ex.message?ex.message:(ex.description?ex.description:"unknown error"));return;}}else{searchBox.title="";removeClass(searchBox,"validregex");removeClass(searchBox,"invalidregex");}','addClass(document.body,"searching");currentSearch=new Search(searchTerm,isRegex,searchRegex,isCaseSensitive);for(i=0;i<logEntries.length;i++){currentSearch.applyTo(logEntries[i]);}','setLogContainerHeight();if(currentSearch.hasVisibleMatches()){setCurrentMatchIndex(0);displayMatches();}else{displayNoMatches();}}}','function updateSearchFromFilters(){if(currentSearch){if(currentSearch.hasMatches()){if(currentMatchIndex===null){currentMatchIndex=0;}','var currentMatch=currentSearch.matches[currentMatchIndex];if(currentMatch.isVisible()){displayMatches();setCurrentMatchIndex(currentMatchIndex);}else{currentMatch.setNotCurrent();var nextVisibleMatchIndex=currentSearch.getNextVisibleMatchIndex();if(nextVisibleMatchIndex>-1){setCurrentMatchIndex(nextVisibleMatchIndex);displayMatches();}else{displayNoMatches();}}}else{displayNoMatches();}}}','function refreshCurrentMatch(){if(currentSearch&&currentSearch.hasVisibleMatches()){setCurrentMatchIndex(currentMatchIndex);}}','function displayMatches(){replaceClass($("searchBox"),"hasmatches","nomatches");$("searchBox").title=""+currentSearch.matches.length+" matches found";$("searchNav").style.display="block";setLogContainerHeight();}','function displayNoMatches(){replaceClass($("searchBox"),"nomatches","hasmatches");$("searchBox").title="No matches found";$("searchNav").style.display="none";setLogContainerHeight();}','function toggleSearchEnabled(enable){enable=(typeof enable=="undefined")?!$("searchDisable").checked:enable;$("searchBox").disabled=!enable;$("searchReset").disabled=!enable;$("searchRegex").disabled=!enable;$("searchNext").disabled=!enable;$("searchPrevious").disabled=!enable;$("searchCaseSensitive").disabled=!enable;$("searchNav").style.display=(enable&&($("searchBox").value!=="")&&currentSearch&&currentSearch.hasVisibleMatches())?"block":"none";if(enable){removeClass($("search"),"greyedout");addClass(document.body,"searching");if($("searchHighlight").checked){addClass(logMainContainer,"searchhighlight");}else{removeClass(logMainContainer,"searchhighlight");}','if($("searchFilter").checked){addClass(logMainContainer,"searchfilter");}else{removeClass(logMainContainer,"searchfilter");}','$("searchDisable").checked=!enable;}else{addClass($("search"),"greyedout");removeClass(document.body,"searching");removeClass(logMainContainer,"searchhighlight");removeClass(logMainContainer,"searchfilter");}','setLogContainerHeight();}','function toggleSearchFilter(){var enable=$("searchFilter").checked;if(enable){addClass(logMainContainer,"searchfilter");}else{removeClass(logMainContainer,"searchfilter");}','refreshCurrentMatch();}','function toggleSearchHighlight(){var enable=$("searchHighlight").checked;if(enable){addClass(logMainContainer,"searchhighlight");}else{removeClass(logMainContainer,"searchhighlight");}}','function clearSearch(){$("searchBox").value="";doSearch();}','function searchNext(){if(currentSearch!==null&&currentMatchIndex!==null){currentSearch.matches[currentMatchIndex].setNotCurrent();var nextMatchIndex=currentSearch.getNextVisibleMatchIndex();if(nextMatchIndex>currentMatchIndex||confirm("Reached the end of the page. Start from the top?")){setCurrentMatchIndex(nextMatchIndex);}}}','function searchPrevious(){if(currentSearch!==null&&currentMatchIndex!==null){currentSearch.matches[currentMatchIndex].setNotCurrent();var previousMatchIndex=currentSearch.getPreviousVisibleMatchIndex();if(previousMatchIndex<currentMatchIndex||confirm("Reached the start of the page. Continue from the bottom?")){setCurrentMatchIndex(previousMatchIndex);}}}','function setCurrentMatchIndex(index){currentMatchIndex=index;currentSearch.matches[currentMatchIndex].setCurrent();}','function addClass(el,cssClass){if(!hasClass(el,cssClass)){if(el.className){el.className+=" "+cssClass;}else{el.className=cssClass;}}}','function hasClass(el,cssClass){if(el.className){var classNames=el.className.split(" ");return array_contains(classNames,cssClass);}','return false;}','function removeClass(el,cssClass){if(hasClass(el,cssClass)){var existingClasses=el.className.split(" ");var newClasses=[];for(var i=0,len=existingClasses.length;i<len;i++){if(existingClasses[i]!=cssClass){newClasses[newClasses.length]=existingClasses[i];}}','el.className=newClasses.join(" ");}}','function replaceClass(el,newCssClass,oldCssClass){removeClass(el,oldCssClass);addClass(el,newCssClass);}','function getElementsByClass(el,cssClass,tagName){var elements=el.getElementsByTagName(tagName);var matches=[];for(var i=0,len=elements.length;i<len;i++){if(hasClass(elements[i],cssClass)){matches.push(elements[i]);}}','return matches;}','function $(id){return document.getElementById(id);}','function isDescendant(node,ancestorNode){while(node!=null){if(node===ancestorNode){return true;}','node=node.parentNode;}','return false;}','function isOrphan(node){var currentNode=node;while(currentNode){if(currentNode==document.body){return false;}','currentNode=currentNode.parentNode;}','return true;}','function escapeHtml(str){return str.replace(/&/g,"&amp;").replace(/[<]/g,"&lt;").replace(/>/g,"&gt;");}','function getWindowWidth(){if(window.innerWidth){return window.innerWidth;}else if(document.documentElement&&document.documentElement.clientWidth){return document.documentElement.clientWidth;}else if(document.body){return document.body.clientWidth;}','return 0;}','function getWindowHeight(){if(window.innerHeight){return window.innerHeight;}else if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight;}else if(document.body){return document.body.clientHeight;}','return 0;}','function getToolBarsHeight(){return $("switches").offsetHeight;}','function getChromeHeight(){var height=getToolBarsHeight();if(showCommandLine){height+=$("commandLine").offsetHeight;}','return height;}','function setLogContainerHeight(){if(logMainContainer){var windowHeight=getWindowHeight();$("body").style.height=getWindowHeight()+"px";logMainContainer.style.height=""+','Math.max(0,windowHeight-getChromeHeight())+"px";}}','function setCommandInputWidth(){if(showCommandLine){$("command").style.width=""+Math.max(0,$("commandLineContainer").offsetWidth-','($("evaluateButton").offsetWidth+13))+"px";}}','window.onresize=function(){setCommandInputWidth();setLogContainerHeight();};if(!Array.prototype.push){Array.prototype.push=function(){for(var i=0,len=arguments.length;i<len;i++){this[this.length]=arguments[i];}','return this.length;};}','if(!Array.prototype.pop){Array.prototype.pop=function(){if(this.length>0){var val=this[this.length-1];this.length=this.length-1;return val;}};}','if(!Array.prototype.shift){Array.prototype.shift=function(){if(this.length>0){var firstItem=this[0];for(var i=0,len=this.length-1;i<len;i++){this[i]=this[i+1];}','this.length=this.length-1;return firstItem;}};}','if(!Array.prototype.splice){Array.prototype.splice=function(startIndex,deleteCount){var itemsAfterDeleted=this.slice(startIndex+deleteCount);var itemsDeleted=this.slice(startIndex,startIndex+deleteCount);this.length=startIndex;var argumentsArray=[];for(var i=0,len=arguments.length;i<len;i++){argumentsArray[i]=arguments[i];}','var itemsToAppend=(argumentsArray.length>2)?itemsAfterDeleted=argumentsArray.slice(2).concat(itemsAfterDeleted):itemsAfterDeleted;for(i=0,len=itemsToAppend.length;i<len;i++){this.push(itemsToAppend[i]);}','return itemsDeleted;};}','function array_remove(arr,val){var index=-1;for(var i=0,len=arr.length;i<len;i++){if(arr[i]===val){index=i;break;}}','if(index>=0){arr.splice(index,1);return index;}else{return false;}}','function array_removeFromStart(array,numberToRemove){if(Array.prototype.splice){array.splice(0,numberToRemove);}else{for(var i=numberToRemove,len=array.length;i<len;i++){array[i-numberToRemove]=array[i];}','array.length=array.length-numberToRemove;}','return array;}','function array_contains(arr,val){for(var i=0,len=arr.length;i<len;i++){if(arr[i]==val){return true;}}','return false;}','function getErrorMessage(ex){if(ex.message){return ex.message;}else if(ex.description){return ex.description;}','return""+ex;}','function moveCaretToEnd(input){if(input.setSelectionRange){input.focus();var length=input.value.length;input.setSelectionRange(length,length);}else if(input.createTextRange){var range=input.createTextRange();range.collapse(false);range.select();}','input.focus();}','function stopPropagation(evt){if(evt.stopPropagation){evt.stopPropagation();}else if(typeof evt.cancelBubble!="undefined"){evt.cancelBubble=true;}}','function getEvent(evt){return evt?evt:event;}','function getTarget(evt){return evt.target?evt.target:evt.srcElement;}','function getRelatedTarget(evt){if(evt.relatedTarget){return evt.relatedTarget;}else if(evt.srcElement){switch(evt.type){case"mouseover":return evt.fromElement;case"mouseout":return evt.toElement;default:return evt.srcElement;}}}','function cancelKeyEvent(evt){evt.returnValue=false;stopPropagation(evt);}','function evalCommandLine(){var expr=$("command").value;evalCommand(expr);$("command").value="";}','function evalLastCommand(){if(lastCommand!=null){evalCommand(lastCommand);}}','var lastCommand=null;var commandHistory=[];var currentCommandIndex=0;function evalCommand(expr){if(appender){appender.evalCommandAndAppend(expr);}else{var prefix=">>> "+expr+"\\r\\n";try{log("INFO",prefix+eval(expr));}catch(ex){log("ERROR",prefix+"Error: "+getErrorMessage(ex));}}','if(expr!=commandHistory[commandHistory.length-1]){commandHistory.push(expr);if(appender){appender.storeCommandHistory(commandHistory);}}','currentCommandIndex=(expr==commandHistory[currentCommandIndex])?currentCommandIndex+1:commandHistory.length;lastCommand=expr;}','//]]>','</script>','<style type="text/css">','body{background-color:white;color:black;padding:0;margin:0;font-family:tahoma,verdana,arial,helvetica,sans-serif;overflow:hidden}div#switchesContainer input{margin-bottom:0}div.toolbar{border-top:solid #ffffff 1px;border-bottom:solid #aca899 1px;background-color:#f1efe7;padding:3px 5px;font-size:68.75%}div.toolbar,div#search input{font-family:tahoma,verdana,arial,helvetica,sans-serif}div.toolbar input.button{padding:0 5px;font-size:100%}div.toolbar input.hidden{display:none}div#switches input#clearButton{margin-left:20px}div#levels label{font-weight:bold}div#levels label,div#options label{margin-right:5px}div#levels label#wrapLabel{font-weight:normal}div#search label{margin-right:10px}div#search label.searchboxlabel{margin-right:0}div#search input{font-size:100%}div#search input.validregex{color:green}div#search input.invalidregex{color:red}div#search input.nomatches{color:white;background-color:#ff6666}div#search input.nomatches{color:white;background-color:#ff6666}div#searchNav{display:none}div#commandLine{display:none}div#commandLine input#command{font-size:100%;font-family:Courier New,Courier}div#commandLine input#evaluateButton{}*.greyedout{color:gray !important;border-color:gray !important}*.greyedout *.alwaysenabled{color:black}*.unselectable{-khtml-user-select:none;-moz-user-select:none;user-select:none}div#log{font-family:Courier New,Courier;font-size:75%;width:100%;overflow:auto;clear:both;position:relative}div.group{border-color:#cccccc;border-style:solid;border-width:1px 0 1px 1px;overflow:visible}div.oldIe div.group,div.oldIe div.group *,div.oldIe *.logentry{height:1%}div.group div.groupheading span.expander{border:solid black 1px;font-family:Courier New,Courier;font-size:0.833em;background-color:#eeeeee;position:relative;top:-1px;color:black;padding:0 2px;cursor:pointer;cursor:hand;height:1%}div.group div.groupcontent{margin-left:10px;padding-bottom:2px;overflow:visible}div.group div.expanded{display:block}div.group div.collapsed{display:none}*.logentry{overflow:visible;display:none;white-space:pre}span.pre{white-space:pre}pre.unwrapped{display:inline !important}pre.unwrapped pre.pre,div.wrapped pre.pre{display:inline}div.wrapped pre.pre{white-space:normal}div.wrapped{display:none}body.searching *.logentry span.currentmatch{color:white !important;background-color:green !important}body.searching div.searchhighlight *.logentry span.searchterm{color:black;background-color:yellow}div.wrap *.logentry{white-space:normal !important;border-width:0 0 1px 0;border-color:#dddddd;border-style:dotted}div.wrap #log_wrapped,#log_unwrapped{display:block}div.wrap #log_unwrapped,#log_wrapped{display:none}div.wrap *.logentry span.pre{overflow:visible;white-space:normal}div.wrap *.logentry pre.unwrapped{display:none}div.wrap *.logentry span.wrapped{display:inline}div.searchfilter *.searchnonmatch{display:none !important}div#log *.TRACE,label#label_TRACE{color:#666666}div#log *.DEBUG,label#label_DEBUG{color:green}div#log *.INFO,label#label_INFO{color:#000099}div#log *.WARN,label#label_WARN{color:#999900}div#log *.ERROR,label#label_ERROR{color:red}div#log *.FATAL,label#label_FATAL{color:#660066}div.TRACE#log *.TRACE,div.DEBUG#log *.DEBUG,div.INFO#log *.INFO,div.WARN#log *.WARN,div.ERROR#log *.ERROR,div.FATAL#log *.FATAL{display:block}div#log div.separator{background-color:#cccccc;margin:5px 0;line-height:1px}','</style>','</head>','<body id="body">','<div id="switchesContainer">','<div id="switches">','<div id="levels" class="toolbar">','Filters:','<input type="checkbox" id="switch_TRACE" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide trace messages" /><label for="switch_TRACE" id="label_TRACE">trace</label>','<input type="checkbox" id="switch_DEBUG" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide debug messages" /><label for="switch_DEBUG" id="label_DEBUG">debug</label>','<input type="checkbox" id="switch_INFO" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide info messages" /><label for="switch_INFO" id="label_INFO">info</label>','<input type="checkbox" id="switch_WARN" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide warn messages" /><label for="switch_WARN" id="label_WARN">warn</label>','<input type="checkbox" id="switch_ERROR" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide error messages" /><label for="switch_ERROR" id="label_ERROR">error</label>','<input type="checkbox" id="switch_FATAL" onclick="applyFilters(); checkAllLevels()" checked="checked" title="Show/hide fatal messages" /><label for="switch_FATAL" id="label_FATAL">fatal</label>','<input type="checkbox" id="switch_ALL" onclick="toggleAllLevels(); applyFilters()" checked="checked" title="Show/hide all messages" /><label for="switch_ALL" id="label_ALL">all</label>','</div>','<div id="search" class="toolbar">','<label for="searchBox" class="searchboxlabel">Search:</label> <input type="text" id="searchBox" onclick="toggleSearchEnabled(true)" onkeyup="scheduleSearch()" size="20" />','<input type="button" id="searchReset" disabled="disabled" value="Reset" onclick="clearSearch()" class="button" title="Reset the search" />','<input type="checkbox" id="searchRegex" onclick="doSearch()" title="If checked, search is treated as a regular expression" /><label for="searchRegex">Regex</label>','<input type="checkbox" id="searchCaseSensitive" onclick="doSearch()" title="If checked, search is case sensitive" /><label for="searchCaseSensitive">Match case</label>','<input type="checkbox" id="searchDisable" onclick="toggleSearchEnabled()" title="Enable/disable search" /><label for="searchDisable" class="alwaysenabled">Disable</label>','<div id="searchNav">','<input type="button" id="searchNext" disabled="disabled" value="Next" onclick="searchNext()" class="button" title="Go to the next matching log entry" />','<input type="button" id="searchPrevious" disabled="disabled" value="Previous" onclick="searchPrevious()" class="button" title="Go to the previous matching log entry" />','<input type="checkbox" id="searchFilter" onclick="toggleSearchFilter()" title="If checked, non-matching log entries are filtered out" /><label for="searchFilter">Filter</label>','<input type="checkbox" id="searchHighlight" onclick="toggleSearchHighlight()" title="Highlight matched search terms" /><label for="searchHighlight" class="alwaysenabled">Highlight all</label>','</div>','</div>','<div id="options" class="toolbar">','Options:','<input type="checkbox" id="enableLogging" onclick="toggleLoggingEnabled()" checked="checked" title="Enable/disable logging" /><label for="enableLogging" id="enableLoggingLabel">Log</label>','<input type="checkbox" id="wrap" onclick="toggleWrap()" title="Enable / disable word wrap" /><label for="wrap" id="wrapLabel">Wrap</label>','<input type="checkbox" id="newestAtTop" onclick="toggleNewestAtTop()" title="If checked, causes newest messages to appear at the top" /><label for="newestAtTop" id="newestAtTopLabel">Newest at the top</label>','<input type="checkbox" id="scrollToLatest" onclick="toggleScrollToLatest()" checked="checked" title="If checked, window automatically scrolls to a new message when it is added" /><label for="scrollToLatest" id="scrollToLatestLabel">Scroll to latest</label>','<input type="button" id="clearButton" value="Clear" onclick="clearLog()" class="button" title="Clear all log messages"  />','<input type="button" id="hideButton" value="Hide" onclick="hide()" class="hidden button" title="Hide the console" />','<input type="button" id="closeButton" value="Close" onclick="closeWindow()" class="hidden button" title="Close the window" />','</div>','</div>','</div>','<div id="log" class="TRACE DEBUG INFO WARN ERROR FATAL"></div>','<div id="commandLine" class="toolbar">','<div id="commandLineContainer">','<input type="text" id="command" title="Enter a JavaScript command here and hit return or press \'Evaluate\'" />','<input type="button" id="evaluateButton" value="Evaluate" class="button" title="Evaluate the command" onclick="evalCommandLine()" />','</div>','</div>','</body>','</html>',''];};var defaultCommandLineFunctions=[];ConsoleAppender=function(){};var consoleAppenderIdCounter=1;ConsoleAppender.prototype=new Appender();ConsoleAppender.prototype.create=function(inPage,container,lazyInit,initiallyMinimized,useDocumentWrite,width,height,focusConsoleWindow){var appender=this;var initialized=false;var consoleWindowCreated=false;var consoleWindowLoaded=false;var consoleClosed=false;var queuedLoggingEvents=[];var isSupported=true;var consoleAppenderId=consoleAppenderIdCounter++;initiallyMinimized=extractBooleanFromParam(initiallyMinimized,this.defaults.initiallyMinimized);lazyInit=extractBooleanFromParam(lazyInit,this.defaults.lazyInit);useDocumentWrite=extractBooleanFromParam(useDocumentWrite,this.defaults.useDocumentWrite);var newestMessageAtTop=this.defaults.newestMessageAtTop;var scrollToLatestMessage=this.defaults.scrollToLatestMessage;width=width?width:this.defaults.width;height=height?height:this.defaults.height;var maxMessages=this.defaults.maxMessages;var showCommandLine=this.defaults.showCommandLine;var commandLineObjectExpansionDepth=this.defaults.commandLineObjectExpansionDepth;var showHideButton=this.defaults.showHideButton;var showCloseButton=this.defaults.showCloseButton;this.setLayout(this.defaults.layout);var init,createWindow,safeToAppend,getConsoleWindow,open;var appenderName=inPage?"InPageAppender":"PopUpAppender";var checkCanConfigure=function(configOptionName){if(consoleWindowCreated){handleError(appenderName+": configuration option '"+configOptionName+"' may not be set after the appender has been initialized");return false;}
return true;};var consoleWindowExists=function(){return(consoleWindowLoaded&&isSupported&&!consoleClosed);};this.isNewestMessageAtTop=function(){return newestMessageAtTop;};this.setNewestMessageAtTop=function(newestMessageAtTopParam){newestMessageAtTop=bool(newestMessageAtTopParam);if(consoleWindowExists()){getConsoleWindow().setNewestAtTop(newestMessageAtTop);}};this.isScrollToLatestMessage=function(){return scrollToLatestMessage;};this.setScrollToLatestMessage=function(scrollToLatestMessageParam){scrollToLatestMessage=bool(scrollToLatestMessageParam);if(consoleWindowExists()){getConsoleWindow().setScrollToLatest(scrollToLatestMessage);}};this.getWidth=function(){return width;};this.setWidth=function(widthParam){if(checkCanConfigure("width")){width=extractStringFromParam(widthParam,width);}};this.getHeight=function(){return height;};this.setHeight=function(heightParam){if(checkCanConfigure("height")){height=extractStringFromParam(heightParam,height);}};this.getMaxMessages=function(){return maxMessages;};this.setMaxMessages=function(maxMessagesParam){maxMessages=extractIntFromParam(maxMessagesParam,maxMessages);if(consoleWindowExists()){getConsoleWindow().setMaxMessages(maxMessages);}};this.isShowCommandLine=function(){return showCommandLine;};this.setShowCommandLine=function(showCommandLineParam){showCommandLine=bool(showCommandLineParam);if(consoleWindowExists()){getConsoleWindow().setShowCommandLine(showCommandLine);}};this.isShowHideButton=function(){return showHideButton;};this.setShowHideButton=function(showHideButtonParam){showHideButton=bool(showHideButtonParam);if(consoleWindowExists()){getConsoleWindow().setShowHideButton(showHideButton);}};this.isShowCloseButton=function(){return showCloseButton;};this.setShowCloseButton=function(showCloseButtonParam){showCloseButton=bool(showCloseButtonParam);if(consoleWindowExists()){getConsoleWindow().setShowCloseButton(showCloseButton);}};this.getCommandLineObjectExpansionDepth=function(){return commandLineObjectExpansionDepth;};this.setCommandLineObjectExpansionDepth=function(commandLineObjectExpansionDepthParam){commandLineObjectExpansionDepth=extractIntFromParam(commandLineObjectExpansionDepthParam,commandLineObjectExpansionDepth);};var minimized=initiallyMinimized;this.isInitiallyMinimized=function(){return initiallyMinimized;};this.setInitiallyMinimized=function(initiallyMinimizedParam){if(checkCanConfigure("initiallyMinimized")){initiallyMinimized=bool(initiallyMinimizedParam);minimized=initiallyMinimized;}};this.isUseDocumentWrite=function(){return useDocumentWrite;};this.setUseDocumentWrite=function(useDocumentWriteParam){if(checkCanConfigure("useDocumentWrite")){useDocumentWrite=bool(useDocumentWriteParam);}};function QueuedLoggingEvent(loggingEvent,formattedMessage){this.loggingEvent=loggingEvent;this.levelName=loggingEvent.level.name;this.formattedMessage=formattedMessage;}
QueuedLoggingEvent.prototype.append=function(){getConsoleWindow().log(this.levelName,this.formattedMessage);};function QueuedGroup(name,initiallyExpanded){this.name=name;this.initiallyExpanded=initiallyExpanded;}
QueuedGroup.prototype.append=function(){getConsoleWindow().group(this.name,this.initiallyExpanded);};function QueuedGroupEnd(){}
QueuedGroupEnd.prototype.append=function(){getConsoleWindow().groupEnd();};var checkAndAppend=function(){safeToAppend();if(!initialized){init();}else if(consoleClosed&&reopenWhenClosed){createWindow();}
if(safeToAppend()){appendQueuedLoggingEvents();}};this.append=function(loggingEvent){if(isSupported){var formattedMessage=appender.getLayout().formatWithException(loggingEvent);queuedLoggingEvents.push(new QueuedLoggingEvent(loggingEvent,formattedMessage));checkAndAppend();}};this.group=function(name,initiallyExpanded){if(isSupported){queuedLoggingEvents.push(new QueuedGroup(name,initiallyExpanded));checkAndAppend();}};this.groupEnd=function(){if(isSupported){queuedLoggingEvents.push(new QueuedGroupEnd());checkAndAppend();}};var appendQueuedLoggingEvents=function(){while(queuedLoggingEvents.length>0){queuedLoggingEvents.shift().append();}
if(focusConsoleWindow){getConsoleWindow().focus();}};this.setAddedToLogger=function(logger){this.loggers.push(logger);if(enabled&&!lazyInit){init();}};this.clear=function(){if(consoleWindowExists()){getConsoleWindow().clearLog();}
queuedLoggingEvents.length=0;};this.focus=function(){if(consoleWindowExists()){getConsoleWindow().focus();}};this.focusCommandLine=function(){if(consoleWindowExists()){getConsoleWindow().focusCommandLine();}};this.focusSearch=function(){if(consoleWindowExists()){getConsoleWindow().focusSearch();}};var commandWindow=window;this.getCommandWindow=function(){return commandWindow;};this.setCommandWindow=function(commandWindowParam){commandWindow=commandWindowParam;};this.executeLastCommand=function(){if(consoleWindowExists()){getConsoleWindow().evalLastCommand();}};var commandLayout=new PatternLayout("%m");this.getCommandLayout=function(){return commandLayout;};this.setCommandLayout=function(commandLayoutParam){commandLayout=commandLayoutParam;};this.evalCommandAndAppend=function(expr){var commandReturnValue={appendResult:true,isError:false};var commandOutput="";try{var result,i;if(!commandWindow.eval&&commandWindow.execScript){commandWindow.execScript("null");}
var commandLineFunctionsHash={};for(i=0,len=commandLineFunctions.length;i<len;i++){commandLineFunctionsHash[commandLineFunctions[i][0]]=commandLineFunctions[i][1];}
var objectsToRestore=[];var addObjectToRestore=function(name){objectsToRestore.push([name,commandWindow[name]]);};addObjectToRestore("appender");commandWindow.appender=appender;addObjectToRestore("commandReturnValue");commandWindow.commandReturnValue=commandReturnValue;addObjectToRestore("commandLineFunctionsHash");commandWindow.commandLineFunctionsHash=commandLineFunctionsHash;var addFunctionToWindow=function(name){addObjectToRestore(name);commandWindow[name]=function(){return this.commandLineFunctionsHash[name](appender,arguments,commandReturnValue);};};for(i=0,len=commandLineFunctions.length;i<len;i++){addFunctionToWindow(commandLineFunctions[i][0]);}
if(commandWindow===window&&commandWindow.execScript){addObjectToRestore("evalExpr");addObjectToRestore("result");window.evalExpr=expr;commandWindow.execScript("window.result=eval(window.evalExpr);");result=window.result;}else{result=commandWindow.eval(expr);}
commandOutput=isUndefined(result)?result:formatObjectExpansion(result,commandLineObjectExpansionDepth);for(i=0,len=objectsToRestore.length;i<len;i++){commandWindow[objectsToRestore[i][0]]=objectsToRestore[i][1];}}catch(ex){commandOutput="Error evaluating command: "+getExceptionStringRep(ex);commandReturnValue.isError=true;}
if(commandReturnValue.appendResult){var message=">>> "+expr;if(!isUndefined(commandOutput)){message+=newLine+commandOutput;}
var level=commandReturnValue.isError?Level.ERROR:Level.INFO;var loggingEvent=new LoggingEvent(null,new Date(),level,[message],null);var mainLayout=this.getLayout();this.setLayout(commandLayout);this.append(loggingEvent);this.setLayout(mainLayout);}};var commandLineFunctions=defaultCommandLineFunctions.concat([]);this.addCommandLineFunction=function(functionName,commandLineFunction){commandLineFunctions.push([functionName,commandLineFunction]);};var commandHistoryCookieName="log4javascriptCommandHistory";this.storeCommandHistory=function(commandHistory){setCookie(commandHistoryCookieName,commandHistory.join(","));};var writeHtml=function(doc){var lines=getConsoleHtmlLines();doc.open();for(var i=0,len=lines.length;i<len;i++){doc.writeln(lines[i]);}
doc.close();};this.setEventTypes(["load","unload"]);var consoleWindowLoadHandler=function(){var win=getConsoleWindow();win.setAppender(appender);win.setNewestAtTop(newestMessageAtTop);win.setScrollToLatest(scrollToLatestMessage);win.setMaxMessages(maxMessages);win.setShowCommandLine(showCommandLine);win.setShowHideButton(showHideButton);win.setShowCloseButton(showCloseButton);win.setMainWindow(window);var storedValue=getCookie(commandHistoryCookieName);if(storedValue){win.commandHistory=storedValue.split(",");win.currentCommandIndex=win.commandHistory.length;}
appender.dispatchEvent("load",{"win":win});};this.unload=function(){logLog.debug("unload "+this+", caller: "+this.unload.caller);if(!consoleClosed){logLog.debug("really doing unload "+this);consoleClosed=true;consoleWindowLoaded=false;consoleWindowCreated=false;appender.dispatchEvent("unload",{});}};var pollConsoleWindow=function(windowTest,interval,successCallback,errorMessage){function doPoll(){try{if(consoleClosed){clearInterval(poll);}
if(windowTest(getConsoleWindow())){clearInterval(poll);successCallback();}}catch(ex){clearInterval(poll);isSupported=false;handleError(errorMessage,ex);}}
var poll=setInterval(doPoll,interval);};var getConsoleUrl=function(){var documentDomainSet=(document.domain!=location.hostname);return useDocumentWrite?"":getBaseUrl()+"console.html"+
(documentDomainSet?"?log4javascript_domain="+escape(document.domain):"");};if(inPage){var containerElement=null;var cssProperties=[];this.addCssProperty=function(name,value){if(checkCanConfigure("cssProperties")){cssProperties.push([name,value]);}};var windowCreationStarted=false;var iframeContainerDiv;var iframeId=uniqueId+"_InPageAppender_"+consoleAppenderId;this.hide=function(){if(initialized&&consoleWindowCreated){if(consoleWindowExists()){getConsoleWindow().$("command").blur();}
iframeContainerDiv.style.display="none";minimized=true;}};this.show=function(){if(initialized){if(consoleWindowCreated){iframeContainerDiv.style.display="block";this.setShowCommandLine(showCommandLine);minimized=false;}else if(!windowCreationStarted){createWindow(true);}}};this.isVisible=function(){return!minimized&&!consoleClosed;};this.close=function(fromButton){if(!consoleClosed&&(!fromButton||confirm("This will permanently remove the console from the page. No more messages will be logged. Do you wish to continue?"))){iframeContainerDiv.parentNode.removeChild(iframeContainerDiv);this.unload();}};open=function(){var initErrorMessage="InPageAppender.open: unable to create console iframe";function finalInit(){try{if(!initiallyMinimized){appender.show();}
consoleWindowLoadHandler();consoleWindowLoaded=true;appendQueuedLoggingEvents();}catch(ex){isSupported=false;handleError(initErrorMessage,ex);}}
function writeToDocument(){try{var windowTest=function(win){return isLoaded(win);};if(useDocumentWrite){writeHtml(getConsoleWindow().document);}
if(windowTest(getConsoleWindow())){finalInit();}else{pollConsoleWindow(windowTest,100,finalInit,initErrorMessage);}}catch(ex){isSupported=false;handleError(initErrorMessage,ex);}}
minimized=false;iframeContainerDiv=containerElement.appendChild(document.createElement("div"));iframeContainerDiv.style.width=width;iframeContainerDiv.style.height=height;iframeContainerDiv.style.border="solid gray 1px";for(var i=0,len=cssProperties.length;i<len;i++){iframeContainerDiv.style[cssProperties[i][0]]=cssProperties[i][1];}
var iframeSrc=useDocumentWrite?"":" src='"+getConsoleUrl()+"'";iframeContainerDiv.innerHTML="<iframe id='"+iframeId+"' name='"+iframeId+"' width='100%' height='100%' frameborder='0'"+iframeSrc+" scrolling='no'></iframe>";consoleClosed=false;var iframeDocumentExistsTest=function(win){try{return bool(win)&&bool(win.document);}catch(ex){return false;}};if(iframeDocumentExistsTest(getConsoleWindow())){writeToDocument();}else{pollConsoleWindow(iframeDocumentExistsTest,100,writeToDocument,initErrorMessage);}
consoleWindowCreated=true;};createWindow=function(show){if(show||!initiallyMinimized){var pageLoadHandler=function(){if(!container){containerElement=document.createElement("div");containerElement.style.position="fixed";containerElement.style.left="0";containerElement.style.right="0";containerElement.style.bottom="0";document.body.appendChild(containerElement);appender.addCssProperty("borderWidth","1px 0 0 0");appender.addCssProperty("zIndex",1000000);open();}else{try{var el=document.getElementById(container);if(el.nodeType==1){containerElement=el;}
open();}catch(ex){handleError("InPageAppender.init: invalid container element '"+container+"' supplied",ex);}}};if(pageLoaded&&container&&container.appendChild){containerElement=container;open();}else if(pageLoaded){pageLoadHandler();}else{log4javascript.addEventListener("load",pageLoadHandler);}
windowCreationStarted=true;}};init=function(){createWindow();initialized=true;};getConsoleWindow=function(){var iframe=window.frames[iframeId];if(iframe){return iframe;}};safeToAppend=function(){if(isSupported&&!consoleClosed){if(consoleWindowCreated&&!consoleWindowLoaded&&getConsoleWindow()&&isLoaded(getConsoleWindow())){consoleWindowLoaded=true;}
return consoleWindowLoaded;}
return false;};}else{var useOldPopUp=appender.defaults.useOldPopUp;var complainAboutPopUpBlocking=appender.defaults.complainAboutPopUpBlocking;var reopenWhenClosed=this.defaults.reopenWhenClosed;this.isUseOldPopUp=function(){return useOldPopUp;};this.setUseOldPopUp=function(useOldPopUpParam){if(checkCanConfigure("useOldPopUp")){useOldPopUp=bool(useOldPopUpParam);}};this.isComplainAboutPopUpBlocking=function(){return complainAboutPopUpBlocking;};this.setComplainAboutPopUpBlocking=function(complainAboutPopUpBlockingParam){if(checkCanConfigure("complainAboutPopUpBlocking")){complainAboutPopUpBlocking=bool(complainAboutPopUpBlockingParam);}};this.isFocusPopUp=function(){return focusConsoleWindow;};this.setFocusPopUp=function(focusPopUpParam){focusConsoleWindow=bool(focusPopUpParam);};this.isReopenWhenClosed=function(){return reopenWhenClosed;};this.setReopenWhenClosed=function(reopenWhenClosedParam){reopenWhenClosed=bool(reopenWhenClosedParam);};this.close=function(){logLog.debug("close "+this);try{popUp.close();this.unload();}catch(ex){}};this.hide=function(){logLog.debug("hide "+this);if(consoleWindowExists()){this.close();}};this.show=function(){logLog.debug("show "+this);if(!consoleWindowCreated){open();}};this.isVisible=function(){return safeToAppend();};var popUp;open=function(){var windowProperties="width="+width+",height="+height+",status,resizable";var frameInfo="";try{var frameEl=window.frameElement;if(frameEl){frameInfo="_"+frameEl.tagName+"_"+(frameEl.name||frameEl.id||"");}}catch(e){frameInfo="_inaccessibleParentFrame";}
var windowName="PopUp_"+location.host.replace(/[^a-z0-9]/gi,"_")+"_"+consoleAppenderId+frameInfo;if(!useOldPopUp||!useDocumentWrite){windowName=windowName+"_"+uniqueId;}
var checkPopUpClosed=function(win){if(consoleClosed){return true;}else{try{return bool(win)&&win.closed;}catch(ex){}}
return false;};var popUpClosedCallback=function(){if(!consoleClosed){appender.unload();}};function finalInit(){getConsoleWindow().setCloseIfOpenerCloses(!useOldPopUp||!useDocumentWrite);consoleWindowLoadHandler();consoleWindowLoaded=true;appendQueuedLoggingEvents();pollConsoleWindow(checkPopUpClosed,500,popUpClosedCallback,"PopUpAppender.checkPopUpClosed: error checking pop-up window");}
try{popUp=window.open(getConsoleUrl(),windowName,windowProperties);consoleClosed=false;consoleWindowCreated=true;if(popUp&&popUp.document){if(useDocumentWrite&&useOldPopUp&&isLoaded(popUp)){popUp.mainPageReloaded();finalInit();}else{if(useDocumentWrite){writeHtml(popUp.document);}
var popUpLoadedTest=function(win){return bool(win)&&isLoaded(win);};if(isLoaded(popUp)){finalInit();}else{pollConsoleWindow(popUpLoadedTest,100,finalInit,"PopUpAppender.init: unable to create console window");}}}else{isSupported=false;logLog.warn("PopUpAppender.init: pop-ups blocked, please unblock to use PopUpAppender");if(complainAboutPopUpBlocking){handleError("log4javascript: pop-up windows appear to be blocked. Please unblock them to use pop-up logging.");}}}catch(ex){handleError("PopUpAppender.init: error creating pop-up",ex);}};createWindow=function(){if(!initiallyMinimized){open();}};init=function(){createWindow();initialized=true;};getConsoleWindow=function(){return popUp;};safeToAppend=function(){if(isSupported&&!isUndefined(popUp)&&!consoleClosed){if(popUp.closed||(consoleWindowLoaded&&isUndefined(popUp.closed))){appender.unload();logLog.debug("PopUpAppender: pop-up closed");return false;}
if(!consoleWindowLoaded&&isLoaded(popUp)){consoleWindowLoaded=true;}}
return isSupported&&consoleWindowLoaded&&!consoleClosed;};}
this.getConsoleWindow=getConsoleWindow;};ConsoleAppender.addGlobalCommandLineFunction=function(functionName,commandLineFunction){defaultCommandLineFunctions.push([functionName,commandLineFunction]);};function PopUpAppender(lazyInit,initiallyMinimized,useDocumentWrite,width,height){this.create(false,null,lazyInit,initiallyMinimized,useDocumentWrite,width,height,this.defaults.focusPopUp);}
PopUpAppender.prototype=new ConsoleAppender();PopUpAppender.prototype.defaults={layout:new PatternLayout("%d{HH:mm:ss} %-5p - %m{1}%n"),initiallyMinimized:false,focusPopUp:false,lazyInit:true,useOldPopUp:true,complainAboutPopUpBlocking:true,newestMessageAtTop:false,scrollToLatestMessage:true,width:"600",height:"400",reopenWhenClosed:false,maxMessages:null,showCommandLine:true,commandLineObjectExpansionDepth:1,showHideButton:false,showCloseButton:true,useDocumentWrite:true};PopUpAppender.prototype.toString=function(){return"PopUpAppender";};log4javascript.PopUpAppender=PopUpAppender;function InPageAppender(container,lazyInit,initiallyMinimized,useDocumentWrite,width,height){this.create(true,container,lazyInit,initiallyMinimized,useDocumentWrite,width,height,false);}
InPageAppender.prototype=new ConsoleAppender();InPageAppender.prototype.defaults={layout:new PatternLayout("%d{HH:mm:ss} %-5p - %m{1}%n"),initiallyMinimized:false,lazyInit:true,newestMessageAtTop:false,scrollToLatestMessage:true,width:"100%",height:"220px",maxMessages:null,showCommandLine:true,commandLineObjectExpansionDepth:1,showHideButton:false,showCloseButton:false,showLogEntryDeleteButtons:true,useDocumentWrite:true};InPageAppender.prototype.toString=function(){return"InPageAppender";};log4javascript.InPageAppender=InPageAppender;log4javascript.InlineAppender=InPageAppender;})();function padWithSpaces(str,len){if(str.length<len){var spaces=[];var numberOfSpaces=Math.max(0,len-str.length);for(var i=0;i<numberOfSpaces;i++){spaces[i]=" ";}
str+=spaces.join("");}
return str;}
(function(){function dir(obj){var maxLen=0;for(var p in obj){maxLen=Math.max(toStr(p).length,maxLen);}
var propList=[];for(p in obj){var propNameStr="  "+padWithSpaces(toStr(p),maxLen+2);var propVal;try{propVal=splitIntoLines(toStr(obj[p])).join(padWithSpaces(newLine,maxLen+6));}catch(ex){propVal="[Error obtaining property. Details: "+getExceptionMessage(ex)+"]";}
propList.push(propNameStr+propVal);}
return propList.join(newLine);}
var nodeTypes={ELEMENT_NODE:1,ATTRIBUTE_NODE:2,TEXT_NODE:3,CDATA_SECTION_NODE:4,ENTITY_REFERENCE_NODE:5,ENTITY_NODE:6,PROCESSING_INSTRUCTION_NODE:7,COMMENT_NODE:8,DOCUMENT_NODE:9,DOCUMENT_TYPE_NODE:10,DOCUMENT_FRAGMENT_NODE:11,NOTATION_NODE:12};var preFormattedElements=["script","pre"];var emptyElements=["br","img","hr","param","link","area","input","col","base","meta"];var indentationUnit="  ";function getXhtml(rootNode,includeRootNode,indentation,startNewLine,preformatted){includeRootNode=(typeof includeRootNode=="undefined")?true:!!includeRootNode;if(typeof indentation!="string"){indentation="";}
startNewLine=!!startNewLine;preformatted=!!preformatted;var xhtml;function isWhitespace(node){return((node.nodeType==nodeTypes.TEXT_NODE)&&/^[ \t\r\n]*$/.test(node.nodeValue));}
function fixAttributeValue(attrValue){return attrValue.toString().replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;");}
function getStyleAttributeValue(el){var stylePairs=el.style.cssText.split(";");var styleValue="";for(var j=0,len=stylePairs.length;j<len;j++){var nameValueBits=stylePairs[j].split(":");var props=[];if(!/^\s*$/.test(nameValueBits[0])){props.push(trim(nameValueBits[0]).toLowerCase()+":"+trim(nameValueBits[1]));}
styleValue=props.join(";");}
return styleValue;}
function getNamespace(el){if(el.prefix){return el.prefix;}else if(el.outerHTML){var regex=new RegExp("<([^:]+):"+el.tagName+"[^>]*>","i");if(regex.test(el.outerHTML)){return RegExp.$1.toLowerCase();}}
return"";}
var lt="<";var gt=">";var i,len;if(includeRootNode&&rootNode.nodeType!=nodeTypes.DOCUMENT_FRAGMENT_NODE){switch(rootNode.nodeType){case nodeTypes.ELEMENT_NODE:var tagName=rootNode.tagName.toLowerCase();xhtml=startNewLine?newLine+indentation:"";xhtml+=lt;var prefix=getNamespace(rootNode);var hasPrefix=!!prefix;if(hasPrefix){xhtml+=prefix+":";}
xhtml+=tagName;for(i=0,len=rootNode.attributes.length;i<len;i++){var currentAttr=rootNode.attributes[i];if(!currentAttr.specified||currentAttr.nodeValue===null||currentAttr.nodeName.toLowerCase()==="style"||typeof currentAttr.nodeValue!=="string"||currentAttr.nodeName.indexOf("_moz")===0){continue;}
xhtml+=" "+currentAttr.nodeName.toLowerCase()+"=\"";xhtml+=fixAttributeValue(currentAttr.nodeValue);xhtml+="\"";}
if(rootNode.style.cssText){var styleValue=getStyleAttributeValue(rootNode);if(styleValue!==""){xhtml+=" style=\""+getStyleAttributeValue(rootNode)+"\"";}}
if(array_contains(emptyElements,tagName)||(hasPrefix&&!rootNode.hasChildNodes())){xhtml+="/"+gt;}else{xhtml+=gt;var childStartNewLine=!(rootNode.childNodes.length===1&&rootNode.childNodes[0].nodeType===nodeTypes.TEXT_NODE);var childPreformatted=array_contains(preFormattedElements,tagName);for(i=0,len=rootNode.childNodes.length;i<len;i++){xhtml+=getXhtml(rootNode.childNodes[i],true,indentation+indentationUnit,childStartNewLine,childPreformatted);}
var endTag=lt+"/"+tagName+gt;xhtml+=childStartNewLine?newLine+indentation+endTag:endTag;}
return xhtml;case nodeTypes.TEXT_NODE:if(isWhitespace(rootNode)){xhtml="";}else{if(preformatted){xhtml=rootNode.nodeValue;}else{var lines=splitIntoLines(trim(rootNode.nodeValue));var trimmedLines=[];for(i=0,len=lines.length;i<len;i++){trimmedLines[i]=trim(lines[i]);}
xhtml=trimmedLines.join(newLine+indentation);}
if(startNewLine){xhtml=newLine+indentation+xhtml;}}
return xhtml;case nodeTypes.CDATA_SECTION_NODE:return"<![CDA"+"TA["+rootNode.nodeValue+"]"+"]>"+newLine;case nodeTypes.DOCUMENT_NODE:xhtml="";for(i=0,len=rootNode.childNodes.length;i<len;i++){xhtml+=getXhtml(rootNode.childNodes[i],true,indentation);}
return xhtml;default:return"";}}else{xhtml="";for(i=0,len=rootNode.childNodes.length;i<len;i++){xhtml+=getXhtml(rootNode.childNodes[i],true,indentation+indentationUnit);}
return xhtml;}}
function createCommandLineFunctions(){ConsoleAppender.addGlobalCommandLineFunction("$",function(appender,args,returnValue){return document.getElementById(args[0]);});ConsoleAppender.addGlobalCommandLineFunction("dir",function(appender,args,returnValue){var lines=[];for(var i=0,len=args.length;i<len;i++){lines[i]=dir(args[i]);}
return lines.join(newLine+newLine);});ConsoleAppender.addGlobalCommandLineFunction("dirxml",function(appender,args,returnValue){var lines=[];for(var i=0,len=args.length;i<len;i++){lines[i]=getXhtml(args[i]);}
return lines.join(newLine+newLine);});ConsoleAppender.addGlobalCommandLineFunction("cd",function(appender,args,returnValue){var win,message;if(args.length===0||args[0]===""){win=window;message="Command line set to run in main window";}else{if(args[0].window==args[0]){win=args[0];message="Command line set to run in frame '"+args[0].name+"'";}else{win=window.frames[args[0]];if(win){message="Command line set to run in frame '"+args[0]+"'";}else{returnValue.isError=true;message="Frame '"+args[0]+"' does not exist";win=appender.getCommandWindow();}}}
appender.setCommandWindow(win);return message;});ConsoleAppender.addGlobalCommandLineFunction("clear",function(appender,args,returnValue){returnValue.appendResult=false;appender.clear();});ConsoleAppender.addGlobalCommandLineFunction("keys",function(appender,args,returnValue){var keys=[];for(var k in args[0]){keys.push(k);}
return keys;});ConsoleAppender.addGlobalCommandLineFunction("values",function(appender,args,returnValue){var values=[];for(var k in args[0]){try{values.push(args[0][k]);}catch(ex){logLog.warn("values(): Unable to obtain value for key "+k+". Details: "+getExceptionMessage(ex));}}
return values;});ConsoleAppender.addGlobalCommandLineFunction("expansionDepth",function(appender,args,returnValue){var expansionDepth=parseInt(args[0],10);if(isNaN(expansionDepth)||expansionDepth<0){returnValue.isError=true;return""+args[0]+" is not a valid expansion depth";}else{appender.setCommandLineObjectExpansionDepth(expansionDepth);return"Object expansion depth set to "+expansionDepth;}});}
function init(){createCommandLineFunctions();}
init();})();function createDefaultLogger(){var logger=log4javascript.getLogger(defaultLoggerName);var a=new log4javascript.PopUpAppender();logger.addAppender(a);return logger;}
log4javascript.setDocumentReady=function(){pageLoaded=true;log4javascript.dispatchEvent("load",{});};if(window.addEventListener){window.addEventListener("load",log4javascript.setDocumentReady,false);}else if(window.attachEvent){window.attachEvent("onload",log4javascript.setDocumentReady);}else{var oldOnload=window.onload;if(typeof window.onload!="function"){window.onload=log4javascript.setDocumentReady;}else{window.onload=function(evt){if(oldOnload){oldOnload(evt);}
log4javascript.setDocumentReady();};}}
return log4javascript;},this);

},{}],4:[function(require,module,exports){
!function(t,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define([],r):"object"==typeof exports?exports.MessageFormat=r():t.MessageFormat=r()}(this,function(){return function(t){var r={};function e(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,e),o.l=!0,o.exports}return e.m=t,e.c=r,e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{enumerable:!0,get:n})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,r){if(1&r&&(t=e(t)),8&r)return t;if(4&r&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(e.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&r&&"string"!=typeof t)for(var o in t)e.d(n,o,function(r){return t[r]}.bind(null,o));return n},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,r){return Object.prototype.hasOwnProperty.call(t,r)},e.p="",e(e.s=8)}([function(t,r,e){var n,o;void 0===(o="function"==typeof(n={af:function(t,r){return r?"other":1==t?"one":"other"},ak:function(t,r){return r?"other":0==t||1==t?"one":"other"},am:function(t,r){return r?"other":t>=0&&t<=1?"one":"other"},ar:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-2);return r?"other":0==t?"zero":1==t?"one":2==t?"two":o>=3&&o<=10?"few":o>=11&&o<=99?"many":"other"},ars:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-2);return r?"other":0==t?"zero":1==t?"one":2==t?"two":o>=3&&o<=10?"few":o>=11&&o<=99?"many":"other"},as:function(t,r){return r?1==t||5==t||7==t||8==t||9==t||10==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},asa:function(t,r){return r?"other":1==t?"one":"other"},ast:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},az:function(t,r){var e=String(t).split("."),n=e[0],o=n.slice(-1),i=n.slice(-2),u=n.slice(-3);return r?1==o||2==o||5==o||7==o||8==o||20==i||50==i||70==i||80==i?"one":3==o||4==o||100==u||200==u||300==u||400==u||500==u||600==u||700==u||800==u||900==u?"few":0==n||6==o||40==i||60==i||90==i?"many":"other":1==t?"one":"other"},be:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-1),i=n&&e[0].slice(-2);return r?2!=o&&3!=o||12==i||13==i?"other":"few":1==o&&11!=i?"one":o>=2&&o<=4&&(i<12||i>14)?"few":n&&0==o||o>=5&&o<=9||i>=11&&i<=14?"many":"other"},bem:function(t,r){return r?"other":1==t?"one":"other"},bez:function(t,r){return r?"other":1==t?"one":"other"},bg:function(t,r){return r?"other":1==t?"one":"other"},bh:function(t,r){return r?"other":0==t||1==t?"one":"other"},bm:function(t,r){return"other"},bn:function(t,r){return r?1==t||5==t||7==t||8==t||9==t||10==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},bo:function(t,r){return"other"},br:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-1),i=n&&e[0].slice(-2),u=n&&e[0].slice(-6);return r?"other":1==o&&11!=i&&71!=i&&91!=i?"one":2==o&&12!=i&&72!=i&&92!=i?"two":(3==o||4==o||9==o)&&(i<10||i>19)&&(i<70||i>79)&&(i<90||i>99)?"few":0!=t&&n&&0==u?"many":"other"},brx:function(t,r){return r?"other":1==t?"one":"other"},bs:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=n.slice(-2),c=o.slice(-1),h=o.slice(-2);return r?"other":i&&1==u&&11!=a||1==c&&11!=h?"one":i&&u>=2&&u<=4&&(a<12||a>14)||c>=2&&c<=4&&(h<12||h>14)?"few":"other"},ca:function(t,r){var e=String(t).split("."),n=!e[1];return r?1==t||3==t?"one":2==t?"two":4==t?"few":"other":1==t&&n?"one":"other"},ce:function(t,r){return r?"other":1==t?"one":"other"},cgg:function(t,r){return r?"other":1==t?"one":"other"},chr:function(t,r){return r?"other":1==t?"one":"other"},ckb:function(t,r){return r?"other":1==t?"one":"other"},cs:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1];return r?"other":1==t&&o?"one":n>=2&&n<=4&&o?"few":o?"other":"many"},cy:function(t,r){return r?0==t||7==t||8==t||9==t?"zero":1==t?"one":2==t?"two":3==t||4==t?"few":5==t||6==t?"many":"other":0==t?"zero":1==t?"one":2==t?"two":3==t?"few":6==t?"many":"other"},da:function(t,r){var e=String(t).split("."),n=e[0],o=Number(e[0])==t;return r?"other":1!=t&&(o||0!=n&&1!=n)?"other":"one"},de:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},dsb:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-2),a=o.slice(-2);return r?"other":i&&1==u||1==a?"one":i&&2==u||2==a?"two":i&&(3==u||4==u)||3==a||4==a?"few":"other"},dv:function(t,r){return r?"other":1==t?"one":"other"},dz:function(t,r){return"other"},ee:function(t,r){return r?"other":1==t?"one":"other"},el:function(t,r){return r?"other":1==t?"one":"other"},en:function(t,r){var e=String(t).split("."),n=!e[1],o=Number(e[0])==t,i=o&&e[0].slice(-1),u=o&&e[0].slice(-2);return r?1==i&&11!=u?"one":2==i&&12!=u?"two":3==i&&13!=u?"few":"other":1==t&&n?"one":"other"},eo:function(t,r){return r?"other":1==t?"one":"other"},es:function(t,r){return r?"other":1==t?"one":"other"},et:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},eu:function(t,r){return r?"other":1==t?"one":"other"},fa:function(t,r){return r?"other":t>=0&&t<=1?"one":"other"},ff:function(t,r){return r?"other":t>=0&&t<2?"one":"other"},fi:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},fil:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=o.slice(-1);return r?1==t?"one":"other":i&&(1==n||2==n||3==n)||i&&4!=u&&6!=u&&9!=u||!i&&4!=a&&6!=a&&9!=a?"one":"other"},fo:function(t,r){return r?"other":1==t?"one":"other"},fr:function(t,r){return r?1==t?"one":"other":t>=0&&t<2?"one":"other"},fur:function(t,r){return r?"other":1==t?"one":"other"},fy:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},ga:function(t,r){var e=String(t).split("."),n=Number(e[0])==t;return r?1==t?"one":"other":1==t?"one":2==t?"two":n&&t>=3&&t<=6?"few":n&&t>=7&&t<=10?"many":"other"},gd:function(t,r){var e=String(t).split("."),n=Number(e[0])==t;return r?1==t||11==t?"one":2==t||12==t?"two":3==t||13==t?"few":"other":1==t||11==t?"one":2==t||12==t?"two":n&&t>=3&&t<=10||n&&t>=13&&t<=19?"few":"other"},gl:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},gsw:function(t,r){return r?"other":1==t?"one":"other"},gu:function(t,r){return r?1==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},guw:function(t,r){return r?"other":0==t||1==t?"one":"other"},gv:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=n.slice(-1),u=n.slice(-2);return r?"other":o&&1==i?"one":o&&2==i?"two":!o||0!=u&&20!=u&&40!=u&&60!=u&&80!=u?o?"other":"many":"few"},ha:function(t,r){return r?"other":1==t?"one":"other"},haw:function(t,r){return r?"other":1==t?"one":"other"},he:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=Number(e[0])==t,u=i&&e[0].slice(-1);return r?"other":1==t&&o?"one":2==n&&o?"two":o&&(t<0||t>10)&&i&&0==u?"many":"other"},hi:function(t,r){return r?1==t?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":t>=0&&t<=1?"one":"other"},hr:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=n.slice(-2),c=o.slice(-1),h=o.slice(-2);return r?"other":i&&1==u&&11!=a||1==c&&11!=h?"one":i&&u>=2&&u<=4&&(a<12||a>14)||c>=2&&c<=4&&(h<12||h>14)?"few":"other"},hsb:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-2),a=o.slice(-2);return r?"other":i&&1==u||1==a?"one":i&&2==u||2==a?"two":i&&(3==u||4==u)||3==a||4==a?"few":"other"},hu:function(t,r){return r?1==t||5==t?"one":"other":1==t?"one":"other"},hy:function(t,r){return r?1==t?"one":"other":t>=0&&t<2?"one":"other"},ia:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},id:function(t,r){return"other"},ig:function(t,r){return"other"},ii:function(t,r){return"other"},in:function(t,r){return"other"},io:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},is:function(t,r){var e=String(t).split("."),n=e[0],o=Number(e[0])==t,i=n.slice(-1),u=n.slice(-2);return r?"other":o&&1==i&&11!=u||!o?"one":"other"},it:function(t,r){var e=String(t).split("."),n=!e[1];return r?11==t||8==t||80==t||800==t?"many":"other":1==t&&n?"one":"other"},iu:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},iw:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=Number(e[0])==t,u=i&&e[0].slice(-1);return r?"other":1==t&&o?"one":2==n&&o?"two":o&&(t<0||t>10)&&i&&0==u?"many":"other"},ja:function(t,r){return"other"},jbo:function(t,r){return"other"},jgo:function(t,r){return r?"other":1==t?"one":"other"},ji:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},jmc:function(t,r){return r?"other":1==t?"one":"other"},jv:function(t,r){return"other"},jw:function(t,r){return"other"},ka:function(t,r){var e=String(t).split("."),n=e[0],o=n.slice(-2);return r?1==n?"one":0==n||o>=2&&o<=20||40==o||60==o||80==o?"many":"other":1==t?"one":"other"},kab:function(t,r){return r?"other":t>=0&&t<2?"one":"other"},kaj:function(t,r){return r?"other":1==t?"one":"other"},kcg:function(t,r){return r?"other":1==t?"one":"other"},kde:function(t,r){return"other"},kea:function(t,r){return"other"},kk:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-1);return r?6==o||9==o||n&&0==o&&0!=t?"many":"other":1==t?"one":"other"},kkj:function(t,r){return r?"other":1==t?"one":"other"},kl:function(t,r){return r?"other":1==t?"one":"other"},km:function(t,r){return"other"},kn:function(t,r){return r?"other":t>=0&&t<=1?"one":"other"},ko:function(t,r){return"other"},ks:function(t,r){return r?"other":1==t?"one":"other"},ksb:function(t,r){return r?"other":1==t?"one":"other"},ksh:function(t,r){return r?"other":0==t?"zero":1==t?"one":"other"},ku:function(t,r){return r?"other":1==t?"one":"other"},kw:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},ky:function(t,r){return r?"other":1==t?"one":"other"},lag:function(t,r){var e=String(t).split("."),n=e[0];return r?"other":0==t?"zero":0!=n&&1!=n||0==t?"other":"one"},lb:function(t,r){return r?"other":1==t?"one":"other"},lg:function(t,r){return r?"other":1==t?"one":"other"},lkt:function(t,r){return"other"},ln:function(t,r){return r?"other":0==t||1==t?"one":"other"},lo:function(t,r){return r&&1==t?"one":"other"},lt:function(t,r){var e=String(t).split("."),n=e[1]||"",o=Number(e[0])==t,i=o&&e[0].slice(-1),u=o&&e[0].slice(-2);return r?"other":1==i&&(u<11||u>19)?"one":i>=2&&i<=9&&(u<11||u>19)?"few":0!=n?"many":"other"},lv:function(t,r){var e=String(t).split("."),n=e[1]||"",o=n.length,i=Number(e[0])==t,u=i&&e[0].slice(-1),a=i&&e[0].slice(-2),c=n.slice(-2),h=n.slice(-1);return r?"other":i&&0==u||a>=11&&a<=19||2==o&&c>=11&&c<=19?"zero":1==u&&11!=a||2==o&&1==h&&11!=c||2!=o&&1==h?"one":"other"},mas:function(t,r){return r?"other":1==t?"one":"other"},mg:function(t,r){return r?"other":0==t||1==t?"one":"other"},mgo:function(t,r){return r?"other":1==t?"one":"other"},mk:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=n.slice(-2),c=o.slice(-1),h=o.slice(-2);return r?1==u&&11!=a?"one":2==u&&12!=a?"two":7!=u&&8!=u||17==a||18==a?"other":"many":i&&1==u&&11!=a||1==c&&11!=h?"one":"other"},ml:function(t,r){return r?"other":1==t?"one":"other"},mn:function(t,r){return r?"other":1==t?"one":"other"},mo:function(t,r){var e=String(t).split("."),n=!e[1],o=Number(e[0])==t,i=o&&e[0].slice(-2);return r?1==t?"one":"other":1==t&&n?"one":!n||0==t||1!=t&&i>=1&&i<=19?"few":"other"},mr:function(t,r){return r?1==t?"one":2==t||3==t?"two":4==t?"few":"other":t>=0&&t<=1?"one":"other"},ms:function(t,r){return r&&1==t?"one":"other"},mt:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-2);return r?"other":1==t?"one":0==t||o>=2&&o<=10?"few":o>=11&&o<=19?"many":"other"},my:function(t,r){return"other"},nah:function(t,r){return r?"other":1==t?"one":"other"},naq:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},nb:function(t,r){return r?"other":1==t?"one":"other"},nd:function(t,r){return r?"other":1==t?"one":"other"},ne:function(t,r){var e=String(t).split("."),n=Number(e[0])==t;return r?n&&t>=1&&t<=4?"one":"other":1==t?"one":"other"},nl:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},nn:function(t,r){return r?"other":1==t?"one":"other"},nnh:function(t,r){return r?"other":1==t?"one":"other"},no:function(t,r){return r?"other":1==t?"one":"other"},nqo:function(t,r){return"other"},nr:function(t,r){return r?"other":1==t?"one":"other"},nso:function(t,r){return r?"other":0==t||1==t?"one":"other"},ny:function(t,r){return r?"other":1==t?"one":"other"},nyn:function(t,r){return r?"other":1==t?"one":"other"},om:function(t,r){return r?"other":1==t?"one":"other"},or:function(t,r){var e=String(t).split("."),n=Number(e[0])==t;return r?1==t||5==t||n&&t>=7&&t<=9?"one":2==t||3==t?"two":4==t?"few":6==t?"many":"other":1==t?"one":"other"},os:function(t,r){return r?"other":1==t?"one":"other"},pa:function(t,r){return r?"other":0==t||1==t?"one":"other"},pap:function(t,r){return r?"other":1==t?"one":"other"},pl:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=n.slice(-1),u=n.slice(-2);return r?"other":1==t&&o?"one":o&&i>=2&&i<=4&&(u<12||u>14)?"few":o&&1!=n&&(0==i||1==i)||o&&i>=5&&i<=9||o&&u>=12&&u<=14?"many":"other"},prg:function(t,r){var e=String(t).split("."),n=e[1]||"",o=n.length,i=Number(e[0])==t,u=i&&e[0].slice(-1),a=i&&e[0].slice(-2),c=n.slice(-2),h=n.slice(-1);return r?"other":i&&0==u||a>=11&&a<=19||2==o&&c>=11&&c<=19?"zero":1==u&&11!=a||2==o&&1==h&&11!=c||2!=o&&1==h?"one":"other"},ps:function(t,r){return r?"other":1==t?"one":"other"},pt:function(t,r){var e=String(t).split("."),n=e[0];return r?"other":0==n||1==n?"one":"other"},"pt-PT":function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},rm:function(t,r){return r?"other":1==t?"one":"other"},ro:function(t,r){var e=String(t).split("."),n=!e[1],o=Number(e[0])==t,i=o&&e[0].slice(-2);return r?1==t?"one":"other":1==t&&n?"one":!n||0==t||1!=t&&i>=1&&i<=19?"few":"other"},rof:function(t,r){return r?"other":1==t?"one":"other"},root:function(t,r){return"other"},ru:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=n.slice(-1),u=n.slice(-2);return r?"other":o&&1==i&&11!=u?"one":o&&i>=2&&i<=4&&(u<12||u>14)?"few":o&&0==i||o&&i>=5&&i<=9||o&&u>=11&&u<=14?"many":"other"},rwk:function(t,r){return r?"other":1==t?"one":"other"},sah:function(t,r){return"other"},saq:function(t,r){return r?"other":1==t?"one":"other"},sc:function(t,r){var e=String(t).split("."),n=!e[1];return r?11==t||8==t||80==t||800==t?"many":"other":1==t&&n?"one":"other"},scn:function(t,r){var e=String(t).split("."),n=!e[1];return r?11==t||8==t||80==t||800==t?"many":"other":1==t&&n?"one":"other"},sd:function(t,r){return r?"other":1==t?"one":"other"},sdh:function(t,r){return r?"other":1==t?"one":"other"},se:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},seh:function(t,r){return r?"other":1==t?"one":"other"},ses:function(t,r){return"other"},sg:function(t,r){return"other"},sh:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=n.slice(-2),c=o.slice(-1),h=o.slice(-2);return r?"other":i&&1==u&&11!=a||1==c&&11!=h?"one":i&&u>=2&&u<=4&&(a<12||a>14)||c>=2&&c<=4&&(h<12||h>14)?"few":"other"},shi:function(t,r){var e=String(t).split("."),n=Number(e[0])==t;return r?"other":t>=0&&t<=1?"one":n&&t>=2&&t<=10?"few":"other"},si:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"";return r?"other":0==t||1==t||0==n&&1==o?"one":"other"},sk:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1];return r?"other":1==t&&o?"one":n>=2&&n<=4&&o?"few":o?"other":"many"},sl:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=n.slice(-2);return r?"other":o&&1==i?"one":o&&2==i?"two":o&&(3==i||4==i)||!o?"few":"other"},sma:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},smi:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},smj:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},smn:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},sms:function(t,r){return r?"other":1==t?"one":2==t?"two":"other"},sn:function(t,r){return r?"other":1==t?"one":"other"},so:function(t,r){return r?"other":1==t?"one":"other"},sq:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-1),i=n&&e[0].slice(-2);return r?1==t?"one":4==o&&14!=i?"many":"other":1==t?"one":"other"},sr:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=n.slice(-2),c=o.slice(-1),h=o.slice(-2);return r?"other":i&&1==u&&11!=a||1==c&&11!=h?"one":i&&u>=2&&u<=4&&(a<12||a>14)||c>=2&&c<=4&&(h<12||h>14)?"few":"other"},ss:function(t,r){return r?"other":1==t?"one":"other"},ssy:function(t,r){return r?"other":1==t?"one":"other"},st:function(t,r){return r?"other":1==t?"one":"other"},sv:function(t,r){var e=String(t).split("."),n=!e[1],o=Number(e[0])==t,i=o&&e[0].slice(-1),u=o&&e[0].slice(-2);return r?1!=i&&2!=i||11==u||12==u?"other":"one":1==t&&n?"one":"other"},sw:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},syr:function(t,r){return r?"other":1==t?"one":"other"},ta:function(t,r){return r?"other":1==t?"one":"other"},te:function(t,r){return r?"other":1==t?"one":"other"},teo:function(t,r){return r?"other":1==t?"one":"other"},th:function(t,r){return"other"},ti:function(t,r){return r?"other":0==t||1==t?"one":"other"},tig:function(t,r){return r?"other":1==t?"one":"other"},tk:function(t,r){var e=String(t).split("."),n=Number(e[0])==t,o=n&&e[0].slice(-1);return r?6==o||9==o||10==t?"few":"other":1==t?"one":"other"},tl:function(t,r){var e=String(t).split("."),n=e[0],o=e[1]||"",i=!e[1],u=n.slice(-1),a=o.slice(-1);return r?1==t?"one":"other":i&&(1==n||2==n||3==n)||i&&4!=u&&6!=u&&9!=u||!i&&4!=a&&6!=a&&9!=a?"one":"other"},tn:function(t,r){return r?"other":1==t?"one":"other"},to:function(t,r){return"other"},tr:function(t,r){return r?"other":1==t?"one":"other"},ts:function(t,r){return r?"other":1==t?"one":"other"},tzm:function(t,r){var e=String(t).split("."),n=Number(e[0])==t;return r?"other":0==t||1==t||n&&t>=11&&t<=99?"one":"other"},ug:function(t,r){return r?"other":1==t?"one":"other"},uk:function(t,r){var e=String(t).split("."),n=e[0],o=!e[1],i=Number(e[0])==t,u=i&&e[0].slice(-1),a=i&&e[0].slice(-2),c=n.slice(-1),h=n.slice(-2);return r?3==u&&13!=a?"few":"other":o&&1==c&&11!=h?"one":o&&c>=2&&c<=4&&(h<12||h>14)?"few":o&&0==c||o&&c>=5&&c<=9||o&&h>=11&&h<=14?"many":"other"},ur:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},uz:function(t,r){return r?"other":1==t?"one":"other"},ve:function(t,r){return r?"other":1==t?"one":"other"},vi:function(t,r){return r&&1==t?"one":"other"},vo:function(t,r){return r?"other":1==t?"one":"other"},vun:function(t,r){return r?"other":1==t?"one":"other"},wa:function(t,r){return r?"other":0==t||1==t?"one":"other"},wae:function(t,r){return r?"other":1==t?"one":"other"},wo:function(t,r){return"other"},xh:function(t,r){return r?"other":1==t?"one":"other"},xog:function(t,r){return r?"other":1==t?"one":"other"},yi:function(t,r){var e=String(t).split("."),n=!e[1];return r?"other":1==t&&n?"one":"other"},yo:function(t,r){return"other"},yue:function(t,r){return"other"},zh:function(t,r){return"other"},zu:function(t,r){return r?"other":t>=0&&t<=1?"one":"other"}})?n.call(r,e,r,t):n)||(t.exports=o)},function(t,r,e){t.exports={date:e(4),duration:e(5),number:e(6),time:e(7)}},function(t,r,e){"use strict";function n(t,r,e,o){this.message=t,this.expected=r,this.found=e,this.location=o,this.name="SyntaxError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,n)}!function(t,r){function e(){this.constructor=t}e.prototype=r.prototype,t.prototype=new e}(n,Error),n.buildMessage=function(t,r){var e={literal:function(t){return'"'+o(t.text)+'"'},class:function(t){var r,e="";for(r=0;r<t.parts.length;r++)e+=t.parts[r]instanceof Array?i(t.parts[r][0])+"-"+i(t.parts[r][1]):i(t.parts[r]);return"["+(t.inverted?"^":"")+e+"]"},any:function(t){return"any character"},end:function(t){return"end of input"},other:function(t){return t.description}};function n(t){return t.charCodeAt(0).toString(16).toUpperCase()}function o(t){return t.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(t){return"\\x0"+n(t)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(t){return"\\x"+n(t)})}function i(t){return t.replace(/\\/g,"\\\\").replace(/\]/g,"\\]").replace(/\^/g,"\\^").replace(/-/g,"\\-").replace(/\0/g,"\\0").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/[\x00-\x0F]/g,function(t){return"\\x0"+n(t)}).replace(/[\x10-\x1F\x7F-\x9F]/g,function(t){return"\\x"+n(t)})}return"Expected "+function(t){var r,n,o,i=new Array(t.length);for(r=0;r<t.length;r++)i[r]=(o=t[r],e[o.type](o));if(i.sort(),i.length>0){for(r=1,n=1;r<i.length;r++)i[r-1]!==i[r]&&(i[n]=i[r],n++);i.length=n}switch(i.length){case 1:return i[0];case 2:return i[0]+" or "+i[1];default:return i.slice(0,-1).join(", ")+", or "+i[i.length-1]}}(t)+" but "+function(t){return t?'"'+o(t)+'"':"end of input"}(r)+" found."},t.exports={SyntaxError:n,parse:function(t,r){r=void 0!==r?r:{};var e,o={},i={start:tr},u=tr,a="#",c=It("#",!1),h=function(){return pr[0]},f=function(){return{type:"octothorpe"}},s=function(t){return t.join("")},l="{",p=It("{",!1),m="}",d=It("}",!1),y=function(t){return{type:"argument",arg:t}},g=",",v=It(",",!1),w="select",b=It("select",!1),S=function(t,e){return r.strict&&pr.unshift(!1),e},k=function(t,e){return r.strict&&pr.shift(),{type:"select",arg:t,cases:e}},x="plural",A=It("plural",!1),j="selectordinal",N=It("selectordinal",!1),C=function(t,r){return pr.unshift(!0),r},F=function(t,e,n,o){var i=("selectordinal"===e?r.ordinal:r.cardinal)||["zero","one","two","few","many","other"];return i&&i.length&&o.forEach(function(r){if(isNaN(r.key)&&i.indexOf(r.key)<0)throw new Error("Invalid key `"+r.key+"` for argument `"+t+"`. Valid "+e+" keys for this locale are `"+i.join("`, `")+"`, and explicit keys like `=0`.")}),pr.shift(),{type:e,arg:t,offset:n||0,cases:o}},O=function(t,r,e){return{type:"function",arg:t,key:r,param:e}},E=Vt("identifier"),z=/^[^\t-\r \x85\u200E\u200F\u2028\u2029!-\/:-@[-\^`{-~\xA1-\xA7\xA9\xAB\xAC\xAE\xB0\xB1\xB6\xBB\xBF\xD7\xF7\u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]/,P=Yt([["\t","\r"]," ","","‎","‏","\u2028","\u2029",["!","/"],[":","@"],["[","^"],"`",["{","~"],["¡","§"],"©","«","¬","®","°","±","¶","»","¿","×","÷",["‐","‧"],["‰","‾"],["⁁","⁓"],["⁕","⁞"],["←","⑟"],["─","❵"],["➔","⯿"],["⸀","⹿"],["、","〃"],["〈","〠"],"〰","﴾","﴿","﹅","﹆"],!0,!1),L=function(t,r){return{key:t,tokens:r}},J=function(t){return t},D=Vt("plural offset"),M="offset",_=It("offset",!1),T=":",R=It(":",!1),B=function(t){return t},q="=",$=It("=",!1),K="number",G=It("number",!1),U="date",Z=It("date",!1),I="time",Y=It("time",!1),V="spellout",W=It("spellout",!1),H="ordinal",Q=It("ordinal",!1),X="duration",tt=It("duration",!1),rt=function(t){if(r.strict||/^\d/.test(t))return!1;switch(t.toLowerCase()){case"select":case"plural":case"selectordinal":return!1;default:return!0}},et=function(t){return t},nt=function(t){return!r.strict},ot=function(t){return{tokens:t}},it=function(t){return{tokens:[t.join("")]}},ut=Vt("a valid (strict) function parameter"),at=/^[^'{}]/,ct=Yt(["'","{","}"],!0,!1),ht=function(t){return t.join("")},ft="'",st=It("'",!1),lt=function(t){return t},pt=function(t){return"{"+t.join("")+"}"},mt=Vt("doubled apostrophe"),dt="''",yt=It("''",!1),gt=function(){return"'"},vt=/^[^']/,wt=Yt(["'"],!0,!1),bt="'{",St=It("'{",!1),kt=function(t){return"{"+t.join("")},xt="'}",At=It("'}",!1),jt=function(t){return"}"+t.join("")},Nt=Vt("escaped string"),Ct="'#",Ft=It("'#",!1),Ot=function(t){return"#"+t.join("")},Et=function(t){return t[0]},zt=Vt("plain char"),Pt=/^[^{}#\0-\x08\x0E-\x1F\x7F]/,Lt=Yt(["{","}","#",["\0","\b"],["",""],""],!0,!1),Jt=function(t){return!pr[0]},Dt=function(t){return t},Mt=Vt("integer"),_t=/^[0-9]/,Tt=Yt([["0","9"]],!1,!1),Rt=Vt("white space"),Bt=/^[\t-\r \x85\u200E\u200F\u2028\u2029]/,qt=Yt([["\t","\r"]," ","","‎","‏","\u2028","\u2029"],!1,!1),$t=0,Kt=[{line:1,column:1}],Gt=0,Ut=[],Zt=0;if("startRule"in r){if(!(r.startRule in i))throw new Error("Can't start parsing from rule \""+r.startRule+'".');u=i[r.startRule]}function It(t,r){return{type:"literal",text:t,ignoreCase:r}}function Yt(t,r,e){return{type:"class",parts:t,inverted:r,ignoreCase:e}}function Vt(t){return{type:"other",description:t}}function Wt(r){var e,n=Kt[r];if(n)return n;for(e=r-1;!Kt[e];)e--;for(n={line:(n=Kt[e]).line,column:n.column};e<r;)10===t.charCodeAt(e)?(n.line++,n.column=1):n.column++,e++;return Kt[r]=n,n}function Ht(t,r){var e=Wt(t),n=Wt(r);return{start:{offset:t,line:e.line,column:e.column},end:{offset:r,line:n.line,column:n.column}}}function Qt(t){$t<Gt||($t>Gt&&(Gt=$t,Ut=[]),Ut.push(t))}function Xt(t,r,e){return new n(n.buildMessage(t,r),t,r,e)}function tr(){var t,r;for(t=[],r=rr();r!==o;)t.push(r),r=rr();return t}function rr(){var r,e,n;if((r=function(){var r,e,n,i;return r=$t,123===t.charCodeAt($t)?(e=l,$t++):(e=o,0===Zt&&Qt(p)),e!==o&&lr()!==o&&(n=er())!==o&&lr()!==o?(125===t.charCodeAt($t)?(i=m,$t++):(i=o,0===Zt&&Qt(d)),i!==o?(e=y(n),r=e):($t=r,r=o)):($t=r,r=o),r}())===o&&(r=function(){var r,e,n,i,u,a,c,h,f;if(r=$t,123===t.charCodeAt($t)?(e=l,$t++):(e=o,0===Zt&&Qt(p)),e!==o)if(lr()!==o)if((n=er())!==o)if(lr()!==o)if(44===t.charCodeAt($t)?(i=g,$t++):(i=o,0===Zt&&Qt(v)),i!==o)if(lr()!==o)if($t,t.substr($t,6)===w?(u=w,$t+=6):(u=o,0===Zt&&Qt(b)),u!==o&&(u=S(n,u)),u!==o)if((u=lr())!==o)if(44===t.charCodeAt($t)?(a=g,$t++):(a=o,0===Zt&&Qt(v)),a!==o)if(lr()!==o){if(c=[],(h=nr())!==o)for(;h!==o;)c.push(h),h=nr();else c=o;c!==o&&(h=lr())!==o?(125===t.charCodeAt($t)?(f=m,$t++):(f=o,0===Zt&&Qt(d)),f!==o?(e=k(n,c),r=e):($t=r,r=o)):($t=r,r=o)}else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;return r}())===o&&(r=function(){var r,e,n,i,u,a,c,h,f,s,y;if(r=$t,123===t.charCodeAt($t)?(e=l,$t++):(e=o,0===Zt&&Qt(p)),e!==o)if(lr()!==o)if((n=er())!==o)if(lr()!==o)if(44===t.charCodeAt($t)?(i=g,$t++):(i=o,0===Zt&&Qt(v)),i!==o)if(lr()!==o)if(u=$t,t.substr($t,6)===x?(a=x,$t+=6):(a=o,0===Zt&&Qt(A)),a===o&&(t.substr($t,13)===j?(a=j,$t+=13):(a=o,0===Zt&&Qt(N))),a!==o&&(a=C(n,a)),(u=a)!==o)if((a=lr())!==o)if(44===t.charCodeAt($t)?(c=g,$t++):(c=o,0===Zt&&Qt(v)),c!==o)if(lr()!==o)if((h=function(){var r,e,n,i,u;return Zt++,r=$t,(e=lr())!==o?(t.substr($t,6)===M?(n=M,$t+=6):(n=o,0===Zt&&Qt(_)),n!==o&&lr()!==o?(58===t.charCodeAt($t)?(i=T,$t++):(i=o,0===Zt&&Qt(R)),i!==o&&lr()!==o&&(u=sr())!==o&&lr()!==o?(e=B(u),r=e):($t=r,r=o)):($t=r,r=o)):($t=r,r=o),Zt--,r===o&&(e=o,0===Zt&&Qt(D)),r}())===o&&(h=null),h!==o){if(f=[],(s=or())!==o)for(;s!==o;)f.push(s),s=or();else f=o;f!==o&&(s=lr())!==o?(125===t.charCodeAt($t)?(y=m,$t++):(y=o,0===Zt&&Qt(d)),y!==o?(e=F(n,u,h,f),r=e):($t=r,r=o)):($t=r,r=o)}else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;else $t=r,r=o;return r}())===o&&(r=function(){var r,e,n,i,u,a,c;return r=$t,123===t.charCodeAt($t)?(e=l,$t++):(e=o,0===Zt&&Qt(p)),e!==o&&lr()!==o&&(n=er())!==o&&lr()!==o?(44===t.charCodeAt($t)?(i=g,$t++):(i=o,0===Zt&&Qt(v)),i!==o&&lr()!==o&&(u=function(){var r,e,n,i,u;return t.substr($t,6)===K?(r=K,$t+=6):(r=o,0===Zt&&Qt(G)),r===o&&(t.substr($t,4)===U?(r=U,$t+=4):(r=o,0===Zt&&Qt(Z)),r===o&&(t.substr($t,4)===I?(r=I,$t+=4):(r=o,0===Zt&&Qt(Y)),r===o&&(t.substr($t,8)===V?(r=V,$t+=8):(r=o,0===Zt&&Qt(W)),r===o&&(t.substr($t,7)===H?(r=H,$t+=7):(r=o,0===Zt&&Qt(Q)),r===o&&(t.substr($t,8)===X?(r=X,$t+=8):(r=o,0===Zt&&Qt(tt)),r===o&&(r=$t,e=$t,Zt++,t.substr($t,6)===w?(n=w,$t+=6):(n=o,0===Zt&&Qt(b)),Zt--,n===o?e=void 0:($t=e,e=o),e!==o?(n=$t,Zt++,t.substr($t,6)===x?(i=x,$t+=6):(i=o,0===Zt&&Qt(A)),Zt--,i===o?n=void 0:($t=n,n=o),n!==o?(i=$t,Zt++,t.substr($t,13)===j?(u=j,$t+=13):(u=o,0===Zt&&Qt(N)),Zt--,u===o?i=void 0:($t=i,i=o),i!==o&&(u=er())!==o&&(rt(u)?void 0:o)!==o?(e=et(u),r=e):($t=r,r=o)):($t=r,r=o)):($t=r,r=o))))))),r}())!==o&&lr()!==o?((a=function(){var r,e,n,i,u;if(r=$t,(e=lr())!==o)if(44===t.charCodeAt($t)?(n=g,$t++):(n=o,0===Zt&&Qt(v)),n!==o){for(i=[],u=rr();u!==o;)i.push(u),u=rr();i!==o&&(u=(u=nt(i))?void 0:o)!==o?(e=ot(i),r=e):($t=r,r=o)}else $t=r,r=o;else $t=r,r=o;if(r===o)if(r=$t,(e=lr())!==o)if(44===t.charCodeAt($t)?(n=g,$t++):(n=o,0===Zt&&Qt(v)),n!==o){for(i=[],u=ur();u!==o;)i.push(u),u=ur();i!==o?(e=it(i),r=e):($t=r,r=o)}else $t=r,r=o;else $t=r,r=o;return r}())===o&&(a=null),a!==o?(125===t.charCodeAt($t)?(c=m,$t++):(c=o,0===Zt&&Qt(d)),c!==o?(e=O(n,u,a),r=e):($t=r,r=o)):($t=r,r=o)):($t=r,r=o)):($t=r,r=o),r}())===o&&(r=$t,35===t.charCodeAt($t)?(e=a,$t++):(e=o,0===Zt&&Qt(c)),e!==o&&(n=(n=h())?void 0:o)!==o?r=e=f():($t=r,r=o),r===o)){if(r=$t,e=[],(n=fr())!==o)for(;n!==o;)e.push(n),n=fr();else e=o;e!==o&&(e=s(e)),r=e}return r}function er(){var r,e,n;if(Zt++,r=$t,e=[],z.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(P)),n!==o)for(;n!==o;)e.push(n),z.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(P));else e=o;return r=e!==o?t.substring(r,$t):e,Zt--,r===o&&(e=o,0===Zt&&Qt(E)),r}function nr(){var t,r,e;return t=$t,lr()!==o&&(r=er())!==o&&lr()!==o&&(e=ir())!==o?t=L(r,e):($t=t,t=o),t}function or(){var r,e,n;return r=$t,lr()!==o&&(e=function(){var r,e,n;return(r=er())===o&&(r=$t,61===t.charCodeAt($t)?(e=q,$t++):(e=o,0===Zt&&Qt($)),e!==o&&(n=sr())!==o?(e=B(n),r=e):($t=r,r=o)),r}())!==o&&lr()!==o&&(n=ir())!==o?r=L(e,n):($t=r,r=o),r}function ir(){var r,e,n,i,u,a;if(r=$t,123===t.charCodeAt($t)?(e=l,$t++):(e=o,0===Zt&&Qt(p)),e!==o)if(n=$t,(i=lr())!==o?(u=$t,Zt++,123===t.charCodeAt($t)?(a=l,$t++):(a=o,0===Zt&&Qt(p)),Zt--,a!==o?($t=u,u=void 0):u=o,u!==o?n=i=[i,u]:($t=n,n=o)):($t=n,n=o),n===o&&(n=null),n!==o){for(i=[],u=rr();u!==o;)i.push(u),u=rr();i!==o&&(u=lr())!==o?(125===t.charCodeAt($t)?(a=m,$t++):(a=o,0===Zt&&Qt(d)),a!==o?r=e=J(i):($t=r,r=o)):($t=r,r=o)}else $t=r,r=o;else $t=r,r=o;return r}function ur(){var r,e,n,i;if(Zt++,r=$t,e=[],at.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(ct)),n!==o)for(;n!==o;)e.push(n),at.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(ct));else e=o;if(e!==o&&(e=ht(e)),(r=e)===o&&(r=ar())===o&&(r=$t,39===t.charCodeAt($t)?(e=ft,$t++):(e=o,0===Zt&&Qt(st)),e!==o&&(n=cr())!==o?(39===t.charCodeAt($t)?(i=ft,$t++):(i=o,0===Zt&&Qt(st)),i!==o?r=e=lt(n):($t=r,r=o)):($t=r,r=o),r===o))if(r=$t,123===t.charCodeAt($t)?(e=l,$t++):(e=o,0===Zt&&Qt(p)),e!==o){for(n=[],i=ur();i!==o;)n.push(i),i=ur();n!==o?(125===t.charCodeAt($t)?(i=m,$t++):(i=o,0===Zt&&Qt(d)),i!==o?r=e=pt(n):($t=r,r=o)):($t=r,r=o)}else $t=r,r=o;return Zt--,r===o&&(e=o,0===Zt&&Qt(ut)),r}function ar(){var r,e;return Zt++,r=$t,t.substr($t,2)===dt?(e=dt,$t+=2):(e=o,0===Zt&&Qt(yt)),e!==o&&(e=gt()),Zt--,(r=e)===o&&(e=o,0===Zt&&Qt(mt)),r}function cr(){var r,e,n;if((r=ar())===o){if(r=$t,e=[],vt.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(wt)),n!==o)for(;n!==o;)e.push(n),vt.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(wt));else e=o;e!==o&&(e=s(e)),r=e}return r}function hr(){var r,e,n,i,u,a;if(Zt++,(r=function(){var r,e,n,i;if(r=$t,t.substr($t,2)===bt?(e=bt,$t+=2):(e=o,0===Zt&&Qt(St)),e!==o){for(n=[],i=cr();i!==o;)n.push(i),i=cr();n!==o?(39===t.charCodeAt($t)?(i=ft,$t++):(i=o,0===Zt&&Qt(st)),i!==o?r=e=kt(n):($t=r,r=o)):($t=r,r=o)}else $t=r,r=o;if(r===o)if(r=$t,t.substr($t,2)===xt?(e=xt,$t+=2):(e=o,0===Zt&&Qt(At)),e!==o){for(n=[],i=cr();i!==o;)n.push(i),i=cr();n!==o?(39===t.charCodeAt($t)?(i=ft,$t++):(i=o,0===Zt&&Qt(st)),i!==o?r=e=jt(n):($t=r,r=o)):($t=r,r=o)}else $t=r,r=o;return r}())===o){if(r=$t,e=$t,n=$t,t.substr($t,2)===Ct?(i=Ct,$t+=2):(i=o,0===Zt&&Qt(Ft)),i!==o){for(u=[],a=cr();a!==o;)u.push(a),a=cr();u!==o?(39===t.charCodeAt($t)?(a=ft,$t++):(a=o,0===Zt&&Qt(st)),a!==o?n=i=Ot(u):($t=n,n=o)):($t=n,n=o)}else $t=n,n=o;n!==o&&(i=(i=h())?void 0:o)!==o?e=n=[n,i]:($t=e,e=o),e!==o&&(e=Et(e)),(r=e)===o&&(39===t.charCodeAt($t)?(r=ft,$t++):(r=o,0===Zt&&Qt(st)))}return Zt--,r===o&&(e=o,0===Zt&&Qt(Nt)),r}function fr(){var r,e;return(r=ar())===o&&(r=hr())===o&&(r=$t,35===t.charCodeAt($t)?(e=a,$t++):(e=o,0===Zt&&Qt(c)),e!==o&&(Jt(e)?void 0:o)!==o?r=e=Dt(e):($t=r,r=o),r===o&&(r=function(){var r;return Zt++,Pt.test(t.charAt($t))?(r=t.charAt($t),$t++):(r=o,0===Zt&&Qt(Lt)),Zt--,r===o&&0===Zt&&Qt(zt),r}())),r}function sr(){var r,e,n;if(Zt++,r=$t,e=[],_t.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(Tt)),n!==o)for(;n!==o;)e.push(n),_t.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(Tt));else e=o;return r=e!==o?t.substring(r,$t):e,Zt--,r===o&&(e=o,0===Zt&&Qt(Mt)),r}function lr(){var r,e,n;for(Zt++,r=$t,e=[],Bt.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(qt));n!==o;)e.push(n),Bt.test(t.charAt($t))?(n=t.charAt($t),$t++):(n=o,0===Zt&&Qt(qt));return r=e!==o?t.substring(r,$t):e,Zt--,r===o&&(e=o,0===Zt&&Qt(Rt)),r}var pr=[!1];if((e=u())!==o&&$t===t.length)return e;throw e!==o&&$t<t.length&&Qt({type:"end"}),Xt(Ut,Gt<t.length?t.charAt(Gt):null,Gt<t.length?Ht(Gt,Gt+1):Ht(Gt,Gt))}}},function(t,r,e){var n,o,i=[{cardinal:["other"],ordinal:["other"]},{cardinal:["one","other"],ordinal:["other"]},{cardinal:["one","other"],ordinal:["one","other"]},{cardinal:["one","two","other"],ordinal:["other"]}];void 0===(o="function"==typeof(n={af:i[1],ak:i[1],am:i[1],ar:{cardinal:["zero","one","two","few","many","other"],ordinal:["other"]},ars:{cardinal:["zero","one","two","few","many","other"],ordinal:["other"]},as:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},asa:i[1],ast:i[1],az:{cardinal:["one","other"],ordinal:["one","few","many","other"]},be:{cardinal:["one","few","many","other"],ordinal:["few","other"]},bem:i[1],bez:i[1],bg:i[1],bh:i[1],bm:i[0],bn:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},bo:i[0],br:{cardinal:["one","two","few","many","other"],ordinal:["other"]},brx:i[1],bs:{cardinal:["one","few","other"],ordinal:["other"]},ca:{cardinal:["one","other"],ordinal:["one","two","few","other"]},ce:i[1],cgg:i[1],chr:i[1],ckb:i[1],cs:{cardinal:["one","few","many","other"],ordinal:["other"]},cy:{cardinal:["zero","one","two","few","many","other"],ordinal:["zero","one","two","few","many","other"]},da:i[1],de:i[1],dsb:{cardinal:["one","two","few","other"],ordinal:["other"]},dv:i[1],dz:i[0],ee:i[1],el:i[1],en:{cardinal:["one","other"],ordinal:["one","two","few","other"]},eo:i[1],es:i[1],et:i[1],eu:i[1],fa:i[1],ff:i[1],fi:i[1],fil:i[2],fo:i[1],fr:i[2],fur:i[1],fy:i[1],ga:{cardinal:["one","two","few","many","other"],ordinal:["one","other"]},gd:{cardinal:["one","two","few","other"],ordinal:["one","two","few","other"]},gl:i[1],gsw:i[1],gu:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},guw:i[1],gv:{cardinal:["one","two","few","many","other"],ordinal:["other"]},ha:i[1],haw:i[1],he:{cardinal:["one","two","many","other"],ordinal:["other"]},hi:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},hr:{cardinal:["one","few","other"],ordinal:["other"]},hsb:{cardinal:["one","two","few","other"],ordinal:["other"]},hu:i[2],hy:i[2],ia:i[1],id:i[0],ig:i[0],ii:i[0],in:i[0],io:i[1],is:i[1],it:{cardinal:["one","other"],ordinal:["many","other"]},iu:i[3],iw:{cardinal:["one","two","many","other"],ordinal:["other"]},ja:i[0],jbo:i[0],jgo:i[1],ji:i[1],jmc:i[1],jv:i[0],jw:i[0],ka:{cardinal:["one","other"],ordinal:["one","many","other"]},kab:i[1],kaj:i[1],kcg:i[1],kde:i[0],kea:i[0],kk:{cardinal:["one","other"],ordinal:["many","other"]},kkj:i[1],kl:i[1],km:i[0],kn:i[1],ko:i[0],ks:i[1],ksb:i[1],ksh:{cardinal:["zero","one","other"],ordinal:["other"]},ku:i[1],kw:i[3],ky:i[1],lag:{cardinal:["zero","one","other"],ordinal:["other"]},lb:i[1],lg:i[1],lkt:i[0],ln:i[1],lo:{cardinal:["other"],ordinal:["one","other"]},lt:{cardinal:["one","few","many","other"],ordinal:["other"]},lv:{cardinal:["zero","one","other"],ordinal:["other"]},mas:i[1],mg:i[1],mgo:i[1],mk:{cardinal:["one","other"],ordinal:["one","two","many","other"]},ml:i[1],mn:i[1],mo:{cardinal:["one","few","other"],ordinal:["one","other"]},mr:{cardinal:["one","other"],ordinal:["one","two","few","other"]},ms:{cardinal:["other"],ordinal:["one","other"]},mt:{cardinal:["one","few","many","other"],ordinal:["other"]},my:i[0],nah:i[1],naq:i[3],nb:i[1],nd:i[1],ne:i[2],nl:i[1],nn:i[1],nnh:i[1],no:i[1],nqo:i[0],nr:i[1],nso:i[1],ny:i[1],nyn:i[1],om:i[1],or:{cardinal:["one","other"],ordinal:["one","two","few","many","other"]},os:i[1],pa:i[1],pap:i[1],pl:{cardinal:["one","few","many","other"],ordinal:["other"]},prg:{cardinal:["zero","one","other"],ordinal:["other"]},ps:i[1],pt:i[1],"pt-PT":i[1],rm:i[1],ro:{cardinal:["one","few","other"],ordinal:["one","other"]},rof:i[1],root:i[0],ru:{cardinal:["one","few","many","other"],ordinal:["other"]},rwk:i[1],sah:i[0],saq:i[1],sc:{cardinal:["one","other"],ordinal:["many","other"]},scn:{cardinal:["one","other"],ordinal:["many","other"]},sd:i[1],sdh:i[1],se:i[3],seh:i[1],ses:i[0],sg:i[0],sh:{cardinal:["one","few","other"],ordinal:["other"]},shi:{cardinal:["one","few","other"],ordinal:["other"]},si:i[1],sk:{cardinal:["one","few","many","other"],ordinal:["other"]},sl:{cardinal:["one","two","few","other"],ordinal:["other"]},sma:i[3],smi:i[3],smj:i[3],smn:i[3],sms:i[3],sn:i[1],so:i[1],sq:{cardinal:["one","other"],ordinal:["one","many","other"]},sr:{cardinal:["one","few","other"],ordinal:["other"]},ss:i[1],ssy:i[1],st:i[1],sv:i[2],sw:i[1],syr:i[1],ta:i[1],te:i[1],teo:i[1],th:i[0],ti:i[1],tig:i[1],tk:{cardinal:["one","other"],ordinal:["few","other"]},tl:i[2],tn:i[1],to:i[0],tr:i[1],ts:i[1],tzm:i[1],ug:i[1],uk:{cardinal:["one","few","many","other"],ordinal:["few","other"]},ur:i[1],uz:i[1],ve:i[1],vi:{cardinal:["other"],ordinal:["one","other"]},vo:i[1],vun:i[1],wa:i[1],wae:i[1],wo:i[0],xh:i[1],xog:i[1],yi:i[1],yo:i[0],yue:i[0],zh:i[0],zu:i[1]})?n.call(r,e,r,t):n)||(t.exports=o)},function(t,r){function e(t,r,e){var n={day:"numeric",month:"short",year:"numeric"};switch(e){case"full":n.weekday="long";case"long":n.month="long";break;case"short":n.month="numeric"}return new Date(t).toLocaleDateString(r,n)}t.exports=function(){return e}},function(t,r){function e(t){if(!isFinite(t))return String(t);var r="";t<0?(r="-",t=Math.abs(t)):t=Number(t);var e=t%60,n=[Math.round(e)===e?e:e.toFixed(3)];return t<60?n.unshift(0):(t=Math.round((t-n[0])/60),n.unshift(t%60),t>=60&&(t=Math.round((t-n[0])/60),n.unshift(t))),r+n.shift()+":"+n.map(function(t){return t<10?"0"+String(t):String(t)}).join(":")}t.exports=function(){return e}},function(t,r){t.exports=function(t){var r=function(t,r,e){var n=e&&e.split(":")||[],o={integer:{maximumFractionDigits:0},percent:{style:"percent"},currency:{style:"currency",currency:n[1]&&n[1].trim()||CURRENCY,minimumFractionDigits:2,maximumFractionDigits:2}};return new Intl.NumberFormat(r,o[n[0]]||{}).format(t)}.toString().replace("CURRENCY",JSON.stringify(t.currency||"USD")).match(/\(([^)]*)\)[^{]*{([\s\S]*)}/);return new Function(r[1],r[2])}},function(t,r){function e(t,r,e){var n={second:"numeric",minute:"numeric",hour:"numeric"};switch(e){case"full":case"long":n.timeZoneName="short";break;case"short":delete n.second}return new Date(t).toLocaleTimeString(r,n)}t.exports=function(){return e}},function(t,r,e){"use strict";e.r(r);var n=e(1),o=e.n(n),i=e(2),u={break:!0,continue:!0,delete:!0,else:!0,for:!0,function:!0,if:!0,in:!0,new:!0,return:!0,this:!0,typeof:!0,var:!0,void:!0,while:!0,with:!0,case:!0,catch:!0,default:!0,do:!0,finally:!0,instanceof:!0,switch:!0,throw:!0,try:!0},a={debugger:!0,class:!0,enum:!0,extends:!0,super:!0,const:!0,export:!0,import:!0,null:!0,true:!0,false:!0,implements:!0,let:!0,private:!0,public:!0,yield:!0,interface:!0,package:!0,protected:!0,static:!0};function c(t,r){if(/^[A-Z_$][0-9A-Z_$]*$/i.test(t)&&!u[t])return r?"".concat(r,".").concat(t):t;var e=JSON.stringify(t);return r?r+"[".concat(e,"]"):e}function h(t){var r=t.trim().replace(/\W+/g,"_");return u[r]||a[r]||/^\d/.test(r)?"_"+r:r}var f=new RegExp("^"+["ar","ckb","fa","he","ks($|[^bfh])","lrc","mzn","pa-Arab","ps","ug","ur","uz-Arab","yi"].join("|^"));function s(t){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function l(t,r){for(var e=0;e<r.length;e++){var n=r[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var p=function(){function t(r){!function(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t),this.mf=r,this.lc=null,this.locales={},this.runtime={},this.formatters={}}var r,e,n;return r=t,(e=[{key:"compile",value:function(t,r,e){var n=this;if("object"!=s(t)){this.lc=r;var o=e[r]||{cardinal:[],ordinal:[]};o.strict=!!this.mf.options.strictNumberSign;var u=Object(i.parse)(t,o).map(function(t){return n.token(t)});return"function(d) { return ".concat(u.join(" + ")||'""',"; }")}var a={};for(var c in t){var h=e.hasOwnProperty(c)?c:r;a[c]=this.compile(t[c],h,e)}return a}},{key:"cases",value:function(t,r){var e=this,n="select"===t.type||!this.mf.hasCustomPluralFuncs,o=t.cases.map(function(t){var o=t.key,i=t.tokens;"other"===o&&(n=!1);var u=i.map(function(t){return e.token(t,r)});return c(o)+": "+(u.join(" + ")||'""')});if(n)throw new Error("No 'other' form found in "+JSON.stringify(t));return"{ ".concat(o.join(", ")," }")}},{key:"token",value:function(t,r){var e,n=this;if("string"==typeof t)return JSON.stringify(t);var o,i,u,a,s=[c(t.arg,"d")];switch(t.type){case"argument":return this.mf.options.biDiSupport?(o=s[0],i=this.lc,u=f.test(i),a=JSON.stringify(u?"‏":"‎"),"".concat(a," + ").concat(o," + ").concat(a)):s[0];case"select":e="select",r&&this.mf.options.strictNumberSign&&(r=null),s.push(this.cases(t,r)),this.runtime.select=!0;break;case"selectordinal":e="plural",s.push(0,h(this.lc),this.cases(t,t),1),this.locales[this.lc]=!0,this.runtime.plural=!0;break;case"plural":e="plural",s.push(t.offset||0,h(this.lc),this.cases(t,t)),this.locales[this.lc]=!0,this.runtime.plural=!0;break;case"function":if(!(t.key in this.mf.fmt)&&t.key in this.mf.constructor.formatters){var l=this.mf.constructor.formatters[t.key];this.mf.fmt[t.key]=l(this.mf)}if(!this.mf.fmt[t.key])throw new Error("Formatting function ".concat(JSON.stringify(t.key)," not found!"));if(s.push(JSON.stringify(this.lc)),t.param){r&&this.mf.options.strictNumberSign&&(r=null);var p=t.param.tokens.map(function(t){return n.token(t,r)});s.push("("+(p.join(" + ")||'""')+").trim()")}e=c(t.key,"fmt"),this.formatters[t.key]=!0;break;case"octothorpe":if(!r)return'"#"';e="number",s=[c(r.arg,"d"),JSON.stringify(r.arg)],r.offset&&s.push(r.offset),this.runtime.number=!0}if(!e)throw new Error("Parser error for token "+JSON.stringify(t));return"".concat(e,"(").concat(s.join(", "),")")}}])&&l(r.prototype,e),n&&l(r,n),t}(),m=e(3),d=e.n(m),y=e(0),g=e.n(y);function v(t,r,e){var n=function(){return r.apply(this,arguments)};if(n.toString=function(){return r.toString()},e){var o=d.a[t]||{};n.cardinal=o.cardinal,n.ordinal=o.ordinal}else n.cardinal=[],n.ordinal=[];return n}function w(t,r){for(var e=r.pluralKeyChecks,n=String(t);n;n=n.replace(/[-_]?[^-_]*$/,"")){var o=g.a[n];if(o)return v(n,o,e)}throw new Error("Localisation function not found for locale "+JSON.stringify(t))}function b(t){return(b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function S(t,r){for(var e=0;e<r.length;e++){var n=r[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var k=function(){function t(r){!function(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t),this.plural=function(t,r,e,n,o){if({}.hasOwnProperty.call(n,t))return n[t];r&&(t-=r);var i=e(t,o);return i in n?n[i]:n.other},this.select=function(t,r){return{}.hasOwnProperty.call(r,t)?r[t]:r.other},this.mf=r,this.setStrictNumber(r.options.strictNumberSign)}var r,e,n;return r=t,(e=[{key:"setStrictNumber",value:function(r){this.number=r?t.strictNumber:t.defaultNumber}},{key:"toString",value:function(t,r){for(var e={},n=Object.keys(r.locales),o=0;o<n.length;++o){var i=n[o];e[h(i)]=t[i]}for(var u=Object.keys(r.runtime),a=0;a<u.length;++a){var f=u[a];e[f]=this[f]}var s=Object.keys(r.formatters);if(s.length>0){e.fmt={};for(var l=0;l<s.length;++l){var p=s[l];e.fmt[p]=this.mf.fmt[p]}}return function t(r,e){if("object"!=b(r)){var n=r.toString().replace(/^(function )\w*/,"$1"),o=/([ \t]*)\S.*$/.exec(n);return o?n.replace(new RegExp("^"+o[1],"mg"),""):n}var i=[];for(var u in r){var a=t(r[u],e+1);i.push(0===e?"var ".concat(u," = ").concat(a,";\n"):"".concat(c(u),": ").concat(a))}if(0===e)return i.join("");if(0===i.length)return"{}";for(var h="  ";--e;)h+="  ";var f=i.join(",\n").replace(/^/gm,h);return"{\n".concat(f,"\n}")}(e,0)}}])&&S(r.prototype,e),n&&S(r,n),t}();function x(t){return(x="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function A(t,r){for(var e=0;e<r.length;e++){var n=r[e];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function j(t,r,e){return r&&A(t.prototype,r),e&&A(t,e),t}k.defaultNumber=function(t,r,e){if(!e)return t;if(isNaN(t))throw new Error("Can't apply offset:"+e+" to argument `"+r+"` with non-numerical value "+JSON.stringify(t)+".");return t-e},k.strictNumber=function(t,r,e){if(isNaN(t))throw new Error("Argument `"+r+"` has non-numerical value "+JSON.stringify(t)+".");return t-(e||0)},e.d(r,"default",function(){return N});var N=function(){function t(r,e){var n=this;if(function(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t),this.options=Object.assign({biDiSupport:!1,customFormatters:null,pluralKeyChecks:!0,strictNumberSign:!1},e),this.pluralFuncs={},"string"==typeof r)this.pluralFuncs[r]=w(r,this.options),this.defaultLocale=r;else if(Array.isArray(r))r.forEach(function(t){n.pluralFuncs[t]=w(t,n.options)}),this.defaultLocale=r[0];else{if(r)for(var o=Object.keys(r),i=0;i<o.length;++i){var u=o[i];if("function"!=typeof r[u]){var a="Expected function value for locale "+String(u);throw new Error(a)}this.pluralFuncs[u]=r[u],this.defaultLocale||(this.defaultLocale=u)}this.defaultLocale?this.hasCustomPluralFuncs=!0:(this.defaultLocale=t.defaultLocale,this.hasCustomPluralFuncs=!1)}this.fmt=Object.assign({},this.options.customFormatters),this.runtime=new k(this)}return j(t,null,[{key:"escape",value:function(t,r){var e=r?/[#{}]/g:/[{}]/g;return String(t).replace(e,"'$&'")}}]),j(t,[{key:"addFormatters",value:function(t){for(var r=Object.keys(t),e=0;e<r.length;++e){var n=r[e];this.fmt[n]=t[n]}return this}},{key:"disablePluralKeyChecks",value:function(){for(var t in this.options.pluralKeyChecks=!1,this.pluralFuncs){var r=this.pluralFuncs[t];r&&(r.cardinal=[],r.ordinal=[])}return this}},{key:"setBiDiSupport",value:function(t){return this.options.biDiSupport=!!t||void 0===t,this}},{key:"setStrictNumberSign",value:function(t){return this.options.strictNumberSign=!!t||void 0===t,this.runtime.setStrictNumber(this.options.strictNumberSign),this}},{key:"compile",value:function(t,r){var e={};if(0===Object.keys(this.pluralFuncs).length)if(r){var n=w(r,this.options);if(!n){var o=JSON.stringify(r);throw new Error("Locale ".concat(o," not found!"))}e[r]=n}else r=this.defaultLocale,e=function(t){for(var r=t.pluralKeyChecks,e={},n=Object.keys(g.a),o=0;o<n.length;++o){var i=n[o];e[i]=v(i,g.a[i],r)}return e}(this.options);else if(r){var i=this.pluralFuncs[r];if(!i){var u=JSON.stringify(r),a=JSON.stringify(this.pluralFuncs);throw new Error("Locale ".concat(u," not found in ").concat(a,"!"))}e[r]=i}else r=this.defaultLocale,e=this.pluralFuncs;var f=new p(this),s=f.compile(t,r,e);if("object"!=x(t)){var l=new Function("number, plural, select, fmt",h(r),"return "+s),m=this.runtime;return l(m.number,m.plural,m.select,this.fmt,e[r])}var d=this.runtime.toString(e,f)+"\n",y=function t(r,e){if(e||(e=0),"object"!=x(r))return r;for(var n="",o=0;o<e;++o)n+="  ";var i=[];for(var u in r){var a=t(r[u],e+1);i.push("\n".concat(n,"  ").concat(c(u),": ").concat(a))}return"{".concat(i.join(","),"\n").concat(n,"}")}(s),b=new Function(d+"return "+y)();if(b.hasOwnProperty("toString"))throw new Error("The top-level message key `toString` is reserved");return b.toString=function(t){return t&&"export default"!==t?t.indexOf(".")>-1?d+t+" = "+y:d+["(function (root, G) {",'  if (typeof define === "function" && define.amd) { define(G); }','  else if (typeof exports === "object") { module.exports = G; }',"  else { "+c(t,"root")+" = G; }","})(this, "+y+");"].join("\n"):d+"export default "+y},b}}]),t}();N.defaultLocale="en",N.formatters=o.a}]).default});

},{}],5:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],6:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
/*!
 * QUnit 2.11.3
 * https://qunitjs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-10-05T01:34Z
 */
(function (global$1) {
	'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var global__default = /*#__PURE__*/_interopDefaultLegacy(global$1);

	var window$1 = global__default['default'].window;
	var self$1 = global__default['default'].self;
	var console = global__default['default'].console;
	var setTimeout$1 = global__default['default'].setTimeout;
	var clearTimeout = global__default['default'].clearTimeout;
	var document$1 = window$1 && window$1.document;
	var navigator = window$1 && window$1.navigator;
	var localSessionStorage = function () {
	  var x = "qunit-test-string";

	  try {
	    global__default['default'].sessionStorage.setItem(x, x);
	    global__default['default'].sessionStorage.removeItem(x);
	    return global__default['default'].sessionStorage;
	  } catch (e) {
	    return undefined;
	  }
	}(); // Support IE 9-10: Fallback for fuzzysort.js used by /reporter/html.js

	if (!global__default['default'].Map) {
	  global__default['default'].Map = function StringMap() {
	    var store = Object.create(null);

	    this.get = function (strKey) {
	      return store[strKey];
	    };

	    this.set = function (strKey, val) {
	      store[strKey] = val;
	      return this;
	    };

	    this.clear = function () {
	      store = Object.create(null);
	    };
	  };
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it;

	  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = o[Symbol.iterator]();
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	// This allows support for IE 9, which doesn't have a console
	// object if the developer tools are not open.

	var Logger = {
	  warn: console ? console.warn.bind(console) : function () {}
	};

	var toString = Object.prototype.toString;
	var hasOwn = Object.prototype.hasOwnProperty;
	var now = Date.now || function () {
	  return new Date().getTime();
	};
	var hasPerformanceApi = detectPerformanceApi();
	var performance = hasPerformanceApi ? window$1.performance : undefined;
	var performanceNow = hasPerformanceApi ? performance.now.bind(performance) : now;

	function detectPerformanceApi() {
	  return window$1 && typeof window$1.performance !== "undefined" && typeof window$1.performance.mark === "function" && typeof window$1.performance.measure === "function";
	}

	function measure(comment, startMark, endMark) {
	  // `performance.measure` may fail if the mark could not be found.
	  // reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`
	  try {
	    performance.measure(comment, startMark, endMark);
	  } catch (ex) {
	    Logger.warn("performance.measure could not be executed because of ", ex.message);
	  }
	}
	var defined = {
	  document: window$1 && window$1.document !== undefined,
	  setTimeout: setTimeout$1 !== undefined
	}; // Returns a new Array with the elements that are in a but not in b

	function diff(a, b) {
	  var i,
	      j,
	      result = a.slice();

	  for (i = 0; i < result.length; i++) {
	    for (j = 0; j < b.length; j++) {
	      if (result[i] === b[j]) {
	        result.splice(i, 1);
	        i--;
	        break;
	      }
	    }
	  }

	  return result;
	}
	/**
	 * Determines whether an element exists in a given array or not.
	 *
	 * @method inArray
	 * @param {Any} elem
	 * @param {Array} array
	 * @return {Boolean}
	 */

	function inArray(elem, array) {
	  return array.indexOf(elem) !== -1;
	}
	/**
	 * Makes a clone of an object using only Array or Object as base,
	 * and copies over the own enumerable properties.
	 *
	 * @param {Object} obj
	 * @return {Object} New object with only the own properties (recursively).
	 */

	function objectValues(obj) {
	  var key,
	      val,
	      vals = is("array", obj) ? [] : {};

	  for (key in obj) {
	    if (hasOwn.call(obj, key)) {
	      val = obj[key];
	      vals[key] = val === Object(val) ? objectValues(val) : val;
	    }
	  }

	  return vals;
	}
	function extend(a, b, undefOnly) {
	  for (var prop in b) {
	    if (hasOwn.call(b, prop)) {
	      if (b[prop] === undefined) {
	        delete a[prop];
	      } else if (!(undefOnly && typeof a[prop] !== "undefined")) {
	        a[prop] = b[prop];
	      }
	    }
	  }

	  return a;
	}
	function objectType(obj) {
	  if (typeof obj === "undefined") {
	    return "undefined";
	  } // Consider: typeof null === object


	  if (obj === null) {
	    return "null";
	  }

	  var match = toString.call(obj).match(/^\[object\s(.*)\]$/),
	      type = match && match[1];

	  switch (type) {
	    case "Number":
	      if (isNaN(obj)) {
	        return "nan";
	      }

	      return "number";

	    case "String":
	    case "Boolean":
	    case "Array":
	    case "Set":
	    case "Map":
	    case "Date":
	    case "RegExp":
	    case "Function":
	    case "Symbol":
	      return type.toLowerCase();

	    default:
	      return _typeof(obj);
	  }
	} // Safe object type checking

	function is(type, obj) {
	  return objectType(obj) === type;
	} // Based on Java's String.hashCode, a simple but not
	// rigorously collision resistant hashing function

	function generateHash(module, testName) {
	  var str = module + "\x1C" + testName;
	  var hash = 0;

	  for (var i = 0; i < str.length; i++) {
	    hash = (hash << 5) - hash + str.charCodeAt(i);
	    hash |= 0;
	  } // Convert the possibly negative integer hash code into an 8 character hex string, which isn't
	  // strictly necessary but increases user understanding that the id is a SHA-like hash


	  var hex = (0x100000000 + hash).toString(16);

	  if (hex.length < 8) {
	    hex = "0000000" + hex;
	  }

	  return hex.slice(-8);
	}

	// Authors: Philippe Rathé <prathe@gmail.com>, David Chan <david@troi.org>

	var equiv = (function () {
	  // Value pairs queued for comparison. Used for breadth-first processing order, recursion
	  // detection and avoiding repeated comparison (see below for details).
	  // Elements are { a: val, b: val }.
	  var pairs = [];

	  var getProto = Object.getPrototypeOf || function (obj) {
	    return obj.__proto__;
	  };

	  function useStrictEquality(a, b) {
	    // This only gets called if a and b are not strict equal, and is used to compare on
	    // the primitive values inside object wrappers. For example:
	    // `var i = 1;`
	    // `var j = new Number(1);`
	    // Neither a nor b can be null, as a !== b and they have the same type.
	    if (_typeof(a) === "object") {
	      a = a.valueOf();
	    }

	    if (_typeof(b) === "object") {
	      b = b.valueOf();
	    }

	    return a === b;
	  }

	  function compareConstructors(a, b) {
	    var protoA = getProto(a);
	    var protoB = getProto(b); // Comparing constructors is more strict than using `instanceof`

	    if (a.constructor === b.constructor) {
	      return true;
	    } // Ref #851
	    // If the obj prototype descends from a null constructor, treat it
	    // as a null prototype.


	    if (protoA && protoA.constructor === null) {
	      protoA = null;
	    }

	    if (protoB && protoB.constructor === null) {
	      protoB = null;
	    } // Allow objects with no prototype to be equivalent to
	    // objects with Object as their constructor.


	    if (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {
	      return true;
	    }

	    return false;
	  }

	  function getRegExpFlags(regexp) {
	    return "flags" in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];
	  }

	  function isContainer(val) {
	    return ["object", "array", "map", "set"].indexOf(objectType(val)) !== -1;
	  }

	  function breadthFirstCompareChild(a, b) {
	    // If a is a container not reference-equal to b, postpone the comparison to the
	    // end of the pairs queue -- unless (a, b) has been seen before, in which case skip
	    // over the pair.
	    if (a === b) {
	      return true;
	    }

	    if (!isContainer(a)) {
	      return typeEquiv(a, b);
	    }

	    if (pairs.every(function (pair) {
	      return pair.a !== a || pair.b !== b;
	    })) {
	      // Not yet started comparing this pair
	      pairs.push({
	        a: a,
	        b: b
	      });
	    }

	    return true;
	  }

	  var callbacks = {
	    "string": useStrictEquality,
	    "boolean": useStrictEquality,
	    "number": useStrictEquality,
	    "null": useStrictEquality,
	    "undefined": useStrictEquality,
	    "symbol": useStrictEquality,
	    "date": useStrictEquality,
	    "nan": function nan() {
	      return true;
	    },
	    "regexp": function regexp(a, b) {
	      return a.source === b.source && // Include flags in the comparison
	      getRegExpFlags(a) === getRegExpFlags(b);
	    },
	    // abort (identical references / instance methods were skipped earlier)
	    "function": function _function() {
	      return false;
	    },
	    "array": function array(a, b) {
	      var i, len;
	      len = a.length;

	      if (len !== b.length) {
	        // Safe and faster
	        return false;
	      }

	      for (i = 0; i < len; i++) {
	        // Compare non-containers; queue non-reference-equal containers
	        if (!breadthFirstCompareChild(a[i], b[i])) {
	          return false;
	        }
	      }

	      return true;
	    },
	    // Define sets a and b to be equivalent if for each element aVal in a, there
	    // is some element bVal in b such that aVal and bVal are equivalent. Element
	    // repetitions are not counted, so these are equivalent:
	    // a = new Set( [ {}, [], [] ] );
	    // b = new Set( [ {}, {}, [] ] );
	    "set": function set(a, b) {
	      var innerEq,
	          outerEq = true;

	      if (a.size !== b.size) {
	        // This optimization has certain quirks because of the lack of
	        // repetition counting. For instance, adding the same
	        // (reference-identical) element to two equivalent sets can
	        // make them non-equivalent.
	        return false;
	      }

	      a.forEach(function (aVal) {
	        // Short-circuit if the result is already known. (Using for...of
	        // with a break clause would be cleaner here, but it would cause
	        // a syntax error on older Javascript implementations even if
	        // Set is unused)
	        if (!outerEq) {
	          return;
	        }

	        innerEq = false;
	        b.forEach(function (bVal) {
	          var parentPairs; // Likewise, short-circuit if the result is already known

	          if (innerEq) {
	            return;
	          } // Swap out the global pairs list, as the nested call to
	          // innerEquiv will clobber its contents


	          parentPairs = pairs;

	          if (innerEquiv(bVal, aVal)) {
	            innerEq = true;
	          } // Replace the global pairs list


	          pairs = parentPairs;
	        });

	        if (!innerEq) {
	          outerEq = false;
	        }
	      });
	      return outerEq;
	    },
	    // Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)
	    // in a, there is some key-value pair (bKey, bVal) in b such that
	    // [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not
	    // counted, so these are equivalent:
	    // a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );
	    // b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );
	    "map": function map(a, b) {
	      var innerEq,
	          outerEq = true;

	      if (a.size !== b.size) {
	        // This optimization has certain quirks because of the lack of
	        // repetition counting. For instance, adding the same
	        // (reference-identical) key-value pair to two equivalent maps
	        // can make them non-equivalent.
	        return false;
	      }

	      a.forEach(function (aVal, aKey) {
	        // Short-circuit if the result is already known. (Using for...of
	        // with a break clause would be cleaner here, but it would cause
	        // a syntax error on older Javascript implementations even if
	        // Map is unused)
	        if (!outerEq) {
	          return;
	        }

	        innerEq = false;
	        b.forEach(function (bVal, bKey) {
	          var parentPairs; // Likewise, short-circuit if the result is already known

	          if (innerEq) {
	            return;
	          } // Swap out the global pairs list, as the nested call to
	          // innerEquiv will clobber its contents


	          parentPairs = pairs;

	          if (innerEquiv([bVal, bKey], [aVal, aKey])) {
	            innerEq = true;
	          } // Replace the global pairs list


	          pairs = parentPairs;
	        });

	        if (!innerEq) {
	          outerEq = false;
	        }
	      });
	      return outerEq;
	    },
	    "object": function object(a, b) {
	      var i,
	          aProperties = [],
	          bProperties = [];

	      if (compareConstructors(a, b) === false) {
	        return false;
	      } // Be strict: don't ensure hasOwnProperty and go deep


	      for (i in a) {
	        // Collect a's properties
	        aProperties.push(i); // Skip OOP methods that look the same

	        if (a.constructor !== Object && typeof a.constructor !== "undefined" && typeof a[i] === "function" && typeof b[i] === "function" && a[i].toString() === b[i].toString()) {
	          continue;
	        } // Compare non-containers; queue non-reference-equal containers


	        if (!breadthFirstCompareChild(a[i], b[i])) {
	          return false;
	        }
	      }

	      for (i in b) {
	        // Collect b's properties
	        bProperties.push(i);
	      } // Ensures identical properties name


	      return typeEquiv(aProperties.sort(), bProperties.sort());
	    }
	  };

	  function typeEquiv(a, b) {
	    var type = objectType(a); // Callbacks for containers will append to the pairs queue to achieve breadth-first
	    // search order. The pairs queue is also used to avoid reprocessing any pair of
	    // containers that are reference-equal to a previously visited pair (a special case
	    // this being recursion detection).
	    //
	    // Because of this approach, once typeEquiv returns a false value, it should not be
	    // called again without clearing the pair queue else it may wrongly report a visited
	    // pair as being equivalent.

	    return objectType(b) === type && callbacks[type](a, b);
	  }

	  function innerEquiv(a, b) {
	    var i, pair; // We're done when there's nothing more to compare

	    if (arguments.length < 2) {
	      return true;
	    } // Clear the global pair queue and add the top-level values being compared


	    pairs = [{
	      a: a,
	      b: b
	    }];

	    for (i = 0; i < pairs.length; i++) {
	      pair = pairs[i]; // Perform type-specific comparison on any pairs that are not strictly
	      // equal. For container types, that comparison will postpone comparison
	      // of any sub-container pair to the end of the pair queue. This gives
	      // breadth-first search order. It also avoids the reprocessing of
	      // reference-equal siblings, cousins etc, which can have a significant speed
	      // impact when comparing a container of small objects each of which has a
	      // reference to the same (singleton) large object.

	      if (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {
	        return false;
	      }
	    } // ...across all consecutive argument pairs


	    return arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));
	  }

	  return function () {
	    var result = innerEquiv.apply(void 0, arguments); // Release any retained objects

	    pairs.length = 0;
	    return result;
	  };
	})();

	/**
	 * Config object: Maintain internal state
	 * Later exposed as QUnit.config
	 * `config` initialized at top of scope
	 */

	var config = {
	  // The queue of tests to run
	  queue: [],
	  // Block until document ready
	  blocking: true,
	  // By default, run previously failed tests first
	  // very useful in combination with "Hide passed tests" checked
	  reorder: true,
	  // By default, modify document.title when suite is done
	  altertitle: true,
	  // HTML Reporter: collapse every test except the first failing test
	  // If false, all failing tests will be expanded
	  collapse: true,
	  // By default, scroll to top of the page when suite is done
	  scrolltop: true,
	  // Depth up-to which object will be dumped
	  maxDepth: 5,
	  // When enabled, all tests must call expect()
	  requireExpects: false,
	  // Placeholder for user-configurable form-exposed URL parameters
	  urlConfig: [],
	  // Set of all modules.
	  modules: [],
	  // The first unnamed module
	  currentModule: {
	    name: "",
	    tests: [],
	    childModules: [],
	    testsRun: 0,
	    unskippedTestsRun: 0,
	    hooks: {
	      before: [],
	      beforeEach: [],
	      afterEach: [],
	      after: []
	    }
	  },
	  callbacks: {},
	  // The storage module to use for reordering tests
	  storage: localSessionStorage
	}; // take a predefined QUnit.config and extend the defaults

	var globalConfig = window$1 && window$1.QUnit && window$1.QUnit.config; // only extend the global config if there is no QUnit overload

	if (window$1 && window$1.QUnit && !window$1.QUnit.version) {
	  extend(config, globalConfig);
	} // Push a loose unnamed module to the modules collection


	config.modules.push(config.currentModule);

	// https://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html

	var dump = (function () {
	  function quote(str) {
	    return "\"" + str.toString().replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"";
	  }

	  function literal(o) {
	    return o + "";
	  }

	  function join(pre, arr, post) {
	    var s = dump.separator(),
	        base = dump.indent(),
	        inner = dump.indent(1);

	    if (arr.join) {
	      arr = arr.join("," + s + inner);
	    }

	    if (!arr) {
	      return pre + post;
	    }

	    return [pre, inner + arr, base + post].join(s);
	  }

	  function array(arr, stack) {
	    var i = arr.length,
	        ret = new Array(i);

	    if (dump.maxDepth && dump.depth > dump.maxDepth) {
	      return "[object Array]";
	    }

	    this.up();

	    while (i--) {
	      ret[i] = this.parse(arr[i], undefined, stack);
	    }

	    this.down();
	    return join("[", ret, "]");
	  }

	  function isArray(obj) {
	    return (//Native Arrays
	      toString.call(obj) === "[object Array]" || // NodeList objects
	      typeof obj.length === "number" && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)
	    );
	  }

	  var reName = /^function (\w+)/,
	      dump = {
	    // The objType is used mostly internally, you can fix a (custom) type in advance
	    parse: function parse(obj, objType, stack) {
	      stack = stack || [];
	      var res,
	          parser,
	          parserType,
	          objIndex = stack.indexOf(obj);

	      if (objIndex !== -1) {
	        return "recursion(".concat(objIndex - stack.length, ")");
	      }

	      objType = objType || this.typeOf(obj);
	      parser = this.parsers[objType];
	      parserType = _typeof(parser);

	      if (parserType === "function") {
	        stack.push(obj);
	        res = parser.call(this, obj, stack);
	        stack.pop();
	        return res;
	      }

	      return parserType === "string" ? parser : this.parsers.error;
	    },
	    typeOf: function typeOf(obj) {
	      var type;

	      if (obj === null) {
	        type = "null";
	      } else if (typeof obj === "undefined") {
	        type = "undefined";
	      } else if (is("regexp", obj)) {
	        type = "regexp";
	      } else if (is("date", obj)) {
	        type = "date";
	      } else if (is("function", obj)) {
	        type = "function";
	      } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {
	        type = "window";
	      } else if (obj.nodeType === 9) {
	        type = "document";
	      } else if (obj.nodeType) {
	        type = "node";
	      } else if (isArray(obj)) {
	        type = "array";
	      } else if (obj.constructor === Error.prototype.constructor) {
	        type = "error";
	      } else {
	        type = _typeof(obj);
	      }

	      return type;
	    },
	    separator: function separator() {
	      if (this.multiline) {
	        return this.HTML ? "<br />" : "\n";
	      } else {
	        return this.HTML ? "&#160;" : " ";
	      }
	    },
	    // Extra can be a number, shortcut for increasing-calling-decreasing
	    indent: function indent(extra) {
	      if (!this.multiline) {
	        return "";
	      }

	      var chr = this.indentChar;

	      if (this.HTML) {
	        chr = chr.replace(/\t/g, "   ").replace(/ /g, "&#160;");
	      }

	      return new Array(this.depth + (extra || 0)).join(chr);
	    },
	    up: function up(a) {
	      this.depth += a || 1;
	    },
	    down: function down(a) {
	      this.depth -= a || 1;
	    },
	    setParser: function setParser(name, parser) {
	      this.parsers[name] = parser;
	    },
	    // The next 3 are exposed so you can use them
	    quote: quote,
	    literal: literal,
	    join: join,
	    depth: 1,
	    maxDepth: config.maxDepth,
	    // This is the list of parsers, to modify them, use dump.setParser
	    parsers: {
	      window: "[Window]",
	      document: "[Document]",
	      error: function error(_error) {
	        return "Error(\"" + _error.message + "\")";
	      },
	      unknown: "[Unknown]",
	      "null": "null",
	      "undefined": "undefined",
	      "function": function _function(fn) {
	        var ret = "function",
	            // Functions never have name in IE
	        name = "name" in fn ? fn.name : (reName.exec(fn) || [])[1];

	        if (name) {
	          ret += " " + name;
	        }

	        ret += "(";
	        ret = [ret, dump.parse(fn, "functionArgs"), "){"].join("");
	        return join(ret, dump.parse(fn, "functionCode"), "}");
	      },
	      array: array,
	      nodelist: array,
	      "arguments": array,
	      object: function object(map, stack) {
	        var keys,
	            key,
	            val,
	            i,
	            nonEnumerableProperties,
	            ret = [];

	        if (dump.maxDepth && dump.depth > dump.maxDepth) {
	          return "[object Object]";
	        }

	        dump.up();
	        keys = [];

	        for (key in map) {
	          keys.push(key);
	        } // Some properties are not always enumerable on Error objects.


	        nonEnumerableProperties = ["message", "name"];

	        for (i in nonEnumerableProperties) {
	          key = nonEnumerableProperties[i];

	          if (key in map && !inArray(key, keys)) {
	            keys.push(key);
	          }
	        }

	        keys.sort();

	        for (i = 0; i < keys.length; i++) {
	          key = keys[i];
	          val = map[key];
	          ret.push(dump.parse(key, "key") + ": " + dump.parse(val, undefined, stack));
	        }

	        dump.down();
	        return join("{", ret, "}");
	      },
	      node: function node(_node) {
	        var len,
	            i,
	            val,
	            open = dump.HTML ? "&lt;" : "<",
	            close = dump.HTML ? "&gt;" : ">",
	            tag = _node.nodeName.toLowerCase(),
	            ret = open + tag,
	            attrs = _node.attributes;

	        if (attrs) {
	          for (i = 0, len = attrs.length; i < len; i++) {
	            val = attrs[i].nodeValue; // IE6 includes all attributes in .attributes, even ones not explicitly
	            // set. Those have values like undefined, null, 0, false, "" or
	            // "inherit".

	            if (val && val !== "inherit") {
	              ret += " " + attrs[i].nodeName + "=" + dump.parse(val, "attribute");
	            }
	          }
	        }

	        ret += close; // Show content of TextNode or CDATASection

	        if (_node.nodeType === 3 || _node.nodeType === 4) {
	          ret += _node.nodeValue;
	        }

	        return ret + open + "/" + tag + close;
	      },
	      // Function calls it internally, it's the arguments part of the function
	      functionArgs: function functionArgs(fn) {
	        var args,
	            l = fn.length;

	        if (!l) {
	          return "";
	        }

	        args = new Array(l);

	        while (l--) {
	          // 97 is 'a'
	          args[l] = String.fromCharCode(97 + l);
	        }

	        return " " + args.join(", ") + " ";
	      },
	      // Object calls it internally, the key part of an item in a map
	      key: quote,
	      // Function calls it internally, it's the content of the function
	      functionCode: "[code]",
	      // Node calls it internally, it's a html attribute value
	      attribute: quote,
	      string: quote,
	      date: quote,
	      regexp: literal,
	      number: literal,
	      "boolean": literal,
	      symbol: function symbol(sym) {
	        return sym.toString();
	      }
	    },
	    // If true, entities are escaped ( <, >, \t, space and \n )
	    HTML: false,
	    // Indentation unit
	    indentChar: "  ",
	    // If true, items in a collection, are separated by a \n, else just a space.
	    multiline: true
	  };
	  return dump;
	})();

	var SuiteReport = /*#__PURE__*/function () {
	  function SuiteReport(name, parentSuite) {
	    _classCallCheck(this, SuiteReport);

	    this.name = name;
	    this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];
	    this.tests = [];
	    this.childSuites = [];

	    if (parentSuite) {
	      parentSuite.pushChildSuite(this);
	    }
	  }

	  _createClass(SuiteReport, [{
	    key: "start",
	    value: function start(recordTime) {
	      if (recordTime) {
	        this._startTime = performanceNow();

	        if (performance) {
	          var suiteLevel = this.fullName.length;
	          performance.mark("qunit_suite_".concat(suiteLevel, "_start"));
	        }
	      }

	      return {
	        name: this.name,
	        fullName: this.fullName.slice(),
	        tests: this.tests.map(function (test) {
	          return test.start();
	        }),
	        childSuites: this.childSuites.map(function (suite) {
	          return suite.start();
	        }),
	        testCounts: {
	          total: this.getTestCounts().total
	        }
	      };
	    }
	  }, {
	    key: "end",
	    value: function end(recordTime) {
	      if (recordTime) {
	        this._endTime = performanceNow();

	        if (performance) {
	          var suiteLevel = this.fullName.length;
	          performance.mark("qunit_suite_".concat(suiteLevel, "_end"));
	          var suiteName = this.fullName.join(" – ");
	          measure(suiteLevel === 0 ? "QUnit Test Run" : "QUnit Test Suite: ".concat(suiteName), "qunit_suite_".concat(suiteLevel, "_start"), "qunit_suite_".concat(suiteLevel, "_end"));
	        }
	      }

	      return {
	        name: this.name,
	        fullName: this.fullName.slice(),
	        tests: this.tests.map(function (test) {
	          return test.end();
	        }),
	        childSuites: this.childSuites.map(function (suite) {
	          return suite.end();
	        }),
	        testCounts: this.getTestCounts(),
	        runtime: this.getRuntime(),
	        status: this.getStatus()
	      };
	    }
	  }, {
	    key: "pushChildSuite",
	    value: function pushChildSuite(suite) {
	      this.childSuites.push(suite);
	    }
	  }, {
	    key: "pushTest",
	    value: function pushTest(test) {
	      this.tests.push(test);
	    }
	  }, {
	    key: "getRuntime",
	    value: function getRuntime() {
	      return this._endTime - this._startTime;
	    }
	  }, {
	    key: "getTestCounts",
	    value: function getTestCounts() {
	      var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	        passed: 0,
	        failed: 0,
	        skipped: 0,
	        todo: 0,
	        total: 0
	      };
	      counts = this.tests.reduce(function (counts, test) {
	        if (test.valid) {
	          counts[test.getStatus()]++;
	          counts.total++;
	        }

	        return counts;
	      }, counts);
	      return this.childSuites.reduce(function (counts, suite) {
	        return suite.getTestCounts(counts);
	      }, counts);
	    }
	  }, {
	    key: "getStatus",
	    value: function getStatus() {
	      var _this$getTestCounts = this.getTestCounts(),
	          total = _this$getTestCounts.total,
	          failed = _this$getTestCounts.failed,
	          skipped = _this$getTestCounts.skipped,
	          todo = _this$getTestCounts.todo;

	      if (failed) {
	        return "failed";
	      } else {
	        if (skipped === total) {
	          return "skipped";
	        } else if (todo === total) {
	          return "todo";
	        } else {
	          return "passed";
	        }
	      }
	    }
	  }]);

	  return SuiteReport;
	}();

	var focused = false;
	var moduleStack = [];

	function isParentModuleInQueue() {
	  var modulesInQueue = config.modules.map(function (module) {
	    return module.moduleId;
	  });
	  return moduleStack.some(function (module) {
	    return modulesInQueue.includes(module.moduleId);
	  });
	}

	function createModule(name, testEnvironment, modifiers) {
	  var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;
	  var moduleName = parentModule !== null ? [parentModule.name, name].join(" > ") : name;
	  var parentSuite = parentModule ? parentModule.suiteReport : globalSuite;
	  var skip = parentModule !== null && parentModule.skip || modifiers.skip;
	  var todo = parentModule !== null && parentModule.todo || modifiers.todo;
	  var module = {
	    name: moduleName,
	    parentModule: parentModule,
	    tests: [],
	    moduleId: generateHash(moduleName),
	    testsRun: 0,
	    unskippedTestsRun: 0,
	    childModules: [],
	    suiteReport: new SuiteReport(name, parentSuite),
	    // Pass along `skip` and `todo` properties from parent module, in case
	    // there is one, to childs. And use own otherwise.
	    // This property will be used to mark own tests and tests of child suites
	    // as either `skipped` or `todo`.
	    skip: skip,
	    todo: skip ? false : todo
	  };
	  var env = {};

	  if (parentModule) {
	    parentModule.childModules.push(module);
	    extend(env, parentModule.testEnvironment);
	  }

	  extend(env, testEnvironment);
	  module.testEnvironment = env;
	  config.modules.push(module);
	  return module;
	}

	function processModule(name, options, executeNow) {
	  var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	  if (objectType(options) === "function") {
	    executeNow = options;
	    options = undefined;
	  }

	  var module = createModule(name, options, modifiers); // Move any hooks to a 'hooks' object

	  var testEnvironment = module.testEnvironment;
	  var hooks = module.hooks = {};
	  setHookFromEnvironment(hooks, testEnvironment, "before");
	  setHookFromEnvironment(hooks, testEnvironment, "beforeEach");
	  setHookFromEnvironment(hooks, testEnvironment, "afterEach");
	  setHookFromEnvironment(hooks, testEnvironment, "after");
	  var moduleFns = {
	    before: setHookFunction(module, "before"),
	    beforeEach: setHookFunction(module, "beforeEach"),
	    afterEach: setHookFunction(module, "afterEach"),
	    after: setHookFunction(module, "after")
	  };
	  var currentModule = config.currentModule;

	  if (objectType(executeNow) === "function") {
	    moduleStack.push(module);
	    config.currentModule = module;
	    executeNow.call(module.testEnvironment, moduleFns);
	    moduleStack.pop();
	    module = module.parentModule || currentModule;
	  }

	  config.currentModule = module;

	  function setHookFromEnvironment(hooks, environment, name) {
	    var potentialHook = environment[name];
	    hooks[name] = typeof potentialHook === "function" ? [potentialHook] : [];
	    delete environment[name];
	  }

	  function setHookFunction(module, hookName) {
	    return function setHook(callback) {
	      module.hooks[hookName].push(callback);
	    };
	  }
	}

	function module$1(name, options, executeNow) {
	  if (focused && !isParentModuleInQueue()) {
	    return;
	  }

	  processModule(name, options, executeNow);
	}

	module$1.only = function () {
	  if (!focused) {
	    config.modules.length = 0;
	    config.queue.length = 0;
	  }

	  processModule.apply(void 0, arguments);
	  focused = true;
	};

	module$1.skip = function (name, options, executeNow) {
	  if (focused) {
	    return;
	  }

	  processModule(name, options, executeNow, {
	    skip: true
	  });
	};

	module$1.todo = function (name, options, executeNow) {
	  if (focused) {
	    return;
	  }

	  processModule(name, options, executeNow, {
	    todo: true
	  });
	};

	var LISTENERS = Object.create(null);
	var SUPPORTED_EVENTS = ["runStart", "suiteStart", "testStart", "assertion", "testEnd", "suiteEnd", "runEnd"];
	/**
	 * Emits an event with the specified data to all currently registered listeners.
	 * Callbacks will fire in the order in which they are registered (FIFO). This
	 * function is not exposed publicly; it is used by QUnit internals to emit
	 * logging events.
	 *
	 * @private
	 * @method emit
	 * @param {String} eventName
	 * @param {Object} data
	 * @return {Void}
	 */

	function emit(eventName, data) {
	  if (objectType(eventName) !== "string") {
	    throw new TypeError("eventName must be a string when emitting an event");
	  } // Clone the callbacks in case one of them registers a new callback


	  var originalCallbacks = LISTENERS[eventName];
	  var callbacks = originalCallbacks ? _toConsumableArray(originalCallbacks) : [];

	  for (var i = 0; i < callbacks.length; i++) {
	    callbacks[i](data);
	  }
	}
	/**
	 * Registers a callback as a listener to the specified event.
	 *
	 * @public
	 * @method on
	 * @param {String} eventName
	 * @param {Function} callback
	 * @return {Void}
	 */

	function on(eventName, callback) {
	  if (objectType(eventName) !== "string") {
	    throw new TypeError("eventName must be a string when registering a listener");
	  } else if (!inArray(eventName, SUPPORTED_EVENTS)) {
	    var events = SUPPORTED_EVENTS.join(", ");
	    throw new Error("\"".concat(eventName, "\" is not a valid event; must be one of: ").concat(events, "."));
	  } else if (objectType(callback) !== "function") {
	    throw new TypeError("callback must be a function when registering a listener");
	  }

	  if (!LISTENERS[eventName]) {
	    LISTENERS[eventName] = [];
	  } // Don't register the same callback more than once


	  if (!inArray(callback, LISTENERS[eventName])) {
	    LISTENERS[eventName].push(callback);
	  }
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var es6Promise = createCommonjsModule(function (module, exports) {
	  /*!
	   * @overview es6-promise - a tiny implementation of Promises/A+.
	   * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	   * @license   Licensed under MIT license
	   *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	   * @version   v4.2.8+1e68dce6
	   */
	  (function (global, factory) {
	     module.exports = factory() ;
	  })(commonjsGlobal, function () {

	    function objectOrFunction(x) {
	      var type = typeof x;
	      return x !== null && (type === 'object' || type === 'function');
	    }

	    function isFunction(x) {
	      return typeof x === 'function';
	    }

	    var _isArray = void 0;

	    if (Array.isArray) {
	      _isArray = Array.isArray;
	    } else {
	      _isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    }

	    var isArray = _isArray;
	    var len = 0;
	    var vertxNext = void 0;
	    var customSchedulerFn = void 0;

	    var asap = function asap(callback, arg) {
	      queue[len] = callback;
	      queue[len + 1] = arg;
	      len += 2;

	      if (len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (customSchedulerFn) {
	          customSchedulerFn(flush);
	        } else {
	          scheduleFlush();
	        }
	      }
	    };

	    function setScheduler(scheduleFn) {
	      customSchedulerFn = scheduleFn;
	    }

	    function setAsap(asapFn) {
	      asap = asapFn;
	    }

	    var browserWindow = typeof window !== 'undefined' ? window : undefined;
	    var browserGlobal = browserWindow || {};
	    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	    var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10

	    var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node

	    function useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function () {
	        return process.nextTick(flush);
	      };
	    } // vertx


	    function useVertxTimer() {
	      if (typeof vertxNext !== 'undefined') {
	        return function () {
	          vertxNext(flush);
	        };
	      }

	      return useSetTimeout();
	    }

	    function useMutationObserver() {
	      var iterations = 0;
	      var observer = new BrowserMutationObserver(flush);
	      var node = document.createTextNode('');
	      observer.observe(node, {
	        characterData: true
	      });
	      return function () {
	        node.data = iterations = ++iterations % 2;
	      };
	    } // web worker


	    function useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = flush;
	      return function () {
	        return channel.port2.postMessage(0);
	      };
	    }

	    function useSetTimeout() {
	      // Store setTimeout reference so es6-promise will be unaffected by
	      // other code modifying setTimeout (like sinon.useFakeTimers())
	      var globalSetTimeout = setTimeout;
	      return function () {
	        return globalSetTimeout(flush, 1);
	      };
	    }

	    var queue = new Array(1000);

	    function flush() {
	      for (var i = 0; i < len; i += 2) {
	        var callback = queue[i];
	        var arg = queue[i + 1];
	        callback(arg);
	        queue[i] = undefined;
	        queue[i + 1] = undefined;
	      }

	      len = 0;
	    }

	    function attemptVertx() {
	      try {
	        var vertx = Function('return this')().require('vertx');

	        vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return useVertxTimer();
	      } catch (e) {
	        return useSetTimeout();
	      }
	    }

	    var scheduleFlush = void 0; // Decide what async method to use to triggering processing of queued callbacks:

	    if (isNode) {
	      scheduleFlush = useNextTick();
	    } else if (BrowserMutationObserver) {
	      scheduleFlush = useMutationObserver();
	    } else if (isWorker) {
	      scheduleFlush = useMessageChannel();
	    } else if (browserWindow === undefined && typeof commonjsRequire === 'function') {
	      scheduleFlush = attemptVertx();
	    } else {
	      scheduleFlush = useSetTimeout();
	    }

	    function then(onFulfillment, onRejection) {
	      var parent = this;
	      var child = new this.constructor(noop);

	      if (child[PROMISE_ID] === undefined) {
	        makePromise(child);
	      }

	      var _state = parent._state;

	      if (_state) {
	        var callback = arguments[_state - 1];
	        asap(function () {
	          return invokeCallback(_state, child, callback, parent._result);
	        });
	      } else {
	        subscribe(parent, child, onFulfillment, onRejection);
	      }

	      return child;
	    }
	    /**
	      `Promise.resolve` returns a promise that will become resolved with the
	      passed `value`. It is shorthand for the following:
	    
	      ```javascript
	      let promise = new Promise(function(resolve, reject){
	        resolve(1);
	      });
	    
	      promise.then(function(value){
	        // value === 1
	      });
	      ```
	    
	      Instead of writing the above, your code now simply becomes the following:
	    
	      ```javascript
	      let promise = Promise.resolve(1);
	    
	      promise.then(function(value){
	        // value === 1
	      });
	      ```
	    
	      @method resolve
	      @static
	      @param {Any} value value that the returned promise will be resolved with
	      Useful for tooling.
	      @return {Promise} a promise that will become fulfilled with the given
	      `value`
	    */


	    function resolve$1(object) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }

	      var promise = new Constructor(noop);
	      resolve(promise, object);
	      return promise;
	    }

	    var PROMISE_ID = Math.random().toString(36).substring(2);

	    function noop() {}

	    var PENDING = void 0;
	    var FULFILLED = 1;
	    var REJECTED = 2;

	    function selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }

	    function cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }

	    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then$$1.call(value, fulfillmentHandler, rejectionHandler);
	      } catch (e) {
	        return e;
	      }
	    }

	    function handleForeignThenable(promise, thenable, then$$1) {
	      asap(function (promise) {
	        var sealed = false;
	        var error = tryThen(then$$1, thenable, function (value) {
	          if (sealed) {
	            return;
	          }

	          sealed = true;

	          if (thenable !== value) {
	            resolve(promise, value);
	          } else {
	            fulfill(promise, value);
	          }
	        }, function (reason) {
	          if (sealed) {
	            return;
	          }

	          sealed = true;
	          reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));

	        if (!sealed && error) {
	          sealed = true;
	          reject(promise, error);
	        }
	      }, promise);
	    }

	    function handleOwnThenable(promise, thenable) {
	      if (thenable._state === FULFILLED) {
	        fulfill(promise, thenable._result);
	      } else if (thenable._state === REJECTED) {
	        reject(promise, thenable._result);
	      } else {
	        subscribe(thenable, undefined, function (value) {
	          return resolve(promise, value);
	        }, function (reason) {
	          return reject(promise, reason);
	        });
	      }
	    }

	    function handleMaybeThenable(promise, maybeThenable, then$$1) {
	      if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	        handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then$$1 === undefined) {
	          fulfill(promise, maybeThenable);
	        } else if (isFunction(then$$1)) {
	          handleForeignThenable(promise, maybeThenable, then$$1);
	        } else {
	          fulfill(promise, maybeThenable);
	        }
	      }
	    }

	    function resolve(promise, value) {
	      if (promise === value) {
	        reject(promise, selfFulfillment());
	      } else if (objectOrFunction(value)) {
	        var then$$1 = void 0;

	        try {
	          then$$1 = value.then;
	        } catch (error) {
	          reject(promise, error);
	          return;
	        }

	        handleMaybeThenable(promise, value, then$$1);
	      } else {
	        fulfill(promise, value);
	      }
	    }

	    function publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }

	      publish(promise);
	    }

	    function fulfill(promise, value) {
	      if (promise._state !== PENDING) {
	        return;
	      }

	      promise._result = value;
	      promise._state = FULFILLED;

	      if (promise._subscribers.length !== 0) {
	        asap(publish, promise);
	      }
	    }

	    function reject(promise, reason) {
	      if (promise._state !== PENDING) {
	        return;
	      }

	      promise._state = REJECTED;
	      promise._result = reason;
	      asap(publishRejection, promise);
	    }

	    function subscribe(parent, child, onFulfillment, onRejection) {
	      var _subscribers = parent._subscribers;
	      var length = _subscribers.length;
	      parent._onerror = null;
	      _subscribers[length] = child;
	      _subscribers[length + FULFILLED] = onFulfillment;
	      _subscribers[length + REJECTED] = onRejection;

	      if (length === 0 && parent._state) {
	        asap(publish, parent);
	      }
	    }

	    function publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;

	      if (subscribers.length === 0) {
	        return;
	      }

	      var child = void 0,
	          callback = void 0,
	          detail = promise._result;

	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];

	        if (child) {
	          invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }

	      promise._subscribers.length = 0;
	    }

	    function invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = isFunction(callback),
	          value = void 0,
	          error = void 0,
	          succeeded = true;

	      if (hasCallback) {
	        try {
	          value = callback(detail);
	        } catch (e) {
	          succeeded = false;
	          error = e;
	        }

	        if (promise === value) {
	          reject(promise, cannotReturnOwn());
	          return;
	        }
	      } else {
	        value = detail;
	      }

	      if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
	        resolve(promise, value);
	      } else if (succeeded === false) {
	        reject(promise, error);
	      } else if (settled === FULFILLED) {
	        fulfill(promise, value);
	      } else if (settled === REJECTED) {
	        reject(promise, value);
	      }
	    }

	    function initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value) {
	          resolve(promise, value);
	        }, function rejectPromise(reason) {
	          reject(promise, reason);
	        });
	      } catch (e) {
	        reject(promise, e);
	      }
	    }

	    var id = 0;

	    function nextId() {
	      return id++;
	    }

	    function makePromise(promise) {
	      promise[PROMISE_ID] = id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }

	    function validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }

	    var Enumerator = function () {
	      function Enumerator(Constructor, input) {
	        this._instanceConstructor = Constructor;
	        this.promise = new Constructor(noop);

	        if (!this.promise[PROMISE_ID]) {
	          makePromise(this.promise);
	        }

	        if (isArray(input)) {
	          this.length = input.length;
	          this._remaining = input.length;
	          this._result = new Array(this.length);

	          if (this.length === 0) {
	            fulfill(this.promise, this._result);
	          } else {
	            this.length = this.length || 0;

	            this._enumerate(input);

	            if (this._remaining === 0) {
	              fulfill(this.promise, this._result);
	            }
	          }
	        } else {
	          reject(this.promise, validationError());
	        }
	      }

	      Enumerator.prototype._enumerate = function _enumerate(input) {
	        for (var i = 0; this._state === PENDING && i < input.length; i++) {
	          this._eachEntry(input[i], i);
	        }
	      };

	      Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
	        var c = this._instanceConstructor;
	        var resolve$$1 = c.resolve;

	        if (resolve$$1 === resolve$1) {
	          var _then = void 0;

	          var error = void 0;
	          var didError = false;

	          try {
	            _then = entry.then;
	          } catch (e) {
	            didError = true;
	            error = e;
	          }

	          if (_then === then && entry._state !== PENDING) {
	            this._settledAt(entry._state, i, entry._result);
	          } else if (typeof _then !== 'function') {
	            this._remaining--;
	            this._result[i] = entry;
	          } else if (c === Promise$1) {
	            var promise = new c(noop);

	            if (didError) {
	              reject(promise, error);
	            } else {
	              handleMaybeThenable(promise, entry, _then);
	            }

	            this._willSettleAt(promise, i);
	          } else {
	            this._willSettleAt(new c(function (resolve$$1) {
	              return resolve$$1(entry);
	            }), i);
	          }
	        } else {
	          this._willSettleAt(resolve$$1(entry), i);
	        }
	      };

	      Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
	        var promise = this.promise;

	        if (promise._state === PENDING) {
	          this._remaining--;

	          if (state === REJECTED) {
	            reject(promise, value);
	          } else {
	            this._result[i] = value;
	          }
	        }

	        if (this._remaining === 0) {
	          fulfill(promise, this._result);
	        }
	      };

	      Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
	        var enumerator = this;
	        subscribe(promise, undefined, function (value) {
	          return enumerator._settledAt(FULFILLED, i, value);
	        }, function (reason) {
	          return enumerator._settledAt(REJECTED, i, reason);
	        });
	      };

	      return Enumerator;
	    }();
	    /**
	      `Promise.all` accepts an array of promises, and returns a new promise which
	      is fulfilled with an array of fulfillment values for the passed promises, or
	      rejected with the reason of the first passed promise to be rejected. It casts all
	      elements of the passed iterable to promises as it runs this algorithm.
	    
	      Example:
	    
	      ```javascript
	      let promise1 = resolve(1);
	      let promise2 = resolve(2);
	      let promise3 = resolve(3);
	      let promises = [ promise1, promise2, promise3 ];
	    
	      Promise.all(promises).then(function(array){
	        // The array here would be [ 1, 2, 3 ];
	      });
	      ```
	    
	      If any of the `promises` given to `all` are rejected, the first promise
	      that is rejected will be given as an argument to the returned promises's
	      rejection handler. For example:
	    
	      Example:
	    
	      ```javascript
	      let promise1 = resolve(1);
	      let promise2 = reject(new Error("2"));
	      let promise3 = reject(new Error("3"));
	      let promises = [ promise1, promise2, promise3 ];
	    
	      Promise.all(promises).then(function(array){
	        // Code here never runs because there are rejected promises!
	      }, function(error) {
	        // error.message === "2"
	      });
	      ```
	    
	      @method all
	      @static
	      @param {Array} entries array of promises
	      @param {String} label optional string for labeling the promise.
	      Useful for tooling.
	      @return {Promise} promise that is fulfilled when all `promises` have been
	      fulfilled, or rejected if any of them become rejected.
	      @static
	    */


	    function all(entries) {
	      return new Enumerator(this, entries).promise;
	    }
	    /**
	      `Promise.race` returns a new promise which is settled in the same way as the
	      first passed promise to settle.
	    
	      Example:
	    
	      ```javascript
	      let promise1 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          resolve('promise 1');
	        }, 200);
	      });
	    
	      let promise2 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          resolve('promise 2');
	        }, 100);
	      });
	    
	      Promise.race([promise1, promise2]).then(function(result){
	        // result === 'promise 2' because it was resolved before promise1
	        // was resolved.
	      });
	      ```
	    
	      `Promise.race` is deterministic in that only the state of the first
	      settled promise matters. For example, even if other promises given to the
	      `promises` array argument are resolved, but the first settled promise has
	      become rejected before the other promises became fulfilled, the returned
	      promise will become rejected:
	    
	      ```javascript
	      let promise1 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          resolve('promise 1');
	        }, 200);
	      });
	    
	      let promise2 = new Promise(function(resolve, reject){
	        setTimeout(function(){
	          reject(new Error('promise 2'));
	        }, 100);
	      });
	    
	      Promise.race([promise1, promise2]).then(function(result){
	        // Code here never runs
	      }, function(reason){
	        // reason.message === 'promise 2' because promise 2 became rejected before
	        // promise 1 became fulfilled
	      });
	      ```
	    
	      An example real-world use case is implementing timeouts:
	    
	      ```javascript
	      Promise.race([ajax('foo.json'), timeout(5000)])
	      ```
	    
	      @method race
	      @static
	      @param {Array} promises array of promises to observe
	      Useful for tooling.
	      @return {Promise} a promise which settles in the same way as the first passed
	      promise to settle.
	    */


	    function race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      if (!isArray(entries)) {
	        return new Constructor(function (_, reject) {
	          return reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function (resolve, reject) {
	          var length = entries.length;

	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    /**
	      `Promise.reject` returns a promise rejected with the passed `reason`.
	      It is shorthand for the following:
	    
	      ```javascript
	      let promise = new Promise(function(resolve, reject){
	        reject(new Error('WHOOPS'));
	      });
	    
	      promise.then(function(value){
	        // Code here doesn't run because the promise is rejected!
	      }, function(reason){
	        // reason.message === 'WHOOPS'
	      });
	      ```
	    
	      Instead of writing the above, your code now simply becomes the following:
	    
	      ```javascript
	      let promise = Promise.reject(new Error('WHOOPS'));
	    
	      promise.then(function(value){
	        // Code here doesn't run because the promise is rejected!
	      }, function(reason){
	        // reason.message === 'WHOOPS'
	      });
	      ```
	    
	      @method reject
	      @static
	      @param {Any} reason value that the returned promise will be rejected with.
	      Useful for tooling.
	      @return {Promise} a promise rejected with the given `reason`.
	    */


	    function reject$1(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(noop);
	      reject(promise, reason);
	      return promise;
	    }

	    function needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }

	    function needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	    
	      Terminology
	      -----------
	    
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	    
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	    
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	    
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	    
	    
	      Basic Usage:
	      ------------
	    
	      ```js
	      let promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	    
	        // on failure
	        reject(reason);
	      });
	    
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	    
	      Advanced Usage:
	      ---------------
	    
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	    
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          let xhr = new XMLHttpRequest();
	    
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	    
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	    
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	    
	      Unlike callbacks, promises are great composable primitives.
	    
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	    
	        return values;
	      });
	      ```
	    
	      @class Promise
	      @param {Function} resolver
	      Useful for tooling.
	      @constructor
	    */


	    var Promise$1 = function () {
	      function Promise(resolver) {
	        this[PROMISE_ID] = nextId();
	        this._result = this._state = undefined;
	        this._subscribers = [];

	        if (noop !== resolver) {
	          typeof resolver !== 'function' && needsResolver();
	          this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	        }
	      }
	      /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	       ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	       Chaining
	      --------
	       The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	       ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	       findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	       ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	       Assimilation
	      ------------
	       Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	       ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	       If the assimliated promise rejects, then the downstream promise will also reject.
	       ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	       Simple Example
	      --------------
	       Synchronous Example
	       ```javascript
	      let result;
	       try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	       Errback Example
	       ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	       Promise Example;
	       ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	       Advanced Example
	      --------------
	       Synchronous Example
	       ```javascript
	      let author, books;
	       try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	       Errback Example
	       ```js
	       function foundBooks(books) {
	       }
	       function failure(reason) {
	       }
	       findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	       Promise Example;
	       ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	       @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	      */

	      /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	      ```js
	      function findAuthor(){
	      throw new Error('couldn't find that author');
	      }
	      // synchronous
	      try {
	      findAuthor();
	      } catch(reason) {
	      // something went wrong
	      }
	      // async with promises
	      findAuthor().catch(function(reason){
	      // something went wrong
	      });
	      ```
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	      */


	      Promise.prototype.catch = function _catch(onRejection) {
	        return this.then(null, onRejection);
	      };
	      /**
	        `finally` will be invoked regardless of the promise's fate just as native
	        try/catch/finally behaves
	      
	        Synchronous example:
	      
	        ```js
	        findAuthor() {
	          if (Math.random() > 0.5) {
	            throw new Error();
	          }
	          return new Author();
	        }
	      
	        try {
	          return findAuthor(); // succeed or fail
	        } catch(error) {
	          return findOtherAuther();
	        } finally {
	          // always runs
	          // doesn't affect the return value
	        }
	        ```
	      
	        Asynchronous example:
	      
	        ```js
	        findAuthor().catch(function(reason){
	          return findOtherAuther();
	        }).finally(function(){
	          // author was either found, or not
	        });
	        ```
	      
	        @method finally
	        @param {Function} callback
	        @return {Promise}
	      */


	      Promise.prototype.finally = function _finally(callback) {
	        var promise = this;
	        var constructor = promise.constructor;

	        if (isFunction(callback)) {
	          return promise.then(function (value) {
	            return constructor.resolve(callback()).then(function () {
	              return value;
	            });
	          }, function (reason) {
	            return constructor.resolve(callback()).then(function () {
	              throw reason;
	            });
	          });
	        }

	        return promise.then(callback, callback);
	      };

	      return Promise;
	    }();

	    Promise$1.prototype.then = then;
	    Promise$1.all = all;
	    Promise$1.race = race;
	    Promise$1.resolve = resolve$1;
	    Promise$1.reject = reject$1;
	    Promise$1._setScheduler = setScheduler;
	    Promise$1._setAsap = setAsap;
	    Promise$1._asap = asap;
	    /*global self*/

	    function polyfill() {
	      var local = void 0;

	      if (typeof commonjsGlobal !== 'undefined') {
	        local = commonjsGlobal;
	      } else if (typeof self !== 'undefined') {
	        local = self;
	      } else {
	        try {
	          local = Function('return this')();
	        } catch (e) {
	          throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	      }

	      var P = local.Promise;

	      if (P) {
	        var promiseToString = null;

	        try {
	          promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {// silently ignored
	        }

	        if (promiseToString === '[object Promise]' && !P.cast) {
	          return;
	        }
	      }

	      local.Promise = Promise$1;
	    } // Strange compat..


	    Promise$1.polyfill = polyfill;
	    Promise$1.Promise = Promise$1;
	    return Promise$1;
	  });
	});

	var Promise$1 = typeof Promise !== "undefined" ? Promise : es6Promise;

	function registerLoggingCallbacks(obj) {
	  var i,
	      l,
	      key,
	      callbackNames = ["begin", "done", "log", "testStart", "testDone", "moduleStart", "moduleDone"];

	  function registerLoggingCallback(key) {
	    var loggingCallback = function loggingCallback(callback) {
	      if (objectType(callback) !== "function") {
	        throw new Error("QUnit logging methods require a callback function as their first parameters.");
	      }

	      config.callbacks[key].push(callback);
	    };

	    return loggingCallback;
	  }

	  for (i = 0, l = callbackNames.length; i < l; i++) {
	    key = callbackNames[i]; // Initialize key collection of logging callback

	    if (objectType(config.callbacks[key]) === "undefined") {
	      config.callbacks[key] = [];
	    }

	    obj[key] = registerLoggingCallback(key);
	  }
	}
	function runLoggingCallbacks(key, args) {
	  var callbacks = config.callbacks[key]; // Handling 'log' callbacks separately. Unlike the other callbacks,
	  // the log callback is not controlled by the processing queue,
	  // but rather used by asserts. Hence to promisfy the 'log' callback
	  // would mean promisfying each step of a test

	  if (key === "log") {
	    callbacks.map(function (callback) {
	      return callback(args);
	    });
	    return;
	  } // ensure that each callback is executed serially


	  return callbacks.reduce(function (promiseChain, callback) {
	    return promiseChain.then(function () {
	      return Promise$1.resolve(callback(args));
	    });
	  }, Promise$1.resolve([]));
	}

	// Doesn't support IE9, it will return undefined on these browsers
	// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack
	var fileName = (sourceFromStacktrace(0) || "").replace(/(:\d+)+\)?/, "").replace(/.+\//, "");
	function extractStacktrace(e, offset) {
	  offset = offset === undefined ? 4 : offset;
	  var stack, include, i;

	  if (e && e.stack) {
	    stack = e.stack.split("\n");

	    if (/^error$/i.test(stack[0])) {
	      stack.shift();
	    }

	    if (fileName) {
	      include = [];

	      for (i = offset; i < stack.length; i++) {
	        if (stack[i].indexOf(fileName) !== -1) {
	          break;
	        }

	        include.push(stack[i]);
	      }

	      if (include.length) {
	        return include.join("\n");
	      }
	    }

	    return stack[offset];
	  }
	}
	function sourceFromStacktrace(offset) {
	  var error = new Error(); // Support: Safari <=7 only, IE <=10 - 11 only
	  // Not all browsers generate the `stack` property for `new Error()`, see also #636

	  if (!error.stack) {
	    try {
	      throw error;
	    } catch (err) {
	      error = err;
	    }
	  }

	  return extractStacktrace(error, offset);
	}

	var priorityCount = 0;
	var unitSampler; // This is a queue of functions that are tasks within a single test.
	// After tests are dequeued from config.queue they are expanded into
	// a set of tasks in this queue.

	var taskQueue = [];
	/**
	 * Advances the taskQueue to the next task. If the taskQueue is empty,
	 * process the testQueue
	 */

	function advance() {
	  advanceTaskQueue();

	  if (!taskQueue.length && !config.blocking && !config.current) {
	    advanceTestQueue();
	  }
	}
	/**
	 * Advances the taskQueue with an increased depth
	 */


	function advanceTaskQueue() {
	  var start = now();
	  config.depth = (config.depth || 0) + 1;
	  processTaskQueue(start);
	  config.depth--;
	}
	/**
	 * Process the first task on the taskQueue as a promise.
	 * Each task is a function returned by https://github.com/qunitjs/qunit/blob/master/src/test.js#L381
	 */


	function processTaskQueue(start) {
	  if (taskQueue.length && !config.blocking) {
	    var elapsedTime = now() - start;

	    if (!defined.setTimeout || config.updateRate <= 0 || elapsedTime < config.updateRate) {
	      var task = taskQueue.shift();
	      Promise$1.resolve(task()).then(function () {
	        if (!taskQueue.length) {
	          advance();
	        } else {
	          processTaskQueue(start);
	        }
	      });
	    } else {
	      setTimeout$1(advance);
	    }
	  }
	}
	/**
	 * Advance the testQueue to the next test to process. Call done() if testQueue completes.
	 */


	function advanceTestQueue() {
	  if (!config.blocking && !config.queue.length && config.depth === 0) {
	    done();
	    return;
	  }

	  var testTasks = config.queue.shift();
	  addToTaskQueue(testTasks());

	  if (priorityCount > 0) {
	    priorityCount--;
	  }

	  advance();
	}
	/**
	 * Enqueue the tasks for a test into the task queue.
	 * @param {Array} tasksArray
	 */


	function addToTaskQueue(tasksArray) {
	  taskQueue.push.apply(taskQueue, _toConsumableArray(tasksArray));
	}
	/**
	 * Return the number of tasks remaining in the task queue to be processed.
	 * @return {Number}
	 */


	function taskQueueLength() {
	  return taskQueue.length;
	}
	/**
	 * Adds a test to the TestQueue for execution.
	 * @param {Function} testTasksFunc
	 * @param {Boolean} prioritize
	 * @param {String} seed
	 */


	function addToTestQueue(testTasksFunc, prioritize, seed) {
	  if (prioritize) {
	    config.queue.splice(priorityCount++, 0, testTasksFunc);
	  } else if (seed) {
	    if (!unitSampler) {
	      unitSampler = unitSamplerGenerator(seed);
	    } // Insert into a random position after all prioritized items


	    var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));
	    config.queue.splice(priorityCount + index, 0, testTasksFunc);
	  } else {
	    config.queue.push(testTasksFunc);
	  }
	}
	/**
	 * Creates a seeded "sample" generator which is used for randomizing tests.
	 */


	function unitSamplerGenerator(seed) {
	  // 32-bit xorshift, requires only a nonzero seed
	  // https://excamera.com/sphinx/article-xorshift.html
	  var sample = parseInt(generateHash(seed), 16) || -1;
	  return function () {
	    sample ^= sample << 13;
	    sample ^= sample >>> 17;
	    sample ^= sample << 5; // ECMAScript has no unsigned number type

	    if (sample < 0) {
	      sample += 0x100000000;
	    }

	    return sample / 0x100000000;
	  };
	}
	/**
	 * This function is called when the ProcessingQueue is done processing all
	 * items. It handles emitting the final run events.
	 */


	function done() {
	  var storage = config.storage;
	  ProcessingQueue.finished = true;
	  var runtime = now() - config.started;
	  var passed = config.stats.all - config.stats.bad;

	  if (config.stats.testCount === 0) {
	    if (config.filter && config.filter.length) {
	      throw new Error("No tests matched the filter \"".concat(config.filter, "\"."));
	    }

	    if (config.module && config.module.length) {
	      throw new Error("No tests matched the module \"".concat(config.module, "\"."));
	    }

	    if (config.moduleId && config.moduleId.length) {
	      throw new Error("No tests matched the moduleId \"".concat(config.moduleId, "\"."));
	    }

	    if (config.testId && config.testId.length) {
	      throw new Error("No tests matched the testId \"".concat(config.testId, "\"."));
	    }

	    throw new Error("No tests were run.");
	  }

	  emit("runEnd", globalSuite.end(true));
	  runLoggingCallbacks("done", {
	    passed: passed,
	    failed: config.stats.bad,
	    total: config.stats.all,
	    runtime: runtime
	  }).then(function () {
	    // Clear own storage items if all tests passed
	    if (storage && config.stats.bad === 0) {
	      for (var i = storage.length - 1; i >= 0; i--) {
	        var key = storage.key(i);

	        if (key.indexOf("qunit-test-") === 0) {
	          storage.removeItem(key);
	        }
	      }
	    }
	  });
	}

	var ProcessingQueue = {
	  finished: false,
	  add: addToTestQueue,
	  advance: advance,
	  taskCount: taskQueueLength
	};

	var TestReport = /*#__PURE__*/function () {
	  function TestReport(name, suite, options) {
	    _classCallCheck(this, TestReport);

	    this.name = name;
	    this.suiteName = suite.name;
	    this.fullName = suite.fullName.concat(name);
	    this.runtime = 0;
	    this.assertions = [];
	    this.skipped = !!options.skip;
	    this.todo = !!options.todo;
	    this.valid = options.valid;
	    this._startTime = 0;
	    this._endTime = 0;
	    suite.pushTest(this);
	  }

	  _createClass(TestReport, [{
	    key: "start",
	    value: function start(recordTime) {
	      if (recordTime) {
	        this._startTime = performanceNow();

	        if (performance) {
	          performance.mark("qunit_test_start");
	        }
	      }

	      return {
	        name: this.name,
	        suiteName: this.suiteName,
	        fullName: this.fullName.slice()
	      };
	    }
	  }, {
	    key: "end",
	    value: function end(recordTime) {
	      if (recordTime) {
	        this._endTime = performanceNow();

	        if (performance) {
	          performance.mark("qunit_test_end");
	          var testName = this.fullName.join(" – ");
	          measure("QUnit Test: ".concat(testName), "qunit_test_start", "qunit_test_end");
	        }
	      }

	      return extend(this.start(), {
	        runtime: this.getRuntime(),
	        status: this.getStatus(),
	        errors: this.getFailedAssertions(),
	        assertions: this.getAssertions()
	      });
	    }
	  }, {
	    key: "pushAssertion",
	    value: function pushAssertion(assertion) {
	      this.assertions.push(assertion);
	    }
	  }, {
	    key: "getRuntime",
	    value: function getRuntime() {
	      return this._endTime - this._startTime;
	    }
	  }, {
	    key: "getStatus",
	    value: function getStatus() {
	      if (this.skipped) {
	        return "skipped";
	      }

	      var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;

	      if (!testPassed) {
	        return "failed";
	      } else if (this.todo) {
	        return "todo";
	      } else {
	        return "passed";
	      }
	    }
	  }, {
	    key: "getFailedAssertions",
	    value: function getFailedAssertions() {
	      return this.assertions.filter(function (assertion) {
	        return !assertion.passed;
	      });
	    }
	  }, {
	    key: "getAssertions",
	    value: function getAssertions() {
	      return this.assertions.slice();
	    } // Remove actual and expected values from assertions. This is to prevent
	    // leaking memory throughout a test suite.

	  }, {
	    key: "slimAssertions",
	    value: function slimAssertions() {
	      this.assertions = this.assertions.map(function (assertion) {
	        delete assertion.actual;
	        delete assertion.expected;
	        return assertion;
	      });
	    }
	  }]);

	  return TestReport;
	}();

	var focused$1 = false;
	function Test(settings) {
	  var i, l;
	  ++Test.count;
	  this.expected = null;
	  this.assertions = [];
	  this.semaphore = 0;
	  this.module = config.currentModule;
	  this.steps = [];
	  this.timeout = undefined;
	  this.errorForStack = new Error(); // If a module is skipped, all its tests and the tests of the child suites
	  // should be treated as skipped even if they are defined as `only` or `todo`.
	  // As for `todo` module, all its tests will be treated as `todo` except for
	  // tests defined as `skip` which will be left intact.
	  //
	  // So, if a test is defined as `todo` and is inside a skipped module, we should
	  // then treat that test as if was defined as `skip`.

	  if (this.module.skip) {
	    settings.skip = true;
	    settings.todo = false; // Skipped tests should be left intact
	  } else if (this.module.todo && !settings.skip) {
	    settings.todo = true;
	  }

	  extend(this, settings);
	  this.testReport = new TestReport(settings.testName, this.module.suiteReport, {
	    todo: settings.todo,
	    skip: settings.skip,
	    valid: this.valid()
	  }); // Register unique strings

	  for (i = 0, l = this.module.tests; i < l.length; i++) {
	    if (this.module.tests[i].name === this.testName) {
	      this.testName += " ";
	    }
	  }

	  this.testId = generateHash(this.module.name, this.testName);
	  this.module.tests.push({
	    name: this.testName,
	    testId: this.testId,
	    skip: !!settings.skip
	  });

	  if (settings.skip) {
	    // Skipped tests will fully ignore any sent callback
	    this.callback = function () {};

	    this.async = false;
	    this.expected = 0;
	  } else {
	    if (typeof this.callback !== "function") {
	      var method = this.todo ? "todo" : "test"; // eslint-disable-next-line max-len

	      throw new TypeError("You must provide a function as a test callback to QUnit.".concat(method, "(\"").concat(settings.testName, "\")"));
	    }

	    this.assert = new Assert(this);
	  }
	}
	Test.count = 0;

	function getNotStartedModules(startModule) {
	  var module = startModule,
	      modules = [];

	  while (module && module.testsRun === 0) {
	    modules.push(module);
	    module = module.parentModule;
	  } // The above push modules from the child to the parent
	  // return a reversed order with the top being the top most parent module


	  return modules.reverse();
	}

	Test.prototype = {
	  // generating a stack trace can be expensive, so using a getter defers this until we need it
	  get stack() {
	    return extractStacktrace(this.errorForStack, 2);
	  },

	  before: function before() {
	    var _this = this;

	    var module = this.module,
	        notStartedModules = getNotStartedModules(module); // ensure the callbacks are executed serially for each module

	    var callbackPromises = notStartedModules.reduce(function (promiseChain, startModule) {
	      return promiseChain.then(function () {
	        startModule.stats = {
	          all: 0,
	          bad: 0,
	          started: now()
	        };
	        emit("suiteStart", startModule.suiteReport.start(true));
	        return runLoggingCallbacks("moduleStart", {
	          name: startModule.name,
	          tests: startModule.tests
	        });
	      });
	    }, Promise$1.resolve([]));
	    return callbackPromises.then(function () {
	      config.current = _this;
	      _this.testEnvironment = extend({}, module.testEnvironment);
	      _this.started = now();
	      emit("testStart", _this.testReport.start(true));
	      return runLoggingCallbacks("testStart", {
	        name: _this.testName,
	        module: module.name,
	        testId: _this.testId,
	        previousFailure: _this.previousFailure
	      }).then(function () {
	        if (!config.pollution) {
	          saveGlobal();
	        }
	      });
	    });
	  },
	  run: function run() {
	    var promise;
	    config.current = this;
	    this.callbackStarted = now();

	    if (config.notrycatch) {
	      runTest(this);
	      return;
	    }

	    try {
	      runTest(this);
	    } catch (e) {
	      this.pushFailure("Died on test #" + (this.assertions.length + 1) + " " + this.stack + ": " + (e.message || e), extractStacktrace(e, 0)); // Else next test will carry the responsibility

	      saveGlobal(); // Restart the tests if they're blocking

	      if (config.blocking) {
	        internalRecover(this);
	      }
	    }

	    function runTest(test) {
	      promise = test.callback.call(test.testEnvironment, test.assert);
	      test.resolvePromise(promise); // If the test has a "lock" on it, but the timeout is 0, then we push a
	      // failure as the test should be synchronous.

	      if (test.timeout === 0 && test.semaphore !== 0) {
	        pushFailure("Test did not finish synchronously even though assert.timeout( 0 ) was used.", sourceFromStacktrace(2));
	      }
	    }
	  },
	  after: function after() {
	    checkPollution();
	  },
	  queueHook: function queueHook(hook, hookName, hookOwner) {
	    var _this2 = this;

	    var callHook = function callHook() {
	      var promise = hook.call(_this2.testEnvironment, _this2.assert);

	      _this2.resolvePromise(promise, hookName);
	    };

	    var runHook = function runHook() {
	      if (hookName === "before") {
	        if (hookOwner.unskippedTestsRun !== 0) {
	          return;
	        }

	        _this2.preserveEnvironment = true;
	      } // The 'after' hook should only execute when there are not tests left and
	      // when the 'after' and 'finish' tasks are the only tasks left to process


	      if (hookName === "after" && hookOwner.unskippedTestsRun !== numberOfUnskippedTests(hookOwner) - 1 && (config.queue.length > 0 || ProcessingQueue.taskCount() > 2)) {
	        return;
	      }

	      config.current = _this2;

	      if (config.notrycatch) {
	        callHook();
	        return;
	      }

	      try {
	        callHook();
	      } catch (error) {
	        _this2.pushFailure(hookName + " failed on " + _this2.testName + ": " + (error.message || error), extractStacktrace(error, 0));
	      }
	    };

	    return runHook;
	  },
	  // Currently only used for module level hooks, can be used to add global level ones
	  hooks: function hooks(handler) {
	    var hooks = [];

	    function processHooks(test, module) {
	      if (module.parentModule) {
	        processHooks(test, module.parentModule);
	      }

	      if (module.hooks[handler].length) {
	        for (var i = 0; i < module.hooks[handler].length; i++) {
	          hooks.push(test.queueHook(module.hooks[handler][i], handler, module));
	        }
	      }
	    } // Hooks are ignored on skipped tests


	    if (!this.skip) {
	      processHooks(this, this.module);
	    }

	    return hooks;
	  },
	  finish: function finish() {
	    config.current = this; // Release the test callback to ensure that anything referenced has been
	    // released to be garbage collected.

	    this.callback = undefined;

	    if (this.steps.length) {
	      var stepsList = this.steps.join(", ");
	      this.pushFailure("Expected assert.verifySteps() to be called before end of test " + "after using assert.step(). Unverified steps: ".concat(stepsList), this.stack);
	    }

	    if (config.requireExpects && this.expected === null) {
	      this.pushFailure("Expected number of assertions to be defined, but expect() was " + "not called.", this.stack);
	    } else if (this.expected !== null && this.expected !== this.assertions.length) {
	      this.pushFailure("Expected " + this.expected + " assertions, but " + this.assertions.length + " were run", this.stack);
	    } else if (this.expected === null && !this.assertions.length) {
	      this.pushFailure("Expected at least one assertion, but none were run - call " + "expect(0) to accept zero assertions.", this.stack);
	    }

	    var i,
	        module = this.module,
	        moduleName = module.name,
	        testName = this.testName,
	        skipped = !!this.skip,
	        todo = !!this.todo,
	        bad = 0,
	        storage = config.storage;
	    this.runtime = now() - this.started;
	    config.stats.all += this.assertions.length;
	    config.stats.testCount += 1;
	    module.stats.all += this.assertions.length;

	    for (i = 0; i < this.assertions.length; i++) {
	      if (!this.assertions[i].result) {
	        bad++;
	        config.stats.bad++;
	        module.stats.bad++;
	      }
	    }

	    notifyTestsRan(module, skipped); // Store result when possible

	    if (storage) {
	      if (bad) {
	        storage.setItem("qunit-test-" + moduleName + "-" + testName, bad);
	      } else {
	        storage.removeItem("qunit-test-" + moduleName + "-" + testName);
	      }
	    } // After emitting the js-reporters event we cleanup the assertion data to
	    // avoid leaking it. It is not used by the legacy testDone callbacks.


	    emit("testEnd", this.testReport.end(true));
	    this.testReport.slimAssertions();
	    var test = this;
	    return runLoggingCallbacks("testDone", {
	      name: testName,
	      module: moduleName,
	      skipped: skipped,
	      todo: todo,
	      failed: bad,
	      passed: this.assertions.length - bad,
	      total: this.assertions.length,
	      runtime: skipped ? 0 : this.runtime,
	      // HTML Reporter use
	      assertions: this.assertions,
	      testId: this.testId,

	      // Source of Test
	      // generating stack trace is expensive, so using a getter will help defer this until we need it
	      get source() {
	        return test.stack;
	      }

	    }).then(function () {
	      if (module.testsRun === numberOfTests(module)) {
	        var completedModules = [module]; // Check if the parent modules, iteratively, are done. If that the case,
	        // we emit the `suiteEnd` event and trigger `moduleDone` callback.

	        var parent = module.parentModule;

	        while (parent && parent.testsRun === numberOfTests(parent)) {
	          completedModules.push(parent);
	          parent = parent.parentModule;
	        }

	        return completedModules.reduce(function (promiseChain, completedModule) {
	          return promiseChain.then(function () {
	            return logSuiteEnd(completedModule);
	          });
	        }, Promise$1.resolve([]));
	      }
	    }).then(function () {
	      config.current = undefined;
	    });

	    function logSuiteEnd(module) {
	      // Reset `module.hooks` to ensure that anything referenced in these hooks
	      // has been released to be garbage collected.
	      module.hooks = {};
	      emit("suiteEnd", module.suiteReport.end(true));
	      return runLoggingCallbacks("moduleDone", {
	        name: module.name,
	        tests: module.tests,
	        failed: module.stats.bad,
	        passed: module.stats.all - module.stats.bad,
	        total: module.stats.all,
	        runtime: now() - module.stats.started
	      });
	    }
	  },
	  preserveTestEnvironment: function preserveTestEnvironment() {
	    if (this.preserveEnvironment) {
	      this.module.testEnvironment = this.testEnvironment;
	      this.testEnvironment = extend({}, this.module.testEnvironment);
	    }
	  },
	  queue: function queue() {
	    var test = this;

	    if (!this.valid()) {
	      return;
	    }

	    function runTest() {
	      return [function () {
	        return test.before();
	      }].concat(_toConsumableArray(test.hooks("before")), [function () {
	        test.preserveTestEnvironment();
	      }], _toConsumableArray(test.hooks("beforeEach")), [function () {
	        test.run();
	      }], _toConsumableArray(test.hooks("afterEach").reverse()), _toConsumableArray(test.hooks("after").reverse()), [function () {
	        test.after();
	      }, function () {
	        return test.finish();
	      }]);
	    }

	    var previousFailCount = config.storage && +config.storage.getItem("qunit-test-" + this.module.name + "-" + this.testName); // Prioritize previously failed tests, detected from storage

	    var prioritize = config.reorder && !!previousFailCount;
	    this.previousFailure = !!previousFailCount;
	    ProcessingQueue.add(runTest, prioritize, config.seed); // If the queue has already finished, we manually process the new test

	    if (ProcessingQueue.finished) {
	      ProcessingQueue.advance();
	    }
	  },
	  pushResult: function pushResult(resultInfo) {
	    if (this !== config.current) {
	      throw new Error("Assertion occurred after test had finished.");
	    } // Destructure of resultInfo = { result, actual, expected, message, negative }


	    var source,
	        details = {
	      module: this.module.name,
	      name: this.testName,
	      result: resultInfo.result,
	      message: resultInfo.message,
	      actual: resultInfo.actual,
	      testId: this.testId,
	      negative: resultInfo.negative || false,
	      runtime: now() - this.started,
	      todo: !!this.todo
	    };

	    if (hasOwn.call(resultInfo, "expected")) {
	      details.expected = resultInfo.expected;
	    }

	    if (!resultInfo.result) {
	      source = resultInfo.source || sourceFromStacktrace();

	      if (source) {
	        details.source = source;
	      }
	    }

	    this.logAssertion(details);
	    this.assertions.push({
	      result: !!resultInfo.result,
	      message: resultInfo.message
	    });
	  },
	  pushFailure: function pushFailure(message, source, actual) {
	    if (!(this instanceof Test)) {
	      throw new Error("pushFailure() assertion outside test context, was " + sourceFromStacktrace(2));
	    }

	    this.pushResult({
	      result: false,
	      message: message || "error",
	      actual: actual || null,
	      source: source
	    });
	  },

	  /**
	   * Log assertion details using both the old QUnit.log interface and
	   * QUnit.on( "assertion" ) interface.
	   *
	   * @private
	   */
	  logAssertion: function logAssertion(details) {
	    runLoggingCallbacks("log", details);
	    var assertion = {
	      passed: details.result,
	      actual: details.actual,
	      expected: details.expected,
	      message: details.message,
	      stack: details.source,
	      todo: details.todo
	    };
	    this.testReport.pushAssertion(assertion);
	    emit("assertion", assertion);
	  },
	  resolvePromise: function resolvePromise(promise, phase) {
	    var then,
	        resume,
	        message,
	        test = this;

	    if (promise != null) {
	      then = promise.then;

	      if (objectType(then) === "function") {
	        resume = internalStop(test);

	        if (config.notrycatch) {
	          then.call(promise, function () {
	            resume();
	          });
	        } else {
	          then.call(promise, function () {
	            resume();
	          }, function (error) {
	            message = "Promise rejected " + (!phase ? "during" : phase.replace(/Each$/, "")) + " \"" + test.testName + "\": " + (error && error.message || error);
	            test.pushFailure(message, extractStacktrace(error, 0)); // Else next test will carry the responsibility

	            saveGlobal(); // Unblock

	            internalRecover(test);
	          });
	        }
	      }
	    }
	  },
	  valid: function valid() {
	    var filter = config.filter,
	        regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec(filter),
	        module = config.module && config.module.toLowerCase(),
	        fullName = this.module.name + ": " + this.testName;

	    function moduleChainNameMatch(testModule) {
	      var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;

	      if (testModuleName === module) {
	        return true;
	      } else if (testModule.parentModule) {
	        return moduleChainNameMatch(testModule.parentModule);
	      } else {
	        return false;
	      }
	    }

	    function moduleChainIdMatch(testModule) {
	      return inArray(testModule.moduleId, config.moduleId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule);
	    } // Internally-generated tests are always valid


	    if (this.callback && this.callback.validTest) {
	      return true;
	    }

	    if (config.moduleId && config.moduleId.length > 0 && !moduleChainIdMatch(this.module)) {
	      return false;
	    }

	    if (config.testId && config.testId.length > 0 && !inArray(this.testId, config.testId)) {
	      return false;
	    }

	    if (module && !moduleChainNameMatch(this.module)) {
	      return false;
	    }

	    if (!filter) {
	      return true;
	    }

	    return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);
	  },
	  regexFilter: function regexFilter(exclude, pattern, flags, fullName) {
	    var regex = new RegExp(pattern, flags);
	    var match = regex.test(fullName);
	    return match !== exclude;
	  },
	  stringFilter: function stringFilter(filter, fullName) {
	    filter = filter.toLowerCase();
	    fullName = fullName.toLowerCase();
	    var include = filter.charAt(0) !== "!";

	    if (!include) {
	      filter = filter.slice(1);
	    } // If the filter matches, we need to honour include


	    if (fullName.indexOf(filter) !== -1) {
	      return include;
	    } // Otherwise, do the opposite


	    return !include;
	  }
	};
	function pushFailure() {
	  if (!config.current) {
	    throw new Error("pushFailure() assertion outside test context, in " + sourceFromStacktrace(2));
	  } // Gets current test obj


	  var currentTest = config.current;
	  return currentTest.pushFailure.apply(currentTest, arguments);
	}

	function saveGlobal() {
	  config.pollution = [];

	  if (config.noglobals) {
	    for (var key in global__default['default']) {
	      if (hasOwn.call(global__default['default'], key)) {
	        // In Opera sometimes DOM element ids show up here, ignore them
	        if (/^qunit-test-output/.test(key)) {
	          continue;
	        }

	        config.pollution.push(key);
	      }
	    }
	  }
	}

	function checkPollution() {
	  var newGlobals,
	      deletedGlobals,
	      old = config.pollution;
	  saveGlobal();
	  newGlobals = diff(config.pollution, old);

	  if (newGlobals.length > 0) {
	    pushFailure("Introduced global variable(s): " + newGlobals.join(", "));
	  }

	  deletedGlobals = diff(old, config.pollution);

	  if (deletedGlobals.length > 0) {
	    pushFailure("Deleted global variable(s): " + deletedGlobals.join(", "));
	  }
	} // Will be exposed as QUnit.test


	function test(testName, callback) {
	  if (focused$1) {
	    return;
	  }

	  var newTest = new Test({
	    testName: testName,
	    callback: callback
	  });
	  newTest.queue();
	}
	function todo(testName, callback) {
	  if (focused$1) {
	    return;
	  }

	  var newTest = new Test({
	    testName: testName,
	    callback: callback,
	    todo: true
	  });
	  newTest.queue();
	} // Will be exposed as QUnit.skip

	function skip(testName) {
	  if (focused$1) {
	    return;
	  }

	  var test = new Test({
	    testName: testName,
	    skip: true
	  });
	  test.queue();
	} // Will be exposed as QUnit.only

	function only(testName, callback) {
	  if (!focused$1) {
	    config.queue.length = 0;
	    focused$1 = true;
	  }

	  var newTest = new Test({
	    testName: testName,
	    callback: callback
	  });
	  newTest.queue();
	} // Resets config.timeout with a new timeout duration.

	function resetTestTimeout(timeoutDuration) {
	  clearTimeout(config.timeout);
	  config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);
	} // Put a hold on processing and return a function that will release it.

	function internalStop(test) {
	  var released = false;
	  test.semaphore += 1;
	  config.blocking = true; // Set a recovery timeout, if so configured.

	  if (defined.setTimeout) {
	    var timeoutDuration;

	    if (typeof test.timeout === "number") {
	      timeoutDuration = test.timeout;
	    } else if (typeof config.testTimeout === "number") {
	      timeoutDuration = config.testTimeout;
	    }

	    if (typeof timeoutDuration === "number" && timeoutDuration > 0) {
	      clearTimeout(config.timeout);

	      config.timeoutHandler = function (timeout) {
	        return function () {
	          pushFailure("Test took longer than ".concat(timeout, "ms; test timed out."), sourceFromStacktrace(2));
	          released = true;
	          internalRecover(test);
	        };
	      };

	      config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);
	    }
	  }

	  return function resume() {
	    if (released) {
	      return;
	    }

	    released = true;
	    test.semaphore -= 1;
	    internalStart(test);
	  };
	} // Forcefully release all processing holds.

	function internalRecover(test) {
	  test.semaphore = 0;
	  internalStart(test);
	} // Release a processing hold, scheduling a resumption attempt if no holds remain.


	function internalStart(test) {
	  // If semaphore is non-numeric, throw error
	  if (isNaN(test.semaphore)) {
	    test.semaphore = 0;
	    pushFailure("Invalid value on test.semaphore", sourceFromStacktrace(2));
	    return;
	  } // Don't start until equal number of stop-calls


	  if (test.semaphore > 0) {
	    return;
	  } // Throw an Error if start is called more often than stop


	  if (test.semaphore < 0) {
	    test.semaphore = 0;
	    pushFailure("Tried to restart test while already started (test's semaphore was 0 already)", sourceFromStacktrace(2));
	    return;
	  } // Add a slight delay to allow more assertions etc.


	  if (defined.setTimeout) {
	    if (config.timeout) {
	      clearTimeout(config.timeout);
	    }

	    config.timeout = setTimeout$1(function () {
	      if (test.semaphore > 0) {
	        return;
	      }

	      if (config.timeout) {
	        clearTimeout(config.timeout);
	      }

	      begin();
	    });
	  } else {
	    begin();
	  }
	}

	function collectTests(module) {
	  var tests = [].concat(module.tests);

	  var modules = _toConsumableArray(module.childModules); // Do a breadth-first traversal of the child modules


	  while (modules.length) {
	    var nextModule = modules.shift();
	    tests.push.apply(tests, nextModule.tests);
	    modules.push.apply(modules, _toConsumableArray(nextModule.childModules));
	  }

	  return tests;
	}

	function numberOfTests(module) {
	  return collectTests(module).length;
	}

	function numberOfUnskippedTests(module) {
	  return collectTests(module).filter(function (test) {
	    return !test.skip;
	  }).length;
	}

	function notifyTestsRan(module, skipped) {
	  module.testsRun++;

	  if (!skipped) {
	    module.unskippedTestsRun++;
	  }

	  while (module = module.parentModule) {
	    module.testsRun++;

	    if (!skipped) {
	      module.unskippedTestsRun++;
	    }
	  }
	}

	var Assert = /*#__PURE__*/function () {
	  function Assert(testContext) {
	    _classCallCheck(this, Assert);

	    this.test = testContext;
	  } // Assert helpers


	  _createClass(Assert, [{
	    key: "timeout",
	    value: function timeout(duration) {
	      if (typeof duration !== "number") {
	        throw new Error("You must pass a number as the duration to assert.timeout");
	      }

	      this.test.timeout = duration; // If a timeout has been set, clear it and reset with the new duration

	      if (config.timeout) {
	        clearTimeout(config.timeout);

	        if (config.timeoutHandler && this.test.timeout > 0) {
	          resetTestTimeout(this.test.timeout);
	        }
	      }
	    } // Documents a "step", which is a string value, in a test as a passing assertion

	  }, {
	    key: "step",
	    value: function step(message) {
	      var assertionMessage = message;
	      var result = !!message;
	      this.test.steps.push(message);

	      if (objectType(message) === "undefined" || message === "") {
	        assertionMessage = "You must provide a message to assert.step";
	      } else if (objectType(message) !== "string") {
	        assertionMessage = "You must provide a string value to assert.step";
	        result = false;
	      }

	      this.pushResult({
	        result: result,
	        message: assertionMessage
	      });
	    } // Verifies the steps in a test match a given array of string values

	  }, {
	    key: "verifySteps",
	    value: function verifySteps(steps, message) {
	      // Since the steps array is just string values, we can clone with slice
	      var actualStepsClone = this.test.steps.slice();
	      this.deepEqual(actualStepsClone, steps, message);
	      this.test.steps.length = 0;
	    } // Specify the number of expected assertions to guarantee that failed test
	    // (no assertions are run at all) don't slip through.

	  }, {
	    key: "expect",
	    value: function expect(asserts) {
	      if (arguments.length === 1) {
	        this.test.expected = asserts;
	      } else {
	        return this.test.expected;
	      }
	    } // Put a hold on processing and return a function that will release it a maximum of once.

	  }, {
	    key: "async",
	    value: function async(count) {
	      var test = this.test;
	      var popped = false,
	          acceptCallCount = count;

	      if (typeof acceptCallCount === "undefined") {
	        acceptCallCount = 1;
	      }

	      var resume = internalStop(test);
	      return function done() {
	        if (config.current !== test) {
	          throw Error("assert.async callback called after test finished.");
	        }

	        if (popped) {
	          test.pushFailure("Too many calls to the `assert.async` callback", sourceFromStacktrace(2));
	          return;
	        }

	        acceptCallCount -= 1;

	        if (acceptCallCount > 0) {
	          return;
	        }

	        popped = true;
	        resume();
	      };
	    } // Exports test.push() to the user API
	    // Alias of pushResult.

	  }, {
	    key: "push",
	    value: function push(result, actual, expected, message, negative) {
	      Logger.warn("assert.push is deprecated and will be removed in QUnit 3.0." + " Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).");
	      var currentAssert = this instanceof Assert ? this : config.current.assert;
	      return currentAssert.pushResult({
	        result: result,
	        actual: actual,
	        expected: expected,
	        message: message,
	        negative: negative
	      });
	    }
	  }, {
	    key: "pushResult",
	    value: function pushResult(resultInfo) {
	      // Destructure of resultInfo = { result, actual, expected, message, negative }
	      var assert = this;
	      var currentTest = assert instanceof Assert && assert.test || config.current; // Backwards compatibility fix.
	      // Allows the direct use of global exported assertions and QUnit.assert.*
	      // Although, it's use is not recommended as it can leak assertions
	      // to other tests from async tests, because we only get a reference to the current test,
	      // not exactly the test where assertion were intended to be called.

	      if (!currentTest) {
	        throw new Error("assertion outside test context, in " + sourceFromStacktrace(2));
	      }

	      if (!(assert instanceof Assert)) {
	        assert = currentTest.assert;
	      }

	      return assert.test.pushResult(resultInfo);
	    }
	  }, {
	    key: "ok",
	    value: function ok(result, message) {
	      if (!message) {
	        message = result ? "okay" : "failed, expected argument to be truthy, was: ".concat(dump.parse(result));
	      }

	      this.pushResult({
	        result: !!result,
	        actual: result,
	        expected: true,
	        message: message
	      });
	    }
	  }, {
	    key: "notOk",
	    value: function notOk(result, message) {
	      if (!message) {
	        message = !result ? "okay" : "failed, expected argument to be falsy, was: ".concat(dump.parse(result));
	      }

	      this.pushResult({
	        result: !result,
	        actual: result,
	        expected: false,
	        message: message
	      });
	    }
	  }, {
	    key: "true",
	    value: function _true(result, message) {
	      this.pushResult({
	        result: result === true,
	        actual: result,
	        expected: true,
	        message: message
	      });
	    }
	  }, {
	    key: "false",
	    value: function _false(result, message) {
	      this.pushResult({
	        result: result === false,
	        actual: result,
	        expected: false,
	        message: message
	      });
	    }
	  }, {
	    key: "equal",
	    value: function equal(actual, expected, message) {
	      // eslint-disable-next-line eqeqeq
	      var result = expected == actual;
	      this.pushResult({
	        result: result,
	        actual: actual,
	        expected: expected,
	        message: message
	      });
	    }
	  }, {
	    key: "notEqual",
	    value: function notEqual(actual, expected, message) {
	      // eslint-disable-next-line eqeqeq
	      var result = expected != actual;
	      this.pushResult({
	        result: result,
	        actual: actual,
	        expected: expected,
	        message: message,
	        negative: true
	      });
	    }
	  }, {
	    key: "propEqual",
	    value: function propEqual(actual, expected, message) {
	      actual = objectValues(actual);
	      expected = objectValues(expected);
	      this.pushResult({
	        result: equiv(actual, expected),
	        actual: actual,
	        expected: expected,
	        message: message
	      });
	    }
	  }, {
	    key: "notPropEqual",
	    value: function notPropEqual(actual, expected, message) {
	      actual = objectValues(actual);
	      expected = objectValues(expected);
	      this.pushResult({
	        result: !equiv(actual, expected),
	        actual: actual,
	        expected: expected,
	        message: message,
	        negative: true
	      });
	    }
	  }, {
	    key: "deepEqual",
	    value: function deepEqual(actual, expected, message) {
	      this.pushResult({
	        result: equiv(actual, expected),
	        actual: actual,
	        expected: expected,
	        message: message
	      });
	    }
	  }, {
	    key: "notDeepEqual",
	    value: function notDeepEqual(actual, expected, message) {
	      this.pushResult({
	        result: !equiv(actual, expected),
	        actual: actual,
	        expected: expected,
	        message: message,
	        negative: true
	      });
	    }
	  }, {
	    key: "strictEqual",
	    value: function strictEqual(actual, expected, message) {
	      this.pushResult({
	        result: expected === actual,
	        actual: actual,
	        expected: expected,
	        message: message
	      });
	    }
	  }, {
	    key: "notStrictEqual",
	    value: function notStrictEqual(actual, expected, message) {
	      this.pushResult({
	        result: expected !== actual,
	        actual: actual,
	        expected: expected,
	        message: message,
	        negative: true
	      });
	    }
	  }, {
	    key: "throws",
	    value: function throws(block, expected, message) {
	      var actual,
	          result = false;
	      var currentTest = this instanceof Assert && this.test || config.current; // 'expected' is optional unless doing string comparison

	      if (objectType(expected) === "string") {
	        if (message == null) {
	          message = expected;
	          expected = null;
	        } else {
	          throw new Error("throws/raises does not accept a string value for the expected argument.\n" + "Use a non-string object value (e.g. regExp) instead if it's necessary.");
	        }
	      }

	      currentTest.ignoreGlobalErrors = true;

	      try {
	        block.call(currentTest.testEnvironment);
	      } catch (e) {
	        actual = e;
	      }

	      currentTest.ignoreGlobalErrors = false;

	      if (actual) {
	        var expectedType = objectType(expected); // We don't want to validate thrown error

	        if (!expected) {
	          result = true; // Expected is a regexp
	        } else if (expectedType === "regexp") {
	          result = expected.test(errorString(actual)); // Log the string form of the regexp

	          expected = String(expected); // Expected is a constructor, maybe an Error constructor
	        } else if (expectedType === "function" && actual instanceof expected) {
	          result = true; // Expected is an Error object
	        } else if (expectedType === "object") {
	          result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message; // Log the string form of the Error object

	          expected = errorString(expected); // Expected is a validation function which returns true if validation passed
	        } else if (expectedType === "function" && expected.call({}, actual) === true) {
	          expected = null;
	          result = true;
	        }
	      }

	      currentTest.assert.pushResult({
	        result: result,
	        // undefined if it didn't throw
	        actual: actual && errorString(actual),
	        expected: expected,
	        message: message
	      });
	    }
	  }, {
	    key: "rejects",
	    value: function rejects(promise, expected, message) {
	      var result = false;
	      var currentTest = this instanceof Assert && this.test || config.current; // 'expected' is optional unless doing string comparison

	      if (objectType(expected) === "string") {
	        if (message === undefined) {
	          message = expected;
	          expected = undefined;
	        } else {
	          message = "assert.rejects does not accept a string value for the expected " + "argument.\nUse a non-string object value (e.g. validator function) instead " + "if necessary.";
	          currentTest.assert.pushResult({
	            result: false,
	            message: message
	          });
	          return;
	        }
	      }

	      var then = promise && promise.then;

	      if (objectType(then) !== "function") {
	        var _message = "The value provided to `assert.rejects` in " + "\"" + currentTest.testName + "\" was not a promise.";

	        currentTest.assert.pushResult({
	          result: false,
	          message: _message,
	          actual: promise
	        });
	        return;
	      }

	      var done = this.async();
	      return then.call(promise, function handleFulfillment() {
	        var message = "The promise returned by the `assert.rejects` callback in " + "\"" + currentTest.testName + "\" did not reject.";
	        currentTest.assert.pushResult({
	          result: false,
	          message: message,
	          actual: promise
	        });
	        done();
	      }, function handleRejection(actual) {
	        var expectedType = objectType(expected); // We don't want to validate

	        if (expected === undefined) {
	          result = true; // Expected is a regexp
	        } else if (expectedType === "regexp") {
	          result = expected.test(errorString(actual)); // Log the string form of the regexp

	          expected = String(expected); // Expected is a constructor, maybe an Error constructor
	        } else if (expectedType === "function" && actual instanceof expected) {
	          result = true; // Expected is an Error object
	        } else if (expectedType === "object") {
	          result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message; // Log the string form of the Error object

	          expected = errorString(expected); // Expected is a validation function which returns true if validation passed
	        } else {
	          if (expectedType === "function") {
	            result = expected.call({}, actual) === true;
	            expected = null; // Expected is some other invalid type
	          } else {
	            result = false;
	            message = "invalid expected value provided to `assert.rejects` " + "callback in \"" + currentTest.testName + "\": " + expectedType + ".";
	          }
	        }

	        currentTest.assert.pushResult({
	          result: result,
	          // leave rejection value of undefined as-is
	          actual: actual && errorString(actual),
	          expected: expected,
	          message: message
	        });
	        done();
	      });
	    }
	  }]);

	  return Assert;
	}(); // Provide an alternative to assert.throws(), for environments that consider throws a reserved word
	// Known to us are: Closure Compiler, Narwhal
	// eslint-disable-next-line dot-notation


	Assert.prototype.raises = Assert.prototype["throws"];
	/**
	 * Converts an error into a simple string for comparisons.
	 *
	 * @param {Error|Object} error
	 * @return {String}
	 */

	function errorString(error) {
	  var resultErrorString = error.toString(); // If the error wasn't a subclass of Error but something like
	  // an object literal with name and message properties...

	  if (resultErrorString.substring(0, 7) === "[object") {
	    var name = error.name ? error.name.toString() : "Error";
	    var message = error.message ? error.message.toString() : "";

	    if (name && message) {
	      return "".concat(name, ": ").concat(message);
	    } else if (name) {
	      return name;
	    } else if (message) {
	      return message;
	    } else {
	      return "Error";
	    }
	  } else {
	    return resultErrorString;
	  }
	}

	/* global module, exports, define */
	function exportQUnit(QUnit) {
	  if (defined.document) {
	    // QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.
	    if (window$1.QUnit && window$1.QUnit.version) {
	      throw new Error("QUnit has already been defined.");
	    }

	    window$1.QUnit = QUnit;
	  } // For nodejs


	  if (typeof module !== "undefined" && module && module.exports) {
	    module.exports = QUnit; // For consistency with CommonJS environments' exports

	    module.exports.QUnit = QUnit;
	  } // For CommonJS with exports, but without module.exports, like Rhino


	  if (typeof exports !== "undefined" && exports) {
	    exports.QUnit = QUnit;
	  }

	  if (typeof define === "function" && define.amd) {
	    define(function () {
	      return QUnit;
	    });
	    QUnit.config.autostart = false;
	  } // For Web/Service Workers


	  if (self$1 && self$1.WorkerGlobalScope && self$1 instanceof self$1.WorkerGlobalScope) {
	    self$1.QUnit = QUnit;
	  }
	}

	// error handling should be suppressed and false otherwise.
	// In this case, we will only suppress further error handling if the
	// "ignoreGlobalErrors" configuration option is enabled.

	function onError(error) {
	  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }

	  if (config.current) {
	    if (config.current.ignoreGlobalErrors) {
	      return true;
	    }

	    pushFailure.apply(void 0, [error.message, error.stacktrace || error.fileName + ":" + error.lineNumber].concat(args));
	  } else {
	    test("global failure", extend(function () {
	      pushFailure.apply(void 0, [error.message, error.stacktrace || error.fileName + ":" + error.lineNumber].concat(args));
	    }, {
	      validTest: true
	    }));
	  }

	  return false;
	}

	function onUnhandledRejection(reason) {
	  var resultInfo = {
	    result: false,
	    message: reason.message || "error",
	    actual: reason,
	    source: reason.stack || sourceFromStacktrace(3)
	  };
	  var currentTest = config.current;

	  if (currentTest) {
	    currentTest.assert.pushResult(resultInfo);
	  } else {
	    test("global failure", extend(function (assert) {
	      assert.pushResult(resultInfo);
	    }, {
	      validTest: true
	    }));
	  }
	}

	var QUnit = {};
	var globalSuite = new SuiteReport(); // The initial "currentModule" represents the global (or top-level) module that
	// is not explicitly defined by the user, therefore we add the "globalSuite" to
	// it since each module has a suiteReport associated with it.

	config.currentModule.suiteReport = globalSuite;
	var globalStartCalled = false;
	var runStarted = false; // Figure out if we're running the tests from a server or not

	QUnit.isLocal = !(defined.document && window$1.location.protocol !== "file:"); // Expose the current QUnit version

	QUnit.version = "2.11.3";
	extend(QUnit, {
	  on: on,
	  module: module$1,
	  test: test,
	  todo: todo,
	  skip: skip,
	  only: only,
	  start: function start(count) {
	    var globalStartAlreadyCalled = globalStartCalled;

	    if (!config.current) {
	      globalStartCalled = true;

	      if (runStarted) {
	        throw new Error("Called start() while test already started running");
	      } else if (globalStartAlreadyCalled || count > 1) {
	        throw new Error("Called start() outside of a test context too many times");
	      } else if (config.autostart) {
	        throw new Error("Called start() outside of a test context when " + "QUnit.config.autostart was true");
	      } else if (!config.pageLoaded) {
	        // The page isn't completely loaded yet, so we set autostart and then
	        // load if we're in Node or wait for the browser's load event.
	        config.autostart = true; // Starts from Node even if .load was not previously called. We still return
	        // early otherwise we'll wind up "beginning" twice.

	        if (!defined.document) {
	          QUnit.load();
	        }

	        return;
	      }
	    } else {
	      throw new Error("QUnit.start cannot be called inside a test context.");
	    }

	    scheduleBegin();
	  },
	  config: config,
	  is: is,
	  objectType: objectType,
	  extend: extend,
	  load: function load() {
	    config.pageLoaded = true; // Initialize the configuration options

	    extend(config, {
	      stats: {
	        all: 0,
	        bad: 0,
	        testCount: 0
	      },
	      started: 0,
	      updateRate: 1000,
	      autostart: true,
	      filter: ""
	    }, true);

	    if (!runStarted) {
	      config.blocking = false;

	      if (config.autostart) {
	        scheduleBegin();
	      }
	    }
	  },
	  stack: function stack(offset) {
	    offset = (offset || 0) + 2;
	    return sourceFromStacktrace(offset);
	  },
	  onError: onError,
	  onUnhandledRejection: onUnhandledRejection
	});
	QUnit.pushFailure = pushFailure;
	QUnit.assert = Assert.prototype;
	QUnit.equiv = equiv;
	QUnit.dump = dump;
	registerLoggingCallbacks(QUnit);

	function scheduleBegin() {
	  runStarted = true; // Add a slight delay to allow definition of more modules and tests.

	  if (defined.setTimeout) {
	    setTimeout$1(function () {
	      begin();
	    });
	  } else {
	    begin();
	  }
	}

	function unblockAndAdvanceQueue() {
	  config.blocking = false;
	  ProcessingQueue.advance();
	}

	function begin() {
	  var i,
	      l,
	      modulesLog = []; // If the test run hasn't officially begun yet

	  if (!config.started) {
	    // Record the time of the test run's beginning
	    config.started = now(); // Delete the loose unnamed module if unused.

	    if (config.modules[0].name === "" && config.modules[0].tests.length === 0) {
	      config.modules.shift();
	    } // Avoid unnecessary information by not logging modules' test environments


	    for (i = 0, l = config.modules.length; i < l; i++) {
	      modulesLog.push({
	        name: config.modules[i].name,
	        tests: config.modules[i].tests
	      });
	    } // The test run is officially beginning now


	    emit("runStart", globalSuite.start(true));
	    runLoggingCallbacks("begin", {
	      totalTests: Test.count,
	      modules: modulesLog
	    }).then(unblockAndAdvanceQueue);
	  } else {
	    unblockAndAdvanceQueue();
	  }
	}
	exportQUnit(QUnit);

	(function () {
	  if (typeof window$1 === "undefined" || typeof document$1 === "undefined") {
	    return;
	  }

	  var config = QUnit.config,
	      hasOwn = Object.prototype.hasOwnProperty; // Stores fixture HTML for resetting later

	  function storeFixture() {
	    // Avoid overwriting user-defined values
	    if (hasOwn.call(config, "fixture")) {
	      return;
	    }

	    var fixture = document$1.getElementById("qunit-fixture");

	    if (fixture) {
	      config.fixture = fixture.cloneNode(true);
	    }
	  }

	  QUnit.begin(storeFixture); // Resets the fixture DOM element if available.

	  function resetFixture() {
	    if (config.fixture == null) {
	      return;
	    }

	    var fixture = document$1.getElementById("qunit-fixture");

	    var resetFixtureType = _typeof(config.fixture);

	    if (resetFixtureType === "string") {
	      // support user defined values for `config.fixture`
	      var newFixture = document$1.createElement("div");
	      newFixture.setAttribute("id", "qunit-fixture");
	      newFixture.innerHTML = config.fixture;
	      fixture.parentNode.replaceChild(newFixture, fixture);
	    } else {
	      var clonedFixture = config.fixture.cloneNode(true);
	      fixture.parentNode.replaceChild(clonedFixture, fixture);
	    }
	  }

	  QUnit.testStart(resetFixture);
	})();

	(function () {
	  // Only interact with URLs via window.location
	  var location = typeof window$1 !== "undefined" && window$1.location;

	  if (!location) {
	    return;
	  }

	  var urlParams = getUrlParams();
	  QUnit.urlParams = urlParams; // Match module/test by inclusion in an array

	  QUnit.config.moduleId = [].concat(urlParams.moduleId || []);
	  QUnit.config.testId = [].concat(urlParams.testId || []); // Exact case-insensitive match of the module name

	  QUnit.config.module = urlParams.module; // Regular expression or case-insenstive substring match against "moduleName: testName"

	  QUnit.config.filter = urlParams.filter; // Test order randomization

	  if (urlParams.seed === true) {
	    // Generate a random seed if the option is specified without a value
	    QUnit.config.seed = Math.random().toString(36).slice(2);
	  } else if (urlParams.seed) {
	    QUnit.config.seed = urlParams.seed;
	  } // Add URL-parameter-mapped config values with UI form rendering data


	  QUnit.config.urlConfig.push({
	    id: "hidepassed",
	    label: "Hide passed tests",
	    tooltip: "Only show tests and assertions that fail. Stored as query-strings."
	  }, {
	    id: "noglobals",
	    label: "Check for Globals",
	    tooltip: "Enabling this will test if any test introduces new properties on the " + "global object (`window` in Browsers). Stored as query-strings."
	  }, {
	    id: "notrycatch",
	    label: "No try-catch",
	    tooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " + "exceptions in IE reasonable. Stored as query-strings."
	  });
	  QUnit.begin(function () {
	    var i,
	        option,
	        urlConfig = QUnit.config.urlConfig;

	    for (i = 0; i < urlConfig.length; i++) {
	      // Options can be either strings or objects with nonempty "id" properties
	      option = QUnit.config.urlConfig[i];

	      if (typeof option !== "string") {
	        option = option.id;
	      }

	      if (QUnit.config[option] === undefined) {
	        QUnit.config[option] = urlParams[option];
	      }
	    }
	  });

	  function getUrlParams() {
	    var i, param, name, value;
	    var urlParams = Object.create(null);
	    var params = location.search.slice(1).split("&");
	    var length = params.length;

	    for (i = 0; i < length; i++) {
	      if (params[i]) {
	        param = params[i].split("=");
	        name = decodeQueryParam(param[0]); // Allow just a key to turn on a flag, e.g., test.html?noglobals

	        value = param.length === 1 || decodeQueryParam(param.slice(1).join("="));

	        if (name in urlParams) {
	          urlParams[name] = [].concat(urlParams[name], value);
	        } else {
	          urlParams[name] = value;
	        }
	      }
	    }

	    return urlParams;
	  }

	  function decodeQueryParam(param) {
	    return decodeURIComponent(param.replace(/\+/g, "%20"));
	  }
	})();

	var fuzzysort = createCommonjsModule(function (module) {

	  (function (root, UMD) {
	    if ( module.exports) module.exports = UMD();else root.fuzzysort = UMD();
	  })(commonjsGlobal, function UMD() {
	    function fuzzysortNew(instanceOptions) {
	      var fuzzysort = {
	        single: function (search, target, options) {
	          if (!search) return null;
	          if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);
	          if (!target) return null;
	          if (!isObj(target)) target = fuzzysort.getPrepared(target);
	          var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;
	          var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;
	          return algorithm(search, target, search[0]); // var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991
	          // var result = algorithm(search, target, search[0])
	          // if(result === null) return null
	          // if(result.score < threshold) return null
	          // return result
	        },
	        go: function (search, targets, options) {
	          if (!search) return noResults;
	          search = fuzzysort.prepareSearch(search);
	          var searchLowerCode = search[0];
	          var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;
	          var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;
	          var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;
	          var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;
	          var resultsLen = 0;
	          var limitedCount = 0;
	          var targetsLen = targets.length; // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]
	          // options.keys

	          if (options && options.keys) {
	            var scoreFn = options.scoreFn || defaultScoreFn;
	            var keys = options.keys;
	            var keysLen = keys.length;

	            for (var i = targetsLen - 1; i >= 0; --i) {
	              var obj = targets[i];
	              var objResults = new Array(keysLen);

	              for (var keyI = keysLen - 1; keyI >= 0; --keyI) {
	                var key = keys[keyI];
	                var target = getValue(obj, key);

	                if (!target) {
	                  objResults[keyI] = null;
	                  continue;
	                }

	                if (!isObj(target)) target = fuzzysort.getPrepared(target);
	                objResults[keyI] = algorithm(search, target, searchLowerCode);
	              }

	              objResults.obj = obj; // before scoreFn so scoreFn can use it

	              var score = scoreFn(objResults);
	              if (score === null) continue;
	              if (score < threshold) continue;
	              objResults.score = score;

	              if (resultsLen < limit) {
	                q.add(objResults);
	                ++resultsLen;
	              } else {
	                ++limitedCount;
	                if (score > q.peek().score) q.replaceTop(objResults);
	              }
	            } // options.key

	          } else if (options && options.key) {
	            var key = options.key;

	            for (var i = targetsLen - 1; i >= 0; --i) {
	              var obj = targets[i];
	              var target = getValue(obj, key);
	              if (!target) continue;
	              if (!isObj(target)) target = fuzzysort.getPrepared(target);
	              var result = algorithm(search, target, searchLowerCode);
	              if (result === null) continue;
	              if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj

	              result = {
	                target: result.target,
	                _targetLowerCodes: null,
	                _nextBeginningIndexes: null,
	                score: result.score,
	                indexes: result.indexes,
	                obj: obj
	              }; // hidden

	              if (resultsLen < limit) {
	                q.add(result);
	                ++resultsLen;
	              } else {
	                ++limitedCount;
	                if (result.score > q.peek().score) q.replaceTop(result);
	              }
	            } // no keys

	          } else {
	            for (var i = targetsLen - 1; i >= 0; --i) {
	              var target = targets[i];
	              if (!target) continue;
	              if (!isObj(target)) target = fuzzysort.getPrepared(target);
	              var result = algorithm(search, target, searchLowerCode);
	              if (result === null) continue;
	              if (result.score < threshold) continue;

	              if (resultsLen < limit) {
	                q.add(result);
	                ++resultsLen;
	              } else {
	                ++limitedCount;
	                if (result.score > q.peek().score) q.replaceTop(result);
	              }
	            }
	          }

	          if (resultsLen === 0) return noResults;
	          var results = new Array(resultsLen);

	          for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();

	          results.total = resultsLen + limitedCount;
	          return results;
	        },
	        goAsync: function (search, targets, options) {
	          var canceled = false;
	          var p = new Promise(function (resolve, reject) {
	            if (!search) return resolve(noResults);
	            search = fuzzysort.prepareSearch(search);
	            var searchLowerCode = search[0];
	            var q = fastpriorityqueue();
	            var iCurrent = targets.length - 1;
	            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;
	            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;
	            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;
	            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;
	            var resultsLen = 0;
	            var limitedCount = 0;

	            function step() {
	              if (canceled) return reject('canceled');
	              var startMs = Date.now(); // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]
	              // options.keys

	              if (options && options.keys) {
	                var scoreFn = options.scoreFn || defaultScoreFn;
	                var keys = options.keys;
	                var keysLen = keys.length;

	                for (; iCurrent >= 0; --iCurrent) {
	                  var obj = targets[iCurrent];
	                  var objResults = new Array(keysLen);

	                  for (var keyI = keysLen - 1; keyI >= 0; --keyI) {
	                    var key = keys[keyI];
	                    var target = getValue(obj, key);

	                    if (!target) {
	                      objResults[keyI] = null;
	                      continue;
	                    }

	                    if (!isObj(target)) target = fuzzysort.getPrepared(target);
	                    objResults[keyI] = algorithm(search, target, searchLowerCode);
	                  }

	                  objResults.obj = obj; // before scoreFn so scoreFn can use it

	                  var score = scoreFn(objResults);
	                  if (score === null) continue;
	                  if (score < threshold) continue;
	                  objResults.score = score;

	                  if (resultsLen < limit) {
	                    q.add(objResults);
	                    ++resultsLen;
	                  } else {
	                    ++limitedCount;
	                    if (score > q.peek().score) q.replaceTop(objResults);
	                  }

	                  if (iCurrent % 1000
	                  /*itemsPerCheck*/
	                  === 0) {
	                    if (Date.now() - startMs >= 10
	                    /*asyncInterval*/
	                    ) {
	                        isNode ? setImmediate(step) : setTimeout(step);
	                        return;
	                      }
	                  }
	                } // options.key

	              } else if (options && options.key) {
	                var key = options.key;

	                for (; iCurrent >= 0; --iCurrent) {
	                  var obj = targets[iCurrent];
	                  var target = getValue(obj, key);
	                  if (!target) continue;
	                  if (!isObj(target)) target = fuzzysort.getPrepared(target);
	                  var result = algorithm(search, target, searchLowerCode);
	                  if (result === null) continue;
	                  if (result.score < threshold) continue; // have to clone result so duplicate targets from different obj can each reference the correct obj

	                  result = {
	                    target: result.target,
	                    _targetLowerCodes: null,
	                    _nextBeginningIndexes: null,
	                    score: result.score,
	                    indexes: result.indexes,
	                    obj: obj
	                  }; // hidden

	                  if (resultsLen < limit) {
	                    q.add(result);
	                    ++resultsLen;
	                  } else {
	                    ++limitedCount;
	                    if (result.score > q.peek().score) q.replaceTop(result);
	                  }

	                  if (iCurrent % 1000
	                  /*itemsPerCheck*/
	                  === 0) {
	                    if (Date.now() - startMs >= 10
	                    /*asyncInterval*/
	                    ) {
	                        isNode ? setImmediate(step) : setTimeout(step);
	                        return;
	                      }
	                  }
	                } // no keys

	              } else {
	                for (; iCurrent >= 0; --iCurrent) {
	                  var target = targets[iCurrent];
	                  if (!target) continue;
	                  if (!isObj(target)) target = fuzzysort.getPrepared(target);
	                  var result = algorithm(search, target, searchLowerCode);
	                  if (result === null) continue;
	                  if (result.score < threshold) continue;

	                  if (resultsLen < limit) {
	                    q.add(result);
	                    ++resultsLen;
	                  } else {
	                    ++limitedCount;
	                    if (result.score > q.peek().score) q.replaceTop(result);
	                  }

	                  if (iCurrent % 1000
	                  /*itemsPerCheck*/
	                  === 0) {
	                    if (Date.now() - startMs >= 10
	                    /*asyncInterval*/
	                    ) {
	                        isNode ? setImmediate(step) : setTimeout(step);
	                        return;
	                      }
	                  }
	                }
	              }

	              if (resultsLen === 0) return resolve(noResults);
	              var results = new Array(resultsLen);

	              for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();

	              results.total = resultsLen + limitedCount;
	              resolve(results);
	            }

	            isNode ? setImmediate(step) : step();
	          });

	          p.cancel = function () {
	            canceled = true;
	          };

	          return p;
	        },
	        highlight: function (result, hOpen, hClose) {
	          if (result === null) return null;
	          if (hOpen === undefined) hOpen = '<b>';
	          if (hClose === undefined) hClose = '</b>';
	          var highlighted = '';
	          var matchesIndex = 0;
	          var opened = false;
	          var target = result.target;
	          var targetLen = target.length;
	          var matchesBest = result.indexes;

	          for (var i = 0; i < targetLen; ++i) {
	            var char = target[i];

	            if (matchesBest[matchesIndex] === i) {
	              ++matchesIndex;

	              if (!opened) {
	                opened = true;
	                highlighted += hOpen;
	              }

	              if (matchesIndex === matchesBest.length) {
	                highlighted += char + hClose + target.substr(i + 1);
	                break;
	              }
	            } else {
	              if (opened) {
	                opened = false;
	                highlighted += hClose;
	              }
	            }

	            highlighted += char;
	          }

	          return highlighted;
	        },
	        prepare: function (target) {
	          if (!target) return;
	          return {
	            target: target,
	            _targetLowerCodes: fuzzysort.prepareLowerCodes(target),
	            _nextBeginningIndexes: null,
	            score: null,
	            indexes: null,
	            obj: null
	          }; // hidden
	        },
	        prepareSlow: function (target) {
	          if (!target) return;
	          return {
	            target: target,
	            _targetLowerCodes: fuzzysort.prepareLowerCodes(target),
	            _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),
	            score: null,
	            indexes: null,
	            obj: null
	          }; // hidden
	        },
	        prepareSearch: function (search) {
	          if (!search) return;
	          return fuzzysort.prepareLowerCodes(search);
	        },
	        // Below this point is only internal code
	        // Below this point is only internal code
	        // Below this point is only internal code
	        // Below this point is only internal code
	        getPrepared: function (target) {
	          if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets

	          var targetPrepared = preparedCache.get(target);
	          if (targetPrepared !== undefined) return targetPrepared;
	          targetPrepared = fuzzysort.prepare(target);
	          preparedCache.set(target, targetPrepared);
	          return targetPrepared;
	        },
	        getPreparedSearch: function (search) {
	          if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches

	          var searchPrepared = preparedSearchCache.get(search);
	          if (searchPrepared !== undefined) return searchPrepared;
	          searchPrepared = fuzzysort.prepareSearch(search);
	          preparedSearchCache.set(search, searchPrepared);
	          return searchPrepared;
	        },
	        algorithm: function (searchLowerCodes, prepared, searchLowerCode) {
	          var targetLowerCodes = prepared._targetLowerCodes;
	          var searchLen = searchLowerCodes.length;
	          var targetLen = targetLowerCodes.length;
	          var searchI = 0; // where we at

	          var targetI = 0; // where you at

	          var typoSimpleI = 0;
	          var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!
	          // walk through target. find sequential matches.
	          // if all chars aren't found then exit

	          for (;;) {
	            var isMatch = searchLowerCode === targetLowerCodes[targetI];

	            if (isMatch) {
	              matchesSimple[matchesSimpleLen++] = targetI;
	              ++searchI;
	              if (searchI === searchLen) break;
	              searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];
	            }

	            ++targetI;

	            if (targetI >= targetLen) {
	              // Failed to find searchI
	              // Check for typo or exit
	              // we go as far as possible before trying to transpose
	              // then we transpose backwards until we reach the beginning
	              for (;;) {
	                if (searchI <= 1) return null; // not allowed to transpose first char

	                if (typoSimpleI === 0) {
	                  // we haven't tried to transpose yet
	                  --searchI;
	                  var searchLowerCodeNew = searchLowerCodes[searchI];
	                  if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char

	                  typoSimpleI = searchI;
	                } else {
	                  if (typoSimpleI === 1) return null; // reached the end of the line for transposing

	                  --typoSimpleI;
	                  searchI = typoSimpleI;
	                  searchLowerCode = searchLowerCodes[searchI + 1];
	                  var searchLowerCodeNew = searchLowerCodes[searchI];
	                  if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char
	                }

	                matchesSimpleLen = searchI;
	                targetI = matchesSimple[matchesSimpleLen - 1] + 1;
	                break;
	              }
	            }
	          }

	          var searchI = 0;
	          var typoStrictI = 0;
	          var successStrict = false;
	          var matchesStrictLen = 0;
	          var nextBeginningIndexes = prepared._nextBeginningIndexes;
	          if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);
	          var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!
	          // Let's try a more advanced and strict test to improve the score
	          // only count it as a match if it's consecutive or a beginning character!

	          if (targetI !== targetLen) for (;;) {
	            if (targetI >= targetLen) {
	              // We failed to find a good spot for this search char, go back to the previous search char and force it forward
	              if (searchI <= 0) {
	                // We failed to push chars forward for a better match
	                // transpose, starting from the beginning
	                ++typoStrictI;
	                if (typoStrictI > searchLen - 2) break;
	                if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char

	                targetI = firstPossibleI;
	                continue;
	              }

	              --searchI;
	              var lastMatch = matchesStrict[--matchesStrictLen];
	              targetI = nextBeginningIndexes[lastMatch];
	            } else {
	              var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];

	              if (isMatch) {
	                matchesStrict[matchesStrictLen++] = targetI;
	                ++searchI;

	                if (searchI === searchLen) {
	                  successStrict = true;
	                  break;
	                }

	                ++targetI;
	              } else {
	                targetI = nextBeginningIndexes[targetI];
	              }
	            }
	          }
	          {
	            // tally up the score & keep track of matches for highlighting later
	            if (successStrict) {
	              var matchesBest = matchesStrict;
	              var matchesBestLen = matchesStrictLen;
	            } else {
	              var matchesBest = matchesSimple;
	              var matchesBestLen = matchesSimpleLen;
	            }

	            var score = 0;
	            var lastTargetI = -1;

	            for (var i = 0; i < searchLen; ++i) {
	              var targetI = matchesBest[i]; // score only goes down if they're not consecutive

	              if (lastTargetI !== targetI - 1) score -= targetI;
	              lastTargetI = targetI;
	            }

	            if (!successStrict) {
	              score *= 1000;
	              if (typoSimpleI !== 0) score += -20;
	              /*typoPenalty*/
	            } else {
	              if (typoStrictI !== 0) score += -20;
	              /*typoPenalty*/
	            }

	            score -= targetLen - searchLen;
	            prepared.score = score;
	            prepared.indexes = new Array(matchesBestLen);

	            for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];

	            return prepared;
	          }
	        },
	        algorithmNoTypo: function (searchLowerCodes, prepared, searchLowerCode) {
	          var targetLowerCodes = prepared._targetLowerCodes;
	          var searchLen = searchLowerCodes.length;
	          var targetLen = targetLowerCodes.length;
	          var searchI = 0; // where we at

	          var targetI = 0; // where you at

	          var matchesSimpleLen = 0; // very basic fuzzy match; to remove non-matching targets ASAP!
	          // walk through target. find sequential matches.
	          // if all chars aren't found then exit

	          for (;;) {
	            var isMatch = searchLowerCode === targetLowerCodes[targetI];

	            if (isMatch) {
	              matchesSimple[matchesSimpleLen++] = targetI;
	              ++searchI;
	              if (searchI === searchLen) break;
	              searchLowerCode = searchLowerCodes[searchI];
	            }

	            ++targetI;
	            if (targetI >= targetLen) return null; // Failed to find searchI
	          }

	          var searchI = 0;
	          var successStrict = false;
	          var matchesStrictLen = 0;
	          var nextBeginningIndexes = prepared._nextBeginningIndexes;
	          if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);
	          var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1]; // Our target string successfully matched all characters in sequence!
	          // Let's try a more advanced and strict test to improve the score
	          // only count it as a match if it's consecutive or a beginning character!

	          if (targetI !== targetLen) for (;;) {
	            if (targetI >= targetLen) {
	              // We failed to find a good spot for this search char, go back to the previous search char and force it forward
	              if (searchI <= 0) break; // We failed to push chars forward for a better match

	              --searchI;
	              var lastMatch = matchesStrict[--matchesStrictLen];
	              targetI = nextBeginningIndexes[lastMatch];
	            } else {
	              var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];

	              if (isMatch) {
	                matchesStrict[matchesStrictLen++] = targetI;
	                ++searchI;

	                if (searchI === searchLen) {
	                  successStrict = true;
	                  break;
	                }

	                ++targetI;
	              } else {
	                targetI = nextBeginningIndexes[targetI];
	              }
	            }
	          }
	          {
	            // tally up the score & keep track of matches for highlighting later
	            if (successStrict) {
	              var matchesBest = matchesStrict;
	              var matchesBestLen = matchesStrictLen;
	            } else {
	              var matchesBest = matchesSimple;
	              var matchesBestLen = matchesSimpleLen;
	            }

	            var score = 0;
	            var lastTargetI = -1;

	            for (var i = 0; i < searchLen; ++i) {
	              var targetI = matchesBest[i]; // score only goes down if they're not consecutive

	              if (lastTargetI !== targetI - 1) score -= targetI;
	              lastTargetI = targetI;
	            }

	            if (!successStrict) score *= 1000;
	            score -= targetLen - searchLen;
	            prepared.score = score;
	            prepared.indexes = new Array(matchesBestLen);

	            for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];

	            return prepared;
	          }
	        },
	        prepareLowerCodes: function (str) {
	          var strLen = str.length;
	          var lowerCodes = []; // new Array(strLen)    sparse array is too slow

	          var lower = str.toLowerCase();

	          for (var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i);

	          return lowerCodes;
	        },
	        prepareBeginningIndexes: function (target) {
	          var targetLen = target.length;
	          var beginningIndexes = [];
	          var beginningIndexesLen = 0;
	          var wasUpper = false;
	          var wasAlphanum = false;

	          for (var i = 0; i < targetLen; ++i) {
	            var targetCode = target.charCodeAt(i);
	            var isUpper = targetCode >= 65 && targetCode <= 90;
	            var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;
	            var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;
	            wasUpper = isUpper;
	            wasAlphanum = isAlphanum;
	            if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;
	          }

	          return beginningIndexes;
	        },
	        prepareNextBeginningIndexes: function (target) {
	          var targetLen = target.length;
	          var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);
	          var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow

	          var lastIsBeginning = beginningIndexes[0];
	          var lastIsBeginningI = 0;

	          for (var i = 0; i < targetLen; ++i) {
	            if (lastIsBeginning > i) {
	              nextBeginningIndexes[i] = lastIsBeginning;
	            } else {
	              lastIsBeginning = beginningIndexes[++lastIsBeginningI];
	              nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;
	            }
	          }

	          return nextBeginningIndexes;
	        },
	        cleanup: cleanup,
	        new: fuzzysortNew
	      };
	      return fuzzysort;
	    } // fuzzysortNew
	    // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()


	    var isNode = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined'; // var MAX_INT = Number.MAX_SAFE_INTEGER
	    // var MIN_INT = Number.MIN_VALUE

	    var preparedCache = new Map();
	    var preparedSearchCache = new Map();
	    var noResults = [];
	    noResults.total = 0;
	    var matchesSimple = [];
	    var matchesStrict = [];

	    function cleanup() {
	      preparedCache.clear();
	      preparedSearchCache.clear();
	      matchesSimple = [];
	      matchesStrict = [];
	    }

	    function defaultScoreFn(a) {
	      var max = -9007199254740991;

	      for (var i = a.length - 1; i >= 0; --i) {
	        var result = a[i];
	        if (result === null) continue;
	        var score = result.score;
	        if (score > max) max = score;
	      }

	      if (max === -9007199254740991) return null;
	      return max;
	    } // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]
	    // prop = 'key1.key2'        10ms
	    // prop = ['key1', 'key2']   27ms


	    function getValue(obj, prop) {
	      var tmp = obj[prop];
	      if (tmp !== undefined) return tmp;
	      var segs = prop;
	      if (!Array.isArray(prop)) segs = prop.split('.');
	      var len = segs.length;
	      var i = -1;

	      while (obj && ++i < len) obj = obj[segs[i]];

	      return obj;
	    }

	    function isObj(x) {
	      return typeof x === 'object';
	    } // faster as a function
	    // Hacked version of https://github.com/lemire/FastPriorityQueue.js


	    var fastpriorityqueue = function () {
	      var r = [],
	          o = 0,
	          e = {};

	      function n() {
	        for (var e = 0, n = r[e], c = 1; c < o;) {
	          var f = c + 1;
	          e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);
	        }

	        for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) r[e] = r[a];

	        r[e] = n;
	      }

	      return e.add = function (e) {
	        var n = o;
	        r[o++] = e;

	        for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) r[n] = r[c];

	        r[n] = e;
	      }, e.poll = function () {
	        if (0 !== o) {
	          var e = r[0];
	          return r[0] = r[--o], n(), e;
	        }
	      }, e.peek = function (e) {
	        if (0 !== o) return r[0];
	      }, e.replaceTop = function (o) {
	        r[0] = o, n();
	      }, e;
	    };

	    var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own

	    return fuzzysortNew();
	  }); // UMD
	  // TODO: (performance) wasm version!?
	  // TODO: (performance) layout memory in an optimal way to go fast by avoiding cache misses
	  // TODO: (performance) preparedCache is a memory leak
	  // TODO: (like sublime) backslash === forwardslash
	  // TODO: (performance) i have no idea how well optizmied the allowing typos algorithm is

	});

	var stats = {
	  passedTests: 0,
	  failedTests: 0,
	  skippedTests: 0,
	  todoTests: 0
	}; // Escape text for attribute or text content.

	function escapeText(s) {
	  if (!s) {
	    return "";
	  }

	  s = s + ""; // Both single quotes and double quotes (for attributes)

	  return s.replace(/['"<>&]/g, function (s) {
	    switch (s) {
	      case "'":
	        return "&#039;";

	      case "\"":
	        return "&quot;";

	      case "<":
	        return "&lt;";

	      case ">":
	        return "&gt;";

	      case "&":
	        return "&amp;";
	    }
	  });
	}

	(function () {
	  // Don't load the HTML Reporter on non-browser environments
	  if (typeof window$1 === "undefined" || !window$1.document) {
	    return;
	  }

	  var config = QUnit.config,
	      hiddenTests = [],
	      document = window$1.document,
	      collapseNext = false,
	      hasOwn = Object.prototype.hasOwnProperty,
	      unfilteredUrl = setUrl({
	    filter: undefined,
	    module: undefined,
	    moduleId: undefined,
	    testId: undefined
	  }),
	      modulesList = [];

	  function addEvent(elem, type, fn) {
	    elem.addEventListener(type, fn, false);
	  }

	  function removeEvent(elem, type, fn) {
	    elem.removeEventListener(type, fn, false);
	  }

	  function addEvents(elems, type, fn) {
	    var i = elems.length;

	    while (i--) {
	      addEvent(elems[i], type, fn);
	    }
	  }

	  function hasClass(elem, name) {
	    return (" " + elem.className + " ").indexOf(" " + name + " ") >= 0;
	  }

	  function addClass(elem, name) {
	    if (!hasClass(elem, name)) {
	      elem.className += (elem.className ? " " : "") + name;
	    }
	  }

	  function toggleClass(elem, name, force) {
	    if (force || typeof force === "undefined" && !hasClass(elem, name)) {
	      addClass(elem, name);
	    } else {
	      removeClass(elem, name);
	    }
	  }

	  function removeClass(elem, name) {
	    var set = " " + elem.className + " "; // Class name may appear multiple times

	    while (set.indexOf(" " + name + " ") >= 0) {
	      set = set.replace(" " + name + " ", " ");
	    } // Trim for prettiness


	    elem.className = typeof set.trim === "function" ? set.trim() : set.replace(/^\s+|\s+$/g, "");
	  }

	  function id(name) {
	    return document.getElementById && document.getElementById(name);
	  }

	  function abortTests() {
	    var abortButton = id("qunit-abort-tests-button");

	    if (abortButton) {
	      abortButton.disabled = true;
	      abortButton.innerHTML = "Aborting...";
	    }

	    QUnit.config.queue.length = 0;
	    return false;
	  }

	  function interceptNavigation(ev) {
	    applyUrlParams();

	    if (ev && ev.preventDefault) {
	      ev.preventDefault();
	    }

	    return false;
	  }

	  function getUrlConfigHtml() {
	    var i,
	        j,
	        val,
	        escaped,
	        escapedTooltip,
	        selection = false,
	        urlConfig = config.urlConfig,
	        urlConfigHtml = "";

	    for (i = 0; i < urlConfig.length; i++) {
	      // Options can be either strings or objects with nonempty "id" properties
	      val = config.urlConfig[i];

	      if (typeof val === "string") {
	        val = {
	          id: val,
	          label: val
	        };
	      }

	      escaped = escapeText(val.id);
	      escapedTooltip = escapeText(val.tooltip);

	      if (!val.value || typeof val.value === "string") {
	        urlConfigHtml += "<label for='qunit-urlconfig-" + escaped + "' title='" + escapedTooltip + "'><input id='qunit-urlconfig-" + escaped + "' name='" + escaped + "' type='checkbox'" + (val.value ? " value='" + escapeText(val.value) + "'" : "") + (config[val.id] ? " checked='checked'" : "") + " title='" + escapedTooltip + "' />" + escapeText(val.label) + "</label>";
	      } else {
	        urlConfigHtml += "<label for='qunit-urlconfig-" + escaped + "' title='" + escapedTooltip + "'>" + val.label + ": </label><select id='qunit-urlconfig-" + escaped + "' name='" + escaped + "' title='" + escapedTooltip + "'><option></option>";

	        if (QUnit.is("array", val.value)) {
	          for (j = 0; j < val.value.length; j++) {
	            escaped = escapeText(val.value[j]);
	            urlConfigHtml += "<option value='" + escaped + "'" + (config[val.id] === val.value[j] ? (selection = true) && " selected='selected'" : "") + ">" + escaped + "</option>";
	          }
	        } else {
	          for (j in val.value) {
	            if (hasOwn.call(val.value, j)) {
	              urlConfigHtml += "<option value='" + escapeText(j) + "'" + (config[val.id] === j ? (selection = true) && " selected='selected'" : "") + ">" + escapeText(val.value[j]) + "</option>";
	            }
	          }
	        }

	        if (config[val.id] && !selection) {
	          escaped = escapeText(config[val.id]);
	          urlConfigHtml += "<option value='" + escaped + "' selected='selected' disabled='disabled'>" + escaped + "</option>";
	        }

	        urlConfigHtml += "</select>";
	      }
	    }

	    return urlConfigHtml;
	  } // Handle "click" events on toolbar checkboxes and "change" for select menus.
	  // Updates the URL with the new state of `config.urlConfig` values.


	  function toolbarChanged() {
	    var updatedUrl,
	        value,
	        tests,
	        field = this,
	        params = {}; // Detect if field is a select menu or a checkbox

	    if ("selectedIndex" in field) {
	      value = field.options[field.selectedIndex].value || undefined;
	    } else {
	      value = field.checked ? field.defaultValue || true : undefined;
	    }

	    params[field.name] = value;
	    updatedUrl = setUrl(params); // Check if we can apply the change without a page refresh

	    if ("hidepassed" === field.name && "replaceState" in window$1.history) {
	      QUnit.urlParams[field.name] = value;
	      config[field.name] = value || false;
	      tests = id("qunit-tests");

	      if (tests) {
	        var length = tests.children.length;
	        var children = tests.children;

	        if (field.checked) {
	          for (var i = 0; i < length; i++) {
	            var test = children[i];
	            var className = test ? test.className : "";
	            var classNameHasPass = className.indexOf("pass") > -1;
	            var classNameHasSkipped = className.indexOf("skipped") > -1;

	            if (classNameHasPass || classNameHasSkipped) {
	              hiddenTests.push(test);
	            }
	          }

	          var _iterator = _createForOfIteratorHelper(hiddenTests),
	              _step;

	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var hiddenTest = _step.value;
	              tests.removeChild(hiddenTest);
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        } else {
	          while ((test = hiddenTests.pop()) != null) {
	            tests.appendChild(test);
	          }
	        }
	      }

	      window$1.history.replaceState(null, "", updatedUrl);
	    } else {
	      window$1.location = updatedUrl;
	    }
	  }

	  function setUrl(params) {
	    var key,
	        arrValue,
	        i,
	        querystring = "?",
	        location = window$1.location;
	    params = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);

	    for (key in params) {
	      // Skip inherited or undefined properties
	      if (hasOwn.call(params, key) && params[key] !== undefined) {
	        // Output a parameter for each value of this key
	        // (but usually just one)
	        arrValue = [].concat(params[key]);

	        for (i = 0; i < arrValue.length; i++) {
	          querystring += encodeURIComponent(key);

	          if (arrValue[i] !== true) {
	            querystring += "=" + encodeURIComponent(arrValue[i]);
	          }

	          querystring += "&";
	        }
	      }
	    }

	    return location.protocol + "//" + location.host + location.pathname + querystring.slice(0, -1);
	  }

	  function applyUrlParams() {
	    var i,
	        selectedModules = [],
	        modulesList = id("qunit-modulefilter-dropdown-list").getElementsByTagName("input"),
	        filter = id("qunit-filter-input").value;

	    for (i = 0; i < modulesList.length; i++) {
	      if (modulesList[i].checked) {
	        selectedModules.push(modulesList[i].value);
	      }
	    }

	    window$1.location = setUrl({
	      filter: filter === "" ? undefined : filter,
	      moduleId: selectedModules.length === 0 ? undefined : selectedModules,
	      // Remove module and testId filter
	      module: undefined,
	      testId: undefined
	    });
	  }

	  function toolbarUrlConfigContainer() {
	    var urlConfigContainer = document.createElement("span");
	    urlConfigContainer.innerHTML = getUrlConfigHtml();
	    addClass(urlConfigContainer, "qunit-url-config");
	    addEvents(urlConfigContainer.getElementsByTagName("input"), "change", toolbarChanged);
	    addEvents(urlConfigContainer.getElementsByTagName("select"), "change", toolbarChanged);
	    return urlConfigContainer;
	  }

	  function abortTestsButton() {
	    var button = document.createElement("button");
	    button.id = "qunit-abort-tests-button";
	    button.innerHTML = "Abort";
	    addEvent(button, "click", abortTests);
	    return button;
	  }

	  function toolbarLooseFilter() {
	    var filter = document.createElement("form"),
	        label = document.createElement("label"),
	        input = document.createElement("input"),
	        button = document.createElement("button");
	    addClass(filter, "qunit-filter");
	    label.innerHTML = "Filter: ";
	    input.type = "text";
	    input.value = config.filter || "";
	    input.name = "filter";
	    input.id = "qunit-filter-input";
	    button.innerHTML = "Go";
	    label.appendChild(input);
	    filter.appendChild(label);
	    filter.appendChild(document.createTextNode(" "));
	    filter.appendChild(button);
	    addEvent(filter, "submit", interceptNavigation);
	    return filter;
	  }

	  function moduleListHtml(modules) {
	    var i,
	        checked,
	        html = "";

	    for (i = 0; i < modules.length; i++) {
	      if (modules[i].name !== "") {
	        checked = config.moduleId.indexOf(modules[i].moduleId) > -1;
	        html += "<li><label class='clickable" + (checked ? " checked" : "") + "'><input type='checkbox' " + "value='" + modules[i].moduleId + "'" + (checked ? " checked='checked'" : "") + " />" + escapeText(modules[i].name) + "</label></li>";
	      }
	    }

	    return html;
	  }

	  function toolbarModuleFilter() {
	    var commit,
	        reset,
	        moduleFilter = document.createElement("form"),
	        label = document.createElement("label"),
	        moduleSearch = document.createElement("input"),
	        dropDown = document.createElement("div"),
	        actions = document.createElement("span"),
	        applyButton = document.createElement("button"),
	        resetButton = document.createElement("button"),
	        allModulesLabel = document.createElement("label"),
	        allCheckbox = document.createElement("input"),
	        dropDownList = document.createElement("ul"),
	        dirty = false;
	    moduleSearch.id = "qunit-modulefilter-search";
	    moduleSearch.autocomplete = "off";
	    addEvent(moduleSearch, "input", searchInput);
	    addEvent(moduleSearch, "input", searchFocus);
	    addEvent(moduleSearch, "focus", searchFocus);
	    addEvent(moduleSearch, "click", searchFocus);
	    config.modules.forEach(function (module) {
	      return module.namePrepared = fuzzysort.prepare(module.name);
	    });
	    label.id = "qunit-modulefilter-search-container";
	    label.innerHTML = "Module: ";
	    label.appendChild(moduleSearch);
	    applyButton.textContent = "Apply";
	    applyButton.style.display = "none";
	    resetButton.textContent = "Reset";
	    resetButton.type = "reset";
	    resetButton.style.display = "none";
	    allCheckbox.type = "checkbox";
	    allCheckbox.checked = config.moduleId.length === 0;
	    allModulesLabel.className = "clickable";

	    if (config.moduleId.length) {
	      allModulesLabel.className = "checked";
	    }

	    allModulesLabel.appendChild(allCheckbox);
	    allModulesLabel.appendChild(document.createTextNode("All modules"));
	    actions.id = "qunit-modulefilter-actions";
	    actions.appendChild(applyButton);
	    actions.appendChild(resetButton);
	    actions.appendChild(allModulesLabel);
	    commit = actions.firstChild;
	    reset = commit.nextSibling;
	    addEvent(commit, "click", applyUrlParams);
	    dropDownList.id = "qunit-modulefilter-dropdown-list";
	    dropDownList.innerHTML = moduleListHtml(config.modules);
	    dropDown.id = "qunit-modulefilter-dropdown";
	    dropDown.style.display = "none";
	    dropDown.appendChild(actions);
	    dropDown.appendChild(dropDownList);
	    addEvent(dropDown, "change", selectionChange);
	    selectionChange();
	    moduleFilter.id = "qunit-modulefilter";
	    moduleFilter.appendChild(label);
	    moduleFilter.appendChild(dropDown);
	    addEvent(moduleFilter, "submit", interceptNavigation);
	    addEvent(moduleFilter, "reset", function () {
	      // Let the reset happen, then update styles
	      window$1.setTimeout(selectionChange);
	    }); // Enables show/hide for the dropdown

	    function searchFocus() {
	      if (dropDown.style.display !== "none") {
	        return;
	      }

	      dropDown.style.display = "block";
	      addEvent(document, "click", hideHandler);
	      addEvent(document, "keydown", hideHandler); // Hide on Escape keydown or outside-container click

	      function hideHandler(e) {
	        var inContainer = moduleFilter.contains(e.target);

	        if (e.keyCode === 27 || !inContainer) {
	          if (e.keyCode === 27 && inContainer) {
	            moduleSearch.focus();
	          }

	          dropDown.style.display = "none";
	          removeEvent(document, "click", hideHandler);
	          removeEvent(document, "keydown", hideHandler);
	          moduleSearch.value = "";
	          searchInput();
	        }
	      }
	    }

	    function filterModules(searchText) {
	      if (searchText === "") {
	        return config.modules;
	      }

	      return fuzzysort.go(searchText, config.modules, {
	        key: "namePrepared",
	        threshold: -10000
	      }).map(function (module) {
	        return module.obj;
	      });
	    } // Processes module search box input


	    var searchInputTimeout;

	    function searchInput() {
	      window$1.clearTimeout(searchInputTimeout);
	      searchInputTimeout = window$1.setTimeout(function () {
	        var searchText = moduleSearch.value.toLowerCase(),
	            filteredModules = filterModules(searchText);
	        dropDownList.innerHTML = moduleListHtml(filteredModules);
	      }, 200);
	    } // Processes selection changes


	    function selectionChange(evt) {
	      var i,
	          item,
	          checkbox = evt && evt.target || allCheckbox,
	          modulesList = dropDownList.getElementsByTagName("input"),
	          selectedNames = [];
	      toggleClass(checkbox.parentNode, "checked", checkbox.checked);
	      dirty = false;

	      if (checkbox.checked && checkbox !== allCheckbox) {
	        allCheckbox.checked = false;
	        removeClass(allCheckbox.parentNode, "checked");
	      }

	      for (i = 0; i < modulesList.length; i++) {
	        item = modulesList[i];

	        if (!evt) {
	          toggleClass(item.parentNode, "checked", item.checked);
	        } else if (checkbox === allCheckbox && checkbox.checked) {
	          item.checked = false;
	          removeClass(item.parentNode, "checked");
	        }

	        dirty = dirty || item.checked !== item.defaultChecked;

	        if (item.checked) {
	          selectedNames.push(item.parentNode.textContent);
	        }
	      }

	      commit.style.display = reset.style.display = dirty ? "" : "none";
	      moduleSearch.placeholder = selectedNames.join(", ") || allCheckbox.parentNode.textContent;
	      moduleSearch.title = "Type to filter list. Current selection:\n" + (selectedNames.join("\n") || allCheckbox.parentNode.textContent);
	    }

	    return moduleFilter;
	  }

	  function toolbarFilters() {
	    var toolbarFilters = document.createElement("span");
	    toolbarFilters.id = "qunit-toolbar-filters";
	    toolbarFilters.appendChild(toolbarLooseFilter());
	    toolbarFilters.appendChild(toolbarModuleFilter());
	    return toolbarFilters;
	  }

	  function appendToolbar() {
	    var toolbar = id("qunit-testrunner-toolbar");

	    if (toolbar) {
	      toolbar.appendChild(toolbarUrlConfigContainer());
	      toolbar.appendChild(toolbarFilters());
	      toolbar.appendChild(document.createElement("div")).className = "clearfix";
	    }
	  }

	  function appendHeader() {
	    var header = id("qunit-header");

	    if (header) {
	      header.innerHTML = "<a href='" + escapeText(unfilteredUrl) + "'>" + header.innerHTML + "</a> ";
	    }
	  }

	  function appendBanner() {
	    var banner = id("qunit-banner");

	    if (banner) {
	      banner.className = "";
	    }
	  }

	  function appendTestResults() {
	    var tests = id("qunit-tests"),
	        result = id("qunit-testresult"),
	        controls;

	    if (result) {
	      result.parentNode.removeChild(result);
	    }

	    if (tests) {
	      tests.innerHTML = "";
	      result = document.createElement("p");
	      result.id = "qunit-testresult";
	      result.className = "result";
	      tests.parentNode.insertBefore(result, tests);
	      result.innerHTML = "<div id=\"qunit-testresult-display\">Running...<br />&#160;</div>" + "<div id=\"qunit-testresult-controls\"></div>" + "<div class=\"clearfix\"></div>";
	      controls = id("qunit-testresult-controls");
	    }

	    if (controls) {
	      controls.appendChild(abortTestsButton());
	    }
	  }

	  function appendFilteredTest() {
	    var testId = QUnit.config.testId;

	    if (!testId || testId.length <= 0) {
	      return "";
	    }

	    return "<div id='qunit-filteredTest'>Rerunning selected tests: " + escapeText(testId.join(", ")) + " <a id='qunit-clearFilter' href='" + escapeText(unfilteredUrl) + "'>Run all tests</a></div>";
	  }

	  function appendUserAgent() {
	    var userAgent = id("qunit-userAgent");

	    if (userAgent) {
	      userAgent.innerHTML = "";
	      userAgent.appendChild(document.createTextNode("QUnit " + QUnit.version + "; " + navigator.userAgent));
	    }
	  }

	  function appendInterface() {
	    var qunit = id("qunit"); // For compat with QUnit 1.2, and to support fully custom theme HTML,
	    // we will use any existing elements if no id="qunit" element exists.
	    //
	    // Note that we don't fail or fallback to creating it ourselves,
	    // because not having id="qunit" (and not having the below elements)
	    // simply means QUnit acts headless, allowing users to use their own
	    // reporters, or for a test runner to listen for events directly without
	    // having the HTML reporter actively render anything.

	    if (qunit) {
	      // Since QUnit 1.3, these are created automatically if the page
	      // contains id="qunit".
	      qunit.innerHTML = "<h1 id='qunit-header'>" + escapeText(document.title) + "</h1>" + "<h2 id='qunit-banner'></h2>" + "<div id='qunit-testrunner-toolbar'></div>" + appendFilteredTest() + "<h2 id='qunit-userAgent'></h2>" + "<ol id='qunit-tests'></ol>";
	    }

	    appendHeader();
	    appendBanner();
	    appendTestResults();
	    appendUserAgent();
	    appendToolbar();
	  }

	  function appendTest(name, testId, moduleName) {
	    var title,
	        rerunTrigger,
	        testBlock,
	        assertList,
	        tests = id("qunit-tests");

	    if (!tests) {
	      return;
	    }

	    title = document.createElement("strong");
	    title.innerHTML = getNameHtml(name, moduleName);
	    rerunTrigger = document.createElement("a");
	    rerunTrigger.innerHTML = "Rerun";
	    rerunTrigger.href = setUrl({
	      testId: testId
	    });
	    testBlock = document.createElement("li");
	    testBlock.appendChild(title);
	    testBlock.appendChild(rerunTrigger);
	    testBlock.id = "qunit-test-output-" + testId;
	    assertList = document.createElement("ol");
	    assertList.className = "qunit-assert-list";
	    testBlock.appendChild(assertList);
	    tests.appendChild(testBlock);
	  } // HTML Reporter initialization and load


	  QUnit.begin(function (details) {
	    var i, moduleObj; // Sort modules by name for the picker

	    for (i = 0; i < details.modules.length; i++) {
	      moduleObj = details.modules[i];

	      if (moduleObj.name) {
	        modulesList.push(moduleObj.name);
	      }
	    }

	    modulesList.sort(function (a, b) {
	      return a.localeCompare(b);
	    }); // Initialize QUnit elements

	    appendInterface();
	  });
	  QUnit.done(function (details) {
	    var banner = id("qunit-banner"),
	        tests = id("qunit-tests"),
	        abortButton = id("qunit-abort-tests-button"),
	        totalTests = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests,
	        html = [totalTests, " tests completed in ", details.runtime, " milliseconds, with ", stats.failedTests, " failed, ", stats.skippedTests, " skipped, and ", stats.todoTests, " todo.<br />", "<span class='passed'>", details.passed, "</span> assertions of <span class='total'>", details.total, "</span> passed, <span class='failed'>", details.failed, "</span> failed."].join(""),
	        test,
	        assertLi,
	        assertList; // Update remaining tests to aborted

	    if (abortButton && abortButton.disabled) {
	      html = "Tests aborted after " + details.runtime + " milliseconds.";

	      for (var i = 0; i < tests.children.length; i++) {
	        test = tests.children[i];

	        if (test.className === "" || test.className === "running") {
	          test.className = "aborted";
	          assertList = test.getElementsByTagName("ol")[0];
	          assertLi = document.createElement("li");
	          assertLi.className = "fail";
	          assertLi.innerHTML = "Test aborted.";
	          assertList.appendChild(assertLi);
	        }
	      }
	    }

	    if (banner && (!abortButton || abortButton.disabled === false)) {
	      banner.className = stats.failedTests ? "qunit-fail" : "qunit-pass";
	    }

	    if (abortButton) {
	      abortButton.parentNode.removeChild(abortButton);
	    }

	    if (tests) {
	      id("qunit-testresult-display").innerHTML = html;
	    }

	    if (config.altertitle && document.title) {
	      // Show ✖ for good, ✔ for bad suite result in title
	      // use escape sequences in case file gets loaded with non-utf-8
	      // charset
	      document.title = [stats.failedTests ? "\u2716" : "\u2714", document.title.replace(/^[\u2714\u2716] /i, "")].join(" ");
	    } // Scroll back to top to show results


	    if (config.scrolltop && window$1.scrollTo) {
	      window$1.scrollTo(0, 0);
	    }
	  });

	  function getNameHtml(name, module) {
	    var nameHtml = "";

	    if (module) {
	      nameHtml = "<span class='module-name'>" + escapeText(module) + "</span>: ";
	    }

	    nameHtml += "<span class='test-name'>" + escapeText(name) + "</span>";
	    return nameHtml;
	  }

	  function getProgressHtml(runtime, stats, total) {
	    var completed = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests;
	    return ["<br />", completed, " / ", total, " tests completed in ", runtime, " milliseconds, with ", stats.failedTests, " failed, ", stats.skippedTests, " skipped, and ", stats.todoTests, " todo."].join("");
	  }

	  QUnit.testStart(function (details) {
	    var running, bad;
	    appendTest(details.name, details.testId, details.module);
	    running = id("qunit-testresult-display");

	    if (running) {
	      addClass(running, "running");
	      bad = QUnit.config.reorder && details.previousFailure;
	      running.innerHTML = [bad ? "Rerunning previously failed test: <br />" : "Running: <br />", getNameHtml(details.name, details.module), getProgressHtml(now() - config.started, stats, Test.count)].join("");
	    }
	  });

	  function stripHtml(string) {
	    // Strip tags, html entity and whitespaces
	    return string.replace(/<\/?[^>]+(>|$)/g, "").replace(/&quot;/g, "").replace(/\s+/g, "");
	  }

	  QUnit.log(function (details) {
	    var assertList,
	        assertLi,
	        message,
	        expected,
	        actual,
	        diff,
	        showDiff = false,
	        testItem = id("qunit-test-output-" + details.testId);

	    if (!testItem) {
	      return;
	    }

	    message = escapeText(details.message) || (details.result ? "okay" : "failed");
	    message = "<span class='test-message'>" + message + "</span>";
	    message += "<span class='runtime'>@ " + details.runtime + " ms</span>"; // The pushFailure doesn't provide details.expected
	    // when it calls, it's implicit to also not show expected and diff stuff
	    // Also, we need to check details.expected existence, as it can exist and be undefined

	    if (!details.result && hasOwn.call(details, "expected")) {
	      if (details.negative) {
	        expected = "NOT " + QUnit.dump.parse(details.expected);
	      } else {
	        expected = QUnit.dump.parse(details.expected);
	      }

	      actual = QUnit.dump.parse(details.actual);
	      message += "<table><tr class='test-expected'><th>Expected: </th><td><pre>" + escapeText(expected) + "</pre></td></tr>";

	      if (actual !== expected) {
	        message += "<tr class='test-actual'><th>Result: </th><td><pre>" + escapeText(actual) + "</pre></td></tr>";

	        if (typeof details.actual === "number" && typeof details.expected === "number") {
	          if (!isNaN(details.actual) && !isNaN(details.expected)) {
	            showDiff = true;
	            diff = details.actual - details.expected;
	            diff = (diff > 0 ? "+" : "") + diff;
	          }
	        } else if (typeof details.actual !== "boolean" && typeof details.expected !== "boolean") {
	          diff = QUnit.diff(expected, actual); // don't show diff if there is zero overlap

	          showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;
	        }

	        if (showDiff) {
	          message += "<tr class='test-diff'><th>Diff: </th><td><pre>" + diff + "</pre></td></tr>";
	        }
	      } else if (expected.indexOf("[object Array]") !== -1 || expected.indexOf("[object Object]") !== -1) {
	        message += "<tr class='test-message'><th>Message: </th><td>" + "Diff suppressed as the depth of object is more than current max depth (" + QUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " + " run with a higher max depth or <a href='" + escapeText(setUrl({
	          maxDepth: -1
	        })) + "'>" + "Rerun</a> without max depth.</p></td></tr>";
	      } else {
	        message += "<tr class='test-message'><th>Message: </th><td>" + "Diff suppressed as the expected and actual results have an equivalent" + " serialization</td></tr>";
	      }

	      if (details.source) {
	        message += "<tr class='test-source'><th>Source: </th><td><pre>" + escapeText(details.source) + "</pre></td></tr>";
	      }

	      message += "</table>"; // This occurs when pushFailure is set and we have an extracted stack trace
	    } else if (!details.result && details.source) {
	      message += "<table>" + "<tr class='test-source'><th>Source: </th><td><pre>" + escapeText(details.source) + "</pre></td></tr>" + "</table>";
	    }

	    assertList = testItem.getElementsByTagName("ol")[0];
	    assertLi = document.createElement("li");
	    assertLi.className = details.result ? "pass" : "fail";
	    assertLi.innerHTML = message;
	    assertList.appendChild(assertLi);
	  });
	  QUnit.testDone(function (details) {
	    var testTitle,
	        time,
	        testItem,
	        assertList,
	        status,
	        good,
	        bad,
	        testCounts,
	        skipped,
	        sourceName,
	        tests = id("qunit-tests");

	    if (!tests) {
	      return;
	    }

	    testItem = id("qunit-test-output-" + details.testId);
	    removeClass(testItem, "running");

	    if (details.failed > 0) {
	      status = "failed";
	    } else if (details.todo) {
	      status = "todo";
	    } else {
	      status = details.skipped ? "skipped" : "passed";
	    }

	    assertList = testItem.getElementsByTagName("ol")[0];
	    good = details.passed;
	    bad = details.failed; // This test passed if it has no unexpected failed assertions

	    var testPassed = details.failed > 0 ? details.todo : !details.todo;

	    if (testPassed) {
	      // Collapse the passing tests
	      addClass(assertList, "qunit-collapsed");
	    } else if (config.collapse) {
	      if (!collapseNext) {
	        // Skip collapsing the first failing test
	        collapseNext = true;
	      } else {
	        // Collapse remaining tests
	        addClass(assertList, "qunit-collapsed");
	      }
	    } // The testItem.firstChild is the test name


	    testTitle = testItem.firstChild;
	    testCounts = bad ? "<b class='failed'>" + bad + "</b>, " + "<b class='passed'>" + good + "</b>, " : "";
	    testTitle.innerHTML += " <b class='counts'>(" + testCounts + details.assertions.length + ")</b>";

	    if (details.skipped) {
	      stats.skippedTests++;
	      testItem.className = "skipped";
	      skipped = document.createElement("em");
	      skipped.className = "qunit-skipped-label";
	      skipped.innerHTML = "skipped";
	      testItem.insertBefore(skipped, testTitle);
	    } else {
	      addEvent(testTitle, "click", function () {
	        toggleClass(assertList, "qunit-collapsed");
	      });
	      testItem.className = testPassed ? "pass" : "fail";

	      if (details.todo) {
	        var todoLabel = document.createElement("em");
	        todoLabel.className = "qunit-todo-label";
	        todoLabel.innerHTML = "todo";
	        testItem.className += " todo";
	        testItem.insertBefore(todoLabel, testTitle);
	      }

	      time = document.createElement("span");
	      time.className = "runtime";
	      time.innerHTML = details.runtime + " ms";
	      testItem.insertBefore(time, assertList);

	      if (!testPassed) {
	        stats.failedTests++;
	      } else if (details.todo) {
	        stats.todoTests++;
	      } else {
	        stats.passedTests++;
	      }
	    } // Show the source of the test when showing assertions


	    if (details.source) {
	      sourceName = document.createElement("p");
	      sourceName.innerHTML = "<strong>Source: </strong>" + escapeText(details.source);
	      addClass(sourceName, "qunit-source");

	      if (testPassed) {
	        addClass(sourceName, "qunit-collapsed");
	      }

	      addEvent(testTitle, "click", function () {
	        toggleClass(sourceName, "qunit-collapsed");
	      });
	      testItem.appendChild(sourceName);
	    }

	    if (config.hidepassed && (status === "passed" || details.skipped)) {
	      // use removeChild instead of remove because of support
	      hiddenTests.push(testItem);
	      tests.removeChild(testItem);
	    }
	  }); // Avoid readyState issue with phantomjs
	  // Ref: #818

	  var notPhantom = function (p) {
	    return !(p && p.version && p.version.major > 0);
	  }(window$1.phantom);

	  if (notPhantom && document.readyState === "complete") {
	    QUnit.load();
	  } else {
	    addEvent(window$1, "load", QUnit.load);
	  } // Wrap window.onerror. We will call the original window.onerror to see if
	  // the existing handler fully handles the error; if not, we will call the
	  // QUnit.onError function.


	  var originalWindowOnError = window$1.onerror; // Cover uncaught exceptions
	  // Returning true will suppress the default browser handler,
	  // returning false will let it run.

	  window$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {
	    var ret = false;

	    if (originalWindowOnError) {
	      for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
	        args[_key - 5] = arguments[_key];
	      }

	      ret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));
	    } // Treat return value as window.onerror itself does,
	    // Only do our handling if not suppressed.


	    if (ret !== true) {
	      var error = {
	        message: message,
	        fileName: fileName,
	        lineNumber: lineNumber
	      }; // According to
	      // https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,
	      // most modern browsers support an errorObj argument; use that to
	      // get a full stack trace if it's available.

	      if (errorObj && errorObj.stack) {
	        error.stacktrace = extractStacktrace(errorObj, 0);
	      }

	      ret = QUnit.onError(error);
	    }

	    return ret;
	  }; // Listen for unhandled rejections, and call QUnit.onUnhandledRejection


	  window$1.addEventListener("unhandledrejection", function (event) {
	    QUnit.onUnhandledRejection(event.reason);
	  });
	})();

	/*
	 * This file is a modified version of google-diff-match-patch's JavaScript implementation
	 * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),
	 * modifications are licensed as more fully set forth in LICENSE.txt.
	 *
	 * The original source of google-diff-match-patch is attributable and licensed as follows:
	 *
	 * Copyright 2006 Google Inc.
	 * https://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * More Info:
	 *  https://code.google.com/p/google-diff-match-patch/
	 *
	 * Usage: QUnit.diff(expected, actual)
	 *
	 */

	QUnit.diff = function () {
	  function DiffMatchPatch() {} //  DIFF FUNCTIONS

	  /**
	   * The data structure representing a diff is an array of tuples:
	   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	   */


	  var DIFF_DELETE = -1,
	      DIFF_INSERT = 1,
	      DIFF_EQUAL = 0,
	      hasOwn = Object.prototype.hasOwnProperty;
	  /**
	   * Find the differences between two texts.  Simplifies the problem by stripping
	   * any common prefix or suffix off the texts before diffing.
	   * @param {string} text1 Old string to be diffed.
	   * @param {string} text2 New string to be diffed.
	   * @param {boolean=} optChecklines Optional speedup flag. If present and false,
	   *     then don't run a line-level diff first to identify the changed areas.
	   *     Defaults to true, which does a faster, slightly less optimal diff.
	   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
	   */

	  DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {
	    var deadline, checklines, commonlength, commonprefix, commonsuffix, diffs; // The diff must be complete in up to 1 second.

	    deadline = new Date().getTime() + 1000; // Check for null inputs.

	    if (text1 === null || text2 === null) {
	      throw new Error("Null input. (DiffMain)");
	    } // Check for equality (speedup).


	    if (text1 === text2) {
	      if (text1) {
	        return [[DIFF_EQUAL, text1]];
	      }

	      return [];
	    }

	    if (typeof optChecklines === "undefined") {
	      optChecklines = true;
	    }

	    checklines = optChecklines; // Trim off common prefix (speedup).

	    commonlength = this.diffCommonPrefix(text1, text2);
	    commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength); // Trim off common suffix (speedup).

	    commonlength = this.diffCommonSuffix(text1, text2);
	    commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength); // Compute the diff on the middle block.

	    diffs = this.diffCompute(text1, text2, checklines, deadline); // Restore the prefix and suffix.

	    if (commonprefix) {
	      diffs.unshift([DIFF_EQUAL, commonprefix]);
	    }

	    if (commonsuffix) {
	      diffs.push([DIFF_EQUAL, commonsuffix]);
	    }

	    this.diffCleanupMerge(diffs);
	    return diffs;
	  };
	  /**
	   * Reduce the number of edits by eliminating operationally trivial equalities.
	   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
	   */


	  DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {
	    var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;
	    changes = false;
	    equalities = []; // Stack of indices where equalities are found.

	    equalitiesLength = 0; // Keeping our own length var is faster in JS.

	    /** @type {?string} */

	    lastequality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]

	    pointer = 0; // Index of current position.
	    // Is there an insertion operation before the last equality.

	    preIns = false; // Is there a deletion operation before the last equality.

	    preDel = false; // Is there an insertion operation after the last equality.

	    postIns = false; // Is there a deletion operation after the last equality.

	    postDel = false;

	    while (pointer < diffs.length) {
	      // Equality found.
	      if (diffs[pointer][0] === DIFF_EQUAL) {
	        if (diffs[pointer][1].length < 4 && (postIns || postDel)) {
	          // Candidate found.
	          equalities[equalitiesLength++] = pointer;
	          preIns = postIns;
	          preDel = postDel;
	          lastequality = diffs[pointer][1];
	        } else {
	          // Not a candidate, and can never become one.
	          equalitiesLength = 0;
	          lastequality = null;
	        }

	        postIns = postDel = false; // An insertion or deletion.
	      } else {
	        if (diffs[pointer][0] === DIFF_DELETE) {
	          postDel = true;
	        } else {
	          postIns = true;
	        }
	        /*
	         * Five types to be split:
	         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
	         * <ins>A</ins>X<ins>C</ins><del>D</del>
	         * <ins>A</ins><del>B</del>X<ins>C</ins>
	         * <ins>A</del>X<ins>C</ins><del>D</del>
	         * <ins>A</ins><del>B</del>X<del>C</del>
	         */


	        if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {
	          // Duplicate record.
	          diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]); // Change second copy to insert.

	          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
	          equalitiesLength--; // Throw away the equality we just deleted;

	          lastequality = null;

	          if (preIns && preDel) {
	            // No changes made which could affect previous entry, keep going.
	            postIns = postDel = true;
	            equalitiesLength = 0;
	          } else {
	            equalitiesLength--; // Throw away the previous equality.

	            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
	            postIns = postDel = false;
	          }

	          changes = true;
	        }
	      }

	      pointer++;
	    }

	    if (changes) {
	      this.diffCleanupMerge(diffs);
	    }
	  };
	  /**
	   * Convert a diff array into a pretty HTML report.
	   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
	   * @param {integer} string to be beautified.
	   * @return {string} HTML representation.
	   */


	  DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {
	    var op,
	        data,
	        x,
	        html = [];

	    for (x = 0; x < diffs.length; x++) {
	      op = diffs[x][0]; // Operation (insert, delete, equal)

	      data = diffs[x][1]; // Text of change.

	      switch (op) {
	        case DIFF_INSERT:
	          html[x] = "<ins>" + escapeText(data) + "</ins>";
	          break;

	        case DIFF_DELETE:
	          html[x] = "<del>" + escapeText(data) + "</del>";
	          break;

	        case DIFF_EQUAL:
	          html[x] = "<span>" + escapeText(data) + "</span>";
	          break;
	      }
	    }

	    return html.join("");
	  };
	  /**
	   * Determine the common prefix of two strings.
	   * @param {string} text1 First string.
	   * @param {string} text2 Second string.
	   * @return {number} The number of characters common to the start of each
	   *     string.
	   */


	  DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {
	    var pointermid, pointermax, pointermin, pointerstart; // Quick check for common null cases.

	    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
	      return 0;
	    } // Binary search.
	    // Performance analysis: https://neil.fraser.name/news/2007/10/09/


	    pointermin = 0;
	    pointermax = Math.min(text1.length, text2.length);
	    pointermid = pointermax;
	    pointerstart = 0;

	    while (pointermin < pointermid) {
	      if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
	        pointermin = pointermid;
	        pointerstart = pointermin;
	      } else {
	        pointermax = pointermid;
	      }

	      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }

	    return pointermid;
	  };
	  /**
	   * Determine the common suffix of two strings.
	   * @param {string} text1 First string.
	   * @param {string} text2 Second string.
	   * @return {number} The number of characters common to the end of each string.
	   */


	  DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {
	    var pointermid, pointermax, pointermin, pointerend; // Quick check for common null cases.

	    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
	      return 0;
	    } // Binary search.
	    // Performance analysis: https://neil.fraser.name/news/2007/10/09/


	    pointermin = 0;
	    pointermax = Math.min(text1.length, text2.length);
	    pointermid = pointermax;
	    pointerend = 0;

	    while (pointermin < pointermid) {
	      if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	        pointermin = pointermid;
	        pointerend = pointermin;
	      } else {
	        pointermax = pointermid;
	      }

	      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }

	    return pointermid;
	  };
	  /**
	   * Find the differences between two texts.  Assumes that the texts do not
	   * have any common prefix or suffix.
	   * @param {string} text1 Old string to be diffed.
	   * @param {string} text2 New string to be diffed.
	   * @param {boolean} checklines Speedup flag.  If false, then don't run a
	   *     line-level diff first to identify the changed areas.
	   *     If true, then run a faster, slightly less optimal diff.
	   * @param {number} deadline Time when the diff should be complete by.
	   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {
	    var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;

	    if (!text1) {
	      // Just add some text (speedup).
	      return [[DIFF_INSERT, text2]];
	    }

	    if (!text2) {
	      // Just delete some text (speedup).
	      return [[DIFF_DELETE, text1]];
	    }

	    longtext = text1.length > text2.length ? text1 : text2;
	    shorttext = text1.length > text2.length ? text2 : text1;
	    i = longtext.indexOf(shorttext);

	    if (i !== -1) {
	      // Shorter text is inside the longer text (speedup).
	      diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]]; // Swap insertions for deletions if diff is reversed.

	      if (text1.length > text2.length) {
	        diffs[0][0] = diffs[2][0] = DIFF_DELETE;
	      }

	      return diffs;
	    }

	    if (shorttext.length === 1) {
	      // Single character string.
	      // After the previous speedup, the character can't be an equality.
	      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	    } // Check to see if the problem can be split in two.


	    hm = this.diffHalfMatch(text1, text2);

	    if (hm) {
	      // A half-match was found, sort out the return data.
	      text1A = hm[0];
	      text1B = hm[1];
	      text2A = hm[2];
	      text2B = hm[3];
	      midCommon = hm[4]; // Send both pairs off for separate processing.

	      diffsA = this.DiffMain(text1A, text2A, checklines, deadline);
	      diffsB = this.DiffMain(text1B, text2B, checklines, deadline); // Merge the results.

	      return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
	    }

	    if (checklines && text1.length > 100 && text2.length > 100) {
	      return this.diffLineMode(text1, text2, deadline);
	    }

	    return this.diffBisect(text1, text2, deadline);
	  };
	  /**
	   * Do the two texts share a substring which is at least half the length of the
	   * longer text?
	   * This speedup can produce non-minimal diffs.
	   * @param {string} text1 First string.
	   * @param {string} text2 Second string.
	   * @return {Array.<string>} Five element Array, containing the prefix of
	   *     text1, the suffix of text1, the prefix of text2, the suffix of
	   *     text2 and the common middle.  Or null if there was no match.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {
	    var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;
	    longtext = text1.length > text2.length ? text1 : text2;
	    shorttext = text1.length > text2.length ? text2 : text1;

	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	      return null; // Pointless.
	    }

	    dmp = this; // 'this' becomes 'window' in a closure.

	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */

	    function diffHalfMatchI(longtext, shorttext, i) {
	      var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB; // Start with a 1/4 length substring at position i as a seed.

	      seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	      j = -1;
	      bestCommon = "";

	      while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
	        prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));
	        suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));

	        if (bestCommon.length < suffixLength + prefixLength) {
	          bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
	          bestLongtextA = longtext.substring(0, i - suffixLength);
	          bestLongtextB = longtext.substring(i + prefixLength);
	          bestShorttextA = shorttext.substring(0, j - suffixLength);
	          bestShorttextB = shorttext.substring(j + prefixLength);
	        }
	      }

	      if (bestCommon.length * 2 >= longtext.length) {
	        return [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];
	      } else {
	        return null;
	      }
	    } // First check if the second quarter is the seed for a half-match.


	    hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4)); // Check again based on the third quarter.

	    hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));

	    if (!hm1 && !hm2) {
	      return null;
	    } else if (!hm2) {
	      hm = hm1;
	    } else if (!hm1) {
	      hm = hm2;
	    } else {
	      // Both matched.  Select the longest.
	      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    } // A half-match was found, sort out the return data.


	    if (text1.length > text2.length) {
	      text1A = hm[0];
	      text1B = hm[1];
	      text2A = hm[2];
	      text2B = hm[3];
	    } else {
	      text2A = hm[0];
	      text2B = hm[1];
	      text1A = hm[2];
	      text1B = hm[3];
	    }

	    midCommon = hm[4];
	    return [text1A, text1B, text2A, text2B, midCommon];
	  };
	  /**
	   * Do a quick line-level diff on both strings, then rediff the parts for
	   * greater accuracy.
	   * This speedup can produce non-minimal diffs.
	   * @param {string} text1 Old string to be diffed.
	   * @param {string} text2 New string to be diffed.
	   * @param {number} deadline Time when the diff should be complete by.
	   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {
	    var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j; // Scan the text on a line-by-line basis first.

	    a = this.diffLinesToChars(text1, text2);
	    text1 = a.chars1;
	    text2 = a.chars2;
	    linearray = a.lineArray;
	    diffs = this.DiffMain(text1, text2, false, deadline); // Convert the diff back to original text.

	    this.diffCharsToLines(diffs, linearray); // Eliminate freak matches (e.g. blank lines)

	    this.diffCleanupSemantic(diffs); // Rediff any replacement blocks, this time character-by-character.
	    // Add a dummy entry at the end.

	    diffs.push([DIFF_EQUAL, ""]);
	    pointer = 0;
	    countDelete = 0;
	    countInsert = 0;
	    textDelete = "";
	    textInsert = "";

	    while (pointer < diffs.length) {
	      switch (diffs[pointer][0]) {
	        case DIFF_INSERT:
	          countInsert++;
	          textInsert += diffs[pointer][1];
	          break;

	        case DIFF_DELETE:
	          countDelete++;
	          textDelete += diffs[pointer][1];
	          break;

	        case DIFF_EQUAL:
	          // Upon reaching an equality, check for prior redundancies.
	          if (countDelete >= 1 && countInsert >= 1) {
	            // Delete the offending records and add the merged ones.
	            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
	            pointer = pointer - countDelete - countInsert;
	            a = this.DiffMain(textDelete, textInsert, false, deadline);

	            for (j = a.length - 1; j >= 0; j--) {
	              diffs.splice(pointer, 0, a[j]);
	            }

	            pointer = pointer + a.length;
	          }

	          countInsert = 0;
	          countDelete = 0;
	          textDelete = "";
	          textInsert = "";
	          break;
	      }

	      pointer++;
	    }

	    diffs.pop(); // Remove the dummy entry at the end.

	    return diffs;
	  };
	  /**
	   * Find the 'middle snake' of a diff, split the problem in two
	   * and return the recursively constructed diff.
	   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	   * @param {string} text1 Old string to be diffed.
	   * @param {string} text2 New string to be diffed.
	   * @param {number} deadline Time at which to bail if not yet complete.
	   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {
	    var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2; // Cache the text lengths to prevent multiple calls.

	    text1Length = text1.length;
	    text2Length = text2.length;
	    maxD = Math.ceil((text1Length + text2Length) / 2);
	    vOffset = maxD;
	    vLength = 2 * maxD;
	    v1 = new Array(vLength);
	    v2 = new Array(vLength); // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.

	    for (x = 0; x < vLength; x++) {
	      v1[x] = -1;
	      v2[x] = -1;
	    }

	    v1[vOffset + 1] = 0;
	    v2[vOffset + 1] = 0;
	    delta = text1Length - text2Length; // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.

	    front = delta % 2 !== 0; // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.

	    k1start = 0;
	    k1end = 0;
	    k2start = 0;
	    k2end = 0;

	    for (d = 0; d < maxD; d++) {
	      // Bail out if deadline is reached.
	      if (new Date().getTime() > deadline) {
	        break;
	      } // Walk the front path one step.


	      for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	        k1Offset = vOffset + k1;

	        if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
	          x1 = v1[k1Offset + 1];
	        } else {
	          x1 = v1[k1Offset - 1] + 1;
	        }

	        y1 = x1 - k1;

	        while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
	          x1++;
	          y1++;
	        }

	        v1[k1Offset] = x1;

	        if (x1 > text1Length) {
	          // Ran off the right of the graph.
	          k1end += 2;
	        } else if (y1 > text2Length) {
	          // Ran off the bottom of the graph.
	          k1start += 2;
	        } else if (front) {
	          k2Offset = vOffset + delta - k1;

	          if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
	            // Mirror x2 onto top-left coordinate system.
	            x2 = text1Length - v2[k2Offset];

	            if (x1 >= x2) {
	              // Overlap detected.
	              return this.diffBisectSplit(text1, text2, x1, y1, deadline);
	            }
	          }
	        }
	      } // Walk the reverse path one step.


	      for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	        k2Offset = vOffset + k2;

	        if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
	          x2 = v2[k2Offset + 1];
	        } else {
	          x2 = v2[k2Offset - 1] + 1;
	        }

	        y2 = x2 - k2;

	        while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
	          x2++;
	          y2++;
	        }

	        v2[k2Offset] = x2;

	        if (x2 > text1Length) {
	          // Ran off the left of the graph.
	          k2end += 2;
	        } else if (y2 > text2Length) {
	          // Ran off the top of the graph.
	          k2start += 2;
	        } else if (!front) {
	          k1Offset = vOffset + delta - k2;

	          if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
	            x1 = v1[k1Offset];
	            y1 = vOffset + x1 - k1Offset; // Mirror x2 onto top-left coordinate system.

	            x2 = text1Length - x2;

	            if (x1 >= x2) {
	              // Overlap detected.
	              return this.diffBisectSplit(text1, text2, x1, y1, deadline);
	            }
	          }
	        }
	      }
	    } // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.


	    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	  };
	  /**
	   * Given the location of the 'middle snake', split the diff in two parts
	   * and recurse.
	   * @param {string} text1 Old string to be diffed.
	   * @param {string} text2 New string to be diffed.
	   * @param {number} x Index of split point in text1.
	   * @param {number} y Index of split point in text2.
	   * @param {number} deadline Time at which to bail if not yet complete.
	   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {
	    var text1a, text1b, text2a, text2b, diffs, diffsb;
	    text1a = text1.substring(0, x);
	    text2a = text2.substring(0, y);
	    text1b = text1.substring(x);
	    text2b = text2.substring(y); // Compute both diffs serially.

	    diffs = this.DiffMain(text1a, text2a, false, deadline);
	    diffsb = this.DiffMain(text1b, text2b, false, deadline);
	    return diffs.concat(diffsb);
	  };
	  /**
	   * Reduce the number of edits by eliminating semantically trivial equalities.
	   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
	   */


	  DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {
	    var changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
	    changes = false;
	    equalities = []; // Stack of indices where equalities are found.

	    equalitiesLength = 0; // Keeping our own length var is faster in JS.

	    /** @type {?string} */

	    lastequality = null; // Always equal to diffs[equalities[equalitiesLength - 1]][1]

	    pointer = 0; // Index of current position.
	    // Number of characters that changed prior to the equality.

	    lengthInsertions1 = 0;
	    lengthDeletions1 = 0; // Number of characters that changed after the equality.

	    lengthInsertions2 = 0;
	    lengthDeletions2 = 0;

	    while (pointer < diffs.length) {
	      if (diffs[pointer][0] === DIFF_EQUAL) {
	        // Equality found.
	        equalities[equalitiesLength++] = pointer;
	        lengthInsertions1 = lengthInsertions2;
	        lengthDeletions1 = lengthDeletions2;
	        lengthInsertions2 = 0;
	        lengthDeletions2 = 0;
	        lastequality = diffs[pointer][1];
	      } else {
	        // An insertion or deletion.
	        if (diffs[pointer][0] === DIFF_INSERT) {
	          lengthInsertions2 += diffs[pointer][1].length;
	        } else {
	          lengthDeletions2 += diffs[pointer][1].length;
	        } // Eliminate an equality that is smaller or equal to the edits on both
	        // sides of it.


	        if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
	          // Duplicate record.
	          diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]); // Change second copy to insert.

	          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT; // Throw away the equality we just deleted.

	          equalitiesLength--; // Throw away the previous equality (it needs to be reevaluated).

	          equalitiesLength--;
	          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1; // Reset the counters.

	          lengthInsertions1 = 0;
	          lengthDeletions1 = 0;
	          lengthInsertions2 = 0;
	          lengthDeletions2 = 0;
	          lastequality = null;
	          changes = true;
	        }
	      }

	      pointer++;
	    } // Normalize the diff.


	    if (changes) {
	      this.diffCleanupMerge(diffs);
	    } // Find any overlaps between deletions and insertions.
	    // e.g: <del>abcxxx</del><ins>xxxdef</ins>
	    //   -> <del>abc</del>xxx<ins>def</ins>
	    // e.g: <del>xxxabc</del><ins>defxxx</ins>
	    //   -> <ins>def</ins>xxx<del>abc</del>
	    // Only extract an overlap if it is as big as the edit ahead or behind it.


	    pointer = 1;

	    while (pointer < diffs.length) {
	      if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
	        deletion = diffs[pointer - 1][1];
	        insertion = diffs[pointer][1];
	        overlapLength1 = this.diffCommonOverlap(deletion, insertion);
	        overlapLength2 = this.diffCommonOverlap(insertion, deletion);

	        if (overlapLength1 >= overlapLength2) {
	          if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
	            // Overlap found.  Insert an equality and trim the surrounding edits.
	            diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);
	            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
	            diffs[pointer + 1][1] = insertion.substring(overlapLength1);
	            pointer++;
	          }
	        } else {
	          if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
	            // Reverse overlap found.
	            // Insert an equality and swap and trim the surrounding edits.
	            diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);
	            diffs[pointer - 1][0] = DIFF_INSERT;
	            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
	            diffs[pointer + 1][0] = DIFF_DELETE;
	            diffs[pointer + 1][1] = deletion.substring(overlapLength2);
	            pointer++;
	          }
	        }

	        pointer++;
	      }

	      pointer++;
	    }
	  };
	  /**
	   * Determine if the suffix of one string is the prefix of another.
	   * @param {string} text1 First string.
	   * @param {string} text2 Second string.
	   * @return {number} The number of characters common to the end of the first
	   *     string and the start of the second string.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {
	    var text1Length, text2Length, textLength, best, length, pattern, found; // Cache the text lengths to prevent multiple calls.

	    text1Length = text1.length;
	    text2Length = text2.length; // Eliminate the null case.

	    if (text1Length === 0 || text2Length === 0) {
	      return 0;
	    } // Truncate the longer string.


	    if (text1Length > text2Length) {
	      text1 = text1.substring(text1Length - text2Length);
	    } else if (text1Length < text2Length) {
	      text2 = text2.substring(0, text1Length);
	    }

	    textLength = Math.min(text1Length, text2Length); // Quick check for the worst case.

	    if (text1 === text2) {
	      return textLength;
	    } // Start by looking for a single character match
	    // and increase length until no match is found.
	    // Performance analysis: https://neil.fraser.name/news/2010/11/04/


	    best = 0;
	    length = 1;

	    while (true) {
	      pattern = text1.substring(textLength - length);
	      found = text2.indexOf(pattern);

	      if (found === -1) {
	        return best;
	      }

	      length += found;

	      if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {
	        best = length;
	        length++;
	      }
	    }
	  };
	  /**
	   * Split two texts into an array of strings.  Reduce the texts to a string of
	   * hashes where each Unicode character represents one line.
	   * @param {string} text1 First string.
	   * @param {string} text2 Second string.
	   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
	   *     An object containing the encoded text1, the encoded text2 and
	   *     the array of unique strings.
	   *     The zeroth element of the array of unique strings is intentionally blank.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {
	    var lineArray, lineHash, chars1, chars2;
	    lineArray = []; // E.g. lineArray[4] === 'Hello\n'

	    lineHash = {}; // E.g. lineHash['Hello\n'] === 4
	    // '\x00' is a valid character, but various debuggers don't like it.
	    // So we'll insert a junk entry to avoid generating a null character.

	    lineArray[0] = "";
	    /**
	     * Split a text into an array of strings.  Reduce the texts to a string of
	     * hashes where each Unicode character represents one line.
	     * Modifies linearray and linehash through being a closure.
	     * @param {string} text String to encode.
	     * @return {string} Encoded string.
	     * @private
	     */

	    function diffLinesToCharsMunge(text) {
	      var chars, lineStart, lineEnd, lineArrayLength, line;
	      chars = ""; // Walk the text, pulling out a substring for each line.
	      // text.split('\n') would would temporarily double our memory footprint.
	      // Modifying text would create many large strings to garbage collect.

	      lineStart = 0;
	      lineEnd = -1; // Keeping our own length variable is faster than looking it up.

	      lineArrayLength = lineArray.length;

	      while (lineEnd < text.length - 1) {
	        lineEnd = text.indexOf("\n", lineStart);

	        if (lineEnd === -1) {
	          lineEnd = text.length - 1;
	        }

	        line = text.substring(lineStart, lineEnd + 1);
	        lineStart = lineEnd + 1;

	        if (hasOwn.call(lineHash, line)) {
	          chars += String.fromCharCode(lineHash[line]);
	        } else {
	          chars += String.fromCharCode(lineArrayLength);
	          lineHash[line] = lineArrayLength;
	          lineArray[lineArrayLength++] = line;
	        }
	      }

	      return chars;
	    }

	    chars1 = diffLinesToCharsMunge(text1);
	    chars2 = diffLinesToCharsMunge(text2);
	    return {
	      chars1: chars1,
	      chars2: chars2,
	      lineArray: lineArray
	    };
	  };
	  /**
	   * Rehydrate the text in a diff from a string of line hashes to real lines of
	   * text.
	   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
	   * @param {!Array.<string>} lineArray Array of unique strings.
	   * @private
	   */


	  DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {
	    var x, chars, text, y;

	    for (x = 0; x < diffs.length; x++) {
	      chars = diffs[x][1];
	      text = [];

	      for (y = 0; y < chars.length; y++) {
	        text[y] = lineArray[chars.charCodeAt(y)];
	      }

	      diffs[x][1] = text.join("");
	    }
	  };
	  /**
	   * Reorder and merge like edit sections.  Merge equalities.
	   * Any edit section can move as long as it doesn't cross an equality.
	   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
	   */


	  DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {
	    var pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;
	    diffs.push([DIFF_EQUAL, ""]); // Add a dummy entry at the end.

	    pointer = 0;
	    countDelete = 0;
	    countInsert = 0;
	    textDelete = "";
	    textInsert = "";

	    while (pointer < diffs.length) {
	      switch (diffs[pointer][0]) {
	        case DIFF_INSERT:
	          countInsert++;
	          textInsert += diffs[pointer][1];
	          pointer++;
	          break;

	        case DIFF_DELETE:
	          countDelete++;
	          textDelete += diffs[pointer][1];
	          pointer++;
	          break;

	        case DIFF_EQUAL:
	          // Upon reaching an equality, check for prior redundancies.
	          if (countDelete + countInsert > 1) {
	            if (countDelete !== 0 && countInsert !== 0) {
	              // Factor out any common prefixes.
	              commonlength = this.diffCommonPrefix(textInsert, textDelete);

	              if (commonlength !== 0) {
	                if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
	                  diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
	                } else {
	                  diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);
	                  pointer++;
	                }

	                textInsert = textInsert.substring(commonlength);
	                textDelete = textDelete.substring(commonlength);
	              } // Factor out any common suffixies.


	              commonlength = this.diffCommonSuffix(textInsert, textDelete);

	              if (commonlength !== 0) {
	                diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
	                textInsert = textInsert.substring(0, textInsert.length - commonlength);
	                textDelete = textDelete.substring(0, textDelete.length - commonlength);
	              }
	            } // Delete the offending records and add the merged ones.


	            if (countDelete === 0) {
	              diffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);
	            } else if (countInsert === 0) {
	              diffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);
	            } else {
	              diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);
	            }

	            pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;
	          } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
	            // Merge this equality with the previous one.
	            diffs[pointer - 1][1] += diffs[pointer][1];
	            diffs.splice(pointer, 1);
	          } else {
	            pointer++;
	          }

	          countInsert = 0;
	          countDelete = 0;
	          textDelete = "";
	          textInsert = "";
	          break;
	      }
	    }

	    if (diffs[diffs.length - 1][1] === "") {
	      diffs.pop(); // Remove the dummy entry at the end.
	    } // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC


	    changes = false;
	    pointer = 1; // Intentionally ignore the first and last element (don't need checking).

	    while (pointer < diffs.length - 1) {
	      if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
	        diffPointer = diffs[pointer][1];
	        position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length); // This is a single edit surrounded by equalities.

	        if (position === diffs[pointer - 1][1]) {
	          // Shift the edit over the previous equality.
	          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
	          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	          diffs.splice(pointer - 1, 1);
	          changes = true;
	        } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
	          // Shift the edit over the next equality.
	          diffs[pointer - 1][1] += diffs[pointer + 1][1];
	          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
	          diffs.splice(pointer + 1, 1);
	          changes = true;
	        }
	      }

	      pointer++;
	    } // If shifts were made, the diff needs reordering and another shift sweep.


	    if (changes) {
	      this.diffCleanupMerge(diffs);
	    }
	  };

	  return function (o, n) {
	    var diff, output, text;
	    diff = new DiffMatchPatch();
	    output = diff.DiffMain(o, n);
	    diff.diffCleanupEfficiency(output);
	    text = diff.diffPrettyHtml(output);
	    return text;
	  };
	}();

}((function() { return this; }())));

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"_process":5,"timers":7}],7:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":5,"timers":7}],8:[function(require,module,exports){
/*
    I18NDomain class
*/
"use strict";

var context = require( '../../context.js' );

var I18NDomain = function( stringToApply ) {
    
    var string = stringToApply;
    
    var putToAutoDefineHelper = function( scope, autoDefineHelper ){
        
        var newString = string;
        var conf = context.getConf();
        
        // Add the domains defined previously
        var previousValue = scope.get( conf.i18nDomainVarName );
        if ( previousValue ) {
            newString += conf.inDefineDelimiter + conf.i18nDomainVarName;
        }
        
        // Add brackets if not present
        if ( newString[ 0 ] !== '[' ){
            newString = '[' + newString + ']';
        }
        
        // Add i18nDomainVarName to the autoDefineHelper
        autoDefineHelper.put(
            conf.i18nDomainVarName,
            newString
        );
    };

    var dependsOn = function(){
        return [];
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        putToAutoDefineHelper: putToAutoDefineHelper,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: I18NDomain.id
    };
};

I18NDomain.id = 'i18n:domain';

I18NDomain.build = function( string ) {
    return string? new I18NDomain( string.trim() ): null;
};

module.exports = I18NDomain;

},{"../../context.js":27}],9:[function(require,module,exports){
/*
    I18nLanguage class
*/
"use strict";

var context = require( '../../context.js' );

var I18NLanguage = function( stringToApply ) {
    
    var string = stringToApply;
    
    var putToAutoDefineHelper = function( autoDefineHelper ){

        // Add i18nLanguageVarName to the autoDefineHelper
        autoDefineHelper.put(
            context.getConf().i18nLanguageVarName,
            string
        );
    };
    
    var dependsOn = function(){
        return [];
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return "I18NLanguage: " + string;
    };
    
    return {
        putToAutoDefineHelper: putToAutoDefineHelper,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: I18NLanguage.id
    };
};

I18NLanguage.id = 'i18n:language';

I18NLanguage.build = function( string ) {
    return string? new I18NLanguage( string.trim() ): null;
};

module.exports = I18NLanguage;

},{"../../context.js":27}],10:[function(require,module,exports){
/*
    METALDefineMacro class
*/
"use strict";

var METALDefineMacro = function( nameToApply ) {
    
    var name = nameToApply;
    
    var process = function( scope, node ){
        
        // Hide macro definitions
        node.style.display = 'none';

        return false;
    };

    var dependsOn = function(){
        return [];
    };
    
    var toString = function(){
        return "METALDefineMacro: " + name;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        toString: toString,
        type: METALDefineMacro.id
    };
};

METALDefineMacro.id = 'metal:define-macro';

METALDefineMacro.build = function( string ) {
    return new METALDefineMacro( string.trim() );
};

module.exports = METALDefineMacro;

},{}],11:[function(require,module,exports){
/*
    METALFillSlot class
*/
"use strict";

var expressionsUtils = require( '../../expressions/expressionsUtils.js' );

var METALFillSlot = function( _string, _expression, _useMacroNode ) {
    
    var string = _string;
    var expression = _expression;
    var useMacroNode = _useMacroNode;
    
    var process = function(){
        // Nothing to do
    };
    
    var dependsOn = function( scope ){
        return expressionsUtils.buildDependsOnList( undefined, scope, expression );
    };
    
    var update = function( parserUpdater ){
        parserUpdater.updateNode( useMacroNode );
    };
    
    var toString = function(){
        return "METALFillSlot: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: METALFillSlot.id
    };
};

METALFillSlot.id = 'metal:fill-slot';

METALFillSlot.build = function( string, useMacroNode ) {
    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
    
    return new METALFillSlot( 
            string,
            expressionBuilder.build( string ),
            useMacroNode
    );
};

module.exports = METALFillSlot;

},{"../../expressions/expressionBuilder.js":46,"../../expressions/expressionsUtils.js":48}],12:[function(require,module,exports){
/*
    METALUseMacro class
*/
"use strict";

var context = require( '../../context.js' );
var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );
var attributeIndex = require( '../attributeIndex.js' );
var attributeCache = require( '../../cache/attributeCache.js' );
var TALDefine = require( '../TAL/talDefine.js' );
var METALFillSlot = require( './metalFillSlot.js' );
var resolver = require( '../../resolver.js' );

var METALUseMacro = function( stringToApply, macroExpressionToApply, defineToApply ) {
    
    var string = stringToApply;
    var macroExpression = macroExpressionToApply;
    var define = defineToApply;
    
    var process = function( scope, node, autoDefineHelper, indexExpressions ){

        // Init some vars
        var macroKey = resolver.getMacroKey( macroExpression, scope );
        var tags = context.getTags();
        var newNode = resolver.getNode( macroKey, scope ); 
        
        // Hide use macro node
        node.style.display = 'none';

        // Remove style attribute to force showing the new node
        newNode.removeAttribute( 'style' );

        // Update define and autoDefine attributes of the new node
        updateNewNodeAttributes( macroKey, newNode, autoDefineHelper, tags, node, indexExpressions );
        
        // Fill slots
        fillSlots( scope, node, tags, newNode, indexExpressions );

        // Add the macro node
        node.parentNode.insertBefore( newNode, node.nextSibling );
        
        return newNode;
    };
    
    var updateNewNodeAttributes = function( macroKey, newNode, autoDefineHelper, tags, node, indexExpressions ){

        // Update the talDefine attribute
        TALDefine.updateAttribute( newNode, define );
        
        // Update the talAutoDefine attribute
        var macroData = resolver.getMacroData( macroKey );
        if ( macroData.url ){
            autoDefineHelper.put( 
                context.getConf().externalMacroUrlVarName, 
                "'" + macroData.url + "'"
            );
            autoDefineHelper.updateNode( newNode );
        }
        
        // Set related id attribute if needed
        if ( indexExpressions ){
            newNode.setAttribute( 
                tags.relatedId, 
                node.getAttribute( tags.id ) 
            );
        }
    };
    
    var fillSlots = function( scope, node, tags, newNode, indexExpressions ){
        
        var list = node.querySelectorAll( 
            "[" + resolver.filterSelector( tags.metalFillSlot ) + "]"
        );
        var element;
        var pos = 0;
        while ( element = list[ pos++ ] ) {
            var slotIdExpressionString = element.getAttribute( tags.metalFillSlot );
            var slotIdExpression = expressionBuilder.build( slotIdExpressionString );
            var slotId = slotIdExpression.evaluate( scope );

            // Index fill slot element
            if ( indexExpressions ){
                var metalFillSlot = attributeCache.getByAttributeClass( 
                    METALFillSlot, 
                    slotIdExpressionString, 
                    element,
                    indexExpressions,
                    scope,
                    function(){
                        return METALFillSlot.build( slotIdExpressionString, node );
                    }
                );
                attributeIndex.add( element, metalFillSlot, scope );   
            }

            // Do nothing if slotIdExpression evaluates to false
            if ( ! slotId ){
                return;
            }

            var slotContent = element.cloneNode( true );
            var currentNode = newNode.querySelector( 
                "[" + resolver.filterSelector( tags.metalDefineSlot ) + "='" + slotId + "']"
            );
            if ( ! currentNode ){
                throw 'Slot "' + slotId + '" in expression "' + slotIdExpressionString +'" not found!';
            }
            currentNode.parentNode.insertBefore( 
                slotContent, 
                currentNode.nextSibling
            );
            slotContent.removeAttribute( tags.metalFillSlot );
            slotContent.setAttribute( tags.id, context.nextExpressionCounter() ); // Set a new id attribute to avoid id conflicts
            currentNode.remove();
        }
    };
    
    var dependsOn = function( scope ){
        return expressionsUtils.buildDependsOnList( undefined, scope, macroExpression );
    };
    
    var update = function( parserUpdater, node ){
        parserUpdater.updateNode( node );
    };
    
    var toString = function(){
        return "METALUseMacro: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: METALUseMacro.id
    };
};

METALUseMacro.id = 'metal:use-macro';

METALUseMacro.build = function( string, stringDefine ) {
    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
    
    return new METALUseMacro( 
            string,
            expressionBuilder.build( string.trim() ),
            stringDefine? stringDefine.trim(): undefined
    );
};

module.exports = METALUseMacro;

},{"../../cache/attributeCache.js":24,"../../context.js":27,"../../expressions/expressionBuilder.js":46,"../../expressions/expressionsUtils.js":48,"../../resolver.js":97,"../TAL/talDefine.js":18,"../attributeIndex.js":23,"./metalFillSlot.js":11}],13:[function(require,module,exports){
/* 
    contentHelper singleton class
*/
"use strict";

var context = require( '../../context.js' );
var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
var evaluateHelper = require( '../../expressions/evaluateHelper.js' );

module.exports = (function() {

    var formInputHasBody = {
        BUTTON: 1,
        LABEL: 1,
        LEGEND: 1,
        FIELDSET: 1,
        OPTION: 1
    };
    
    var build = function( tag, string, constructorFunction ) {

        // Process it
        var content = string.trim();

        // Check if is an HTML expression
        var structure = content.indexOf( context.getConf().htmlStructureExpressionPrefix + ' ' ) === 0;
        var expressionString = structure? 
            content.substr( 1 + context.getConf().htmlStructureExpressionPrefix.length ): 
            content;
        if ( ! expressionString ){
            throw tag + ' expression void.';
        }
        
        return constructorFunction(
            string,
            expressionBuilder.build( expressionString ),
            structure,
            expressionString
        );
    };
    
    var updateNode = function( node, structure, evaluated ){

        // Check default
        if ( evaluateHelper.isDefault( evaluated ) ){
            return true;
        }

        // Check nothing
        if ( evaluateHelper.isNothing( evaluated ) ){
            evaluated = "";
        }

        // Add it to node
        node.innerHTML = evaluated;
        if ( ! structure ) {
            node[ "form" in node && !formInputHasBody[ node.tagName ] ? "value": "innerText" ] = evaluated;
        }

        return true;
    };
    
    return {
        build: build,
        updateNode: updateNode
    };
})();

},{"../../context.js":27,"../../expressions/evaluateHelper.js":44,"../../expressions/expressionBuilder.js":46}],14:[function(require,module,exports){
/*
    TALAttributes class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../../expressions/expressionTokenizer.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );
var utils = require( '../../utils.js' );

var TALAttributes = function( stringToApply, attributeItemsToApply ) {
    
    var string = stringToApply;
    var attributeItems = attributeItemsToApply;
    
    var process = function( scope, node, attributeName ){
        
        for ( var i = 0; i < attributeItems.length; i++ ) {
            var attributeItem = attributeItems[ i ];
            var name = attributeItem.name;
            
            if ( ! attributeName || name === attributeName ){
                var value = attributeItem.expression.evaluate( scope );

                if ( name ){
                    processSimpleAttributeItem( node, name, value );
                } else {
                    processMapAttributeItem( node, value );
                }
            }
        }
    };

    var processMapAttributeItem = function( node, map ){
    
        // Do nothing if map is null
        if ( ! map ){
            return;
        }
        
        if ( ! utils.isPlainObject( map ) ){
            throw 'Invalid attribute value: "' + map + '". Object expected.';
        }
        
        for ( var name in map ){
            var value = map[ name ];
            processSimpleAttributeItem( node, name, value );
        }
    };
    
    var processSimpleAttributeItem = function( node, name, value ){
        
        // Boolean attributes
        if ( context.isBooleanAttribute( name ) ){
            if ( value ){
                node.setAttribute( name, '' );
            } else {
                node.removeAttribute( name );
            }
            return;
        }
        
        // If value is undefined don't parser the attribute
        if ( value == undefined ) {
            return;
        }
            
        // Alt attributes
        if ( context.isAltAttribute( name ) ) {
            switch ( name ) {
            case "innerHTML":
                throw node; // should use "qtext"
            case "style":
                node.style.cssText = value;
                break;
            /*
            case "text":
                node[ querySelectorAll ? name : innerText ] = value;
                break; // option.text unstable in IE
            */
            case "class":
                name = "className";
            default:
                node[ name ] = value;
            }
            return;
        } 

        // Regular attributes
        node.setAttribute( name, value );
    };

    var dependsOn = function( scope ){

        var result = [];
        var object = {};
        
        for ( var i = 0; i < attributeItems.length; i++ ) {
            var attributeItem = attributeItems[ i ];
            var dependsOnList = expressionsUtils.buildDependsOnList( undefined, scope, attributeItem.expression );
            if ( dependsOnList && dependsOnList.length > 0 ){
                object[ attributeItem.name ] = dependsOnList;
            }
        }
        
        if ( Object.keys( object ).length > 0 ){
            result.push( object );
        }
        
        return result;
    };
    
    var update = function( parserUpdater, node, scope, indexItem ){
        process( scope, node, indexItem.groupId );
    };
    
    var toString = function(){
        return "TALAttributes: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALAttributes.id
    };
};

TALAttributes.id = 'tal:attributes';

TALAttributes.build = function( string ) {

    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
    
    var attributeItems = [];
    var expressionString = string.trim();
    var tokens = new ExpressionTokenizer( 
            expressionString, 
            context.getConf().attributeDelimiter, 
            true );

    while ( tokens.hasMoreTokens() ) {
        var attribute = tokens.nextToken().trim();
        var space = attribute.indexOf( context.getConf().inAttributeDelimiter );
        if ( space === -1 ) {
            attributeItems.push({
                name: undefined,
                expression: expressionBuilder.build( attribute )
            });
        }
        var name = attribute.substring( 0, space );
        var valueExpression = attribute.substring( space + 1 ).trim();

        attributeItems.push({
            name: name,
            expression: expressionBuilder.build( valueExpression )
        });
    }
    
    return new TALAttributes( string, attributeItems );
};

module.exports = TALAttributes;

},{"../../context.js":27,"../../expressions/expressionBuilder.js":46,"../../expressions/expressionTokenizer.js":47,"../../expressions/expressionsUtils.js":48,"../../utils.js":101}],15:[function(require,module,exports){
/*
    TALCondition class
*/
"use strict";

var evaluateHelper = require( '../../expressions/evaluateHelper.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );
var context = require( '../../context.js' );

var TALCondition = function( stringToApply, expressionToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    
    var process = function( scope, node ){
        
        var result = evaluateHelper.evaluateBoolean( scope, expression );
        
        node.setAttribute( context.getTags().conditionResult, result );
        node.style.display = result ? '' : 'none';
        
        return result;
    };

    var dependsOn = function( scope ){
        return expressionsUtils.buildDependsOnList( undefined, scope, expression );
    };
    
    var update = function( parserUpdater, node ){
        parserUpdater.updateNode( node, true );
    };
    
    var updatableFromAction = function( parserUpdater, node ){
        
        var scope = parserUpdater.getNodeScope( node );
        var result = evaluateHelper.evaluateBoolean( scope, expression );
        var valueFromTag = 'true' === node.getAttribute( context.getTags().conditionResult );
        
        return result !== valueFromTag;
    };
    
    var toString = function(){
        return "TALCondition: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        updatableFromAction: updatableFromAction,
        toString: toString,
        type: TALCondition.id
    };
};

TALCondition.id = 'tal:condition';

TALCondition.build = function( string ) {
    
    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
    
    return new TALCondition( 
                string,
                expressionBuilder.build( string ) );
};

module.exports = TALCondition;

},{"../../context.js":27,"../../expressions/evaluateHelper.js":44,"../../expressions/expressionBuilder.js":46,"../../expressions/expressionsUtils.js":48}],16:[function(require,module,exports){
/*
    TALContent class
*/
"use strict";

var evaluateHelper = require( '../../expressions/evaluateHelper.js' );
var contentHelper = require( './contentHelper.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );

var TALContent = function( stringToApply, expressionToApply, structureToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    var structure = structureToApply;
    
    var process = function( scope, node ){
        
        return contentHelper.updateNode( 
            node, 
            structure, 
            evaluateHelper.evaluateToNotNull( scope, expression ) 
        );
    };

    var dependsOn = function( scope ){
        return expressionsUtils.buildDependsOnList( undefined, scope, expression );
    };
    
    var update = function( parserUpdater, node, scope ){
        process( scope, node );
    };
    
    var toString = function(){
        return "TALContent: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALContent.id
    };
};

TALContent.id = 'tal:content';

TALContent.build = function( string ) {
    
    return contentHelper.build( 
        'TALContent',
        string,
        function( _string, _expression, _structure ){
            return new TALContent( _string, _expression, _structure );
        }
    );
};

module.exports = TALContent;

},{"../../expressions/evaluateHelper.js":44,"../../expressions/expressionsUtils.js":48,"./contentHelper.js":13}],17:[function(require,module,exports){
/*
    TALDeclare class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../../expressions/expressionTokenizer.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );

var TALDeclare = function( _string, _declareItems ) {
    
    var string = _string;
    var declareItems = _declareItems;
    
    var process = function( scope, autoDefineHelper ){

        putVariables( scope, autoDefineHelper );

        return processDeclareItems( scope );
    };
    
    var putVariables = function( scope, autoDefineHelper ) {
        
        // Add strictModeVarName to the autoDefineHelper if needed
        var strictModeVarName = context.getConf().strictModeVarName;
        if ( true !== scope.get( strictModeVarName ) ){
            autoDefineHelper.put( strictModeVarName, 'true' );
        }
        
        // Build declared and required
        var declaredVarsVarName = context.getConf().declaredVarsVarName;
        var declared = scope.get( declaredVarsVarName ) || [];
        for ( var i = 0; i < declareItems.length; i++ ) {
            var declareItem = declareItems[ i ];
            declared.push( declareItem.name );
        }
        
        // Add declaredVarsVarName to the autoDefineHelper
        autoDefineHelper.put( 
            declaredVarsVarName, 
            expressionsUtils.buildList( declared, true )
        );
    };
    
    var processDeclareItems = function( scope ) {
        
        var errorsArray = [];

        for ( var i = 0; i < declareItems.length; i++ ) {
            var declareItem = declareItems[ i ];
            var errors = checkDeclareItem(
                scope,
                declareItem.name,
                declareItem.type,
                declareItem.required,
                declareItem.defaultValueString,
                declareItem.defaultValueExpression
            );
            errorsArray = errorsArray.concat( errors );
        }

        processErrorsArray( errorsArray );

        return errorsArray.length === 0;
    };

    var checkDeclareItem = function( scope, name, type, required, defaultValueString, defaultValueExpression ) {
        
        var errorsArray = [];
        
        var value = scope.get( name );
        
        // Set default value if needed
        if ( value === undefined && defaultValueExpression !== undefined ){
            var setDefaultValueError = setDefaultValue( scope, name, type, defaultValueString, defaultValueExpression );
            if ( setDefaultValueError ){
                errorsArray.push( setDefaultValueError );
                return errorsArray;
            }
            value = scope.get( name );
        }
        
        // Check type
        var typeCheckError = checkType( name, type, value );
        if ( typeCheckError ){
            errorsArray.push( typeCheckError );
        }
        
        // Check required
        var requiredCheckError = checkRequired( name, required, value );
        if ( requiredCheckError ){
            errorsArray.push( requiredCheckError );
        }
        
        return errorsArray;
    };
    
    var checkType = function( name, expectedType, value ) {
        
        if ( ! expectedType ){
            return;
        }
        
        var realType = getTypeOf( value );
        return realType === expectedType.toLowerCase()? 
            false: 
            'Expected value type (' + expectedType.toLowerCase() + ') of ' + name + ' property does not match type (' + realType + '), value is "' + value + '".';
    };
    
    /*
        typeOf();                   // undefined
        typeOf(null);               // null
        typeOf(NaN);                // number
        typeOf(5);                  // number
        typeOf([]);                 // array
        typeOf('');                 // string
        typeOf(function () {});     // function
        typeOf(/a/)                 // regexp
        typeOf(new Date())          // date
        typeOf(new Error)           // error
        typeOf(Promise.resolve())   // promise
        typeOf(function *() {})     // generatorfunction
        typeOf(new WeakMap())       // weakmap
        typeOf(new Map())           // map
        typeOf({});                 // object
        typeOf(new MyConstructor()) // MyConstructor
    */
    var getTypeOf = function( value ){
        
        var temp = {}.toString.call( value ).split(' ')[ 1 ].slice( 0, -1 ).toLowerCase();
        return temp === 'object'? 
            value.constructor.name.toLowerCase(): 
            temp;
    };
    
    var checkRequired = function( name, required, value ) {
        
        return true === required && value === undefined? 
            'Required value must not be undefined: ' + name:
            false;
    };
    
    var setDefaultValue = function( scope, name, type, defaultValueString, defaultValueExpression ) {
        
        try {
            var defaultValue = defaultValueExpression.evaluate( scope );
            scope.set( name, defaultValue );
            return false;
            
        } catch ( e ) {
            return 'Error trying to evaluate default value of field ' + name + ', expression [' + defaultValueString + ']: ' + e;
        }
    };
    
    var processErrorsArray = function( errorsArray ) {

        if ( errorsArray.length === 0 ){
            return;
        }
        
        throw errorsArray;
    };
    
    var dependsOn = function(){
        return [];
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return "TALDeclare: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALDeclare.id
    };
};

TALDeclare.id = 'tal:declare';

TALDeclare.build = function( string ) {

    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );

    var declareItems = [];
    var omitTypes = [ 'undefined', 'null' ];
    
    var tokens = new ExpressionTokenizer( 
        string.trim(), 
        context.getConf().declareDelimiter, 
        true 
    );

    while ( tokens.hasMoreTokens() ) {
        
        var inPropTokens = new ExpressionTokenizer( 
            tokens.nextToken().trim(), 
            context.getConf().inDeclareDelimiter, 
            true 
        );
        
        var name = undefined;
        var type = undefined;
        var defaultValueString = undefined;
        var required = false;
        var state = 1;
        while ( inPropTokens.hasMoreTokens() ){
            var currentToken = inPropTokens.nextToken();
            if ( TALDeclare.tokenIsRequired( currentToken ) ){
                required = true;
                continue;
            }
            switch ( state ) {
                case 1:
                    name = currentToken;
                    break;
                case 2:
                    if ( -1 === omitTypes.indexOf( currentToken.toLowerCase() ) ){
                        type = currentToken;   
                    }
                    break;
                case 3:
                    defaultValueString = currentToken;
                    break;
                default:
                    throw 'Too many arguments in talDeclare item: ' + string.trim();
            }
            ++state;
        }
        
        // The name is the only required element
        if ( ! name ){
            continue;
        }
        
        declareItems.push({
            name: name,
            type: type,
            required: required,
            defaultValueString: defaultValueString,
            defaultValueExpression: defaultValueString == undefined? undefined: expressionBuilder.build( defaultValueString )
        });
    }

    return new TALDeclare( string, declareItems );
};

TALDeclare.tokenIsRequired = function( token ) {
    return "required" === token.toLowerCase();
};

module.exports = TALDeclare;

},{"../../context.js":27,"../../expressions/expressionBuilder.js":46,"../../expressions/expressionTokenizer.js":47,"../../expressions/expressionsUtils.js":48}],18:[function(require,module,exports){
/*
    TALDefine class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../../expressions/expressionTokenizer.js' );

var TALDefine = function( stringToApply, defineItemsToApply ) {
    
    var string = stringToApply;
    var defineItems = defineItemsToApply;
    
    var process = function( scope, forceGlobal ){
        
        // Update scope
        for ( var i = 0; i < defineItems.length; i++ ) {
            var defineItem = defineItems[ i ];
            scope.set( 
                    defineItem.name, 
                    defineItem.nocall? defineItem.expression: defineItem.expression.evaluate( scope ), 
                    forceGlobal || defineItem.global,
                    defineItem.nocall,
                    defineItem.expression
            );
        }
    };
    
    var dependsOn = function(){
        return [];
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return "TALDefine: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALDefine.id
    };
};

TALDefine.id = 'tal:define';

TALDefine.build = function( string ) {

    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );

    var defineItems = [];
    var expressionString = string.trim();
    var tokens = new ExpressionTokenizer( 
        expressionString, 
        context.getConf().defineDelimiter, 
        true );

    while ( tokens.hasMoreTokens() ) {
        var variable = tokens.nextToken().trim();
        var space = variable.indexOf( context.getConf().inDefineDelimiter );
        if ( space === -1 ) {
            throw 'Bad variable definition: ' + variable;
        }

        var nocall = false;
        var global = false;
        var currentToken = variable.substring( 0, space );
        var nextTokens = variable.substring( space + 1 ).trim();
        var tokenDone = false;
        do {
            var specialToken = false;
            if ( context.getConf().globalVariableExpressionPrefix === currentToken ){
                global = true;
                specialToken = true;
            } else if ( context.getConf().nocallVariableExpressionPrefix === currentToken ){
                nocall = true;  
                specialToken = true;
            } 
            
            if ( specialToken ){
                space = nextTokens.indexOf( context.getConf().inDefineDelimiter );
                currentToken = nextTokens.substring( 0, space );
                nextTokens = nextTokens.substring( space + 1 ).trim();
                
            } else {
                defineItems.push({
                    name: currentToken,
                    expression: expressionBuilder.build( nextTokens ),
                    global: global,
                    nocall: nocall
                });
                tokenDone = true;
            }

        } while( ! tokenDone && space !== -1 );
    }

    return new TALDefine( string, defineItems );
};


TALDefine.appendStrings = function() {
    
    var result = arguments[ 0 ];
    
    for ( var c = 1; c < arguments.length; ++c ){
        var string = arguments[ c ];
        if ( string ){
            result = result? result + context.getConf().defineDelimiter + string: string;
        }
    }
    
    return result;
};

TALDefine.updateAttribute = function( node, defineToAdd ){

    var tags = context.getTags();
    var nodeDefine = node.getAttribute( tags.talDefine );
    var fullDefine = TALDefine.appendStrings( defineToAdd, nodeDefine );

    if ( fullDefine ){
        node.setAttribute( tags.talDefine, fullDefine );
    }
};

module.exports = TALDefine;

},{"../../context.js":27,"../../expressions/expressionBuilder.js":46,"../../expressions/expressionTokenizer.js":47}],19:[function(require,module,exports){
/*
    TALOmitTag class
*/
"use strict";

var BooleanLiteral = require( '../../expressions/path/literals/booleanLiteral.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );
var context = require( '../../context.js' );

var TALOmitTag = function( stringToApply, expressionToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    
    var process = function( scope, node, parserNodeRenderer ){
        
        var result = expression.evaluate( scope );
        if ( ! result ){
            return false;
        }
        
        // Process the contents
        parserNodeRenderer.defaultContent( node );
        
        // Move children from current node to its parent and then remove it
        var tags = context.getTags();
        var parentNode = node.parentNode;
        while ( node.firstChild ) {
            if ( node.firstChild.nodeType === 1 ){
                node.firstChild.setAttribute( tags.qdup, 1 );
            }
            parentNode.appendChild( node.firstChild );
        }
        parentNode.removeChild( node );

        return true;
    };
    
    var dependsOn = function( scope ){
        return expressionsUtils.buildDependsOnList( undefined, scope, expression );
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return "TALOmitTag: " + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALOmitTag.id
    };
};

TALOmitTag.id = 'tal:omit-tag';

TALOmitTag.build = function( string ) {
    
    var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
    
    var expressionString = string.trim();
    var expression = expressionString == ''?
            new BooleanLiteral( true ):
            expressionBuilder.build( expressionString );
    
    return new TALOmitTag( string, expression );
};

module.exports = TALOmitTag;

},{"../../context.js":27,"../../expressions/expressionBuilder.js":46,"../../expressions/expressionsUtils.js":48,"../../expressions/path/literals/booleanLiteral.js":59}],20:[function(require,module,exports){
/*
    TALOnError class
*/
"use strict";

var context = require( '../../context.js' );
var contentHelper = require( './contentHelper.js' );

var TALOnError = function( stringToApply, structureToApply ) {
    
    var string = stringToApply;
    var structure = structureToApply;
    
    var putToAutoDefineHelper = function( autoDefineHelper ){

        // Add onErrorVarName to the autoDefineHelper
        autoDefineHelper.put(
            context.getConf().onErrorVarName,
            string,
            true
        );
        
        // Add onErrorStructureVarName to the autoDefineHelper
        autoDefineHelper.put(
            context.getConf().onErrorStructureVarName,
            structure,
            false
        );
    };

    var dependsOn = function(){
        return [];
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return "TALOnError: " + string;
    };
    
    return {
        putToAutoDefineHelper: putToAutoDefineHelper,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALOnError.id
    };
};

TALOnError.id = 'tal:on-error';

TALOnError.build = function( string ) {

    return contentHelper.build( 
        'TALOnError',
        string,
        function( _string, _expression, _structure, _expressionString ){
            return new TALOnError( _expressionString, _structure );
        }
    );
};

module.exports = TALOnError;

},{"../../context.js":27,"./contentHelper.js":13}],21:[function(require,module,exports){
/*
    TALRepeat class
*/
"use strict";

var expressionsUtils = require( '../../expressions/expressionsUtils.js' );
var expressionBuilder = require( '../../expressions/expressionBuilder.js' );
var Loop = require( '../../parsers/loop.js' );

var TALRepeat = function( stringToApply, varNameToApply, expressionStringToApply ) {
    
    var string = stringToApply;
    var varName = varNameToApply;
    var expressionString = expressionStringToApply;
    var expression = expressionBuilder.build( expressionString );
    var loop;
    
    var process = function( scope ){
        loop = new Loop( varName, expressionString, scope );
        return loop;
    };
    
    var dependsOn = function( scope ){
        return expressionsUtils.buildDependsOnList( undefined, scope, expression );
    };
    
    var update = function( parserUpdater, node ){
        parserUpdater.updateNode( node );
    };
    
    var toString = function(){
        return "TALRepeat: " + string;
    };
    
    var getExpressionString = function(){
        return expressionString;
    };
    
    var getVarName = function(){
        return varName;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALRepeat.id,
        getExpressionString: getExpressionString,
        getVarName: getVarName
    };
};

TALRepeat.id = 'tal:repeat';

TALRepeat.build = function( string ) {
    
    var expressionString = string.trim();
    var space = expressionString.indexOf( ' ' );
    if ( space === -1 ) {
        throw 'Bad repeat expression: ' + expressionString;
    }
    var varName = expressionString.substring( 0, space );
    var loopExpression = expressionString.substring( space + 1 );
    
    return new TALRepeat( string, varName, loopExpression );
};

module.exports = TALRepeat;

},{"../../expressions/expressionBuilder.js":46,"../../expressions/expressionsUtils.js":48,"../../parsers/loop.js":88}],22:[function(require,module,exports){
/*
    TALReplace class
*/
"use strict";

var evaluateHelper = require( '../../expressions/evaluateHelper.js' );
var contentHelper = require( './contentHelper.js' );
var expressionsUtils = require( '../../expressions/expressionsUtils.js' );

var TALReplace = function( stringToApply, expressionToApply, structureToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    var structure = structureToApply;
    
    var process = function( scope, node ){
        
        // Evaluate
        var evaluated = evaluateHelper.evaluateToNotNull( scope, expression );
        
        // Check default
        if ( evaluateHelper.isDefault( evaluated ) ){
            return true;
        }

        // Check nothing
        if ( evaluateHelper.isNothing( evaluated ) ){
            evaluated = "";
        }
        
        if ( structure ){
            // Replace HTML
            node.outerHTML = evaluated;
            
        } else {
            // Replace original node by new text node
            var textNode = node.ownerDocument.createTextNode( evaluated );
            node.parentNode.replaceChild( textNode, node );
        }
        
        return true;
    };
    
    var dependsOn = function( scope ){
        //return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression );
        return expressionsUtils.buildDependsOnList( undefined, scope, expression );
    };
    
    var update = function(){
        // Nothing to do
    };
    
    var toString = function(){
        return 'TALReplace: ' + string;
    };
    
    return {
        process: process,
        dependsOn: dependsOn,
        update: update,
        toString: toString,
        type: TALReplace.id
    };
};

TALReplace.id = 'tal:replace';

TALReplace.build = function( string ) {

    return contentHelper.build( 
        'TALReplace',
        string,
        function( _string, _expression, _structure ){
            return new TALReplace( _string, _expression, _structure );
        }
    );
};

module.exports = TALReplace;

},{"../../expressions/evaluateHelper.js":44,"../../expressions/expressionsUtils.js":48,"./contentHelper.js":13}],23:[function(require,module,exports){
/* 
    attributeIndex singleton class
*/
"use strict";

var utils = require( '../utils.js' );
var context = require( '../context.js' );

module.exports = (function() {
    
    var map;
    
    var reset = function(){
        map = {};
    };
    reset();
    
    var add = function( node, attributeInstance, scope ){
        
        addList(
            node,
            attributeInstance,
            attributeInstance.dependsOn( scope )
        );
    };
    
    var addList = function( node, attributeInstance, list, groupId ){
        
        for ( var i = 0; i < list.length; i++ ) {
            addAny( node, attributeInstance, list[ i ], groupId );
        }
    };
    var addObject = function( node, attributeInstance, item ){
        
        for ( var groupId in item ){
            addAny( node, attributeInstance, item[ groupId ], groupId );
        }
    };
    var addAny = function( node, attributeInstance, item, groupId ){
        
        if ( utils.isPlainObject( item ) ){
            addObject( node, attributeInstance, item );
        } else if ( Array.isArray( item ) ){
            addList( node, attributeInstance, item, groupId );
        } else {
            addVar( node, attributeInstance, item, groupId );
        }
    };
    /*
    var addVar = function( node, attributeInstance, varName, groupId  ){
        
        var list = map[ varName ];
        if ( ! list ){
            list = [];
            map[ varName ] = list;
        }

        list.push(
            {
                attributeInstance: attributeInstance,
                nodeId: node.getAttribute( context.getTags().id ),
                groupId: groupId
            }
        );
    };
    */
    var addVar = function( node, attributeInstance, varName, groupId  ){
        
        var list = map[ varName ];
        if ( ! list ){
            list = [];
            map[ varName ] = list;
        }
        
        var newItem = {
            attributeInstance: attributeInstance,
            nodeId: node.getAttribute( context.getTags().id ),
            groupId: groupId
        };
        
        //var index = list.findIndex( item => utils.deepEqual( item, newItem ) );
        var index = list.findIndex( 
            function( item ) { 
                return utils.deepEqual( item, newItem );
            }
        );
        if ( index === -1 ){
            list.push( newItem );
        } else {
            list[ index ] = newItem;
        }
    };
    
    var getVarsList = function( varName ){
        
        var items = map[ varName ];
        
        // Return an empty list if needed
        if ( items === undefined ){
            return [];
        }
        
        // Remove items with removed nodes
        cleanItems( items );
        
        // We must build another list to avoid sync errors
        var result = [];
        result = result.concat( items );
        return result;
    };
    
    //TODO findNodeById duplicated
    var findNodeById = function ( nodeId ) {
        
        return window.document.querySelector( 
            '[' + context.getTags().id + '="' + nodeId + '"]' 
        );
    };
    
    // Iterate through items and remove them when node does not exist in DOM
    var cleanItems = function( items ){
        
        var indexesToRemove = [];
        
        // Build list of items to remove
        for ( var i = 0; i < items.length; ++i ){
            var item = items[ i ];
            var node = findNodeById( item.nodeId );
            if ( ! node ){
                indexesToRemove.push( i );
            }
        }
        
        // Remove items
        for ( var j = indexesToRemove.length - 1; j >= 0 ; --j ){
            var indexToRemove = indexesToRemove[ j ];
            items.splice( indexToRemove, 1 );
        };
    };
    /*
    var removeVar = function( varName, nodeId ){
        
        var list = map[ varName ];

        var filtered = list.filter(
            function( value, index, arr ){
                return value.nodeId !== nodeId;
            }
        );

        map[ varName ] = filtered;
    };
    
    var removeVarFromNodes = function( varName, nodeIds ){
        
        var list = map[ varName ];

        var filtered = list.filter(
            function( value, index, arr ){
                return nodeIds.indexOf( value.nodeId ) === -1;
            }
        );

        if ( filtered.length === 0 ){
            delete map[ varName ];
        } else {
            map[ varName ] = filtered;
        }
        
    };
    
    var getAllNodeIds = function( target ){
        
        // Get the list
        var list = target.querySelectorAll( '[' + context.getTags().id + ']' );

        // Iterate the list
        var result = [];
        var nodeIdAttributeName = context.getTags().id;
        var node;
        var pos = 0;
        while ( node = list[ pos++ ] ) {
            result.push( 
                node.getAttribute( nodeIdAttributeName ) 
            );
        }
        
        return result;
    };
    
    var removeNode = function( node ){

        var nodeIds = getAllNodeIds( node );

        var nodeId = node.getAttribute( context.getTags().id );
        nodeIds.push( nodeId );
        
        for ( var varName in map ){
            removeVarFromNodes( varName, nodeIds );
        }
    };
    
    var removeMultipleNodes = function( nodeIds ){

        for ( var varName in map ){
            removeVarFromNodes( varName, nodeIds );
        }
    };
    */
    return {
        add: add,
        getVarsList: getVarsList,
        //removeVar: removeVar,
        //removeNode: removeNode,
        //removeMultipleNodes: removeMultipleNodes,
        reset: reset
    };
})();

},{"../context.js":27,"../utils.js":101}],24:[function(require,module,exports){
/*
    attributeCache singleton class
*/
"use strict";

var CacheHelper = require( './cacheHelper.js' );
var context = require( '../context.js' );
var log = require( '../logHelper.js' );
var attributeIndex = require( '../attributes/attributeIndex.js' );

module.exports = (function() {
    
    var map;
    
    var reset = function(){
        map = {};
    };
    reset();
    
    var get = function( attribute, string ) {
        
        var attributeMap = map[ attribute ];
        
        if ( ! attributeMap ){
            return null;
        }
         
        return attributeMap[ CacheHelper.hashCode( string ) ];
    };
    
    var put = function( attribute, string, value ){
        
        var attributeMap = map[ attribute ];
        
        if ( ! attributeMap ){
            attributeMap = {};
            map[ attribute ] = attributeMap;
        }
        
        attributeMap[ CacheHelper.hashCode( string ) ] = value;
    };
    
    var index = function( node, attribute, scope ){
        
        if ( node ){
            log.debug( 'Must index!' );
            attributeIndex.add( node, attribute, scope );
            
        } else {
            log.debug( 'Not indexed!' );
        }
        
        return attribute;
    };
    
    var getByDetails = function( attributeType, string, buildFunction, force, node, scope ) {
        
        log.debug( 
            'Request building of ZPT attribute "' + string + '", force "' + force + '"' );
        
        // Get from cache if possible
        if ( force || ! context.getConf().attributeCacheOn ){
            log.debug( 'Cache OFF!' );
            
        } else {
            log.debug( 'Cache ON!' );
            var fromCache = get( attributeType, string );
            if ( fromCache ){
                log.debug( 'Found in cache!' );
                //return fromCache;
                return index( node, fromCache, scope );
            } else {
                log.debug( 'NOT found in cache!' );
            }
        }
        
        // Force build and put into cache
        log.debug( 'Must build!' );
        var builded = buildFunction();
        put( attributeType, string, builded );
        //return builded;
        return index( node, builded, scope );
    };
    
    var getByAttributeClass = function( attributeInstance, string, node, indexExpressions, scope, constructor ) {
        
        return getByDetails( 
                attributeInstance.id, 
                string, 
                constructor || function(){
                    return attributeInstance.build( string );
                }, 
                false,
                indexExpressions? node: undefined,
                scope
        );
    };
    
    return {
        //getByDetails: getByDetails,
        getByAttributeClass: getByAttributeClass,
        reset: reset
    };
})();

},{"../attributes/attributeIndex.js":23,"../context.js":27,"../logHelper.js":74,"./cacheHelper.js":25}],25:[function(require,module,exports){
/*
    cacheHelper singleton class
*/
module.exports = (function() {
    "use strict";
    
    var hashCode = function( string ) {

        if ( Array.prototype.reduce ) {
            return string.split( "" ).reduce(
                function( a, b ){
                    a = ( ( a << 5 ) - a ) + b.charCodeAt( 0 );
                    return a&a
                },
                0 );
        }

        var hash = 0;
        if ( string.length === 0 ){
            return hash;
        }
        for ( var i = 0, len = string.length; i < len; i++ ) {
            var chr = string.charCodeAt( i );
            hash = ( ( hash << 5 ) - hash ) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        
        return hash;
    };
    
    return {
        hashCode: hashCode
    };
})();

},{}],26:[function(require,module,exports){
/*
    expressionCache singleton class
*/
module.exports = (function() {
    "use strict";
    
    var CacheHelper = require( './cacheHelper.js' );
    var context = require( '../context.js' );
    var log = require( '../logHelper.js' );
    
    var map = {};
    
    var get = function( string ) {
        return map[ CacheHelper.hashCode( string ) ];
    };
    
    var put = function( string, value ){
        map[ CacheHelper.hashCode( string ) ] = value;
    };
    
    var process = function( string, buildFunction, force ) {
        
        log.debug( 
            'Request building of expression "' + string + '", force "' + force + '"' );
        
        // Get from cache if possible
        if ( ! force && context.getConf().expressionCacheOn ){
            log.debug( 'Cache ON!' );
            var fromCache = get( string );
            if ( fromCache ){
                log.debug( 'Found in cache!' );
                return fromCache;
            } 
            log.debug( 'NOT found in cache!' );
            
        } else {
            log.debug( 'Cache OFF!' );
        }
        
        // Force build and put into cache
        log.debug( 'Must build!' );
        var builded = buildFunction();
        put( string, builded );
        return builded;
    };
    
    var clean = function( ) {
        map = {};
    };
    
    return {
        get: process,
        clean: clean
    };
})();

},{"../context.js":27,"../logHelper.js":74,"./cacheHelper.js":25}],27:[function(require,module,exports){
/* 
    context singleton class
*/

var log4javascript = require( 'log4javascript' );
var utils = require( './utils.js' );
var LoopItem = require( './parsers/loopItem.js' );
var CSSAnimationManager = require( './parsers/dictionaryActions/cssAnimationManager.js' );

module.exports = (function() {
    "use strict";
    
    /* Tags */
    var defaultTags = {
        talCondition:     "data-condition",
        talRepeat:        "data-repeat",
        talAttributes:    "data-attributes",
        talContent:       "data-content",
        talDefine:        "data-define",
        talAutoDefine:    "data-tauto-define",
        talOmitTag:       "data-omit-tag",
        talReplace:       "data-replace",
        talOnError:       "data-on-error",
        talDeclare:         "data-declare",
        metalDefineMacro: "data-define-macro",
        metalUseMacro:    "data-use-macro",
        metalDefineSlot:  "data-define-slot",
        metalFillSlot:    "data-fill-slot",
        metalMacro:       "data-mmacro",
        i18nDomain:       "data-domain",
        i18nLanguage:     "data-language",
        //scopeKey:         "data-scope-key",
        rootKey:          "data-root-key",
        qdup:             "data-qdup",
        id:               "data-id",
        relatedId:        "data-related-id",
        conditionResult:  "data-condition-result"
    };
    var originalTags = {
        talCondition:     "tal:condition",
        talRepeat:        "tal:repeat",
        talAttributes:    "tal:attributes",
        talContent:       "tal:content",
        talDefine:        "tal:define",
        talAutoDefine:    "tal:auto-define",
        talOmitTag:       "tal:omit-tag",
        talReplace:       "tal:replace",
        talOnError:       "tal:on-error",
        talDeclare:       "tal:declare",
        metalDefineMacro: "metal:define-macro",
        metalUseMacro:    "metal:use-macro",
        metalDefineSlot:  "metal:define-slot",
        metalFillSlot:    "metal:fill-slot",
        metalMacro:       "data-mmacro",
        i18nDomain:       "i18n:domain",
        i18nLanguage:     "i18n:language",
        //scopeKey:         "data-scope-key",
        rootKey:          "data-root-key",
        qdup:             "data-qdup",
        id:               "data-id",
        relatedId:        "data-related-id",
        conditionResult:  "data-condition-result"
    };
    var tags = defaultTags;
    var tal = '';
    
    var getTags = function (){
        return tags;
    };
    
    var setTags = function ( tagsToSet ){
        tags = tagsToSet;
        tal = '';
    };
    
    var getTal = function (){
        if ( tal === '' ){
            var c = 0;
            var notInclude = tags.qdup;
            for ( var property in tags ) {
                if ( notInclude === tags[ property ] ){
                    continue;
                }
                if ( c++ > 0){
                    tal += ",";
                }
                tal += "*[" + tags[ property ] + "]";
            }
        }
        
        return tal;
    };
    var useOriginalTags = function(){
        setTags( originalTags );
    };
    /* End Tags */
    
    /* Formatters */
    var formatters = {};
    formatters.lowerCase = function ( value ){
        return value.toLocaleLowerCase();
    };
    formatters.upperCase = function ( value ){
        return value.toLocaleUpperCase();
    };
    formatters.localeDate = function ( value ){
        return value.toLocaleDateString;
    };
    formatters.localeTime = function ( value ){
        return value.toLocaleTimeString;
    };
    formatters.localeString = function ( value, locale ){
        return locale? 
               value.toLocaleString( value, locale ): 
               value.toLocaleString( value );
    };
    formatters.fix = function ( number, fixTo ){
        return number.toFixed( fixTo );
    };
    
    var getFormatter = function ( id ){
        return formatters[ id ];
    };
    
    var registerFormatter = function ( id, formatter ){
        formatters[ id ] = formatter;
    };
    var unregisterFormatter = function ( id ){
        delete formatters[ id ];
    };
    /* End Formatters */
    
    /* Conf */
    var EXPRESSION_SUFFIX = ':';
    var PRIVATE_VARS_PREFIX = '_';
    var defaultConf = {
        pathDelimiter:          '|',
        pathSegmentDelimiter:   '/',
        expressionDelimiter:    ' ',
        intervalDelimiter:      ':',
        propertyDelimiter:      '/',
        defineDelimiter:        ';',
        inDefineDelimiter:      ' ',
        attributeDelimiter:     ';',
        inAttributeDelimiter:   ' ',
        domainDelimiter:        ' ',
        i18nOptionsDelimiter:   ';',
        inI18nOptionsDelimiter: ' ',
        argumentsDelimiter:     ',',
        macroDelimiter:         '@',
        declareDelimiter:         ';',
        inDeclareDelimiter:       ' ',
        
        i18nConfResourceId:      "/CONF/",
        
        htmlStructureExpressionPrefix:  "structure",
        globalVariableExpressionPrefix: "global",
        nocallVariableExpressionPrefix: "nocall",
        
        templateErrorVarName:    "error",
        onErrorVarName:          PRIVATE_VARS_PREFIX + "on-error",
        onErrorStructureVarName: PRIVATE_VARS_PREFIX + "on-error-structure",
        i18nDomainVarName:       PRIVATE_VARS_PREFIX + "i18nDomain",
        i18nLanguageVarName:     PRIVATE_VARS_PREFIX + "i18nLanguage",
        externalMacroUrlVarName: PRIVATE_VARS_PREFIX + "externalMacroUrl",
        strictModeVarName:       PRIVATE_VARS_PREFIX + "strictMode",
        declaredVarsVarName:     PRIVATE_VARS_PREFIX + "declaredVars",
        repeatVarName:           PRIVATE_VARS_PREFIX + "repeat",
        
        windowVarName:           "window",
        contextVarName:          "context",
        
        nothingVarName:          "nothing",
        defaultVarName:          "default",
        nothingVarValue:         "___nothing___",
        defaultVarValue:         "___default___",
        
        loggingOn:    false,
        loggingLevel: log4javascript.Level.ERROR,

        externalMacroPrefixURL: "",
        variableNameRE:         /^[A-Za-z0-9_/-]+$/,
        expressionCacheOn:      true,
        attributeCacheOn:       true,

        expressionSuffix:     EXPRESSION_SUFFIX,
        stringExpression:     "string" + EXPRESSION_SUFFIX,
        existsExpression:     "exists" + EXPRESSION_SUFFIX,
        notExpression:        "not" + EXPRESSION_SUFFIX,
        javaScriptExpression: "js" + EXPRESSION_SUFFIX,
        equalsExpression:     "eq" + EXPRESSION_SUFFIX,
        greaterExpression:    "gt" + EXPRESSION_SUFFIX,
        lowerExpression:      "lt" + EXPRESSION_SUFFIX,
        addExpression:        "+" + EXPRESSION_SUFFIX,
        subExpression:        "-" + EXPRESSION_SUFFIX,
        mulExpression:        "*" + EXPRESSION_SUFFIX,
        divExpression:        "/" + EXPRESSION_SUFFIX,
        modExpression:        "%" + EXPRESSION_SUFFIX,
        orExpression:         "or" + EXPRESSION_SUFFIX,
        andExpression:        "and" + EXPRESSION_SUFFIX,
        condExpression:       "cond" + EXPRESSION_SUFFIX,
        formatExpression:     "format" + EXPRESSION_SUFFIX,
        trExpression:         "tr" + EXPRESSION_SUFFIX,
        trNumberExpression:   "trNumber" + EXPRESSION_SUFFIX,
        trCurrencyExpression: "trCurrency" + EXPRESSION_SUFFIX,
        trDateTimeExpression: "trDate" + EXPRESSION_SUFFIX,
        inExpression:         "in" + EXPRESSION_SUFFIX,
        queryExpression:      "query" + EXPRESSION_SUFFIX,
        pathExpression:       "",
        
        firstIndexIdentifier: "_first_",
        lastIndexIdentifier:  "_last_"
    };
    var conf = defaultConf;
    
    var getConf = function (){
        return conf;
    };
    
    var setConf = function ( confToSet ){
        conf = confToSet;
    };
    /* End conf */
    
    /* Logger */
    var logger;
    var getDefaultLogger = function (){
        
        var defaultLogger = log4javascript.getDefaultLogger();
        
        defaultLogger.setLevel( getConf().loggingLevel );
        //defaultLogger.removeAllAppenders();
        //defaultLogger.addAppender( new log4javascript.BrowserConsoleAppender( true ) );
        
        return defaultLogger;
    };
    var getLogger = function (){
        
        if ( ! logger && getConf().loggingOn ){
            logger = getDefaultLogger();
        }
        
        return logger;
    };
    var setLogger = function ( loggerToSet ){
        logger = loggerToSet;
    };
    /* End Logger */
    
    /* 
        Boolean attributes:
        The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value.
    */
    var booleanAttributes = {
        checked: 1,
        compact: 1,
        declare: 1,
        defer: 1,
        disabled: 1,
        ismap: 1,
        multiple: 1,
        nohref: 1,
        noresize: 1,
        noshade: 1,
        nowrap: 1,
        readonly: 1,
        selected: 1
    };
    
    var getBooleanAttributes = function (){
        return booleanAttributes;
    };
    var setBooleanAttributes = function ( booleanAttributesToSet ){
        booleanAttributes = booleanAttributesToSet;
    };
    var isBooleanAttribute = function ( attribute ){
        return booleanAttributes[ attribute ] === 1;
    };
    /* End Boolean attributes */
    
    /* 
        Alt attributes:
        Attributes which don't support setAttribute().
    */
    var altAttributes = {
        className: 1,
        class: 1,
        href: 1,
        htmlFor: 1,
        id: 1,
        innerHTML: 1,
        label: 1,
        style: 1,
        src: 1,
        text: 1,
        title: 1,
        value: 1
    };
    // All booleanAttributes are also altAttributes
    utils.extend( altAttributes, booleanAttributes );
    
    var getAltAttributes = function (){
        return altAttributes;
    };
    var setAltAttributes = function ( altAttributesToSet ){
        altAttributes = altAttributesToSet;
    };
    var isAltAttribute = function ( attribute ){
        return altAttributes[ attribute ] === 1;
    };
    /* End Alt attributes */
    
    /* Errors */
    var defaultErrorFunction = function( error ) {
        
        var msg = Array.isArray( error )?
            error.join( '\n' ):
            error;
        
        window.alert( msg );
        
        throw msg;
    };
    var errorFunction = defaultErrorFunction;
    var setErrorFunction = function( _errorFunction ){
        self.errorFunction = _errorFunction;
    };
    var asyncError = function( url, errorMessage, failCallback ){

        var msg = 'Error trying to get ' + url + ': ' + errorMessage;
        if ( failCallback ){
            failCallback( msg );
        } else {
            errorFunction( msg );
        }
    };
    /* End errors */
    
    /* Repeat */
    var repeat = function( index, length, offset ){
        return new LoopItem( index, length, offset );
    };
    /* End repeat*/
    
    /* Folder dictionaries */
    var folderDictionaries = [];
    var setFolderDictionaries = function( _folderDictionaries ){
        folderDictionaries = _folderDictionaries;
    };
    var getFolderDictionaries = function(){
        return folderDictionaries;
    };
    /* End folder dictionaries */
    
    /* Strict mode  */
    var strictMode = false;
    var setStrictMode = function( _strictMode ){
        strictMode = _strictMode;
    };
    var isStrictMode = function(){
        return strictMode;
    };
    /* End strict mode  */
    
    /* Expression counter */
    var expressionCounter = 0;
    var nextExpressionCounter = function(){
        return ++expressionCounter;
    };
    var setExpressionCounter = function( _expressionCounter ){
        expressionCounter = _expressionCounter;
    };
    /* End expression counter */
    
    /* Run counter */
    var runCounter = 0;
    var nextRunCounter = function(){
        return ++runCounter;
    };
    /* End run counter */
    
    /* Animation managers */
    var defaultAnimationManager = CSSAnimationManager;
    var animationManager = defaultAnimationManager;
    var getAnimationManager = function(){
        return animationManager;
    };
    var setAnimationManager = function( _animationManager ){
        animationManager = _animationManager;
    };
    /* End animation managers*/
    
    var self = {
        getTags: getTags,
        setTags: setTags,
        getTal: getTal,
        getFormatter: getFormatter,
        registerFormatter: registerFormatter,
        unregisterFormatter: unregisterFormatter,
        getConf: getConf,
        setConf: setConf,
        getLogger: getLogger,
        setLogger: setLogger,
        useOriginalTags: useOriginalTags,
        getBooleanAttributes: getBooleanAttributes,
        setBooleanAttributes: setBooleanAttributes,
        isBooleanAttribute: isBooleanAttribute,
        getAltAttributes: getAltAttributes,
        setAltAttributes: setAltAttributes,
        isAltAttribute: isAltAttribute,
        errorFunction: errorFunction,
        setErrorFunction: setErrorFunction,
        asyncError: asyncError,
        repeat: repeat,
        setFolderDictionaries: setFolderDictionaries,
        getFolderDictionaries: getFolderDictionaries,
        setStrictMode: setStrictMode,
        isStrictMode: isStrictMode,
        nextExpressionCounter: nextExpressionCounter,
        setExpressionCounter: setExpressionCounter,
        nextRunCounter: nextRunCounter,
        getAnimationManager: getAnimationManager,
        setAnimationManager: setAnimationManager
    };
    
    return self;
})();

},{"./parsers/dictionaryActions/cssAnimationManager.js":84,"./parsers/loopItem.js":89,"./utils.js":101,"log4javascript":3}],28:[function(require,module,exports){
/*
    AddExpression class
*/
"use strict";

var context = require( '../../context.js' );
var arithmethicHelper = require( './arithmethicHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var AddExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        return arithmethicHelper.evaluate( 
            string,
            scope,
            expressionList, 
            AddExpression.mathOperation, 
            function( total, value ){
                return total + value;
            } 
        );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

AddExpression.removePrefix = true;
AddExpression.getPrefix = function() {
    return context.getConf().addExpression;
};
AddExpression.mathOperation = 'add';
AddExpression.getId = AddExpression.mathOperation;

AddExpression.build = function( string ) {
    
    var expressionList = arithmethicHelper.build( 
            string,
            AddExpression.mathOperation 
    );

    return new AddExpression( string, expressionList );
};

module.exports = AddExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./arithmethicHelper.js":29}],29:[function(require,module,exports){
/* 
    arithmethicHelper singleton class
*/
module.exports = (function() {
    "use strict";
    
    var context = require( '../../context.js' );
    var ExpressionTokenizer = require( '../expressionTokenizer.js' );
    var evaluateHelper = require( '../evaluateHelper.js' );
    
    var build = function( string, tag ) {
        var expressionBuilder = require( '../expressionBuilder.js' );

        if ( string.length === 0 ) {
            throw tag + " expression void.";
        }
        
        var segments = new ExpressionTokenizer( 
                string, 
                context.getConf().expressionDelimiter, 
                false 
        );

        return expressionBuilder.buildList( segments );
    };
    
    var evaluate = function( string, scope, expressionList, mathOperation, arithmethicFunction ) {
        
        // Evaluate segments
        var result = 0;
        var c = 0;
        
        for ( var i = 0; i < expressionList.length; i++ ) {
            var expression = expressionList[ i ];
            var evaluated = expression.evaluate( scope );
            
            if ( ! Array.isArray( evaluated ) ){ 
                // Process numeric value
                result = processInteger( 
                    c++, 
                    evaluated, 
                    result, 
                    arithmethicFunction, 
                    mathOperation, 
                    expression );
                
            } else {
                // Process array of numeric
                for ( var j = 0; j < evaluated.length; j++ ) {
                    result = processInteger( 
                        c++, 
                        evaluated[ j ], 
                        result, 
                        arithmethicFunction, 
                        mathOperation, 
                        expression );
                }
            }
        }
        
        if ( c < 2 ) {
            throw 'Error in expression "' + string + '". Only one element in evaluation of "' + mathOperation 
                + '" expression, please add at least one more.';
        }
        
        return result;
    };
    
    var processInteger = function( c, value, result, arithmethicFunction, mathOperation, expression ){
        
        if ( ! evaluateHelper.isNumber( value ) ) {
            throw "Error trying doing math operation, value '" + value 
                    + "' is not a valid number in expression '" + mathOperation + ' ' + expression + "'";
        }

        return c == 0? Number( value ): arithmethicFunction( result, Number( value ) );
    };
    
    return {
        build: build,
        evaluate: evaluate
    };
})();

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionBuilder.js":46,"../expressionTokenizer.js":47}],30:[function(require,module,exports){
/*
    DivideExpression class
*/
"use strict";

var context = require( '../../context.js' );
var arithmethicHelper = require( './arithmethicHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var DivideExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        return arithmethicHelper.evaluate( 
            string,
            scope,
            expressionList, 
            DivideExpression.mathOperation, 
            function( total, value ){
                return total / value;
            } 
        );
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

DivideExpression.removePrefix = true;
DivideExpression.getPrefix = function() {
    return context.getConf().divExpression;
};
DivideExpression.mathOperation = 'divide';
DivideExpression.getId = DivideExpression.mathOperation;

DivideExpression.build = function( string ) {
    
    var expressionList = arithmethicHelper.build( 
            string,
            DivideExpression.mathOperation 
    );

    return new DivideExpression( string, expressionList );
};

module.exports = DivideExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./arithmethicHelper.js":29}],31:[function(require,module,exports){
/*
    ModExpression class
*/
"use strict";

var context = require( '../../context.js' );
var arithmethicHelper = require( './arithmethicHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var ModExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        return arithmethicHelper.evaluate( 
            string,
            scope,
            expressionList, 
            ModExpression.mathOperation, 
            function( total, value ){
                return total % value;
            } 
        );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

ModExpression.removePrefix = true;
ModExpression.getPrefix = function() {
    return context.getConf().modExpression;
};
ModExpression.mathOperation = 'mod';
ModExpression.getId = ModExpression.mathOperation;

ModExpression.build = function( string ) {
    
    var expressionList = arithmethicHelper.build( 
            string,
            ModExpression.mathOperation 
    );

    return new ModExpression( string, expressionList );
};

module.exports = ModExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./arithmethicHelper.js":29}],32:[function(require,module,exports){
/*
    MultiplyExpression class
*/
"use strict";

var context = require( '../../context.js' );
var arithmethicHelper = require( './arithmethicHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var MultiplyExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        return arithmethicHelper.evaluate( 
            string,
            scope,
            expressionList, 
            MultiplyExpression.mathOperation, 
            function( total, value ){
                return total * value;
            } 
        );
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

MultiplyExpression.removePrefix = true;
MultiplyExpression.getPrefix = function() {
    return context.getConf().mulExpression;
};
MultiplyExpression.mathOperation = 'multiply';
MultiplyExpression.getId = MultiplyExpression.mathOperation;

MultiplyExpression.build = function( string ) {
    
    var expressionList = arithmethicHelper.build( 
            string,
            MultiplyExpression.mathOperation 
    );

    return new MultiplyExpression( string, expressionList );
};

module.exports = MultiplyExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./arithmethicHelper.js":29}],33:[function(require,module,exports){
/*
    SubstractExpression class
*/
"use strict";

var context = require( '../../context.js' );
var arithmethicHelper = require( './arithmethicHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var SubstractExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        return arithmethicHelper.evaluate( 
            string,
            scope,
            expressionList, 
            SubstractExpression.mathOperation, 
            function( total, value ){
                return total - value;
            } 
        );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

SubstractExpression.removePrefix = true;
SubstractExpression.getPrefix = function() {
    return context.getConf().subExpression;
};
SubstractExpression.mathOperation = 'substract';
SubstractExpression.getId = SubstractExpression.mathOperation;

SubstractExpression.build = function( string ) {
    
    var expressionList = arithmethicHelper.build( 
            string,
            SubstractExpression.mathOperation 
    );

    return new SubstractExpression( string, expressionList );
};

module.exports = SubstractExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./arithmethicHelper.js":29}],34:[function(require,module,exports){
/*
    AndExpression class
*/
"use strict";

var context = require( '../../context.js' );
var evaluateHelper = require( '../evaluateHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var AndExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        for ( var i = 0; i < expressionList.length; i++ ) {
            var expression = expressionList[ i ];
            if ( ! evaluateHelper.evaluateBoolean( scope, expression ) ){
                return false;
            }
        }

        return true;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

AndExpression.removePrefix = true;
AndExpression.getPrefix = function() {
    return context.getConf().andExpression;
};
AndExpression.getId = AndExpression.getPrefix;

AndExpression.build = function( string ) {
    var boolHelper = require( './boolHelper.js' );
    
    var expressionList = boolHelper.build( string, 'And' );

    return new AndExpression( string, expressionList );
};

module.exports = AndExpression;

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionsUtils.js":48,"./boolHelper.js":35}],35:[function(require,module,exports){
/* 
    boolHelper singleton class
*/
"use strict";

module.exports = (function() {    
    var context = require( '../../context.js' );
    var ExpressionTokenizer = require( '../expressionTokenizer.js' );
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var build = function( s, tag ) {
        
        var string = s.trim();
        
        if ( string.length === 0 ) {
            throw tag + ' expression void.';
        }

        var segments = new ExpressionTokenizer( 
                string, 
                context.getConf().expressionDelimiter, 
                false );
        if ( segments.countTokens() === 1 ) {
            throw 'Syntax error in expression "' + string + '". Only one element in ' + tag + ' expression, please add at least one more.';
        }
        
        return expressionBuilder.buildList( segments );
    };
    
    return {
        build: build
    };
})();

},{"../../context.js":27,"../expressionBuilder.js":46,"../expressionTokenizer.js":47}],36:[function(require,module,exports){
/*
    CondExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var expressionsUtils = require( '../expressionsUtils.js' );
var evaluateHelper = require( '../evaluateHelper.js' );

var CondExpression = function( stringToApply, expression1ToApply, expression2ToApply, expression3ToApply ) {
    
    var string = stringToApply;
    var expression1 = expression1ToApply;
    var expression2 = expression2ToApply;
    var expression3 = expression3ToApply;
    
    var evaluate = function( scope ){
        
        return evaluateHelper.evaluateBoolean( scope, expression1 )?
            expression2.evaluate( scope ):
            expression3.evaluate( scope );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression1, expression2, expression3 );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

CondExpression.removePrefix = true;
CondExpression.getPrefix = function() {
    return context.getConf().condExpression;
};
CondExpression.getId = CondExpression.getPrefix;

CondExpression.build = function( s ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var string = s.trim();

    if ( string.length === 0 ) {
        throw 'Cond expression void.';
    }

    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().expressionDelimiter, 
            false );
    if ( segments.countTokens() !== 3 ) {
        throw 'Syntax error in cond expression "' + string + '". 3 element are needed.';
    }

    return new CondExpression( 
        string,
        expressionBuilder.build( segments.nextToken() ), 
        expressionBuilder.build( segments.nextToken() ), 
        expressionBuilder.build( segments.nextToken() ) 
    );
};

module.exports = CondExpression;

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48}],37:[function(require,module,exports){
/*
    NotExpression class
*/
"use strict";

var context = require( '../../context.js' );
var evaluateHelper = require( '../evaluateHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var NotExpression = function( stringToApply, expressionToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    
    var evaluate = function( scope ){
        return ! evaluateHelper.evaluateBoolean( scope, expression );
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

NotExpression.removePrefix = true;
NotExpression.getPrefix = function() {
    return context.getConf().notExpression;
};
NotExpression.getId = NotExpression.getPrefix;

NotExpression.build = function( string ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var expression = expressionBuilder.build( string );
    
    return new NotExpression( string, expression );
};

module.exports = NotExpression;

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionBuilder.js":46,"../expressionsUtils.js":48}],38:[function(require,module,exports){
/*
    OrExpression class
*/
"use strict";

var context = require( '../../context.js' );
var evaluateHelper = require( '../evaluateHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var OrExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        for ( var i = 0; i < expressionList.length; i++ ) {
            var expression = expressionList[ i ];
            if ( evaluateHelper.evaluateBoolean( scope, expression ) ){
                return true;
            }
        }

        return false;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

OrExpression.removePrefix = true;
OrExpression.getPrefix = function() {
    return context.getConf().orExpression;
};
OrExpression.getId = OrExpression.getPrefix;

OrExpression.build = function( string ) {
    var boolHelper = require( './boolHelper.js' );
    
    var expressionList = boolHelper.build( string, 'Or' );

    return new OrExpression( string, expressionList );
};

module.exports = OrExpression;

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionsUtils.js":48,"./boolHelper.js":35}],39:[function(require,module,exports){
/* 
    comparisonHelper singleton class
*/
"use strict";

module.exports = (function() {
    var context = require( '../../context.js' );
    var ExpressionTokenizer = require( '../expressionTokenizer.js' );
    var evaluateHelper = require( '../evaluateHelper.js' );
    
    var build = function( s, tag ) {
        var expressionBuilder = require( '../expressionBuilder.js' );
        
        var string = s.trim();
        
        if ( string.length === 0 ) {
            throw tag + ' expression void.';
        }

        var segments = new ExpressionTokenizer( 
                string, 
                context.getConf().expressionDelimiter, 
                false );
        if ( segments.countTokens() !== 2 ) {
            throw 'Wrong number of elements in expression "' + string + '", ' + tag + ' expressions only support two.';
        }

        var expression1 = expressionBuilder.build( segments.nextToken() );
        var expression2 = expressionBuilder.build( segments.nextToken() );
        
        return {
            expression1: expression1,
            expression2: expression2
        };
    };
    
    var evaluate = function( scope, valueExpression1, valueExpression2 ) {
        
        return {
            number1: evaluateHelper.evaluateNumber( scope, valueExpression1 ),
            number2: evaluateHelper.evaluateNumber( scope, valueExpression2 )
        };
    };
    
    return {
        build: build,
        evaluate: evaluate
    };
})();

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionBuilder.js":46,"../expressionTokenizer.js":47}],40:[function(require,module,exports){
/*
    EqualsExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var EqualsExpression = function( stringToApply, argsToApply ) {
    
    var string = stringToApply;
    var args = argsToApply;
    
    var evaluate = function( scope ){
        var arg0 = args[ 0 ];
        var result0 = arg0.evaluate( scope );
        
        for ( var i = 1; i < args.length; i++ ) {
            var arg = args[ i ];
            var result = arg.evaluate( scope );
            if ( result0 != result ){
                return false;
            }
        }
        
        return true;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, args );
    };
    
    var toString = function(){
        return string;
    };

    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

EqualsExpression.removePrefix = true;
EqualsExpression.getPrefix = function() {
    return context.getConf().equalsExpression;
};
EqualsExpression.getId = EqualsExpression.getPrefix;

EqualsExpression.build = function( s ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var string = s.trim();
    
    if ( string.length === 0 ) {
        throw 'Equals expression void.';
    }

    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().expressionDelimiter, 
            false );
    if ( segments.countTokens() === 1 ) {
        throw 'Only one element in equals expression "' + string + '", please add at least one more.';
    }

    return new EqualsExpression( 
        string,
        expressionBuilder.buildList( segments ) 
    );
};

module.exports = EqualsExpression;

},{"../../context.js":27,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48}],41:[function(require,module,exports){
/*
    GreaterExpression class
*/
"use strict";

var context = require( '../../context.js' );
var comparisonHelper = require( './comparisonHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var GreaterExpression = function( stringToApply, expression1ToApply, expression2ToApply ) {
    
    var string = stringToApply;
    var expression1 = expression1ToApply;
    var expression2 = expression2ToApply;
    
    var evaluate = function( scope ){
        var numbers = comparisonHelper.evaluate( scope, expression1, expression2 );
        return numbers.number1 > numbers.number2;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression1, expression2 );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

GreaterExpression.removePrefix = true;
GreaterExpression.getPrefix = function() {
    return context.getConf().greaterExpression;
};
GreaterExpression.getId = GreaterExpression.getPrefix;

GreaterExpression.build = function( string ) {
    
    var data = comparisonHelper.build( string, 'greater' );

    return new GreaterExpression( string, data.expression1, data.expression2 );
};

module.exports = GreaterExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./comparisonHelper.js":39}],42:[function(require,module,exports){
/*
    InExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var InExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){
        var expression0 = expressionList[ 0 ];
        var evaluated0 = expression0.evaluate( scope );
        
        for ( var i = 1; i < expressionList.length; i++ ) {
            var expression = expressionList[ i ];
            var evaluated = expression.evaluate( scope );
            
            if ( Array.isArray( evaluated ) ){ 
                for ( var j = 0; j < evaluated.length; j++ ) {
                    if ( evaluated0 == evaluated[ j ] ){
                        return true;
                    }
                }
                continue;
            }
            
            if ( evaluated0 == evaluated ){
                return true;
            }
        }
        
        return false;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

InExpression.removePrefix = true;
InExpression.getPrefix = function() {
    return context.getConf().inExpression;
};
InExpression.getId = InExpression.getPrefix;

InExpression.build = function( s ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var string = s.trim();
    
    if ( string.length === 0 ) {
        throw 'In expression void.';
    }

    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().expressionDelimiter, 
            false 
    );
    if ( segments.countTokens() === 1 ) {
        throw 'Only one element in in expression "' + string + '", please add at least one more.';
    }

    return new InExpression( 
        string,
        expressionBuilder.buildList( segments ) 
    );
};

module.exports = InExpression;

},{"../../context.js":27,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48}],43:[function(require,module,exports){
/*
    LowerExpression class
*/
"use strict";

var context = require( '../../context.js' );
var comparisonHelper = require( './comparisonHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var LowerExpression = function( stringToApply, expression1ToApply, expression2ToApply ) {
    
    var string = stringToApply;
    var expression1 = expression1ToApply;
    var expression2 = expression2ToApply;
    
    var evaluate = function( scope ){
        var numbers = comparisonHelper.evaluate( scope, expression1, expression2 );
        return numbers.number1 < numbers.number2;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression1, expression2 );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

LowerExpression.removePrefix = true;
LowerExpression.getPrefix = function() {
    return context.getConf().lowerExpression;
};
LowerExpression.getId = LowerExpression.getPrefix;

LowerExpression.build = function( string ) {
    
    var data = comparisonHelper.build( string, 'lower' );

    return new LowerExpression( string, data.expression1, data.expression2 );
};

module.exports = LowerExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"./comparisonHelper.js":39}],44:[function(require,module,exports){
/* 
    evaluateHelper singleton class
*/
"use strict";

var context = require( '../context.js' );

module.exports = (function() {
    
    var evaluateToNotNull = function( scope, expression ) {
        var evaluated = expression.evaluate( scope );
        return evaluated == undefined? 'undefined': evaluated;
    };
    
    var evaluateBoolean = function( scope, expression ) {
        var evaluated = expression.evaluate( scope );
        
        if ( evaluated === undefined
            || evaluated == null
            || evaluated == 'false' 
            || evaluated == false 
            || evaluated == 0 ){
            return false;
        }
        
        return true;
    };
    
    var evaluateNumber = function( scope, expression, errorMessageToApply ) {
        var evaluated = expression.evaluate( scope );
        
        if ( ! isNumber( evaluated ) ){
            var errorMessage = 
                errorMessageToApply? 
                errorMessageToApply: 
                'Expression "' + expression + '" is not a valid number.';
            throw errorMessage;
        }
        
        return evaluated;
    };
    
    var isNumber = function( string ){
        return ! isNaN( parseFloat( string ) ) || ! isFinite( string );
    };
    /*
    var evaluateInteger = function( scope, expression, errorMessageToApply ) {
        var evaluated = expression.evaluate( scope );
        
        if ( ! isInteger( evaluated ) ){
            var errorMessage = 
                errorMessageToApply? 
                errorMessageToApply: 
                'Expression "' + expression + '" is not a valid integer.'
            throw errorMessage;
        }
        
        return evaluated;
    };*/
    /*
    var isInteger = function( string ){
        return ! isNaN( parseInt( string ) ) || ! isFinite( string );
    };*/
    
    var evaluateExpressionList = function ( list, scope ){
        
        var result = [];
        
        for ( var i = 0; i < list.length; i++ ) {
            var expression = list[ i ];
            result.push( expression.evaluate( scope ) );
        }
        
        return result;
    };
    
    var isDefault = function( value ){
        return value === context.getConf().defaultVarValue;
    };
    var isNothing = function( value ){
        return value === context.getConf().nothingVarValue;
    };
    
    return {
        evaluateToNotNull: evaluateToNotNull,
        evaluateBoolean: evaluateBoolean,
        evaluateNumber: evaluateNumber,
        //evaluateInteger: evaluateInteger,
        isNumber: isNumber,
        //isInteger: isInteger,
        evaluateExpressionList: evaluateExpressionList,
        isDefault: isDefault,
        isNothing: isNothing
    };
})();

},{"../context.js":27}],45:[function(require,module,exports){
/*
    ExistsExpression class
*/
"use strict";

var context = require( '../context.js' );
var expressionsUtils = require( './expressionsUtils.js' );

var ExistsExpression = function( stringToApply, expressionToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    
    var evaluate = function( scope ){
        
        try {
            return undefined !== expression.evaluate( scope );
            
        } catch ( e ){
            return false;
        }
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

ExistsExpression.removePrefix = true;
ExistsExpression.getPrefix = function() {
    return context.getConf().existsExpression;
};
ExistsExpression.getId = ExistsExpression.getPrefix;

ExistsExpression.build = function( string ) {
    var expressionBuilder = require( './expressionBuilder.js' );
    
    var expression = expressionBuilder.build( string );
    return new ExistsExpression( string, expression );
};

module.exports = ExistsExpression;

},{"../context.js":27,"./expressionBuilder.js":46,"./expressionsUtils.js":48}],46:[function(require,module,exports){
/* 
    expressionBuilder singleton class
*/
module.exports = (function() {
    "use strict";
    
    var context = require( '../context.js' );
    var ExpressionTokenizer = require( './expressionTokenizer.js' );
    var PathExpression = require( './path/pathExpression.js' );
    var expressionCache = require( '../cache/expressionCache.js' );
    /*var log = require( '../logHelper.js' );*/
    
    var expressionManagers = {};
    var withoutPrefixExpressionManagers = {};
    var DEFAULT_ID = PathExpression.getId();
    
    /* Register expression managers */
    var register = function( expressionsManager, id ) {
        expressionManagers[ id || expressionsManager.getPrefix() || expressionsManager.getId() ] = expressionsManager;
        
        if ( ! expressionsManager.removePrefix && expressionsManager.getPrefix() ){
            withoutPrefixExpressionManagers[ expressionsManager.getPrefix() ] = expressionsManager;
        }
    };
    
    var unregister = function( expressionsManager, id ) {
        delete expressionManagers[ id || expressionsManager.getPrefix() || expressionsManager.getId() ];
    };
    
    var registerGeneralPurpose = function(){
        register( require( './existsExpression.js' ) );
        register( require( './formatExpression.js' ) );
        register( require( './stringExpression.js' ) );
        register( require( './path/pathExpression.js' ) );
    };
    var registerComparison = function(){
        register( require( './comparison/equalsExpression.js' ) );
        register( require( './comparison/greaterExpression.js' ) );
        register( require( './comparison/lowerExpression.js' ) );
        register( require( './comparison/inExpression.js' ) );
    };
    var registerArithmetic = function(){
        register( require( './arithmethic/addExpression.js' ) );
        register( require( './arithmethic/substractExpression.js' ) );
        register( require( './arithmethic/multiplyExpression.js' ) );
        register( require( './arithmethic/divideExpression.js' ) );
        register( require( './arithmethic/modExpression.js' ) );
    };
    var registerLogical = function(){
        register( require( './bool/andExpression.js' ) );
        register( require( './bool/condExpression.js' ) );
        register( require( './bool/notExpression.js' ) );
        register( require( './bool/orExpression.js' ) );
    };
    var registerI18n = function(){
        register( require( './i18n/trCurrencyExpression.js' ) );
        register( require( './i18n/trDateTimeExpression.js' ) );
        register( require( './i18n/trNumberExpression.js' ) );
        register( require( './i18n/trStringExpression.js' ) );
    };
    var registerScripting = function(){
        register( require( './scripting/javascriptExpression.js' ) );
        register( require( './scripting/queryExpression.js' ) );
    };
    
    var registerAll = function(){
        registerGeneralPurpose();
        registerComparison();
        registerArithmetic();
        registerLogical();
        registerI18n();
        registerScripting();
    }();
    /* End Register expression managers */
    
    var build = function( string, force ) {
        return expressionCache.get(
                string, 
                function(){
                    return forceBuild( string );
                }, 
                force
        );
    };
    
    var forceBuild = function( string ) {
        var effectiveString = removeParenthesisIfAny( string.trim() );
        var index = effectiveString.indexOf( context.getConf().expressionSuffix );
        var id = undefined;
        var isDefault = false;
        
        // Is the default expression type? Is registered?
        if ( index !== -1 ){
            id = effectiveString.substring( 0, index )  + ':';
            
            // If the id is not resistered must be a path
            isDefault = ! expressionManagers.hasOwnProperty( id );
        } else {
            isDefault = true;
        }
        
        // Remove prefix and set id if it is default expression type
        var removePrefix = false;
        var expressionManager = undefined;
        if ( isDefault ){
            /*id = DEFAULT_ID;*/
            expressionManager = getWithoutPrefixExpressionManager( effectiveString );
        } else {
            removePrefix = true;
        }
        
        // Get the expression manager and build the expression
        expressionManager = expressionManager || expressionManagers[ id ];
        var finalString = undefined;
        if ( removePrefix && expressionManager.removePrefix ){
            finalString = effectiveString.substr( id.length );
        } else {
            finalString = effectiveString;
        }
        return expressionManager.build( finalString );
    };
    
    var getWithoutPrefixExpressionManager = function( string ){
        
        for ( var prefix in withoutPrefixExpressionManagers ) {
            if ( string.indexOf( prefix ) === 0 ) {
                return withoutPrefixExpressionManagers[ prefix ];
            }
        }
        
        return expressionManagers[ DEFAULT_ID ];
    };
    
    var buildList = function( segments ) {
        var list = [];
        
        while ( segments.hasMoreTokens() ) {
            list.push(
                build( 
                    segments.nextToken().trim()  ) );
        }

        return list;
    };
    
    var removePrefix = function( string, prefix ) {
        return string.substr( prefix.length );
    };
    
    var removePrefixAndBuild = function( string, prefix ) {
        return build(
                string.substr( prefix.length ));
    };
    
    var removeParenthesisIfAny = function( token ){
        var effectiveToken = token.trim();
        
        if ( effectiveToken == '' ){
            return effectiveToken;
        }
        
        if ( effectiveToken.charAt( 0 ) === '(' ){
            return removeParenthesisIfAny( 
                        effectiveToken.substring( 1, effectiveToken.lastIndexOf( ')' ) ).trim() );
        }
        
        return effectiveToken;
    };
    
    var endsWith = function( str, suffix ) {
        return str.indexOf( suffix, str.length - suffix.length ) !== -1;
    };
    
    var getArgumentsFromString = function( string ) {
        
        // Parse and evaluate arguments; then push them to an array
        var tokens = new ExpressionTokenizer( 
                string, 
                context.getConf().argumentsDelimiter, 
                true );
        var args = [];
        while ( tokens.hasMoreTokens() ) {
            var currentString = tokens.nextToken().trim();
            args.push( 
                    build( currentString ) );
        }
        
        return args;
    };
    
    return {
        register: register,
        unregister: unregister,
        registerAll: registerAll,
        build: build,
        buildList: buildList,
        removePrefix: removePrefix,
        removePrefixAndBuild: removePrefixAndBuild,
        removeParenthesisIfAny: removeParenthesisIfAny,
        endsWith: endsWith,
        getArgumentsFromString: getArgumentsFromString
    };
})();

},{"../cache/expressionCache.js":26,"../context.js":27,"./arithmethic/addExpression.js":28,"./arithmethic/divideExpression.js":30,"./arithmethic/modExpression.js":31,"./arithmethic/multiplyExpression.js":32,"./arithmethic/substractExpression.js":33,"./bool/andExpression.js":34,"./bool/condExpression.js":36,"./bool/notExpression.js":37,"./bool/orExpression.js":38,"./comparison/equalsExpression.js":40,"./comparison/greaterExpression.js":41,"./comparison/inExpression.js":42,"./comparison/lowerExpression.js":43,"./existsExpression.js":45,"./expressionTokenizer.js":47,"./formatExpression.js":49,"./i18n/trCurrencyExpression.js":50,"./i18n/trDateTimeExpression.js":51,"./i18n/trNumberExpression.js":53,"./i18n/trStringExpression.js":54,"./path/pathExpression.js":63,"./scripting/javascriptExpression.js":68,"./scripting/queryExpression.js":69,"./stringExpression.js":70}],47:[function(require,module,exports){
/* 
    Class ExpressionTokenizer 
*/
module.exports = function( exp, delimiter, escape ) {
    "use strict";
    
    var expressionBuilder = require( './expressionBuilder.js' );
    var removeParenthesisIfAny = expressionBuilder.removeParenthesisIfAny;
    
    var expression = exp.trim();

    var iterator;
    var currIndex = 0;
    var delimiterCount = 0;
    var delimiters = [];
    
    var makeIterator = function( array ){
        var nextIndex = 0;
        
        return {
            next: function(){
                return nextIndex < array.length ?
                   array [ nextIndex++ ] :
                   undefined;
            },
            hasNext: function(){
                return nextIndex < array.length;
            }
        };
    };
    
    var analyze = function(){
        var avoidRepeatedSeparators = delimiter === ' ';
        
        // Go ahead and find delimiters, if any, at construction time
        var parentLevel = 0;
        var inQuote = false;
        var previousCh = '';
        
        // Scan for delimiters
        var length = expression.length;
        for ( var i = 0; i < length; i++ ) {
            var ch = expression.charAt( i );
            
            if ( ch === delimiter ) {
                // If delimiter is not buried in parentheses or a quote
                if ( parentLevel === 0 && ! inQuote  ) {
                    
                    if ( avoidRepeatedSeparators && ( previousCh === delimiter || previousCh === '\n' ) ) {
                        continue;
                    }
                    
                    var nextCh = ( i + 1 < length ) ? expression.charAt( i + 1 ) : '';
                    
                    // And if delimiter is not escaped
                    if ( ! ( escape && nextCh === delimiter ) ) {
                        delimiterCount++;
                        delimiters.push( i );
                    } else {
                        // Somewhat inefficient way to pare the
                        // escaped delimiter down to a single
                        // character without breaking our stride
                        expression = expression.substring( 0, i + 1 ) + expression.substring( i + 2 );
                        length--;
                    }
                }
            // Increment parenthesis level
            } else if ( ch === '(' || ch === '[' ) {
                parentLevel++;
                
            // Decrement parenthesis level
            } else if ( ch === ')' || ch === ']' ) {
                parentLevel--;
                // If unmatched right parenthesis
                if ( parentLevel < 0 ) {
                    throw 'Syntax error. Unmatched right parenthesis: ' + expression;
                }
                
            // Start or end quote
            } else if ( ch === '\'' ) {
                inQuote = ! inQuote;
            }
            
            previousCh = ch;
        }
        
        // If unmatched left parenthesis
        if ( parentLevel > 0 ) {
            throw 'Syntax error: unmatched left parenthesis: ' + expression;
        }
        
        // If runaway quote
        if ( inQuote ) {
            throw 'Syntax error: runaway quotation: ' + expression;
        }
        
        iterator = makeIterator( delimiters );
    }();
    
    var hasMoreTokens = function( ) {
        return currIndex < expression.length;
    };
    
    var nextToken = function( ) {
        var token;
        
        if ( iterator.hasNext() ) {
            var next = iterator.next();
            var delim = parseInt( next );
            token = expression.substring( currIndex, delim ).trim();
            currIndex = delim + 1;
            delimiterCount--;
            
            return removeParenthesisIfAny( token );
        }
        
        token = expression.substring( currIndex ).trim();
        currIndex = expression.length;
        
        return removeParenthesisIfAny( token );
    };
        
    var countTokens = function( ) {
        if ( hasMoreTokens() ) {
            return delimiterCount + 1;
        }
        return 0;
    };
    
    var nextTokenIfAny = function( defaultValue ) {
        return hasMoreTokens()? nextToken(): defaultValue;
    };
    
    return {
        hasMoreTokens: hasMoreTokens,
        nextToken: nextToken,
        countTokens: countTokens,
        nextTokenIfAny: nextTokenIfAny
    };
};

},{"./expressionBuilder.js":46}],48:[function(require,module,exports){
/* 
    expressionsUtils singleton class
*/
"use strict";

var evaluateHelper = require( './evaluateHelper.js' );
var utils = require( '../utils.js' );
var DepsDataItem = require( '../parsers/depsDataItem.js' );

module.exports = (function() {
    
    var buildLiteral = function( value ) {
        return evaluateHelper.isNumber( value )? "" + value: "'" + value + "'";
    };
    
    var buildList = function( items, asStrings ) {
        
        var result = '[';
        var separator = asStrings? "'": "";
        
        for ( var i = 0; i < items.length; i++ ) {
            result += separator + items[ i ] + separator + " ";
        }
        
        result += ']';
        return result;
    };
    
    var buildDependsOnList = function(){
        
        var result = [];
        
        var depsDataItem = arguments[ 0 ];
        if ( ! depsDataItem ){
            depsDataItem = new DepsDataItem();
        }
        
        var scope = arguments[ 1 ];
        
        for ( var argCounter = 2; argCounter < arguments.length; argCounter++ ){
            var list = arguments[ argCounter ];
            result = result.concat( 
                getDependsOnFromList( depsDataItem, scope, list )
            );
        }
        
        return result;
    };
    
    var getDependsOnFromList = function( depsDataItem, scope, arg ){
        
        var result = [];
        
        if ( ! arg ){
            return result;
        }
        
        if ( ! Array.isArray( arg ) ){
            return getDependsOnFromNonList( depsDataItem, scope, arg );
        }
        
        var list = arg;
        for ( var i = 0; i < list.length; i++ ) {
            var item = list[ i ];
            result = result.concat( 
                Array.isArray( item )? getDependsOnFromList( scope, item ): getDependsOnFromNonList( depsDataItem, scope, item )
            );
        }

        return result;
    };
    
    var getDependsOnFromNonList = function( depsDataItem, scope, item ){
        
        return ! utils.isFunction( item.dependsOn ) || ( utils.isFunction( item.getVarName ) && depsDataItem === item.getVarName() )? 
            []: 
            item.dependsOn( depsDataItem, scope );
    };
    
    return {
        buildLiteral: buildLiteral,
        buildList: buildList,
        buildDependsOnList: buildDependsOnList
    };
})();

},{"../parsers/depsDataItem.js":77,"../utils.js":101,"./evaluateHelper.js":44}],49:[function(require,module,exports){
/*
    FormatExpression class
*/
"use strict";

var utils = require( '../utils.js' );
var context = require( '../context.js' );
var ExpressionTokenizer = require( './expressionTokenizer.js' );
var expressionsUtils = require( './expressionsUtils.js' );
var evaluateHelper = require( './evaluateHelper.js' );

var FormatExpression = function( stringToApply, formatterExpressionToApply, argsExpressionsToApply ) {
    
    var string = stringToApply;
    var formatterExpression = formatterExpressionToApply;
    var argsExpressions = argsExpressionsToApply;
    
    var evaluate = function( scope ){
        
        // Get formatter
        var formatter = evaluateFormatter( scope, formatterExpression );
        
        // Get arguments
        var args = evaluateHelper.evaluateExpressionList( argsExpressions, scope );
        
        return formatter.apply( formatter, args );
    };
    
    var evaluateFormatter = function( scope, expression ) {
        
        // Try to get a built-in formatter
        var formatter = context.getFormatter( expression );
        
        // Try to get a function with a name
        if ( ! isValidFormatter( formatter ) ){
            formatter = scope.get( expression );
        }
    
        // Try to get a function evaluating the expression
        if ( ! isValidFormatter( formatter ) ){
            try {
                var expressionBuilder = require( './expressionBuilder.js' );
                var formatterExpression = expressionBuilder.build( expression );
                var value = formatterExpression.evaluate( scope );
                
                return evaluateFormatter( scope, value );

            } catch( e ){
                // Nothing to do
            }
        }
        
        // Return the formatter only if it is valid
        if ( isValidFormatter( formatter ) ){
            return formatter;
        }
        
        throw 'No valid formatter found: ' + string;
    };
    
    var isValidFormatter = function( formatter ){
        return formatter && utils.isFunction( formatter );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, formatterExpression, argsExpressions );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

FormatExpression.removePrefix = true;
FormatExpression.getPrefix = function() {
    return context.getConf().formatExpression;
};
FormatExpression.getId = FormatExpression.getPrefix;

FormatExpression.build = function( s ) {
    var expressionBuilder = require( './expressionBuilder.js' );
    
    var string = s.trim();
    if ( string.length === 0 ) {
        throw 'Format expression void.';
    }

    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().expressionDelimiter, 
            false );
    var numberOfTokens = segments.countTokens();
    if ( numberOfTokens === 1 ) {
        throw 'Only one element in format expression: "' + string + '". Please add at least one more.';
    }

    // Get formatter
    var formatter = segments.nextToken().trim();

    // Get arguments
    var argsExpressions = [];
    while ( segments.hasMoreTokens() ) {
        var argExpression = expressionBuilder.build( segments.nextToken() );
        argsExpressions.push( argExpression );
    }

    return new FormatExpression( string, formatter, argsExpressions );
};

module.exports = FormatExpression;

},{"../context.js":27,"../utils.js":101,"./evaluateHelper.js":44,"./expressionBuilder.js":46,"./expressionTokenizer.js":47,"./expressionsUtils.js":48}],50:[function(require,module,exports){
/*
    TrCurrencyExpression class
*/
"use strict";

var context = require( '../../context.js' );
var trHelper = require( './trHelper.js' );

var TrCurrencyExpression = function( stringToApply, expressionToApply, argsExpressionsToApply, subformatToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    var argsExpressions = argsExpressionsToApply;
    var subformat = subformatToApply;
    
    var evaluate = function( scope ){
        var evaluated = trHelper.evaluate( 
                scope, 
                expression, 
                argsExpressions, 
                'currency', 
                subformat );
        return evaluated;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return trHelper.dependsOn( depsDataItem, scope, expression, argsExpressions );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

TrCurrencyExpression.removePrefix = true;
TrCurrencyExpression.getPrefix = function() {
    return context.getConf().trCurrencyExpression;
};
TrCurrencyExpression.getId = TrCurrencyExpression.getPrefix;

TrCurrencyExpression.build = function( string ) {
    
    var trData = trHelper.build( 
            string,
            TrCurrencyExpression.getPrefix(), 
            2, 
            3, 
            true );

    return new TrCurrencyExpression( 
            string, 
            trData.expression, 
            trData.argsExpressions, 
            trData.subformat );
};

module.exports = TrCurrencyExpression;

},{"../../context.js":27,"./trHelper.js":52}],51:[function(require,module,exports){
/*
    TrDateTimeExpression class
*/
"use strict";

var context = require( '../../context.js' );
var trHelper = require( './trHelper.js' );

var TrDateTimeExpression = function( stringToApply, expressionToApply, argsExpressionsToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    var argsExpressions = argsExpressionsToApply;
    
    var evaluate = function( scope ){
        var evaluated = trHelper.evaluate( 
                scope, 
                expression, 
                argsExpressions, 
                'datetime', 
                null );
        return evaluated;
    };

    var dependsOn = function( depsDataItem, scope ){
        return trHelper.dependsOn( depsDataItem, scope, expression, argsExpressions );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

TrDateTimeExpression.removePrefix = true;
TrDateTimeExpression.getPrefix = function() {
    return context.getConf().trDateTimeExpression;
};
TrDateTimeExpression.getId = TrDateTimeExpression.getPrefix;

TrDateTimeExpression.build = function( string ) {
    
    var trData = trHelper.build( 
            string,
            TrDateTimeExpression.getPrefix(), 
            1, 
            2, 
            false );

    return new TrDateTimeExpression( 
            string, 
            trData.expression, 
            trData.argsExpressions );
};

module.exports = TrDateTimeExpression;

},{"../../context.js":27,"./trHelper.js":52}],52:[function(require,module,exports){
/* 
    trHelper singleton class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var i18nHelper = require( '../../i18n/i18nHelper.js' );
var evaluateHelper = require( '../evaluateHelper.js' );
var expressionsUtils = require( '../expressionsUtils.js' );
var VariableExpression = require( '../path/variableExpression.js' );

module.exports = (function() {
    
    var build = function( string, tag, minElements, maxElements, useSubformat ) {
        var expressionBuilder = require( '../expressionBuilder.js' );
        
        if ( string.length === 0 ) {
            throw tag + ' expression void.';
        }

        var segments = new ExpressionTokenizer( 
                string.trim(), 
                context.getConf().expressionDelimiter, 
                false );
        
        // Check number of tokens
        var count = segments.countTokens();
        if ( count < minElements ) {
            throw 'Too few elements in ' + tag + ' expression (minimum is ' + minElements 
                    + ', ' + count + ' present): ' + string.trim();
        }
        if ( count > maxElements ) {
            throw 'Too many elements in ' + tag + ' expression (maximum is ' + maxElements 
                    + ', ' + count + ' present):' + string.trim();
        }
        
        // Get tokens
        var subformat = useSubformat? 
                expressionBuilder.build( segments.nextToken() ): 
                undefined;
        var expression = expressionBuilder.build( 
                segments.nextToken().trim() );
        var argsSegment = segments.hasMoreTokens()? 
                segments.nextToken().trim(): 
                undefined;
        
        return {
            expression: expression,
            argsExpressions: buildI18nArgs( argsSegment ),
            subformat: subformat
        };
    };
    
    var buildI18nArgs = function( segment ){
        var expressionBuilder = require( '../expressionBuilder.js' );
        
        var args = {};
        if ( ! segment ){
            return args;
        }
        var tokens = new ExpressionTokenizer( 
                segment, 
                context.getConf().i18nOptionsDelimiter, 
                true
        );
        while ( tokens.hasMoreTokens() ) {
            var token = tokens.nextToken().trim();
            var argsTokens = new ExpressionTokenizer( 
                    token, 
                    context.getConf().inI18nOptionsDelimiter, 
                    true 
            );
            if ( argsTokens.countTokens() !== 2 ) {
                throw '2 elements are needed in i18n expression.';
            }
            
            var argKey = argsTokens.nextToken().trim();
            var argExpression = expressionBuilder.build( 
                    argsTokens.nextToken().trim() );
            args[ argKey ] = argExpression;
        }
        return args;
    };
    
    var evaluateI18nArgs = function( scope, i18nArgs ){
        var values = {};
        
        for ( var argKey in i18nArgs ) {
            var argExpression = i18nArgs[ argKey ];
            var argValue = evaluateHelper.evaluateToNotNull( scope, argExpression );
            values[ argKey ] = argValue;
        }
        
        return values;
    };
    
    var evaluate = function( scope, valueExpression, argsExpressions, format, subformat ) {
        var argValues = evaluateI18nArgs( scope, argsExpressions );
        var subformatEvaluated = 
                subformat? 
                evaluateHelper.evaluateToNotNull( scope, subformat ): 
                undefined;
        var valueEvaluated = evaluateHelper.evaluateToNotNull( scope, valueExpression );
        var evaluated = translate( 
                scope, 
                valueEvaluated, 
                argValues, 
                format, 
                subformatEvaluated );
        
        return evaluated;
    };
    
    var translate = function( scope, id, i18nArgs, format, subformat ){
        
        var i18nList = scope.get( context.getConf().i18nDomainVarName );
        var language = scope.get( context.getConf().i18nLanguageVarName );
        return i18nHelper.tr( 
            i18nList, 
            id, 
            i18nArgs, 
            format, 
            subformat,
            language 
        );
    };
    
    var dependsOn = function( depsDataItem, scope, expression, argsExpressions ){
        
        return expressionsUtils.buildDependsOnList( 
            depsDataItem, 
            scope, 
            new VariableExpression( context.getConf().i18nDomainVarName ),
            new VariableExpression( context.getConf().i18nLanguageVarName ),
            expression, 
            argsExpressions
        );
    };
    
    return {
        build: build,
        evaluate: evaluate,
        dependsOn: dependsOn
    };
})();

},{"../../context.js":27,"../../i18n/i18nHelper.js":73,"../evaluateHelper.js":44,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48,"../path/variableExpression.js":67}],53:[function(require,module,exports){
/*
    TrNumberExpression class
*/
"use strict";

var context = require( '../../context.js' );
var trHelper = require( './trHelper.js' );

var TrNumberExpression = function( stringToApply, expressionToApply, argsExpressionsToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    var argsExpressions = argsExpressionsToApply;
    
    var evaluate = function( scope ){
        var evaluated = trHelper.evaluate( 
                scope, 
                expression, 
                argsExpressions, 
                'number', 
                null 
        );
        return evaluated;
    };

    var dependsOn = function( depsDataItem, scope ){
        return trHelper.dependsOn( depsDataItem, scope, expression, argsExpressions );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

TrNumberExpression.removePrefix = true;
TrNumberExpression.getPrefix = function() {
    return context.getConf().trNumberExpression;
};
TrNumberExpression.getId = TrNumberExpression.getPrefix;

TrNumberExpression.build = function( string ) {
    
    var trData = trHelper.build( 
            string,
            TrNumberExpression.getPrefix(), 
            1, 
            2, 
            false 
    );

    return new TrNumberExpression( 
            string, 
            trData.expression, 
            trData.argsExpressions 
    );
};

module.exports = TrNumberExpression;

},{"../../context.js":27,"./trHelper.js":52}],54:[function(require,module,exports){
/*
    TrStringExpression class
*/
"use strict";

var context = require( '../../context.js' );
var trHelper = require( './trHelper.js' );

var TrStringExpression = function( stringToApply, expressionToApply, argsExpressionsToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    var argsExpressions = argsExpressionsToApply;
    
    var evaluate = function( scope ){
        var evaluated = trHelper.evaluate( 
                scope, 
                expression, 
                argsExpressions, 
                'string', 
                null 
        );
        return evaluated;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return trHelper.dependsOn( depsDataItem, scope, expression, argsExpressions );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

TrStringExpression.removePrefix = true;
TrStringExpression.getPrefix = function() {
    return context.getConf().trExpression;
};
TrStringExpression.getId = TrStringExpression.getPrefix;

TrStringExpression.build = function( string ) {
    
    var trData = trHelper.build( 
            string,
            TrStringExpression.getPrefix(), 
            1, 
            2, 
            false 
    );

    return new TrStringExpression( 
            string, 
            trData.expression, 
            trData.argsExpressions 
    );
};

module.exports = TrStringExpression;

},{"../../context.js":27,"./trHelper.js":52}],55:[function(require,module,exports){
/*
    ArrayExpression class
*/
"use strict";

var expressionsUtils = require( '../expressionsUtils.js' );

var ArrayExpression = function( arrayBaseToApply, indexesToApply ) {
    
    var arrayBase = arrayBaseToApply;
    var indexes = indexesToApply;
    
    var evaluate = function( scope ){
        
        // Evaluate and check array bases and indexes
        var evaluatedArrayBase = arrayBase.evaluate( scope );

        // Iterate indexes
        var result = evaluatedArrayBase;
        for ( var i = 0; i < indexes.length; i++ ) {
            
            // Get and evaluate index as integer
            var indexExpression = indexes[ i ];

            // Evaluate array access
            result = result[ indexExpression.evaluate( scope ) ];
        }
        
        return result;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        
        // Build the arrayBaseDependsOn
        var arrayBaseDependsOn = expressionsUtils.buildDependsOnList( depsDataItem, scope, arrayBase );
        
        // This must be rare!
        if ( arrayBaseDependsOn.length === 0 ){
            return [];
        } else if ( arrayBaseDependsOn.length > 1 ){
            return expressionsUtils.buildDependsOnList( depsDataItem, scope, arrayBase, indexes );
        }
        
        // Join all together
        var dep = arrayBaseDependsOn[ 0 ];
        for ( var i = 0; i < indexes.length; ++i ){
            var indexExpression = indexes[ i ];
            var indexEvaluated = indexExpression.evaluate( scope );
            dep += '[' + indexEvaluated + ']';
        }
        
        return [ dep ];
    };
    
    var toString = function(){
        return arrayBase + '[' + indexes + ']';
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

ArrayExpression.build = function( arrayBase, accessor ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var indexes = [];
    
    var done = false;
    while ( ! done ){

        // Array accessor must begin and end with brackets
        var close = accessor.indexOf( ']' );
        if ( accessor.charAt( 0 ) !== '[' || close === -1 ) {
            throw 'Bad array accessor: '  + accessor;
        }

        // Get index and add to indexes
        var index = expressionBuilder.build( 
                accessor.substring( 1, close ) 
        );
        indexes.push( index );

        // continue processing array access for multidimensional arrays
        close++;
        if ( accessor.length > close ) {
            accessor = accessor.substring( close );
        } else {
            done = true;
        }
    }
    
    return new ArrayExpression( arrayBase, indexes );
};

ArrayExpression.buildArrayData = function( token ) {
    
    var bracket = ArrayExpression.findArrayAccessor( token );
    
    if ( bracket <= 0 ) {
        return undefined;
    }
    
    return {
        arrayAccessor: token.substring( bracket ).trim(),
        token: token.substring( 0, bracket ).trim()
    };
};

ArrayExpression.findArrayAccessor = function( token ) {
    var SCANNING = 0;
    var IN_PAREN = 1;
    var IN_QUOTE = 2;

    var length = token.length;
    var state = SCANNING;
    var parenDepth = 0;
    for ( var i = 0; i < length; i++ ) {
        var ch = token.charAt( i );
        switch( state ) {
        case IN_PAREN:
            if ( ch === ')' ) {
                parenDepth--;
                if ( parenDepth === 0 ) {
                    state = SCANNING;
                }
            } else if ( ch === '(' ) {
                parenDepth++;
            }
            break;

        case IN_QUOTE:
            if ( ch === '\'' ) {
                state = SCANNING;
            }
            break;

        case SCANNING:
            if ( ch === '\'' ) {
                state = IN_QUOTE;
            } else if ( ch === '(' ) {
                parenDepth++;
                state = IN_PAREN;
            } else if ( ch === '[' ) {
                return i;
            }
        }
    }

    return -1;
};

module.exports = ArrayExpression;

},{"../expressionBuilder.js":46,"../expressionsUtils.js":48}],56:[function(require,module,exports){
/*
    FunctionExpression class
*/
"use strict";

var evaluateHelper = require( '../evaluateHelper.js' );

var FunctionExpression = function( stringToApply, nameToApply, argsToApply ) {
    
    var string = stringToApply;
    var name = nameToApply;
    var args = argsToApply;
    
    var evaluate = function( scope ){
        var evaluatedArgs = evaluateHelper.evaluateExpressionList( args, scope );
        var element = scope.get( name );
        return ! element? undefined: element.apply( element, evaluatedArgs );
    };

    var dependsOn = function(){
        return [];
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

FunctionExpression.build = function( string ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var leftParent = string.indexOf( '(' );
    if ( leftParent === -1 ) {
        return undefined;
    }
    
    if ( ! expressionBuilder.endsWith( string, ')' ) ) {
        throw 'Syntax error. Bad function call: ' + string;
    }
    var functionName = string.substring( 0, leftParent ).trim();
    var argsString = string.substring( leftParent + 1, string.length - 1 );
    var args = expressionBuilder.getArgumentsFromString( argsString );

    return new FunctionExpression( string, functionName, args );
};

module.exports = FunctionExpression;

},{"../evaluateHelper.js":44,"../expressionBuilder.js":46}],57:[function(require,module,exports){
/*
    IndirectionExpression class
*/
"use strict";

var IndirectionExpression = function( nameToApply ) {
    
    var name = nameToApply;
    
    var evaluate = function( scope, parent ){
        return parent[ scope.get( name ) ];
    };
    
    var dependsOn = function(){
        return [];
    };
    
    var toString = function(){
        return '?' + name;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

IndirectionExpression.build = function( string ) {
    
    if ( string.charAt( 0 ) !== '?' ) {
        return undefined;
    }
    
    return new IndirectionExpression( string.substring( 1 ) );
};

module.exports = IndirectionExpression;

},{}],58:[function(require,module,exports){
/*
    ListExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var expressionsUtils = require( '../expressionsUtils.js' );
var RangeExpression = require( './rangeExpression.js' );

var ListExpression = function( stringToApply, itemsToApply ) {
    
    var string = stringToApply;
    var items = itemsToApply;
    
    var evaluate = function( scope ){
        
        var result = [];
        
        for ( var i = 0; i < items.length; i++ ) {
            var expression = items[ i ];
            var evaluated = expression.evaluate( scope );
            
            if ( Array.isArray( evaluated ) ){ 
                result = result.concat( evaluated );
            } else {
                result.push( evaluated );
            }
        }

        return result;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, items );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

ListExpression.build = function( s ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    if ( s.charAt( 0 ) !== '[' || s.charAt( s.length - 1 ) !==  ']' ) {
        return undefined;
    }
    
    var string = s.substring( 1, s.length - 1 );
    var items = [];
    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().expressionDelimiter, 
            true );

    while ( segments.hasMoreTokens() ) {
        var segment = segments.nextToken().trim();
        var range = RangeExpression.build( segment );

        items.push(
            range?
            range:
            expressionBuilder.build( segment )
        );
    }

    return new ListExpression( string, items );
};

module.exports = ListExpression;

},{"../../context.js":27,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48,"./rangeExpression.js":66}],59:[function(require,module,exports){
/*
    BooleanLiteral class
*/
"use strict";

var BooleanLiteral = function( literalToApply ) {

    var literal = literalToApply;
    
    var evaluate = function( scope ){
        return literal;
    };
    
    var toString = function(){
        return "" + literal;
    };
    
    var dependsOn = function(){
        return [];
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

BooleanLiteral.build = function( string ) {
    
    if ( 'true' === string ) {
        return new BooleanLiteral( true );
    }
    if ( 'false' === string ) {
        return new BooleanLiteral( false );
    }
    return undefined;
};

module.exports = BooleanLiteral;

},{}],60:[function(require,module,exports){
/*
    NumericLiteral class
*/
"use strict";

var NumericLiteral = function( literalToApply ) {
    
    var literal = literalToApply;
    
    var evaluate = function( scope ){
        return literal;
    };
    
    var dependsOn = function(){
        return [];
    };
    
    var toString = function(){
        return literal;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

NumericLiteral.build = function( string ) {
    
    if ( isFinite( string ) ){
        var integerValue = parseInt( string );
        if ( integerValue == string ){
            return new NumericLiteral( integerValue );
        }

        var floatValue = parseFloat( string );
        if ( floatValue == string ){
            return new NumericLiteral( floatValue );
        }
    }

    return undefined;
};

module.exports = NumericLiteral;

},{}],61:[function(require,module,exports){
/*
    StringLiteral class
*/
"use strict";

var StringLiteral = function( literalToApply ) {

    var literal = literalToApply;
    
    var evaluate = function( scope ){
        return literal;
    };
    
    var dependsOn = function(){
        return [];
    };
    
    var toString = function(){
        return literal;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

StringLiteral.build = function( string ) {
    
    if ( string.charAt( 0 ) === "'" && string.charAt( string.length - 1 ) ===  "'" ) {
        return new StringLiteral( 
            string.substring( 1, string.length - 1 ) );
    }

    return undefined;
};

module.exports = StringLiteral;

},{}],62:[function(require,module,exports){
/*
    MethodExpression class
*/
"use strict";

var evaluateHelper = require( '../evaluateHelper.js' );

var MethodExpression = function( stringToApply, nameToApply, argsToApply ) {
    
    var string = stringToApply;
    var name = nameToApply;
    var args = argsToApply;
    
    var evaluate = function( scope, parent ){
        var evaluatedArgs = evaluateHelper.evaluateExpressionList( args, scope );
        return parent[ name ].apply( parent, evaluatedArgs );
    };

    var dependsOn = function(){
        return undefined;
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

MethodExpression.build = function( string ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var leftParent = string.indexOf( '(' );
    if ( leftParent === -1 ) {
        return undefined;
    }
    
    if ( ! expressionBuilder.endsWith( string, ')' ) ) {
        throw 'Syntax error. Bad method call: ' + string;
    }
    
    var methodName = string.substring( 0, leftParent ).trim();
    var argsString = string.substring( leftParent + 1, string.length - 1 );
    var args = expressionBuilder.getArgumentsFromString( argsString );
    
    return new MethodExpression( string, methodName, args );
};

module.exports = MethodExpression;

},{"../evaluateHelper.js":44,"../expressionBuilder.js":46}],63:[function(require,module,exports){
/*
    PathExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var StringLiteral = require( './literals/stringLiteral.js' );
var PathSegmentExpression = require( './pathSegmentExpression.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var PathExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){

        var exception = undefined;
        
        for ( var i = 0; i < expressionList.length; i++ ) {
            try {
                var expression = expressionList[ i ];
                var result = expression.evaluate( scope );
                if ( result != null ){
                    return result;
                }
            } catch( e ) {
                exception = e;
            }
        }
        
        if ( exception ) {
            throw exception;
        }
        
        return null;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

PathExpression.removePrefix = false;
PathExpression.getPrefix = function() {
    return context.getConf().pathExpression;
};
PathExpression.getId = function() { 
    return 'path';
};

PathExpression.build = function( s ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var string = s.trim();
    
    // Blank expression evaluates to blank string
    if ( string.length === 0 ) {
        return StringLiteral.build( '' );
    }
    
    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().pathDelimiter, 
            false );

    // If there is only 1 must be a path segment
    if ( segments.countTokens() === 1 ) {
        return PathSegmentExpression.build( string );
    }

    // If there are more than 1 they can be any expression instance
    var expressionList = [];
    while ( segments.hasMoreTokens() ) {
        var nextToken = segments.nextToken();
        if ( ! nextToken ){
            throw 'Null token inside path expression: ' + string;
        }
        expressionList.push( 
            expressionBuilder.build( 
                nextToken
            ) 
        );
    }
    return new PathExpression( string, expressionList );
};

module.exports = PathExpression;

},{"../../context.js":27,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48,"./literals/stringLiteral.js":61,"./pathSegmentExpression.js":64}],64:[function(require,module,exports){
/*
    PathSegmentExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var expressionsUtils = require( '../expressionsUtils.js' );
var ArrayExpression = require( './arrayExpression.js' );
var StringLiteral = require( './literals/stringLiteral.js' );
var NumericLiteral = require( './literals/numericLiteral.js' );
var BooleanLiteral = require( './literals/booleanLiteral.js' );
var ListExpression = require( './listExpression.js' );
var FunctionExpression = require( './functionExpression.js' );
var VariableExpression = require( './variableExpression.js' );
var IndirectionExpression = require( './indirectionExpression.js' );
var MethodExpression = require( './methodExpression.js' );
var PropertyExpression = require( './propertyExpression.js' );

var PathSegmentExpression = function( stringToApply, itemsToApply ) {
    
    var string = stringToApply;
    var items = itemsToApply;
    
    var evaluate = function( scope ){
        
        var token = items[ 0 ];
        var result = token.evaluate( scope );
        for ( var i = 1; i < items.length; i++ ) {
            // Only last element can be null
            if ( result == null ) {
                throw 'Error evaluating "' + string + '": "'  + token + '" is null';
            }
            token = items[ i ];
            result = token.evaluate( scope, result );
        }
        
        return result;
    };
    
    var dependsOn = function( depsDataItem, scope ){
        
        var firstSegmentDependsOn = expressionsUtils.buildDependsOnList( depsDataItem, scope, items[ 0 ] );
        if ( firstSegmentDependsOn.length === 0 ){
            return [];
        } else if ( firstSegmentDependsOn.length > 1 ){
            return firstSegmentDependsOn;
        }
        
        var temp = firstSegmentDependsOn[ 0 ];
        var result = [ temp ];
        for ( var i = 1; i < items.length; i++ ) {
            var token = items[ i ];
            var tokenDependsOn = token.dependsOn( temp );
            if ( ! tokenDependsOn ){
                break;
                //return temp;
            }
            
            temp += tokenDependsOn;
            result.push( temp );
        }
        
        return result;
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

PathSegmentExpression.build = function( string ) {
    
    var items = [];
    
    // Blank expression evaluates to blank string
    if ( string.length === 0 ) {
        items.push( 
            StringLiteral.build( '' ) );
        return items;
    }

    // Build first token
    var path = new ExpressionTokenizer( 
            string, 
            context.getConf().pathSegmentDelimiter, 
            false );
    var token = path.nextToken().trim();
    items.push(
            PathSegmentExpression.buildFirstPathToken( token ) );

    // Traverse the path
    while ( path.hasMoreTokens() ) {
        token = path.nextToken().trim();
        items.push(
            PathSegmentExpression.buildNextPathToken( token ) );
    }
    
    return new PathSegmentExpression( string, items );
};

PathSegmentExpression.buildFirstPathToken = function( t ){

    // Separate identifier from any array accessors
    var arrayData = ArrayExpression.buildArrayData( t );
    var arrayAccessor = arrayData? arrayData.arrayAccessor: undefined;
    var token = arrayData? arrayData.token: t;

    // First token must come from dictionary or be a literal

    // First see if it's a string literal
    var result = StringLiteral.build( token );

    // If it's not, try to see if it's a number
    if ( result === undefined ) {
        result = NumericLiteral.build( token );

        // Maybe it's a boolean literal
        if ( result === undefined ) {
            result = BooleanLiteral.build( token );

            // A list?
            if ( result === undefined ){
                result = ListExpression.build( token );

                // A function call?
                if ( result === undefined ) {
                    result = FunctionExpression.build( token );

                    // Must be an object in scope
                    if ( result === undefined ) {
                        result = VariableExpression.build( token );
                        
                        // Not recognized expression
                        if ( result === undefined ) {
                            throw 'Unknown expression: ' + token;
                        }
                    }
                }
            }
        }
    }

    if ( arrayAccessor !== undefined ) {
        result = ArrayExpression.build( result, arrayAccessor );
    }

    return result;
};

PathSegmentExpression.buildNextPathToken = function( t ){
    
    // Separate identifier from any array accessors
    var arrayData = ArrayExpression.buildArrayData( t );
    var arrayAccessor = arrayData? arrayData.arrayAccessor: undefined;
    var token = arrayData? arrayData.token: t;

    // Test for indirection
    var result = IndirectionExpression.build( token );
    
    // A method call?
    if ( result === undefined ) {
        result = MethodExpression.build( token );

        // A property
        if ( result === undefined ) {
            result = PropertyExpression.build( token );
        }
    }

    if ( arrayAccessor !== undefined ) {
        result = ArrayExpression.build( result, arrayAccessor );
    }

    return result;
};

module.exports = PathSegmentExpression;

},{"../../context.js":27,"../expressionTokenizer.js":47,"../expressionsUtils.js":48,"./arrayExpression.js":55,"./functionExpression.js":56,"./indirectionExpression.js":57,"./listExpression.js":58,"./literals/booleanLiteral.js":59,"./literals/numericLiteral.js":60,"./literals/stringLiteral.js":61,"./methodExpression.js":62,"./propertyExpression.js":65,"./variableExpression.js":67}],65:[function(require,module,exports){
/*
    PropertyExpression class
*/
"use strict";

var PropertyExpression = function( nameToApply ) {
    
    var name = nameToApply;
    
    var evaluate = function( scope, parent ){
        return parent[ name ];
    };
    
    var dependsOn = function( parent ){
        return '.' + name;
    };
    
    var toString = function(){
        return name;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

PropertyExpression.build = function( string ) {
    return new PropertyExpression( string );
};

module.exports = PropertyExpression;

},{}],66:[function(require,module,exports){
/*
    RangeExpression class
*/
"use strict";

var context = require( '../../context.js' );
var ExpressionTokenizer = require( '../expressionTokenizer.js' );
var expressionsUtils = require( '../expressionsUtils.js' );
var evaluateHelper = require( '../evaluateHelper.js' );
var NumericLiteral = require( './literals/numericLiteral.js' );

var RangeExpression = function( stringToApply, startExpressionToApply, endExpressionToApply, stepExpressionToApply ) {
    
    var string = stringToApply;
    var startExpression = startExpressionToApply;
    var endExpression = endExpressionToApply;
    var stepExpression = stepExpressionToApply;
    
    var evaluate = function( scope ){
        
        // Evaluate all expressions
        var start = evaluateHelper.evaluateNumber( scope, startExpression );
        var end = evaluateHelper.evaluateNumber( scope, endExpression );
        var step = evaluateHelper.evaluateNumber( scope, stepExpression );
        
        // The range is valid, evaluate it
        var result = [];
        var forward = step > 0; 
        
        var c = start;
        while( forward? c <= end: c >= end ){
            result.push( c );
            c += step;
        }
        
        return result;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, startExpression, endExpression, stepExpression );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

RangeExpression.build = function( s ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    if ( ! s ) {
        return undefined;
    }

    var string = s.trim();
    
    // If it contains spaces it is not a valid range
    if ( string.indexOf( ' ' ) !== -1 ) {
        return undefined;
    }
    
    var segments = new ExpressionTokenizer( 
            string, 
            context.getConf().intervalDelimiter, 
            false );

    var numberOfTokens = segments.countTokens();
    if ( numberOfTokens !== 2 && numberOfTokens !== 3 ) {
        return undefined;
    }

    var RANGE_DEFAULT_START = 0;
    var RANGE_DEFAULT_STEP = 1;
    
    // Build start expression
    var start = segments.nextToken().trim();
    var startExpression = start == ''? 
            NumericLiteral.build( RANGE_DEFAULT_START ): 
            expressionBuilder.build( start );

    // Build end expression
    var endExpression = expressionBuilder.build( segments.nextToken() );

    // Build step expression
    var stepExpression = numberOfTokens === 3? 
            expressionBuilder.build( segments.nextToken() ):
            NumericLiteral.build( RANGE_DEFAULT_STEP );
    
    return new RangeExpression( string, startExpression, endExpression, stepExpression );
};

module.exports = RangeExpression;

},{"../../context.js":27,"../evaluateHelper.js":44,"../expressionBuilder.js":46,"../expressionTokenizer.js":47,"../expressionsUtils.js":48,"./literals/numericLiteral.js":60}],67:[function(require,module,exports){
/*
    VariableExpression class
*/
"use strict";

var context = require( '../../context.js' );

var VariableExpression = function( nameToApply ) {
    
    var name = nameToApply;
    
    var evaluate = function( scope ){
        
        if ( ! scope.isValidVariable( name ) ){
            throw 'Not declared variable found using strict mode:' + name;
        }
        
        return scope.get( name );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        
        if ( ! depsDataItem.mustAddVar( name ) ){
            return [];
        }
        
        var expression = scope.getVarExpression( name );
        if ( ! expression ){
            depsDataItem.add1NonExpressionVar( name );
            return [ name ];
        }
        
        depsDataItem.add1ExpressionVar( name );
        var result = expression.dependsOn( depsDataItem, scope );
        depsDataItem.addAllVars( result, scope );
        return result;
    };
    
    var getVarName = function(){
        return name;
    };
    
    var toString = function(){
        return name;
    };

    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        getVarName: getVarName,
        toString: toString
    };
};

VariableExpression.build = function( string ) {
    
    return context.getConf().variableNameRE.test( string )?
        new VariableExpression( string ):
        undefined;
};

module.exports = VariableExpression;

},{"../../context.js":27}],68:[function(require,module,exports){
/*
    JavascriptExpression class
*/
"use strict";

var context = require( '../../context.js' );
var expressionsUtils = require( '../expressionsUtils.js' );
var StringExpression = require( '../stringExpression.js' );

var JavascriptExpression = function( expressionToApply ) {
    
    var stringExpression = expressionToApply;
    
    var evaluate = function( scope ){
        var evaluatedString = stringExpression.evaluate( scope );
        return eval( evaluatedString );
    };
    
    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, stringExpression );
    };
    
    var toString = function(){
        return stringExpression;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

JavascriptExpression.removePrefix = true;

JavascriptExpression.getPrefix = function() {
    if ( JavascriptExpression.prefix === undefined ){
        JavascriptExpression.prefix = context.getConf().javaScriptExpression;
    }
    return JavascriptExpression.prefix;
};

JavascriptExpression.getId = JavascriptExpression.getPrefix;

JavascriptExpression.build = function( string ) {
    return new JavascriptExpression(
            StringExpression.build( string ) );
};

module.exports = JavascriptExpression;

},{"../../context.js":27,"../expressionsUtils.js":48,"../stringExpression.js":70}],69:[function(require,module,exports){
/*
    QueryExpression class
*/
"use strict";

var context = require( '../../context.js' );
var expressionsUtils = require( '../expressionsUtils.js' );

var QueryExpression = function( stringToApply, expressionToApply ) {
    
    var string = stringToApply;
    var expression = expressionToApply;
    
    var evaluate = function( scope ){
        
        try {
            var evaluated = expression.evaluate( scope );
            var elementList = window.document.querySelectorAll( evaluated );
            
            // elementList with length 1
            if ( elementList.length === 1 ){
                return elementList[ 0 ].innerText;
            }
            
            // elementList with length > 1
            var texts = [];
            for ( var i = 0; i < elementList.length; ++i ){
                texts.push( elementList[ i ].innerText );
            }
            return texts;
            
        } catch ( e ){
            return 'Query expression error in "' + string + '": ' + e;
        }
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expression );
    };
    
    var toString = function(){
        return string;
    };

    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

QueryExpression.removePrefix = true;
QueryExpression.getPrefix = function() {
    return context.getConf().queryExpression;
};
QueryExpression.getId = QueryExpression.getPrefix;

QueryExpression.build = function( string ) {
    var expressionBuilder = require( '../expressionBuilder.js' );
    
    var expression = expressionBuilder.build( string );
    
    return new QueryExpression( string, expression );
};

module.exports = QueryExpression;

},{"../../context.js":27,"../expressionBuilder.js":46,"../expressionsUtils.js":48}],70:[function(require,module,exports){
/*
    StringExpression class
*/
"use strict";

var context = require( '../context.js' );
var StringLiteral = require( './path/literals/stringLiteral.js' );
var PathExpression = require( './path/pathExpression.js' );
var expressionsUtils = require( './expressionsUtils.js' );

var StringExpression = function( stringToApply, expressionListToApply ) {
    
    var string = stringToApply;
    var expressionList = expressionListToApply;
    
    var evaluate = function( scope ){
        
        var result = '';
        
        for ( var i = 0; i < expressionList.length; i++ ) {
            var expression = expressionList[ i ];
            result += expression.evaluate( scope );
        }
        
        return result;
    };

    var dependsOn = function( depsDataItem, scope ){
        return expressionsUtils.buildDependsOnList( depsDataItem, scope, expressionList );
    };
    
    var toString = function(){
        return string;
    };
    
    return {
        evaluate: evaluate,
        dependsOn: dependsOn,
        toString: toString
    };
};

StringExpression.removePrefix = true;
StringExpression.getPrefix = function() {
    return context.getConf().stringExpression;
};
StringExpression.getId = StringExpression.getPrefix;

StringExpression.build = function( string ) {
    var STATE_SCANNING = 0;
    var STATE_AT_DOLLAR = 1;
    var STATE_IN_EXPRESSION = 2;
    var STATE_IN_BRACKETED_EXPRESSION = 3;

    var expressionList = [];
    var literal = '';
    var subexpression = '';
    var state = STATE_SCANNING;

    for ( var i = 0; i < string.length; i++ ) {
        var ch = string.charAt( i );

        switch ( state ) {
                
        // In the string part of the expression
        case STATE_SCANNING:
            // Found a dollar sign
            if ( ch === '$' ) {
                state = STATE_AT_DOLLAR;
                
            // Just keep appending to buffer
            } else {
                literal += ch;
            }
            break;

        // Next character after dollar sign
        case STATE_AT_DOLLAR:
            // An escaped dollar sign
            if ( ch === '$' ) {
                literal += '$';
                state = STATE_SCANNING;
                
            // Beginning of a bracketed expression
            } else if ( ch === '{' ) {
                // Reset subexpression and change state
                subexpression = '';
                state = STATE_IN_BRACKETED_EXPRESSION;

                // Add literal and reset it if needed
                if ( literal ){
                    expressionList.push( 
                            new StringLiteral( literal ) 
                    );
                    literal = '';
                }
                
            // Beginning of a non bracketed expression
            } else {
                subexpression += ch;
                state = STATE_IN_EXPRESSION;
                
                // Add literal and reset it if needed
                if ( literal ){
                    expressionList.push( 
                            new StringLiteral( literal )
                    );
                    literal = '';
                }
            }
            break;

        // In subexpression
        case STATE_IN_BRACKETED_EXPRESSION:
        case STATE_IN_EXPRESSION:
            // Check for end
            if ( ( state === STATE_IN_BRACKETED_EXPRESSION && ch === '}' )
                    || ( state === STATE_IN_EXPRESSION && ch == ' ' ) ) {
                expressionList.push( 
                        PathExpression.build( subexpression ) 
                );

                if ( state === STATE_IN_EXPRESSION ) {
                    literal += ch;
                }
                state = STATE_SCANNING;
                
            // Keep appending to subexpression
            } else {
                subexpression += ch;
            }
        }
    }

    // Ended in unclosed bracket
    if ( state === STATE_IN_BRACKETED_EXPRESSION ) {
        throw 'Unclosed left curly brace: ' + string;
        
    // Ended at expression
    } else if ( state == STATE_IN_EXPRESSION ) {
        expressionList.push( 
                PathExpression.build( subexpression ) 
        );
    }

    if ( literal ){
        expressionList.push( 
                new StringLiteral( literal ) 
        );
    }

    return new StringExpression( string, expressionList );
};

module.exports = StringExpression;

},{"../context.js":27,"./expressionsUtils.js":48,"./path/literals/stringLiteral.js":61,"./path/pathExpression.js":63}],71:[function(require,module,exports){
/* 
    I18n class 
    External dependencies: Intl (supported by recent browsers) and MessageFormat
*/
module.exports = function( languageId, res ) {
    "use strict";
    
    var MessageFormat = require( 'messageformat' );
    var context = require( '../context.js' );
    var utils = require( '../utils.js' );
    
    var resources = res;
    var mf = new MessageFormat( languageId );
    var cache = {};
    var numberFormatCache = {};
    var dateTimeFormatCache = {};
    /*var CONF_RESOURCE_ID = '/CONF/';*/
    var CONF_RESOURCE_ID = context.getConf().i18nConfResourceId;
    
    var getLanguage = function(){
        //return resources[ context.getConf().i18nConfResourceId ].language;
        return resources[ CONF_RESOURCE_ID ].language;
    };
    
    var getLocale = function(){
        //return resources[ context.getConf().i18nConfResourceId ].locale;
        return resources[ CONF_RESOURCE_ID ].locale;
    };
    
    var exists = function( id ) {
        return resources[ id ] !== undefined;
    };
    
    var tr = function( id, params, format, subformat ) {
        
        switch ( format ) {
        case 'string':
            return trString( id, params );
        case 'number':
            return trNumber( id, params );
        case 'currency':
            return trCurrency( id, params, subformat );
        case 'datetime':
            return trDateTime( id, params );
        } 
        
        throw 'I18n format type not supported: ' + format;
    };
    
    var trString = function( id, params ) {
        
        var mfunc = cache[ id ];
        
        if ( ! mfunc ){
            mfunc = mf.compile( resources[ id ] );
            cache[ id ] = mfunc;
        }
        
        return mfunc( params );
    };
    
    var getSource = function( params ){
        
        return params && utils.isFunction( params.toSource )?
            params.toSource():
            '';
    };
    
    var trNumber = function( value, params ) {
        
        var source = getSource( params );
        var numberFormat = numberFormatCache[ source ];
        
        if ( ! numberFormat ){
            numberFormat = new Intl.NumberFormat( getLocale(), params );
            numberFormatCache[ source ] = numberFormat;
        }
        
        return numberFormat.format( value );
    };
    
    var trCurrency = function( value, params, theCurrency ) {
        
        params.style = 'currency';
        params.currency = theCurrency;
        
        return trNumber( value, params );
    };
    
    var trDateTime = function( value, params ) {
        
        var source = getSource( params );
        var dateTimeFormat = dateTimeFormatCache[ source ];
        
        if ( ! dateTimeFormat ){
            dateTimeFormat = new Intl.DateTimeFormat( getLocale(), params );
            dateTimeFormatCache[ source ] = dateTimeFormat;
        }
        
        return dateTimeFormat.format( value );
    };
    
    return {
        getLanguage: getLanguage,
        getLocale: getLocale,
        exists: exists,
        tr: tr
    };
};

},{"../context.js":27,"../utils.js":101,"messageformat":4}],72:[function(require,module,exports){
/* 
    I18nBundle class 
*/
module.exports = function( ) {
    "use strict";
    
    var i18nList = {};
    var first = undefined;

    var add = function( i18n ){
        i18nList[ i18n.getLanguage() ] = i18n;
        if ( ! first ){
            first = i18n;
        }
    };
    
    var exists = function( id ){
        return first.exists( id );
    };
    
    var tr = function( id, params, format, subformat, language ) {
        
        if ( ! language ){
            throw 'Language not defined! Please, use data-iLanguage to define it before trying to translate anything!';
        }
        
        var i18n = i18nList[ language ];
        
        if ( ! i18n ){
            throw 'Language "' + language + '" not found in I18nBundle!';
        }
        
        return i18n.tr( id, params, format, subformat );
    };

    // Init!
    for ( var c = 0; c < arguments.length; c++ ) {
        add( arguments[ c ] );
    }
    
    return {
        add: add,
        exists: exists,
        tr: tr
    };
};

},{}],73:[function(require,module,exports){
/* 
    i18nHelper singleton class 
*/
var utils = require( '../utils.js' );
var I18n = require( './i18n.js' );
var context = require( '../context.js' );

module.exports = (function() {
    "use strict";
    
    var tr = function ( i18nList, id, params, format, subformat, language ){
        
        if ( ! i18nList ) {
            return 'No I18n instance defined!';
        }
            
        var length = i18nList.length;
        if ( ! length ){
            return 'Void I18n list!';
        }

        for ( var i = 0; i < length; i++ ) {
            var i18n = i18nList[ i ];
            if ( format !== 'string' || i18n.exists( id ) ){
                return i18n.tr( id, params, format, subformat, language );
            }
        }
        
        return 'I18n resource "' + id + '" not found!';
    };
    
    var loadAsync = function( remoteList, callback, failCallback ){
        
        loadAsyncItem( 
            {}, 
            callback, 
            failCallback,
            remoteList, 
            remoteList.length - 1 );
    };
    
    var loadAsyncItem = function( map, callback, failCallback, remoteList, currentIndex ){
        
        var url = remoteList[ currentIndex ];
        utils.getJSON( 
            {
                url: url,
                done: function( data ) {
                    map[ url ] = data;
                    if ( currentIndex > 0 ){
                        loadAsyncItem( 
                            map, 
                            callback, 
                            failCallback,
                            remoteList, 
                            --currentIndex );
                    } else {
                        callback( map );
                    }
                },
                fail: function( jqxhr, textStatus, error ) {
                    context.asyncError( url, error, failCallback );
                }
            }
        );
    };
    /*
    var loadAsyncItem = function( map, callback, failCallback, remoteList, currentIndex ){
        
        var url = remoteList[ currentIndex ];
        $.getJSON( url )
            .done(
                function( data ) {
                    map[ url ] = data;
                    if ( currentIndex > 0 ){
                        loadAsyncItem( 
                            map, 
                            callback, 
                            failCallback,
                            remoteList, 
                            --currentIndex );
                    } else {
                        callback( map );
                    }
                }
            )
            .fail(
                function( jqxhr, textStatus, error ) {
                    context.asyncError( url, error, failCallback );
                }
            );
    };
    */
    
    var loadAsyncAuto = function( dictionary, i18n, callback, failCallback ){
        
        // Return if it is nothing to do
        if ( ! i18n || ! i18n.files || ! Object.keys( i18n.files ).length ){
            callback();
            return;
        }
        
        // Build jsonFiles array
        var numberOfLanguages = Object.keys( i18n.files ).length;
        var jsonFiles = [];
        var urlPrefix = i18n.urlPrefix || '';
        for ( var lang in i18n.files ){
            var langFiles = i18n.files[ lang ];
            for ( var index in langFiles ){
                var file = langFiles[ index ];
                var url = urlPrefix + file;
                jsonFiles.push( url );
            }
        }
        
        // Use loadAsync method to load all jsonFiles; then register I18n instances and arrays
        loadAsync( 
            jsonFiles, 
            function( i18nMap ){
                
                for ( var lang in i18n.files ){
                    var langFiles = i18n.files[ lang ];
                    var i18nInstanceArray = [];
                    
                    // Register array vars
                    dictionary[ buildI18nInstanceArrayName( lang ) ] = i18nInstanceArray;
                    if ( numberOfLanguages === 1 ){
                        dictionary[ 'i18nArray' ] = i18nInstanceArray;
                    }
                    
                    for ( var index in langFiles ){
                        var file = langFiles[ index ];
                        var url = urlPrefix + file;
                        var i18nInstance = new I18n( lang, i18nMap[ url ] );
                        
                        // Register i18n instances
                        dictionary[ buildI18nInstanceName( file ) ] = i18nInstance;
                        i18nInstanceArray.unshift( i18nInstance ); // Add to the beginning of the array
                    }
                }
                
                callback();
            },
            failCallback 
        );
    };
    
    var buildI18nInstanceArrayName = function( lang ){
        return 'i18n' + lang.toUpperCase() + 'Array';
    };
    
    var buildI18nInstanceName = function( file ){
        
        var fileWithoutExtension = file.substr( 0, file.lastIndexOf( '.' ) );
        return 'i18n' + fileWithoutExtension.toUpperCase();
    };

    return {
        tr: tr,
        loadAsync: loadAsync,
        loadAsyncAuto: loadAsyncAuto
    };
})();

},{"../context.js":27,"../utils.js":101,"./i18n.js":71}],74:[function(require,module,exports){
/*
    logHelper singleton class
*/
module.exports = (function() {
    "use strict";
    
    var context = require( './context.js' );
    
    var trace = function (){
        
        var logger = context.getLogger();
        
        if ( ! logger ){
            return;
        }
        
        logger.trace.apply( logger, arguments );
    };
    
    var debug = function (){
        
        var logger = context.getLogger();
        
        if ( ! logger ){
            return;
        }
        
        logger.debug.apply( logger, arguments );
    };
    
    var info = function (){
        
        var logger = context.getLogger();
        
        if ( ! logger ){
            return;
        }
        
        logger.info.apply( logger, arguments );
    };
    
    var warn = function (){
        
        var logger = context.getLogger();
        
        if ( ! logger ){
            return;
        }
        
        logger.warn.apply( logger, arguments );
    };
    
    var error = function (){
        
        var logger = context.getLogger();
        
        if ( ! logger ){
            return;
        }
        
        logger.error.apply( logger, arguments );
    };
    
    var fatal = function (){
        
        var logger = context.getLogger();
        
        if ( ! logger ){
            return;
        }
        
        logger.fatal.apply( logger, arguments );
    };
    
    /*
    var fatalAndThrow = function ( message ){
        
        fatal.apply( this, arguments );
        throw message;
    };*/
    
    return {
        trace: trace,
        debug: debug,
        info: info,
        warn: warn,
        error: error,
        fatal: fatal
        //fatalAndThrow: fatalAndThrow
    };
})();

},{"./context.js":27}],75:[function(require,module,exports){
/*
    Exported functions
*/
exports.run = function( options ){
    
    var parser = require( './parsers/parser.js' );
    return parser.run( options );
};

/* Declare exports */
exports.I18n = require( './i18n/i18n.js' );
exports.I18nBundle = require( './i18n/i18nBundle.js' );
exports.i18nHelper = require( './i18n/i18nHelper.js' );
exports.context = require( './context.js' );
exports.logHelper = require( './logHelper.js' );
exports.expressionBuilder = require( './expressions/expressionBuilder.js' );
exports.evaluateHelper = require( './expressions/evaluateHelper.js' );
exports.ExpressionTokenizer = require( './expressions/expressionTokenizer.js' );
exports.ReactiveDictionary = require( './scopes/reactiveDictionary.js' );
exports.version = require( './version.js' );

/* Support RequireJS module pattern */
if ( typeof define === 'function' && define.amd ) {
    define( 'zpt.run', exports.run );
    define( 'zpt.I18n', exports.I18n );
    define( 'zpt.I18nBundle', exports.I18nBundle );
    define( 'zpt.i18nHelper', exports.i18nHelper );
    define( 'zpt.context', exports.context );
    define( 'zpt.logHelper', exports.logHelper );
    define( 'zpt.expressionBuilder', exports.expressionBuilder );
    define( 'zpt.evaluateHelper', exports.evaluateHelper );
    define( 'zpt.ExpressionTokenizer', exports.ExpressionTokenizer );
    define( 'zpt.ReactiveDictionary', exports.ReactiveDictionary );
    define( 'zpt.version', exports.version );
}

},{"./context.js":27,"./expressions/evaluateHelper.js":44,"./expressions/expressionBuilder.js":46,"./expressions/expressionTokenizer.js":47,"./i18n/i18n.js":71,"./i18n/i18nBundle.js":72,"./i18n/i18nHelper.js":73,"./logHelper.js":74,"./parsers/parser.js":92,"./scopes/reactiveDictionary.js":98,"./version.js":102}],76:[function(require,module,exports){
/* 
    Class AutoDefineHelper 
*/
var context = require( '../context.js' );
var TALDefine = require( '../attributes/TAL/talDefine.js' );

module.exports = function ( node ) {
    "use strict";
    
    var defineDelimiter = context.getConf().defineDelimiter;
    var inDefineDelimiter = context.getConf().inDefineDelimiter;
    var nocallExpressionPrefix = context.getConf().nocallVariableExpressionPrefix;
    var talAutoDefine = context.getTags().talAutoDefine;

    var buffer = '';
    if ( node && node.getAttribute( talAutoDefine ) ){
        buffer = node.getAttribute( talAutoDefine );
    }
    
    var put = function( name, string, nocall ){
        
        if ( buffer !== '' ){
            buffer += defineDelimiter;
        }
        buffer += (nocall? nocallExpressionPrefix + inDefineDelimiter: '') + name + inDefineDelimiter + string;
    };

    var updateNode = function( node ){

        if ( buffer ){
            node.setAttribute( talAutoDefine, buffer );
            return buffer;
        }
    };
    
    return {
        put: put,
        updateNode: updateNode
    };
};

},{"../attributes/TAL/talDefine.js":18,"../context.js":27}],77:[function(require,module,exports){
/* 
    Class DepsDataItem 
*/
"use strict";

var DepsDataItem = function() {
    
    this.nonExpressionVars = {};
    this.expressionVars = {};
};

DepsDataItem.prototype.mustAddVar = function( varName ){
    return this.nonExpressionVars[ varName ] === undefined && this.expressionVars[ varName ] === undefined;
};

DepsDataItem.prototype.addAllVars = function( varNames, scope ){
    
    for ( var name in varNames ){
        this.add1Var( varNames[ name ], scope );
    }
};

DepsDataItem.prototype.add1ExpressionVar = function( varName ){
    this.expressionVars[ varName ] = true;
};

DepsDataItem.prototype.add1NonExpressionVar = function( varName ){
    this.nonExpressionVars[ varName ] = true;
};

DepsDataItem.prototype.add1Var = function( varName, scope ){

    var map = scope.isLocalVar( varName )? this.expressionVars: this.nonExpressionVars;
    map[ varName ] = true;

    return true;
};

module.exports = DepsDataItem;

},{}],78:[function(require,module,exports){
/* 
    Class AbstractAction
*/
"use strict";

var utils = require( '../../utils.js' );
var context = require( '../../context.js' );

var AbstractAction = function( object, dictionary ) {
    
    this.id = object.id;
    this.var = object.var;
    this.currentElement = object.currentElement;
    this.animation = object.animation;
    this.animationCallback = object.animationCallback;
    if ( object.search ){
        if ( this.id || this.var ){
            throw 'Error in action: you can not set a search and then and id: if you set a search ZPT-JS will set the id for you!';
        }
        this.initializeUsingSearch( object.search, dictionary );
    }
};

AbstractAction.prototype.initializeUsingSearch = function( search, dictionary ){

    this.id = '';
    this.var = dictionary;
    
    // Iterate search items and build id and var
    for ( var i = 0; i < search.length; ++i ){
        var item = search[ i ];
        
        // Replace item is it a search object, '_first_' or '_last_'
        if ( utils.isPlainObject( item ) ){
            item = this.search( this.var, item );
        } else if ( item === context.getConf().firstIndexIdentifier ){
            item = 0;
        } else if ( item === context.getConf().lastIndexIdentifier ){
            item = this.var.length - 1;
        }
        
        // Build the id
        if ( Number.isInteger( item ) ){
            this.id += '[' + item + ']';
        } else {
            var separator = i === 0? '': '.';
            this.id += separator + item;
        }
        
        // Build the var
        this.var = this.var[ item ];
    }
};

AbstractAction.prototype.search = function( list, expressionElement ){
    
    for ( var i = 0; i < list.length; ++i ){
        var record = list[ i ];
        if ( AbstractAction.elementMaches( record, expressionElement ) ){
            return i;
        }
    }
    
    throw 'No record found matching your criteria!';
};

AbstractAction.elementMaches = function( element, expressionElement ){
    
    if ( expressionElement == undefined ){
        throw 'Expression to match must not be null!';
    }

    if ( Array.isArray( expressionElement ) ){
        throw 'Expression ' + utils.genericToString( expressionElement ) + ' to match must not be an array!';
    }

    if ( utils.isPlainObject( expressionElement ) ){
        for ( var i in expressionElement ){
            if ( expressionElement[ i ] !== element[ i ] ){
                return false;
            }
        }
        return true;
    }

    // Must be numeric or string
    return element === expressionElement;
};

AbstractAction.prototype.getValue = function( dictionary ){
    return this.var === undefined?
        dictionary[ this.id ]:
        this.var;
};

AbstractAction.prototype.resolveThisNode = function( indexItem, parserUpdater ){
    
    //var attributeInstance = indexItem.attributeInstance;
    var node = parserUpdater.findNodeById( indexItem.nodeId );
    if ( ! node ){
        // Removed node!
        parserUpdater.addRemovedToStatistics();
        return false;
    }
    parserUpdater.addUpdatedToStatistics();
    
    // Return the node
    return node;
};

AbstractAction.prototype.attributeInstanceIsRelated = function( attributeInstance ){
    throw 'Error: attributeInstanceIsRelated must be implemented!';
};

AbstractAction.prototype.updateDictionary = function(){
    throw 'Error: updateDictionary must be implemented!';
};

AbstractAction.prototype.updateHTML = function(){
    throw 'Error: updateHTML must be implemented!';
};

module.exports = AbstractAction;

},{"../../context.js":27,"../../utils.js":101}],79:[function(require,module,exports){
/* 
    Class AbstractArrayAction
*/
"use strict";

var AbstractAction = require( './abstractAction.js' );
var utils = require( '../../utils.js' );
var context = require( '../../context.js' );

var AbstractArrayAction = function( object, dictionary ) {
    AbstractAction.call( this, object, dictionary );
    
    this.index = object.index;
};

AbstractArrayAction.prototype = Object.create( AbstractAction.prototype );

AbstractArrayAction.getIndexNumericValue = function( index ){
    
    if ( index === undefined ){
        return undefined;   
    }
    
    if ( index === context.getConf().firstIndexIdentifier ){
        return 0;
    } else if ( index === context.getConf().lastIndexIdentifier ){
        return -1; // This means it is the last
    }
    return index;
};

AbstractArrayAction.prototype.getIndexNumericValue = function(){
    return AbstractArrayAction.getIndexNumericValue( this.index );
};

AbstractArrayAction.prototype.getIndexToUse = function( dictionary ){

    if ( this.index === undefined && this.currentElement === undefined ){
        throw 'index or currentElement must be defined in ' + this.id + ' array action!';
    }
    
    // Check if it uses the index
    var indexNumericValue = this.getIndexNumericValue();
    if ( indexNumericValue !== undefined ){
        return indexNumericValue;
    }

    // Must use currentElement
    var arrayValue = this.getValue( dictionary );
    
    for ( var i = 0; i < arrayValue.length; ++i ){
        var element = arrayValue[ i ];
        if ( AbstractAction.elementMaches( element, this.currentElement ) ){
            return i;
        }
    }
    
    throw 'currentElement ' + utils.genericToString( this.currentElement ) + ' not found in ' + this.id + ' array action!';
};

AbstractArrayAction.prototype.attributeInstanceIsRelated = function( attributeInstance ){
    return AbstractArrayAction.staticAttributeInstanceIsRelated( attributeInstance );
};

AbstractArrayAction.staticAttributeInstanceIsRelated = function( attributeInstance ){
    return attributeInstance.type === 'tal:repeat';
};

AbstractArrayAction.prototype.updateDictionary = function(){
    throw 'Error: updateDictionary must be implemented!';
};

AbstractArrayAction.prototype.updateHTML = function(){
    throw 'Error: updateHTML must be implemented!';
};

AbstractArrayAction.prototype.resolveChildNode = function( indexItem, parserUpdater ){
    
    //var attributeInstance = indexItem.attributeInstance;
    var node = parserUpdater.findNodeById( indexItem.nodeId );
    if ( ! node ){
        // Removed node!
        parserUpdater.addRemovedToStatistics();
        return false;
    }
    parserUpdater.addUpdatedToStatistics();
    
    // Return the node
    return this.indexToUse === -1?
        null:
        this.getIndexOfLoop( node.parentNode, indexItem.nodeId, this.indexToUse );
};

AbstractArrayAction.prototype.getIndexOfLoop = function( parentNode, nodeId, indexInLoop ){
    
    var numberOfChildren = parentNode.childElementCount;
    for ( var i = 0; i < numberOfChildren; ++i ){
        var childNode = parentNode.children[ i ];
        var currentNodeId = childNode.getAttribute( context.getTags().id );
        if ( currentNodeId === nodeId ){
            return parentNode.children[ 1 + i + indexInLoop ];
        }
    }
    
    return null;
};

module.exports = AbstractArrayAction;

},{"../../context.js":27,"../../utils.js":101,"./abstractAction.js":78}],80:[function(require,module,exports){
/* 
    Class AbstractObjectAction
*/
"use strict";

var AbstractAction = require( './abstractAction.js' );

var AbstractObjectAction = function( object, dictionary ) {
    AbstractAction.call( this, object, dictionary );
    
    this.property = object.property;
    this.id += '.' + object.property;
};

AbstractObjectAction.prototype = Object.create( AbstractAction.prototype );

AbstractObjectAction.prototype.attributeInstanceIsRelated = function( attributeInstance ){
    return true;
};

AbstractObjectAction.prototype.updateHTML = function( indexItem, parserUpdater, actionInstance ){
    
    // Must get the node
    var node = this.resolveThisNode( indexItem, parserUpdater );
    if ( ! node ){
        throw 'No node found to update';
    }
    
    // Update the selected node
    parserUpdater.updateNode( node );
    
    // Run animation
    parserUpdater.runAnimation( actionInstance, node );
    
    return true;
};

module.exports = AbstractObjectAction;

},{"./abstractAction.js":78}],81:[function(require,module,exports){
/* 
    Class ArrayCreate
*/
"use strict";

var AbstractArrayAction = require( './abstractArrayAction.js' );
var context = require( '../../context.js' );
var ParserNodeRenderer = require( '../../parsers/parserNodeRenderer.js' );
var utils = require( '../../utils.js' );

var ArrayCreate = function( object, dictionary ) {
    AbstractArrayAction.call( this, object, dictionary );
    
    this.newElement = object.newElement;
};

ArrayCreate.prototype = Object.create( AbstractArrayAction.prototype );

ArrayCreate.prototype.updateDictionary = function( dictionary ){
    
    this.indexToUse = this.getIndexToUse( dictionary );
    var arrayValue = this.getValue( dictionary );
    
    if ( this.indexToUse === -1 ){
        this.resolvedIndex = arrayValue.length;
        arrayValue.push( this.newElement );
    } else {
        this.resolvedIndex = this.indexToUse;
        arrayValue.splice( this.indexToUse, 0, this.newElement );
    }
};

ArrayCreate.prototype.updateHTML = function( indexItem, parserUpdater, actionInstance ){
    
    // Must get the nodeToUpdate
    var node = this.resolveThisNode( indexItem, parserUpdater );
    if ( ! node ){
        throw 'No node found to clone';
    }
    
    // Init some vars
    var tags = context.getTags();
    var parentNode = node.parentNode;
    
    // Clone and configure the node
    var tmpNode = ParserNodeRenderer.cloneAndConfigureNode( 
        node, 
        true, 
        tags, 
        node.getAttribute( tags.id ) 
    );
    ParserNodeRenderer.configureNodeForNewItem( 
        tmpNode, 
        tags, 
        parentNode, 
        indexItem, 
        this.resolvedIndex
    );
    
    // Insert it
    var sibling = this.indexToUse === -1?
        null:
        parentNode.children[ 1 + this.indexToUse ];
    parentNode.insertBefore( tmpNode, sibling );
    
    // Update the selected node
    parserUpdater.updateNode( tmpNode );
    
    // Run animation
    parserUpdater.runAnimation( actionInstance, tmpNode );
    
    return true;
};

ArrayCreate.buildMultiple = function( object, dictionary ){

    var actions = [];
    
    // Copy newElements to a new array
    var newElements = utils.copyArray( object.newElement );
    
    // Configure the object, create the first instance and add it to the list
    object.newElement = newElements[ 0 ];
    var firstActionInstance = new ArrayCreate( object, dictionary );
    actions.push( firstActionInstance );
    
    // Get the firstIndex and if the new elments must be the last
    var firstIndex = firstActionInstance.getIndexNumericValue();
    var isLast = -1 === firstIndex;
        
    // Build actions list
    for ( var i = 1; i < newElements.length; ++i ){
        var newElement = newElements[ i ];
        
        // Clone the object and configure the newElement and the index
        var newObject = utils.deepExtend( object );
        newObject.newElement = newElement;
        newObject.index = isLast?
            -1:
            firstIndex + i;
        
        // Instance the action instance and add it to the list
        var newActionInstance = new ArrayCreate( newObject, dictionary );
        actions.push( newActionInstance );
    }
    
    return actions;
};

module.exports = ArrayCreate;

},{"../../context.js":27,"../../parsers/parserNodeRenderer.js":93,"../../utils.js":101,"./abstractArrayAction.js":79}],82:[function(require,module,exports){
/* 
    Class ArrayDelete
*/
"use strict";

var AbstractArrayAction = require( './abstractArrayAction.js' );
var utils = require( '../../utils.js' );
var attributeIndex = require( '../../attributes/attributeIndex.js' );
var nodeRemover = require( '../nodeRemover.js' );

var ArrayDelete = function( object, dictionary ) {
    AbstractArrayAction.call( this, object, dictionary );
};

ArrayDelete.prototype = Object.create( AbstractArrayAction.prototype );

ArrayDelete.prototype.updateDictionary = function( dictionary ){

    this.indexToUse = this.getIndexToUse( dictionary );
    var arrayValue = this.getValue( dictionary );
    arrayValue.splice( this.indexToUse, 1 );
};

ArrayDelete.prototype.updateHTML = function( indexItem, parserUpdater, actionInstance, continueData ){
    
    // Must get the nodeToUpdate
    var nodeToDelete = this.resolveChildNode( indexItem, parserUpdater );
    if ( ! nodeToDelete ){
        throw 'No node found to be deleted at this index: ' + this.indexToUse;
    }
    
    // Run animation
    parserUpdater.runAnimation( 
        actionInstance, 
        nodeToDelete, 
        function(){
            
            // Remove the selected node from the index and from HTML
            //attributeIndex.removeNode( nodeToDelete ); 
            nodeRemover.removeNode( nodeToDelete );
            //TODO update next siblings?
            
            // Continue
            parserUpdater.continueUpdateHTML( continueData );
        } 
    );
    
    //return true;
    return false;
};

ArrayDelete.buildMultiple = function( object, dictionary ){

    var actions = [];
    var property = object.index? 'index': 'currentElement';

    // Copy indexes to a new array
    var allItems = utils.copyArray( object[ property ] );
    
    // Build actions list
    for ( var i = 0; i < allItems.length; ++i ){
        var item = allItems[ i ];
        
        // Clone the object and configure the index
        var newObject = utils.deepExtend( object );
        newObject[ property ] = item;
        
        // Instance the action instance and add it to the list
        var newActionInstance = new ArrayDelete( newObject, dictionary );
        newActionInstance.index = newActionInstance.getIndexToUse( dictionary );
        actions.push( newActionInstance );
    }
    
    // Sort actions
    actions.sort(
        function( a, b ){ return b.index - a.index; }
    );
    
    return actions;
};

module.exports = ArrayDelete;

},{"../../attributes/attributeIndex.js":23,"../../utils.js":101,"../nodeRemover.js":91,"./abstractArrayAction.js":79}],83:[function(require,module,exports){
/* 
    Class ArrayUpdate
*/
"use strict";

var AbstractArrayAction = require( './abstractArrayAction.js' );

var ArrayUpdate = function( object, dictionary ) {
    AbstractArrayAction.call( this, object, dictionary );
    
    this.newElement = object.newElement;
};

ArrayUpdate.prototype = Object.create( AbstractArrayAction.prototype );

ArrayUpdate.prototype.updateDictionary = function( dictionary ){
    
    this.indexToUse = this.getIndexToUse( dictionary );
    var arrayValue = this.getValue( dictionary );
    arrayValue[ this.indexToUse ] = this.newElement;
};

ArrayUpdate.prototype.updateHTML = function( indexItem, parserUpdater, actionInstance ){
    
    // Must get the nodeToUpdate
    var nodeToUpdate = this.resolveChildNode( indexItem, parserUpdater );
    if ( ! nodeToUpdate ){
        throw 'No node found to be updated at this index: ' + this.indexToUse;
    }
    
    // Update the selected node
    parserUpdater.updateNode( nodeToUpdate, true );
    
    // Run animation
    parserUpdater.runAnimation( actionInstance, nodeToUpdate );
    
    return true;
};

module.exports = ArrayUpdate;

},{"./abstractArrayAction.js":79}],84:[function(require,module,exports){
/* 
    Class CSSAnimationManager 
*/
"use strict";

module.exports = (function() {
    
    var animate = function( dictionaryAction, node, callback ) {
        
        // Run callback and return if there is no animation
        if ( ! dictionaryAction.animation ){
            if ( callback ){
                callback();
            };
            return;
        }
        
        // Set the animation
        node.style.animation = 'none';
        setTimeout(
            function() {
                // Set the animationend listener
                var animationendCallback = function( event ){
                    if ( callback ){
                        callback();
                    }
                };
                //node.removeEventListener( 'animationend', animationendCallback );
                node.addEventListener( 'animationend', animationendCallback );

                // Set the animation
                node.style.animation = dictionaryAction.animation;
            }, 
            10
        );
    };
    
    var reset = function( node ) {
        node.style.animation = 'none';
    };
    
    var self = {
        animate: animate,
        reset: reset
    };
    
    return self;
})();

},{}],85:[function(require,module,exports){
/* 
    Class dictionaryActionBuilder 
*/
"use strict";

var ArrayUpdate = require( './arrayUpdate.js' );
var ArrayDelete = require( './arrayDelete.js' );
var ArrayCreate = require( './arrayCreate.js' );
var ObjectUpdate = require( './objectUpdate.js' );
var ObjectDelete = require( './objectDelete.js' );

module.exports = (function() {
    
    var build = function( object, dictionary ) {
        
        switch ( object.action ) {
        case 'updateArray':
            return new ArrayUpdate( object, dictionary );
        case 'deleteArray':
            return Array.isArray( object.index ) || Array.isArray( object.currentElement )? 
                ArrayDelete.buildMultiple( object, dictionary ):
                new ArrayDelete( object, dictionary );
        case 'createArray':
            return Array.isArray( object.newElement )? 
                ArrayCreate.buildMultiple( object, dictionary ):
                new ArrayCreate( object, dictionary );
        case 'updateObject':
            return object.editedProperties || object.deletedProperties?
                ObjectUpdate.buildMultiple( object, dictionary ):
                new ObjectUpdate( object, dictionary );
        case 'deleteObject':
            return new ObjectDelete( object, dictionary );
        default:
            throw 'Unknown dictionary action: ' + object.action;
        }
    };
    
    var self = {
        build: build
    };
    
    return self;
})();

},{"./arrayCreate.js":81,"./arrayDelete.js":82,"./arrayUpdate.js":83,"./objectDelete.js":86,"./objectUpdate.js":87}],86:[function(require,module,exports){
/* 
    Class ObjectDelete
*/
"use strict";

var AbstractObjectAction = require( './abstractObjectAction.js' );

var ObjectDelete = function( object, dictionary ) {
    AbstractObjectAction.call( this, object, dictionary );
};

ObjectDelete.prototype = Object.create( AbstractObjectAction.prototype );

ObjectDelete.prototype.updateDictionary = function( dictionary ){
    
    var objectValue = this.getValue( dictionary );
    delete objectValue[ this.property ];
};

module.exports = ObjectDelete;

},{"./abstractObjectAction.js":80}],87:[function(require,module,exports){
/* 
    Class ObjectUpdate
*/
"use strict";

var AbstractObjectAction = require( './abstractObjectAction.js' );
var ObjectDelete = require( './objectDelete.js' );
var utils = require( '../../utils.js' );

var ObjectUpdate = function( object, dictionary ) {
    AbstractObjectAction.call( this, object, dictionary );
    
    this.newElement = object.newElement;
};

ObjectUpdate.prototype = Object.create( AbstractObjectAction.prototype );

ObjectUpdate.prototype.updateDictionary = function( dictionary ){
    
    var objectValue = this.getValue( dictionary );
    objectValue[ this.property ] = this.newElement;
};

ObjectUpdate.buildMultiple = function( object, dictionary ){

    var actions = [];
    var clonedObject = utils.deepExtend( object );
    
    // Copy editedProperties and deletedProperties
    var editedProperties = clonedObject.editedProperties;
    var deletedProperties = clonedObject.deletedProperties;
    
    // Delete them
    delete clonedObject.editedProperties;
    delete clonedObject.deletedProperties;
        
    // Build actions list for editedProperties
    if ( editedProperties ){
        clonedObject.action = 'updateObject';
        for ( var editedPropertiesId in editedProperties ){
            var editedPropertiesValue = editedProperties[ editedPropertiesId ];

            // Clone the object and configure property and newElement
            var newObject = utils.deepExtend( clonedObject );
            newObject.property = editedPropertiesId;
            newObject.newElement = editedPropertiesValue;

            // Instance the action instance and add it to the list
            var newActionInstance = new ObjectUpdate( newObject, dictionary );
            actions.push( newActionInstance );
        }
    }
    
    // Build actions list for deletedProperties
    if ( deletedProperties ){
        clonedObject.action = 'deleteObject';
        for ( var i = 0; i < deletedProperties.length; ++i ){
            var deletedPropertiesItem = deletedProperties[ i ];

            // Clone the object and configure property
            newObject = utils.deepExtend( clonedObject );
            newObject.property = deletedPropertiesItem;

            // Instance the action instance and add it to the list
            newActionInstance = new ObjectDelete( newObject, dictionary );
            actions.push( newActionInstance );
        }
    }
    
    return actions;
};

module.exports = ObjectUpdate;

},{"../../utils.js":101,"./abstractObjectAction.js":80,"./objectDelete.js":86}],88:[function(require,module,exports){
/* 
    Class Loop 
*/
"use strict";

var AutoDefineHelper = require( './autoDefineHelper.js' );
var expressionBuilder = require( '../expressions/expressionBuilder.js' );
var context = require( '../context.js' );

var Loop = function ( _itemVariableName, _expressionString, scope ) {
    
    var itemVariableName = _itemVariableName;
    var expressionString = _expressionString;
    
    var expression = expressionBuilder.build( expressionString );
    var getExpression = function(){
        return expression;
    };
    
    var items = expression.evaluate( scope );
    var getItems = function(){
        return items;
    };
    
    var currentIndex = -1;
    var maxIndex = items? items.length - 1: -1;
    
    var offset = 0;
    var setOffset = function( _offset ){
        offset = _offset;
    };
    
    var repeat = function(){
        
        if ( currentIndex++ < maxIndex ) {
            
            return Loop.buildAutoDefineHelper( 
                itemVariableName, 
                currentIndex, 
                expressionString, 
                items.length, 
                offset 
            );
        }
        
        return null;
    };
    
    return {
        setOffset: setOffset,
        repeat:repeat,
        getItems: getItems,
        getExpression: getExpression
    };
};

Loop.buildAutoDefineHelper = function( itemVariableName, itemIndex, expressionString, numberOfItems, offset ){
    
    var autoDefineHelper = new AutoDefineHelper();

    // Declare item-index, item-all, item and item-repeat variables
    autoDefineHelper.put(
        itemVariableName + '-index',
        itemIndex
    );
    autoDefineHelper.put(
        itemVariableName + '-all',
        expressionString
    );
    autoDefineHelper.put(
        itemVariableName,
        itemVariableName + '-all' + '[' + itemVariableName + '-index' + ']'
    );
    autoDefineHelper.put(
        itemVariableName + '-repeat',
        "context/repeat(" 
            + itemVariableName + "-index" + ","
            + numberOfItems + ","
            + offset
            + ")"
    );

    return autoDefineHelper;
};

Loop.setAutoDefineAttribute = function( node, itemVariableName, itemIndex, expressionString, numberOfItems, offset ){
    
    // Set item-index, item-all, item and item-repeat attributes
    node.setAttribute( 
        context.getTags().talAutoDefine,
        itemVariableName + '-index ' + itemIndex + ';'
            + itemVariableName + '-all ' + expressionString + ';'
            + itemVariableName + ' ' + itemVariableName +'-all[' + itemVariableName + '-index];'
            + itemVariableName + '-repeat context/repeat(' + itemVariableName + '-index,' + numberOfItems + ',' + offset + ')'
    );
};

module.exports = Loop;

},{"../context.js":27,"../expressions/expressionBuilder.js":46,"./autoDefineHelper.js":76}],89:[function(require,module,exports){
/* 
    Class LoopItem
*/
"use strict";

var LoopItem = function ( _currentIndex, _itemsLength, _offset ) {
    
    this.currentIndex = _currentIndex;
    this.itemsLength = _itemsLength;
    this.offset = _offset;
};

LoopItem.prototype.index = function( ) {
    return this.offset + this.currentIndex;
};

LoopItem.prototype.number = function( ) {
    return this.index() + 1;
};

LoopItem.prototype.even = function( ) {
    return this.index() % 2 === 0;
};

LoopItem.prototype.odd = function ( ) {
    return this.index() % 2 === 1;
};

LoopItem.prototype.start = function ( ) {
    return this.index() === 0;
};

LoopItem.prototype.end = function ( ) {
    return this.currentIndex === this.itemsLength - 1;
};

LoopItem.prototype.length = function () {
    return this.offset + this.itemsLength;
};

LoopItem.prototype.letter = function () {
    return this.formatLetter( this.index(), 'a' );
};

LoopItem.prototype.Letter = function () {
    return this.formatLetter( this.index(), 'A' );
};

LoopItem.prototype.formatLetter = function ( ii, startChar ) {
    var i = ii;
    var buffer = '';
    var start = startChar.charCodeAt( 0 ); 
    var digit = i % 26;
    buffer += String.fromCharCode( start + digit );

    while( i > 25 ) {
        i /= 26;
        digit = (i - 1 ) % 26;
        buffer += String.fromCharCode( start + digit );
    }

    return buffer.split('').reverse().join('');
};

LoopItem.prototype.roman = function () {
    return this.formatRoman( this.index() + 1, 0 );
};

LoopItem.prototype.Roman = function () {
    return this.formatRoman( this.index() + 1, 1 );
};

LoopItem.prototype.formatRoman = function ( nn, capital ) {
    var n = nn;

    // Can't represent any number 4000 or greater
    if ( n >= 4000 ) {
        return 'Overflow formatting roman!';
    }

    var buf = '';
    for ( var decade = 0; n !== 0; decade++ ) {
        var digit = n % 10;
        if ( digit > 0 ) {
            digit--;
            buf += this.romanArray [ decade ][ digit ][ capital ];
        }
        n = (n / 10) >> 0;
    }

    return buf.split( '' ).reverse().join( '' );
};

LoopItem.prototype.romanArray = [
    /* One's place */
    [
        [ "i", "I" ],
        [ "ii", "II" ], 
        [ "iii", "III" ],
        [ "vi", "VI" ],
        [ "v", "V" ],
        [ "iv", "IV" ],
        [ "iiv", "IIV" ],
        [ "iiiv", "IIIV" ],
        [ "xi", "XI" ]
    ],

    /* 10's place */
    [
        [ "x", "X" ],
        [ "xx", "XX" ],
        [ "xxx", "XXX" ],
        [ "lx", "LX" ],
        [ "l", "L" ],
        [ "xl", "XL" ],
        [ "xxl", "XXL" ],
        [ "xxxl", "XXXL" ],
        [ "cx", "CX" ]
    ],

    /* 100's place */
    [
        [ "c", "C" ],
        [ "cc", "CC" ],
        [ "ccc", "CCC" ],
        [ "dc", "DC" ],
        [ "d", "D" ],
        [ "cd", "CD" ],
        [ "ccd", "CCD" ],
        [ "cccd", "CCCD" ],
        [ "mc", "MC" ]
    ],

    /* 1000's place */
    [
        [ "m", "M" ],
        [ "mm", "MM" ],
        [ "mmm", "MMM" ]
    ]
];

module.exports = LoopItem;

},{}],90:[function(require,module,exports){
/* 
    Class NodeAttributes 
*/
"use strict";

var context = require( '../context.js' );

var NodeAttributes = function( node, indexExpressions ) {
    
    var tags = context.getTags();
    
    // tal namespace
    this.talDefine = node.getAttribute( tags.talDefine );
    this.talCondition = node.getAttribute( tags.talCondition );
    this.talRepeat = node.getAttribute( tags.talRepeat );
    this.talContent = node.getAttribute( tags.talContent );
    this.talAttributes = node.getAttribute( tags.talAttributes );
    this.talOmitTag = node.getAttribute( tags.talOmitTag );
    this.talReplace = node.getAttribute( tags.talReplace );
    this.talOnError = node.getAttribute( tags.talOnError );
    this.talDeclare = node.getAttribute( tags.talDeclare );
    //this.talTag = undefined;
    
    // metal namespace
    this.metalDefineMacro = node.getAttribute( tags.metalDefineMacro );
    this.metalUseMacro = node.getAttribute( tags.metalUseMacro );
    this.metalDefineSlot = node.getAttribute( tags.metalDefineSlot );
    this.metalFillSlot = node.getAttribute( tags.metalFillSlot );
    
    // i18n namespace
    this.i18nDomain = node.getAttribute( tags.i18nDomain );
    this.i18nLanguage = node.getAttribute( tags.i18nLanguage );
    
    // For internal use
    this.qdup = node.getAttribute( tags.qdup );
    
    // Init this.id and set the node id if indexExpressions is true, some attribute is set and it is undefined
    if ( indexExpressions && this.isDynamicContentOn() ){
        this.id = node.getAttribute( tags.id );
        if ( ! this.id ){
            //this.id = utils.generateId( 6 );
            this.id = context.nextExpressionCounter();
            node.setAttribute( tags.id, this.id );
        }
    }
};

NodeAttributes.prototype.isDynamicContentOn = function() {
    
    return this.talDefine 
        || this.talCondition
        || this.talRepeat
        || this.talContent
        || this.talAttributes
        || this.talOmitTag 
        || this.talReplace
        || this.talOnError
        || this.talDeclare
        //|| this.talTag
        //|| this.metalDefineMacro 
        || this.metalUseMacro 
        //|| this.metalDefineSlot 
        || this.metalFillSlot 
        || this.i18nDomain
        || this.i18nLanguage;
        //|| this.qdup;
};

module.exports = NodeAttributes;

},{"../context.js":27}],91:[function(require,module,exports){
/* 
    Class NodeRemover 
*/
"use strict";

var context = require( '../context.js' );

module.exports = (function() {
    
    var tags = context.getTags();
    
    var removeGeneratedNodes = function( target ) {
        
        // Is multiroot?
        if ( Array.isArray( target ) ){ 
            // There are several roots
            
            var result = [];
            for ( var c = 0; c < target.length; c++ ) {
                result = result.concat( 
                    removeNodes( target[ c ] )
                );
            }
            return result;
        }
        
        // There is only one root
        return removeNodes( target );
    };
    
    var removeNodes = function( target ) {
        
        var result = [];
        
        result = result.concat( removeNodesByTag( target, tags.qdup ) );       // Remove all generated nodes (repeats)
        result = result.concat( removeNodesByTag( target, tags.metalMacro ) ); // Remove all generated nodes (macros)
        
        return result;
    };
    
    var removeNodesByTag = function( target, tag ){
        
        var list = target.querySelectorAll( "*[" + tag + "]" );
        return removeList( list );
    };
    
    var removeRelatedNodes = function( target ){
        
        var list = target.parentNode.querySelectorAll( 
            '[' + context.getTags().relatedId + '="' + target.getAttribute( context.getTags().id ) + '"]' 
        );
        return removeList( list );
    };
    
    var removeList = function( list ){

        var result = [];
        
        var node;
        var pos = 0;
        while ( node = list[ pos++ ] ) {
            // Add nodeId to result if needed
            var nodeId = getNodeId( node );
            if ( nodeId !== undefined ){
                result.push( nodeId );
            }
            
            // Add the nodeIds of its children
            addNodeIdsToList( node, result );
            
            // Remove node
            node.parentNode.removeChild( node );
        }
        
        return result;
    };
    
    var addNodeIdsToList = function( target, result ){
        
        // Get the nodes with data-id
        var nodeIdAttributeName = context.getTags().id;
        var list = target.querySelectorAll( '[' + nodeIdAttributeName + ']' );
        
        // Iterate the list
        var node;
        var pos = 0;
        while ( node = list[ pos++ ] ) {
            result.push( 
                node.getAttribute( nodeIdAttributeName ) 
            );
        }
    };
    
    var getNodeId = function( node ){
        
        var nodeIdAttributeName = context.getTags().id;
        
        return node.hasAttribute( nodeIdAttributeName )?
            node.getAttribute( nodeIdAttributeName ):
            undefined;
    };
    
    var removeNode = function( node ){
        var nodeId = getNodeId( node );
        var parentNode = node.parentNode;
        if ( parentNode ){
            parentNode.removeChild( node );
        }
        return nodeId;
    };
    
    var removeMultipleNodes = function( node, mustRemoveGeneratedNodes ){
        
        var result = removeRelatedNodes( node );
        
        if ( mustRemoveGeneratedNodes ){
            result = result.concat(
                removeGeneratedNodes( node )
            );
        }
        
        return result;
    };
    
    var self = {
        removeGeneratedNodes: removeGeneratedNodes,
        //removeRelatedNodes: removeRelatedNodes,
        removeNode: removeNode,
        removeMultipleNodes: removeMultipleNodes
    };
    
    return self;
})();

},{"../context.js":27}],92:[function(require,module,exports){
/* 
    Class Parser 
*/
"use strict";

var context = require( '../context.js' );
var ParserRenderer = require( './parserRenderer.js' );
var ParserUpdater = require( './parserUpdater.js' );
var ParserPreloader = require( './parserPreloader.js' );
var ReactiveDictionary = require( '../scopes/reactiveDictionary.js' );

module.exports = (function() {
    
    var parserOptions = {
        command: undefined, // preload, fullRender or partialRender
        root: undefined,
        dictionary: {},
        indexExpressions: true
        //notRemoveGeneratedTags,
        //target,
        //declaredRemotePageUrls,
        //i18n,
        //callback,
        //failCallback,
    };
    
    var updateParserOptions = function( options ){
        
        parserOptions.command = options.command || 'fullRender';
        parserOptions.root = options.root === undefined? parserOptions.root: options.root;
        parserOptions.dictionary = ( options.dictionary instanceof ReactiveDictionary?
            options.dictionary._getNonReactiveDictionary(): 
            options.dictionary )
            || parserOptions.dictionary;
        //parserOptions.dictionary = options.dictionary || parserOptions.dictionary;
        parserOptions.indexExpressions = options.indexExpressions === undefined? parserOptions.indexExpressions: options.indexExpressions;
    };
    
    var run = function( _options ){
        
        var options = _options || {};
        
        // Init parser options
        updateParserOptions( options );
    
        var command = options.command || 'fullRender';
        switch ( command ) {
            case 'preload':
                return processPreload(
                    options.callback,
                    options.failCallback,
                    options.declaredRemotePageUrls || [],
                    options.i18n,
                    options.notRemoveGeneratedTags,
                    options.maxFolderDictionaries
                );
            case 'fullRender':
            case 'partialRender':
                return processRender(
                    command === 'partialRender'? options.target: parserOptions.root,
                    options.dictionaryExtension,
                    options.notRemoveGeneratedTags,
                    parserOptions.indexExpressions && command === 'fullRender',
                    options.goToURLHash === undefined? context.nextRunCounter() === 1: false
                );
            case 'update':
                return processUpdate( 
                    options.dictionaryChanges,
                    options.dictionaryActions
                );
            default:
                throw 'Unknown command: ' + command;
        }
    };
    
    var processPreload = function( callback, failCallback, declaredRemotePageUrls, i18n, notRemoveGeneratedTags, maxFolderDictionaries ){
        
        var parserPreloader = new ParserPreloader( 
            parserOptions, 
            callback, 
            failCallback, 
            declaredRemotePageUrls, 
            i18n, 
            notRemoveGeneratedTags, 
            maxFolderDictionaries
        );

        parserPreloader.run();

        return parserPreloader;
    };
    
    var processRender = function( target, dictionaryExtension, notRemoveGeneratedTags, resetIndex, goToURLHash ){
        
        var parserRenderer = new ParserRenderer( 
            parserOptions, 
            target, 
            dictionaryExtension, 
            notRemoveGeneratedTags, 
            resetIndex,
            goToURLHash
        );

        parserRenderer.run();
        
        return parserRenderer;
    };
    
    var processUpdate = function( dictionaryChanges, dictionaryActions ) {
        
        var parserUpdater = new ParserUpdater( 
            dictionaryChanges,
            dictionaryActions,
            parserOptions
        );

        parserUpdater.run();
        
        return parserUpdater;
    };
    
    var getOptions = function(){
        return parserOptions;
    };
    
    var self = {
        run: run,
        getOptions: getOptions
    };
    
    return self;
})();

},{"../context.js":27,"../scopes/reactiveDictionary.js":98,"./parserPreloader.js":94,"./parserRenderer.js":95,"./parserUpdater.js":96}],93:[function(require,module,exports){
(function (process){(function (){
/* 
    Class ParserNodeRenderer
*/
"use strict";

var context = require( '../context.js' );
var log = require( '../logHelper.js' );
var NodeAttributes = require( './nodeAttributes.js' );
var attributeCache = require( '../cache/attributeCache.js' );
var attributeIndex = require( '../attributes/attributeIndex.js' );
var AutoDefineHelper = require( './autoDefineHelper.js' );
var evaluateHelper = require( '../expressions/evaluateHelper.js' );
var Loop = require( './loop.js' );

var I18NDomain = require( '../attributes/I18N/i18nDomain.js' );
var I18NLanguage = require( '../attributes/I18N/i18nLanguage.js' );
var METALDefineMacro = require( '../attributes/METAL/metalDefineMacro.js' );
var METALUseMacro = require( '../attributes/METAL/metalUseMacro.js' );
var TALAttributes = require( '../attributes/TAL/talAttributes.js' );
var TALCondition = require( '../attributes/TAL/talCondition.js' );
var TALContent = require( '../attributes/TAL/talContent.js' );
var TALDefine = require( '../attributes/TAL/talDefine.js' );
var TALOmitTag = require( '../attributes/TAL/talOmitTag.js' );
var TALOnError = require( '../attributes/TAL/talOnError.js' );
var TALRepeat = require( '../attributes/TAL/talRepeat.js' );
var TALReplace = require( '../attributes/TAL/talReplace.js' );
var TALDeclare = require( '../attributes/TAL/talDeclare.js' );
var contentHelper = require( '../attributes/TAL/contentHelper.js' );

var ParserNodeRenderer = function( _target, _scope, _indexExpressions ) {
    
    var target = _target; 
    var scope = _scope;
    var indexExpressions = _indexExpressions;
    
    var tags = context.getTags();
    
    var run = function(){
        process( target );
    };
    
    var process = function( node ) {

        try {
            // Get the attributes from the node
            var attributes = new NodeAttributes( node, indexExpressions );
            
            scope.startElement();

            // Process instructions
            attributes.talRepeat != null ? 
                processLoop( node, attributes ):
                processElement( node, attributes );

            scope.endElement();

        } catch ( e ) {
            
            // Try to treat error
            if ( ! treatError( node, e ) ) {
                throw e;
            }
        }
    };
    
    var processLoopNextSibling = function( node ){

        var counter = -1;
        var nextSibling = node;
        do {
            ++counter;
            nextSibling = nextSibling.nextElementSibling;
            if ( ! nextSibling ){
                return {
                    nextSibling: null,
                    counter: counter
                };
            }
        } while ( nextSibling.hasAttribute( tags.qdup ) );

        return {
            nextSibling: nextSibling,
            counter: counter
        };
    };
    
    var processLoop = function( node, attributes ) {
        
        // Process repeat
        //var talRepeat = TALRepeat.build( attributes.talRepeat );
        var talRepeat = attributeCache.getByAttributeClass( 
            TALRepeat, 
            attributes.talRepeat, 
            node,
            indexExpressions,
            scope
        );
        var loop = talRepeat.process( scope, node );

        // Check default
        if ( evaluateHelper.isDefault( loop.getItems() ) ){
            processElement( node, attributes );
            return true;
        }
        
        // Configure the node to clone it later
        node.removeAttribute( tags.talRepeat );
        node.removeAttribute( 'style' );
        node.setAttribute( tags.qdup, 1 );
        var nodeId = node.getAttribute( 'id' );
        node.removeAttribute( 'id' );
        var nodeDataId = node.getAttribute( tags.id );
        node.removeAttribute( tags.id );
        
        var nextSiblingData = processLoopNextSibling( node );
        var nextSibling = nextSiblingData.nextSibling;
        loop.setOffset( nextSiblingData.counter );
        //log.warn( 'loop counter: ' + nextSiblingData.counter );
        
        var autoDefineHelper;
        while ( autoDefineHelper = loop.repeat() ) {
            
            scope.startElement();
            
            // Clone and configure the node
            var tmpNode = ParserNodeRenderer.cloneAndConfigureNode( node, indexExpressions, tags, nodeDataId );

            // Insert it
            var parentNode = node.parentNode;
            parentNode.insertBefore( tmpNode, nextSibling );
            
            // Process it
            if ( ! processElement( tmpNode, attributes, autoDefineHelper ) ) {
                scope.endElement();
                return false;
            }
            
            scope.endElement();
        }

        // Configure repeat node (the original) to enable future reevaluation
        node.style.display = 'none';
        node.setAttribute( tags.talRepeat, attributes.talRepeat );
        if ( nodeId !== '' && nodeId != null ){
            node.setAttribute( 'id', nodeId );
        }
        if ( nodeDataId !== '' && nodeDataId != null ){
            node.setAttribute( tags.id, nodeDataId );
        }
        node.removeAttribute( tags.qdup );
        
        return true;
    };

    var treatError = function( node, exception ) {

        try {
            // Set the error variable
            var templateError = {
                type: exception.name,
                value: exception.message,
                traceback: exception.stack
            };
            scope.set( 
                context.getConf().templateErrorVarName, 
                templateError 
            );
            
            // Exit if there is no on-error expression defined
            var content = scope.get( context.getConf().onErrorVarName );
            if ( content == null ) {
                log.fatal( exception );
                scope.endElement();
                return false;
            }
            
            log.error( exception );
            scope.endElement();
            
            contentHelper.updateNode( 
                node, 
                scope.get( context.getConf().onErrorStructureVarName ), 
                content 
            );
            
            return content;
            
        } catch ( e ) {
            log.fatal( e );
            scope.endElement();
            throw e;
        }
    };
    
    var processElement = function( node, attributes, _autoDefineHelper ) {

        // If it is defined a metalFillSlot or a metalDefineMacro do nothing
        if ( attributes.metalFillSlot || ! processMETALDefineMacro(
            node, 
            attributes.metalDefineMacro 
        ) ) {
            // Stop processing the rest of this node as it is invisible
            return false;
        }
        
        var autoDefineHelper = _autoDefineHelper || new AutoDefineHelper( node );
        
        if ( ! processDeclare( 
            node,
            attributes.talDeclare,
            autoDefineHelper
        ) ) {
            // Stop processing the rest of this node as it is invisible
            return false;
        }
        
        processOnError( 
            node,
            attributes.talOnError,
            autoDefineHelper
        );
        
        processI18nLanguage( 
            node,
            attributes.i18nLanguage,
            autoDefineHelper
        );
        
        processI18nDomain(
            node,
            attributes.i18nDomain, 
            autoDefineHelper
        );
        
        processAutoDefine( 
            node, 
            autoDefineHelper
        );
        
        ParserNodeRenderer.processDefine( 
            node,
            attributes.talDefine,  
            false,
            scope,
            indexExpressions
        );
        
        if ( ! processCondition(
                node, 
                attributes.talCondition 
        ) ) {
            // Stop processing the rest of this node as it is invisible
            return false;
        }

        var omittedTag = processOmitTag(
                node, 
                attributes.talOmitTag 
        );

        var replaced = processReplace(
                node, 
                attributes.talReplace 
        );

        if ( ! omittedTag && ! replaced ) {
            
            processAttributes(
                    node, 
                    attributes.talAttributes 
            );

            if ( ! processContent(
                    node, 
                    attributes.talContent ) ) {

                defaultContent( node );
            }
        }

        processMETALUseMacro(
                node, 
                attributes.metalUseMacro, 
                attributes.talDefine,
                autoDefineHelper
        );
        
        return true;
    };

    var defaultContent = function( node ) {

        var childNodes = node.childNodes;
        if ( ! childNodes ) {
            return;
        }

        for ( var i = 0; i < childNodes.length; i++ ) {
            var currentChildNode = childNodes[ i ];

            // Check if node is ELEMENT_NODE and not parsed yet
            if ( currentChildNode && currentChildNode.nodeType === 1
                    && ! currentChildNode.getAttribute( tags.qdup ) ) {
                process( currentChildNode );
            }
        }
    };
    
    var processOnError = function( node, string, autoDefineHelper ) {

        if ( ! string ) {
            return;
        }

        var talOnError = attributeCache.getByAttributeClass( 
            TALOnError, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talOnError.putToAutoDefineHelper( autoDefineHelper );
    };
    
    var processAutoDefine = function( node, autoDefineHelper ) {
        
        var string = autoDefineHelper.updateNode( node );
        if ( ! string ) {
            return;
        }
        
        var talDefine = attributeCache.getByAttributeClass( 
            TALDefine, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talDefine.process( scope, false );
    };

    var processI18nDomain = function( node, string, autoDefineHelper ) {

        if ( ! string ) {
            return;
        }

        var i18nDomain = attributeCache.getByAttributeClass( 
            I18NDomain, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return i18nDomain.putToAutoDefineHelper( scope, autoDefineHelper );
    };
    
    var processI18nLanguage = function( node, string, autoDefineHelper ) {

        if ( ! string ) {
            return;
        }

        var i18nLanguage = attributeCache.getByAttributeClass( 
            I18NLanguage, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return i18nLanguage.putToAutoDefineHelper( autoDefineHelper );
    };
    
    var processDeclare = function( node, string, autoDefineHelper ) {

        if ( ! string ) {
            return true;
        }

        var talDeclare = attributeCache.getByAttributeClass( 
            TALDeclare, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talDeclare.process( scope, autoDefineHelper );
    };
    
    var processMETALDefineMacro = function( node, string ) {

        if ( ! string ) {
            return true;
        }

        // No sense to cache macro definitions!
        var metalDefineMacro = METALDefineMacro.build( string );
        return metalDefineMacro.process( scope, node );
    };

    var processMETALUseMacro = function( node, string, stringDefine, autoDefineHelper ) {

        if ( ! string ) {
            return;
        }
        
        // No sense to cache macro uses!
        var metalUseMacro = METALUseMacro.build( string, stringDefine, scope );
        var newNode = metalUseMacro.process( scope, node, autoDefineHelper, indexExpressions );
        newNode.setAttribute( tags.qdup, 1 );
        
        // Index node
        if ( indexExpressions ){
            attributeIndex.add( node, metalUseMacro, scope );
        }
    
        // Process new node
        return process( newNode );
    };

    var processCondition = function( node, string ) {

        if ( ! string ) {
            return true;
        }

        var talCondition = attributeCache.getByAttributeClass( 
            TALCondition, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talCondition.process( scope, node );
    };
    
    var processReplace = function( node, string ) {
        
        if ( ! string ){
            return false;
        }
        
        var talReplace = attributeCache.getByAttributeClass( 
            TALReplace, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talReplace.process( scope, node );
    };

    var processOmitTag = function( node, string ) {

        if ( string == null ) {
            return false;
        }

        var talOmitTag = attributeCache.getByAttributeClass( 
            TALOmitTag, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talOmitTag.process( scope, node, self );
    };
    
    var processContent = function( node, string ) {
        
        if ( ! string ){
            return false;
        }

        var talContent = attributeCache.getByAttributeClass( 
            TALContent, 
            string, 
            node,
            indexExpressions,
            scope
        );
        return talContent.process( scope, node );
    };
  
    var processAttributes = function( node, string ) {

        if ( ! string ) {
            return;
        }

        var talAttributes = attributeCache.getByAttributeClass( 
            TALAttributes, 
            string, 
            node,
            indexExpressions,
            scope 
        );
        return talAttributes.process( scope, node );
    };
    
    var self = {
        run: run,
        defaultContent: defaultContent
    };
    
    return self;
};

ParserNodeRenderer.processDefine = function( node, string, forceGlobal, scope, indexExpressions ) {

    if ( ! string ) {
        return;
    }

    var talDefine = attributeCache.getByAttributeClass( 
        TALDefine, 
        string, 
        node,
        indexExpressions,
        scope
    );
    return talDefine.process( scope, forceGlobal );
};

ParserNodeRenderer.cloneAndConfigureNode = function( node, indexExpressions, tags, nodeDataId ) {
    
    // Clone node
    var tmpNode = node.cloneNode( true );
    if ( 'form' in tmpNode ) {
        tmpNode.checked = false;
    }

    // Set id and related id if needed
    if ( indexExpressions ){
        tmpNode.setAttribute( tags.id, context.nextExpressionCounter() );
        tmpNode.setAttribute( tags.relatedId, nodeDataId );
    }
    
    return tmpNode;
};

ParserNodeRenderer.configureNodeForNewItem = function( tmpNode, tags, parentNode, indexItem, indexToUse ) {
    
    // Remove attributes
    tmpNode.removeAttribute( tags.talRepeat );
    tmpNode.removeAttribute( 'style' );
    tmpNode.setAttribute( tags.qdup, 1 );
    
    // Configure loop attributes
    Loop.setAutoDefineAttribute( 
        tmpNode, 
        indexItem.attributeInstance.getVarName(), 
        indexToUse,
        indexItem.attributeInstance.getExpressionString(), 
        parentNode.childElementCount, 
        0
    );
};

module.exports = ParserNodeRenderer;

}).call(this)}).call(this,require('_process'))

},{"../attributes/I18N/i18nDomain.js":8,"../attributes/I18N/i18nLanguage.js":9,"../attributes/METAL/metalDefineMacro.js":10,"../attributes/METAL/metalUseMacro.js":12,"../attributes/TAL/contentHelper.js":13,"../attributes/TAL/talAttributes.js":14,"../attributes/TAL/talCondition.js":15,"../attributes/TAL/talContent.js":16,"../attributes/TAL/talDeclare.js":17,"../attributes/TAL/talDefine.js":18,"../attributes/TAL/talOmitTag.js":19,"../attributes/TAL/talOnError.js":20,"../attributes/TAL/talRepeat.js":21,"../attributes/TAL/talReplace.js":22,"../attributes/attributeIndex.js":23,"../cache/attributeCache.js":24,"../context.js":27,"../expressions/evaluateHelper.js":44,"../logHelper.js":74,"./autoDefineHelper.js":76,"./loop.js":88,"./nodeAttributes.js":90,"_process":5}],94:[function(require,module,exports){
/* 
    Class ParserPreloader
*/
"use strict";

var context = require( '../context.js' );
var log = require( '../logHelper.js' );
var nodeRemover = require( './nodeRemover.js' );
var Scope = require( '../scopes/scope.js' );
var i18nHelper = require( '../i18n/i18nHelper.js' );
var resolver = require( '../resolver.js' );
var attributeIndex = require( '../attributes/attributeIndex.js' );

var ParserPreloader = function( _parserOptions, _callback, _failCallback, _declaredRemotePageUrls, _i18n, _notRemoveGeneratedTags, _maxFolderDictionaries ) {
    
    var parserOptions = _parserOptions;
    var callback = _callback;
    var failCallback = _failCallback;
    var declaredRemotePageUrls = _declaredRemotePageUrls;
    var i18n = _i18n;
    var notRemoveGeneratedTags = _notRemoveGeneratedTags;
    var maxFolderDictionaries = _maxFolderDictionaries;
    
    var run = function(){

        try {
            if ( ! notRemoveGeneratedTags ){
                nodeRemover.removeGeneratedNodes( parserOptions.root );
                /*
                attributeIndex.removeMultipleNodes(
                    nodeRemover.removeGeneratedNodes( parserOptions.root )
                );
                */
            }

            var scope = new Scope( 
                parserOptions.dictionary, 
                parserOptions.dictionaryExtension, 
                true 
            );

            scope.loadFolderDictionariesAsync( 
                maxFolderDictionaries, 
                window.location,
                function(){
                    context.setFolderDictionaries( scope.folderDictionaries );

                    i18nHelper.loadAsyncAuto( 
                        parserOptions.dictionary,
                        i18n,
                        function(){
                            resolver.loadRemotePages( 
                                scope,
                                declaredRemotePageUrls,
                                callback,
                                failCallback
                            );
                        },
                        failCallback
                    );
                } 
            );

        } catch( e ){
            log.fatal( 'Exiting init method of ZPT with errors: ' + e );
            throw e;
        }
    };

    
    var self = {
        run: run
    };
    
    return self;
};

module.exports = ParserPreloader;

},{"../attributes/attributeIndex.js":23,"../context.js":27,"../i18n/i18nHelper.js":73,"../logHelper.js":74,"../resolver.js":97,"../scopes/scope.js":99,"./nodeRemover.js":91}],95:[function(require,module,exports){
(function (process){(function (){
/* 
    Class ParserRenderer
*/
"use strict";

var context = require( '../context.js' );
var log = require( '../logHelper.js' );
var attributeCache = require( '../cache/attributeCache.js' );
var attributeIndex = require( '../attributes/attributeIndex.js' );
var nodeRemover = require( './nodeRemover.js' );
var scopeBuilder = require( '../scopes/scopeBuilder.js' );
var ParserNodeRenderer = require( './parserNodeRenderer.js' );

var ParserRenderer = function( _parserOptions, _target, _dictionaryExtension, _notRemoveGeneratedTags, _resetIndex, _goToURLHash ) {
    
    var parserOptions = _parserOptions;
    var target = _target;
    var dictionaryExtension = _dictionaryExtension;
    var notRemoveGeneratedTags = _notRemoveGeneratedTags;
    var resetIndex = _resetIndex;
    var goToURLHash = _goToURLHash;
    
    var run = function(){
        process();
    };
    
    var process = function(){

        try {
            if ( ! target ){
                throw 'Unable to process null root or target!';
            }

            if ( ! notRemoveGeneratedTags ){
                nodeRemover.removeGeneratedNodes( target );
                /*
                attributeIndex.removeMultipleNodes(
                    nodeRemover.removeGeneratedNodes( target )
                );
                */
            }

            if ( resetIndex ){
                attributeIndex.reset();
                attributeCache.reset();
            }

            processAllTargetElements();
            
            if ( goToURLHash ){
                processGoToURLHash();
            }

        } catch( e ){
            log.fatal( 'Exiting run method of ZPT with errors: ' + e );
            context.errorFunction( e );
            //throw e;
        }
    };

    var processAllTargetElements = function() {

        // Is multiroot?
        if ( Array.isArray( target ) ){ 
            // There are several roots
            for ( var c = 0; c < target.length; c++ ) {
                process1Target( target[ c ] );
            }
        } else {
            // There is only one root
            process1Target( target );
        }
    };

    var process1Target = function( currentTarget ) {

        var parserNodeRenderer = new ParserNodeRenderer( 
            currentTarget, 
            scopeBuilder.build( 
                parserOptions, 
                currentTarget, 
                dictionaryExtension,
                parserOptions.command === 'partialRender'
            ),
            parserOptions.indexExpressions
        );

        parserNodeRenderer.run();
    };
    
    var processGoToURLHash = function(){
        
        var id = decodeURI( window.location.hash ).substr( 1 );
        if ( ! id ){
            return;
        }
        
        var element = window.document.getElementById( id );
        if ( ! element ){
            log.warn( 'Unable to go to URL hash. Element with id "' + id + '" not found!' );
            return;
        }

        // Go to hash
        window.location.href = '#' + id;
    };
    
    var self = {
        run: run
    };
    
    return self;
};

module.exports = ParserRenderer;

}).call(this)}).call(this,require('_process'))

},{"../attributes/attributeIndex.js":23,"../cache/attributeCache.js":24,"../context.js":27,"../logHelper.js":74,"../scopes/scopeBuilder.js":100,"./nodeRemover.js":91,"./parserNodeRenderer.js":93,"_process":5}],96:[function(require,module,exports){
/* 
    Class ParserUpdater
*/
"use strict";

var context = require( '../context.js' );
var log = require( '../logHelper.js' );
var attributeIndex = require( '../attributes/attributeIndex.js' );
var scopeBuilder = require( '../scopes/scopeBuilder.js' );
var ParserNodeRenderer = require( './parserNodeRenderer.js' );
var nodeRemover = require( './nodeRemover.js' );
var utils = require( '../utils.js' );
var dictionaryActionBuilder = require( './dictionaryActions/dictionaryActionBuilder.js' );
var AbstractArrayAction = require( './dictionaryActions/abstractArrayAction.js' );

var ParserUpdater = function( _dictionaryChanges, _dictionaryActions, _parserOptions ) {
    
    var dictionaryChanges = _dictionaryChanges;
    var dictionaryActions = _dictionaryActions;
    var parserOptions = _parserOptions;
    
    var scopeMap = {};
    var nodeAttributes, 
        statistics;
    var dictionaryActionsInstances;
    
    var initializeDictionaryActionsInstances = function(){
        
        dictionaryActionsInstances = [];
        
        if ( ! dictionaryActions ){
            return;
        }
        
        for ( var i = 0; i < dictionaryActions.length; ++i ){
            var action = dictionaryActions[ i ];
            var newActionInstance = dictionaryActionBuilder.build( action, parserOptions.dictionary );
            if ( Array.isArray( newActionInstance ) ){
                dictionaryActionsInstances = dictionaryActionsInstances.concat( newActionInstance );
            } else {
                dictionaryActionsInstances.push( newActionInstance );
            }
        }
    };
    initializeDictionaryActionsInstances();
    
    var getStatistics = function(){
        return statistics;
    };

    var updateDictionaryForDictionaryChanges = function(){
        
        if ( dictionaryChanges ){
            utils.extend( parserOptions.dictionary, dictionaryChanges );
        }
    };
    
    var addUpdatedToStatistics = function(){
        ++statistics.totalUpdates;
    };
    
    var addRemovedToStatistics = function(){
        ++statistics.removedNodeUpdates;
    };
    
    var run = function(){
        
        try {
            // Check the index was built
            if ( ! parserOptions.indexExpressions ){
                throw 'Unable to update, no index built! Set indexExpressions to true!';
            }
            
            // Init some vars
            nodeAttributes = {};
            statistics = {
                totalUpdates: 0,
                removedNodeUpdates: 0
            };

            // Do all required HTML updates
            updateHTML();
            
        } catch( e ){
            log.fatal( 'Exiting run method of update command of ZPT with errors: ' + e );
            context.errorFunction( e );
        }
    };

    var updateHTML = function(){

        if ( updateHTMLFromActions( 0 ) ){
            updateHTMLFromVarChange();
        }
    };
    
    var updateHTMLFromActions = function( initial ){

        for ( var i = initial; i < dictionaryActionsInstances.length; ++i ){
            var actionInstance = dictionaryActionsInstances[ i ];
            
            // Update dictionary using action
            actionInstance.updateDictionary( parserOptions.dictionary );
            
            // Get the list of changes related to varName
            var list = attributeIndex.getVarsList( actionInstance.id );
            if ( ! list ){
                continue;
            }
            
            // Iterate list and update HTML if required
            if ( ! updateHTMLFromVarsList( actionInstance, i, 0, list ) ){
                return false;
            }
            /*
            for ( var j = 0; j < list.length; j++ ) {
                var indexItem = list[ j ];
                if ( ! actionInstance.attributeInstanceIsRelated( indexItem.attributeInstance ) ){
                    if ( ! utils.isFunction( indexItem.attributeInstance.updatableFromAction ) 
                            || indexItem.attributeInstance.updatableFromAction( self, findNodeById( indexItem.nodeId ) ) ){
                        buildDataFromVarChangeExcluding( actionInstance.id );
                    }
                    continue;
                }
                
                if ( ! actionInstance.updateHTML( 
                    indexItem, 
                    self, 
                    actionInstance, 
                    { 
                        actionInstance: actionInstance,
                        i: i, 
                        list: list,
                        initialJ: j 
                    }
                ) ){
                    return false;
                }
            }
            */
        }
        
        return true;
    };
    
    var updateHTMLFromVarsList = function( actionInstance, i, initialJ, list ){
        
        // Iterate list and update HTML if required
        for ( var j = initialJ; j < list.length; j++ ) {
            var indexItem = list[ j ];
            if ( ! actionInstance.attributeInstanceIsRelated( indexItem.attributeInstance ) ){
                if ( ! utils.isFunction( indexItem.attributeInstance.updatableFromAction ) 
                        || indexItem.attributeInstance.updatableFromAction( self, findNodeById( indexItem.nodeId ) ) ){
                    buildDataFromVarChangeExcluding( actionInstance.id );
                }
                continue;
            }

            if ( ! actionInstance.updateHTML( 
                indexItem, 
                self, 
                actionInstance, 
                { 
                    actionInstance: actionInstance,
                    i: i, 
                    initialJ: j,
                    list: list
                }
            ) ){
                return false;
            }
        }
        
        return true;
    };
    
    var continueUpdateHTML = function( continueData ){

        updateHTMLFromVarsList(
            continueData.actionInstance, 
            continueData.i, 
            continueData.initialJ + 1, 
            continueData.list
        );
        
        if ( updateHTMLFromActions( continueData.i + 1 ) ){
            updateHTMLFromVarChange();
        }
    };
    
    var runAnimation = function( actionInstance, node, callback ){
        
        // Build combinedCallback combining callback and actionInstance.animationCallback
        var combinedCallback = function(){
                if ( callback ){
                    callback();
                } else {
                    context.getAnimationManager().reset( node );
                }
                if ( actionInstance.animationCallback ){
                    actionInstance.animationCallback();
                }
            };
        
        // Get animation manager to run animation
        context.getAnimationManager().animate( actionInstance, node, combinedCallback );
    };
    /*
    var runAnimation = function( actionInstance, node, callback ){
        
        // Build combinedCallback combining callback and actionInstance.animationCallback
        var combinedCallback = ! callback && ! actionInstance.animationCallback? 
            undefined:
            function(){
                if ( callback ){
                    callback();
                }
                if ( actionInstance.animationCallback ){
                    actionInstance.animationCallback();
                }
            };
        
        // Get animation manager to run animation
        context.getAnimationManager().animate( actionInstance, node, combinedCallback );
    };
    */
    
    var updateHTMLFromVarChange = function(){
        
        // Update dictionary
        updateDictionaryForDictionaryChanges();
        
        // Build data
        for ( var varName in dictionaryChanges ){
            buildDataFromVarChange( varName );
        }
        
        // Update attributes
        for ( var i in nodeAttributes ) {
            var currentNodeAttributeList = nodeAttributes[ i ];
            for ( var j in currentNodeAttributeList ){
                updateAttribute( currentNodeAttributeList[ j ] );   
            }
        }
    };
    
    var buildDataFromVarChange = function( varName ){
        
        // Get the list of changes related to varName
        var list = attributeIndex.getVarsList( varName );
        buildDataFromList( varName, list );
    };
    
    var buildDataFromVarChangeExcluding = function( varName ){
        
        // Get the list of changes related to varName
        var list = attributeIndex.getVarsList( varName );
        
        var filtered = list.filter(
            function( indexItem, index, arr ){
                return ! AbstractArrayAction.staticAttributeInstanceIsRelated(
                    indexItem.attributeInstance
                );
            }
        );
        
        buildDataFromList( varName, filtered );
    };
    
    var buildDataFromList = function( varName, list ){
        
        if ( ! list ){
            return;
        }
        
        // Build data about all changes
        var length = list.length;
        for ( var i = 0; i < length; i++ ) {
            addNewNodeAttribute( varName, list[ i ] );
            /*
            if ( ! addNewNodeAttribute( varName, list[ i ] ) ){
                attributeIndex.removeVar( varName, list[ i ].nodeId );
            }
            */
        }
    };
    
    var findNodeById = function ( nodeId ) {
        
        return window.document.querySelector( 
            '[' + context.getTags().id + '="' + nodeId + '"]' 
        );
    };

    var addNewNodeAttribute = function( varName, indexItem ){

        var attributeInstance = indexItem.attributeInstance;
        var node = findNodeById( indexItem.nodeId );
        if ( ! node ){
            // Removed node!
            ++statistics.removedNodeUpdates;
            return false;
        }

        // Add data to nodeData
        var thisNodeData = nodeAttributes[ indexItem.nodeId ];
        if ( ! thisNodeData ){
            thisNodeData = {};
            nodeAttributes[ indexItem.nodeId ] = thisNodeData;
        }
        var elementId = indexItem.groupId? 
            attributeInstance.type + '/' + indexItem.groupId: 
            attributeInstance.type;
        thisNodeData[ elementId ] = indexItem;

        return true;
    };
    
    var updateAttribute = function( indexItem ){
        
        var attributeInstance = indexItem.attributeInstance;
        var node = findNodeById( indexItem.nodeId );
        if ( ! node ){
            // Removed node!
            ++statistics.removedNodeUpdates;
            return false;
        }
        
        ++statistics.totalUpdates;
        
        var scope = getNodeScope( node, indexItem.nodeId );
        
        attributeInstance.update( self, node, scope, indexItem );
        
        return true;
    };

    var getNodeScope = function( node, nodeId ){
        
        if ( ! nodeId ){
            nodeId = node.getAttribute( context.getTags().id );
        }
        
        var thisScope = scopeMap[ nodeId ];
        
        if ( ! thisScope ){
            thisScope = scopeBuilder.build( 
                parserOptions, 
                node, 
                undefined,
                true
            );
            scopeMap[ nodeId ] = thisScope;
        }

        return thisScope;
    };
    
    var updateNode = function( node, mustRemoveGeneratedNodes ){
        
        // Remove related to node nodes
        nodeRemover.removeMultipleNodes( node, mustRemoveGeneratedNodes );
        /*
        attributeIndex.removeMultipleNodes(
            nodeRemover.removeMultipleNodes( node, mustRemoveGeneratedNodes )
        );
        */
        
        // Instance and invoke parserNodeRenderer to update node
        var parserNodeRenderer = new ParserNodeRenderer( 
            node, 
            scopeBuilder.build( 
                parserOptions, 
                node, 
                undefined,
                true
            ),
            true
        );
        parserNodeRenderer.run();
    };
    /*
    var deleteNode = function( node ){
        node.parentNode.removeChild( node );
    };
    */
    var self = {
        run: run,
        updateNode: updateNode,
        //deleteNode: deleteNode,
        findNodeById: findNodeById,
        getNodeScope: getNodeScope,
        getStatistics: getStatistics,
        addUpdatedToStatistics: addUpdatedToStatistics,
        addRemovedToStatistics: addRemovedToStatistics,
        runAnimation: runAnimation,
        continueUpdateHTML: continueUpdateHTML
    };
    
    return self;
};

module.exports = ParserUpdater;

},{"../attributes/attributeIndex.js":23,"../context.js":27,"../logHelper.js":74,"../scopes/scopeBuilder.js":100,"../utils.js":101,"./dictionaryActions/abstractArrayAction.js":79,"./dictionaryActions/dictionaryActionBuilder.js":85,"./nodeRemover.js":91,"./parserNodeRenderer.js":93}],97:[function(require,module,exports){
/* 
    resolver singleton class
*/
var utils = require( './utils.js' );
var context = require( './context.js' );
var expressionBuilder = require( './expressions/expressionBuilder.js' );

module.exports = (function( ) {
    "use strict";
    
    var macros = {};
    var remotePages = {};
    
    var getNode = function( macroKey, scope ) {
        
        var node = macros[ macroKey ];
        
        if ( ! node ){
            node = loadNode( macroKey, scope );
        }
        
        return node? node.cloneNode( true ): undefined;
    };
    /*
    var isRemote = function( macroKey ){
        return -1 != macroKey.indexOf( context.getConf().macroDelimiter );
    };*/
    
    var getMacroDataUsingExpression = function ( macroKeyExpression, scope ){
        
        var macroKey = macroKeyExpression.evaluate( scope );
        
        if ( ! macroKey ){
            return {
                macroId: null,
                url: null
            };
        }
        
        return getMacroData( macroKey, scope );
    };
    
    var getMacroDataUsingExpressionString = function ( macroKeyExpressionString, scope ){
        
        var macroKeyExpression = expressionBuilder.build( macroKeyExpressionString );
        return getMacroDataUsingExpression( macroKeyExpression, scope );
    };
    
    var getMacroData = function ( macroKey, scope ){

        var index = macroKey.indexOf( context.getConf().macroDelimiter );
        
        return index === -1?
            {
                macroId: macroKey,
                url: null
            }:
            {
                macroId: macroKey.substring( 0, index ),
                url: buildURL ( macroKey.substring( 1 + index ) )
            };
    };
    
    var builDefineMacroSelector = function( macroId ){
        return "[" + filterSelector( context.getTags().metalDefineMacro ) + "='" + macroId + "']";
    };
    
    var loadNode = function( macroKey, scope ){

        var macroData = getMacroData( macroKey, scope );

        if ( macroData.url ){
            // Node is in another page
            return loadRemoteNode( macroKey, macroData );
        }
        
        // No url set
        var urlInScope = scope.get( context.getConf().externalMacroUrlVarName );
        if ( urlInScope ){
            // Try to find node in another page but using a previously defined url
            macroData.url = urlInScope;
            var remoteNode = loadRemoteNode( macroKey, macroData );
            if ( remoteNode ){
                // Node is found in another page
                return remoteNode;
            }
        }
        
        // Node is in this page
        var macroId = macroData.macroId;
        var selector = builDefineMacroSelector( macroId );
        var node = window.document.querySelector( selector );

        if ( ! node ){
            throw "Node using selector '" + selector + "' is null!";
        }

        return configureNode( 
            node.cloneNode( true ), 
            macroId,
            macroKey );
        
    };
    var loadRemoteNode = function( macroKey, macroData ){
        
        var element = remotePages[ macroData.url ];
        
        if ( ! element ){
            throw 'Macros in URL ' + macroData.url + ' not preloaded!';
        }
        
        var selector = builDefineMacroSelector( macroData.macroId );
        var node = element.querySelector( selector );
        
        if ( ! node ){
            return undefined;
        }
        
        return configureNode( 
                    node.cloneNode( true ), 
                    macroData.macroId,
                    macroKey );
    };
    
    var buildRemotePageUrlList = function( scope, declaredRemotePageUrls ){
        
        var remotePageUrls = declaredRemotePageUrls.slice();
        
        var list = document.querySelectorAll( 
            "[" + filterSelector( context.getTags().metalUseMacro ) + "]"
        );
        var currentMacroUse;
        var pos = 0;
        while ( currentMacroUse = list[ pos++ ] ) {
            var macroKeyExpressionString = currentMacroUse.getAttribute( context.getTags().metalUseMacro );
            
            try {
                var macroData = getMacroDataUsingExpressionString( macroKeyExpressionString, scope );

                var url = macroData.url;
                if ( url && remotePageUrls.indexOf( url ) === -1 ){
                    remotePageUrls.push( url );
                }
            } catch ( exception ){
                // Macrodata could not be resolved, do nothing
            }
        }
                                                              
        return remotePageUrls;
    };
    
    // Add preffix if the URL is not absolute
    var buildURL = function( URL ){
        return URL.startsWith( '/' )? URL: context.getConf().externalMacroPrefixURL + URL;
    };
    
    var loadRemotePages = function( scope, declaredRemotePageUrls, callback, failCallback ){

        var remotePageUrls = buildRemotePageUrlList( scope, declaredRemotePageUrls );
        var pending = remotePageUrls.length;
        remotePages = {};
        
        if ( ! pending ){
            if ( callback && utils.isFunction( callback ) ){
                callback();   
            }
            return;
        }
        
        for ( var c = 0; c < remotePageUrls.length; c++ ) {
            var currentPageUrl = buildURL( remotePageUrls[ c ] );
            
            /* jshint loopfunc: true */
            utils.ajax(
                {
                    url: currentPageUrl,
                    //dataType: 'html',
                    done: function( html ) {
                        var element = document.createElement( 'div' );
                        element.innerHTML = html;
                        remotePages[ this.url ] = element;
                        if ( --pending == 0 && callback && utils.isFunction( callback ) ){
                            callback();
                        }
                    },
                    fail: function( jqXHR, textStatus, error ) {
                        context.asyncError( currentPageUrl, error, failCallback );
                    }
                }
            );
            /*
            $.ajax({
                url: currentPageUrl,
                dataType: 'html'
            }).done( function( html ) {
                var element = $( '<div></div>' );
                element.html( html );
                remotePages[ this.url ] = element;
                if ( --pending == 0 && callback && utils.isFunction( callback ) ){
                    callback();
                }
            }).fail( function( jqXHR, textStatus, error ) {
                context.asyncError( currentPageUrl, error, failCallback );
            });
            */
        }
    };
                  
    var configureNode = function( node, macroId, macroKey ){
        node.removeAttribute( context.getTags().metalDefineMacro );
        node.setAttribute( context.getTags().metalMacro, macroId );
        
        macros[ macroKey ] = node;
        
        return node;
    };
    
    var getMacroKey = function( macroKeyExpression, scope ){
        
        var macroData = getMacroDataUsingExpression( macroKeyExpression, scope );
        
        return macroData.url? macroData.macroId + context.getConf().macroDelimiter + macroData.url: macroData.macroId;
    };
    
    // Must filter to replace : by \\:
    var filterSelector = function( selector ){
        return selector.replace( /:/gi, '\\:' );
    };
    
    return {
        getNode: getNode,
        //isRemote: isRemote,
        loadRemotePages: loadRemotePages,
        getMacroData: getMacroData,
        getMacroKey: getMacroKey,
        filterSelector: filterSelector
    };
})();

},{"./context.js":27,"./expressions/expressionBuilder.js":46,"./utils.js":101}],98:[function(require,module,exports){
/* 
    ReactiveDictionary class 
*/
"use strict";

var zpt = require( '../main.js' );

var ReactiveDictionary = function( _nonReactiveDictionary, _initialAutoCommit ) {
    
    // Init some vars
    var self = this;
    this._privateScope = {
        nonReactiveDictionary: _nonReactiveDictionary,
        autoCommit: true,
        dictionaryChanges: {},
        dictionaryActions: [],
        commit: function(){
            zpt.run({
                command: 'update',
                dictionaryChanges: self._privateScope.dictionaryChanges,
                dictionaryActions: self._privateScope.dictionaryActions
            });
            self._privateScope.dictionaryChanges = {};
            self._privateScope.dictionaryActions = [];
        }
    };

    // Define some methods
    this._getNonReactiveDictionary = function(){
        return this._privateScope.nonReactiveDictionary;
    };
    
    this._isAutoCommit = function(){
        return this._privateScope.autoCommit;
    };
    
    this._setAutoCommit = function( _autoCommit ){
        this._privateScope.autoCommit = _autoCommit;
    };
    
    this._commit = function(){
        this._privateScope.commit();
    };

    this._addActions = function( dictionaryActions ){
        
        // Record this actions to commit it later
        self._privateScope.dictionaryActions = self._privateScope.dictionaryActions.concat( dictionaryActions );
        
        // Commit the change only if autoCommit is on
        if ( self._isAutoCommit() ){
            self._privateScope.commit();
        }
    };
    
    this._addVariable = function( key, value ){
        
        // Set the value in nonReactiveDictionary
        self._privateScope.nonReactiveDictionary[ key ] = value;
        
        // Define getter and setter
        this._defineProperty( 
            this._privateScope.nonReactiveDictionary, 
            key 
        );
    };

    this._defineProperty = function( dictionary, key ){

        // Define property to set getter and setter
        Object.defineProperty(
            self, 
            key, 
            {
                enumerable: true,
                configurable: true,
                get: function () { 
                    return dictionary[ key ];
                },
                set: function ( value ) {
                    // Record this change to commit it later
                    self._privateScope.dictionaryChanges[ key ] = value;

                    // Commit the change only if autoCommit is on
                    if ( self._isAutoCommit() ){
                        self._privateScope.commit();
                    }
                }
            }
        );
    };
    
    // Initialize
    this._initialize = function( dictionary ){
        
        // Initialize autoCommit
        if ( _initialAutoCommit !== undefined ){
            this._setAutoCommit( _initialAutoCommit );
        }
        
        // Iterate properties in dictionary to define setters and getters
        var keys = Object.keys( dictionary );
        for ( var i = 0; i < keys.length; i++ ){
            var key = keys[ i ];
            var property = Object.getOwnPropertyDescriptor( dictionary, key );
            if ( property && property.configurable === false ) {
                continue;
            }
            
            // Define getter and setter
            (function( key ) {
                self._defineProperty( dictionary, key );
            })( key );
        }
    };
    this._initialize( this._privateScope.nonReactiveDictionary );
};

module.exports = ReactiveDictionary;

},{"../main.js":75}],99:[function(require,module,exports){
/* 
    Class Scope 
*/
"use strict";

var context = require( '../context.js' );
var utils = require( '../utils.js' );
var loadjs = require( 'loadjs' );

var Scope = function( _dictionary, _dictionaryExtension, addCommonVars, _folderDictionaries ) {
    
    this.dictionary = _dictionary || {};
    this.dictionaryExtension = _dictionaryExtension || {};
    this.vars = {};
    this.changesStack = [];
    this.nocallVars = {};
    this.folderDictionaries = _folderDictionaries || [];
    this.globalVarsExpressions = {};
    
    if ( addCommonVars ){
        this.setCommonVars();
    }
    this.setMandatoryVars();
};

Scope.prototype.setMandatoryVars = function(){

    // Register nothing var
    this.setVar( 
        context.getConf().nothingVarName, 
        context.getConf().nothingVarValue 
    );
    
    // Register default var
    this.setVar( 
        context.getConf().defaultVarName, 
        context.getConf().defaultVarValue 
    );
};

Scope.prototype.setCommonVars = function(){
    
    // Register window object if it exists
    if ( window ){
        this.setVar( 
            context.getConf().windowVarName, 
            window 
        );
    }

    // Register context
    this.setVar( 
        context.getConf().contextVarName, 
        context 
    );
};

Scope.prototype.startElement = function(){
    
    var vars = {
        varsToUnset: [],
        varsToSet: {},
        expressions: {},
        impliedDeclaredVars: []
    };

    this.changesStack.push( vars );

    return vars;
};

Scope.prototype.currentVars = function(){
    return this.changesStack[ this.changesStack.length - 1 ];
};

Scope.prototype.setVar = function( name, value ) {
    this.vars[ name ] = value;
};

Scope.prototype.getWithoutEvaluating = function( name ) {
    
    var value;
    
    value = this.vars[ name ];
    if ( value !== undefined ){
        return value;
    }
    
    value = this.dictionaryExtension[ name ];
    if ( value !== undefined ){
        return value;
    }
    
    value = this.dictionary[ name ];
    if ( value !== undefined ){
        return value;
    }
    
    for ( var i = 0; i < this.folderDictionaries.length; ++i ){
        value = this.folderDictionaries[ i ][ name ];
        if ( value !== undefined ){
            return value;
        }
    }
    
    return undefined;
};

Scope.prototype.get = function( name ) {

    var value = this.getWithoutEvaluating( name );
    
    if ( ! this.nocallVars[ name ] ){
        return value;
    }
    
    return value && utils.isFunction( value.evaluate )?
        value.evaluate( this ): 
        'Error evaluating property "' + name + '": ' + value;
};

Scope.prototype.unset = function( name ) {
    delete this.vars[ name ];
};

Scope.prototype.endElement = function ( ) {

    var vars = this.changesStack.pop(); 

    var varsToUnset = vars.varsToUnset;
    var varsToSet = vars.varsToSet; 

    for ( var i = 0; i < varsToUnset.length; ++i ){
        this.unset( varsToUnset[ i ] );
    }

    for ( var name in varsToSet ){
        var value = varsToSet[ name ];
        this.setVar( name, value );
    }
};

Scope.prototype.set = function ( name, value, isGlobal, nocall, _expression ) {
    
    var expression = _expression === undefined? null: _expression;
    
    if ( ! isGlobal ){

        // Local vars
        var vars = this.currentVars();
        var currentValue = this.getWithoutEvaluating( name );

        if ( currentValue != null ){
            vars.varsToSet[ name ] = currentValue;
            
        } else {
            vars.varsToUnset.push( name );
        }
        
        vars.expressions[ name ] = expression;
        
        if ( this.isStrictMode() ){
            vars.impliedDeclaredVars.push( name );
        }
        
    } else {
        
        // Global vars
        this.globalVarsExpressions[ name ] = expression; 
    }
    
    // Common to global and local vars
    this.setVar( name, value );
    
    // Add to nocallVars if needed
    if ( nocall ){
        this.nocallVars[ name ] = true;
    }
};

Scope.prototype.loadFolderDictionariesAsync = function ( maxFolderDictionaries, location, callback ) {
    
    if ( ! maxFolderDictionaries ) {
        callback();
        return;
    }
    
    var urlList = this.buildUrlListOfFolderDictionaries( maxFolderDictionaries, location );
    this.loadFolderDictionary(
        maxFolderDictionaries,
        callback,
        urlList, 
        0
    );
};

Scope.prototype.loadFolderDictionary = function ( maxFolderDictionaries, callback, urlList, i ) {
    
    var instance = this;
    
    var loadjsCallback = function( url, success ){
        
        // Treat js file only if load is sucessfull
        if ( success && window.folderDictionary ){
            instance.folderDictionaries.push( window.folderDictionary );
        }
            
        // Run callback and return if the urlList is over
        if ( i === urlList.length){
            callback();
            return;
        }

        // Continue, the urlList is not over
        instance.loadFolderDictionary(
            maxFolderDictionaries, 
            callback,
            urlList, 
            i
        );
    };
    
    var url = urlList[ i++ ];
    loadjs(
        url, 
        {
            success: function() { 
                loadjsCallback( url, true );
            },
            error: function() { 
                loadjsCallback( url, false );
            }
        }
    );
};

Scope.prototype.buildUrlListOfFolderDictionaries = function ( maxFolderDictionaries, location ) {
    
    var result = [];
    
    var c = 0;
    var path = location.pathname;
    var lastIndex = path.lastIndexOf( '/' );
    while ( lastIndex !== -1 && ++c <= maxFolderDictionaries ){
        var parent = path.substr( 0, lastIndex );
        result.push( 
            location.origin + parent + '/' + 'folderDictionary.js' 
        );
        lastIndex = parent.lastIndexOf( '/' );
    }
    
    return result;
};

Scope.prototype.isStrictMode = function(){
    return context.isStrictMode() || this.get( context.getConf().strictModeVarName );
};

Scope.prototype.isValidVariable = function( name ){
    
    // If strict mode is off all variable are valid
    if ( ! this.isStrictMode() ){
        return true;
    }
    
    // If the variable is declared return true
    var declared = this.get( context.getConf().declaredVarsVarName );
    var isDeclared = declared && declared.indexOf? 
        declared.indexOf( name ) !== -1: 
        false;
    if ( isDeclared ){
        return true;
    }
    
    // Check if the variable is implicitly declared
    for ( var i = this.changesStack.length - 1; i >= 0; --i ){
        var vars = this.changesStack[ i ];
        var isImplied = vars.impliedDeclaredVars.indexOf( name ) !== -1;
        if ( isImplied ){
            return true;
        }
    }
    
    return false;
};

Scope.prototype.getVarExpression = function ( name ) {
    
    var expression = this.getExpressionFromLocal( name );
    return expression !== undefined? expression: this.globalVarsExpressions[ name ];
};

Scope.prototype.getExpressionFromLocal = function ( name ) {

    for ( var i = this.changesStack.length - 1; i >= 0; --i ){
        var vars = this.changesStack[ i ];
        var expression = vars.expressions[ name ];
        if ( expression !== undefined ){
            return expression;
        }
    }
    
    return undefined;
};

Scope.prototype.isLocalVar = function ( name ) {
    return this.vars[ name ] !== undefined;
};

module.exports = Scope;

},{"../context.js":27,"../utils.js":101,"loadjs":2}],100:[function(require,module,exports){
/* 
    scopeBuilder singleton class
*/
"use strict";

var context = require( '../context.js' );
var Scope = require( './scope.js' );
var utils = require( '../utils.js' );
var ParserNodeRenderer = require( '../parsers/parserNodeRenderer.js' );

module.exports = (function() {
    
    var keyLength = 6;
    
    var build = function( parserOptions, target, dictionaryExtension, mustUpdate ) {

        var scope = new Scope( 
            parserOptions.dictionary, 
            dictionaryExtension, 
            true,
            context.getFolderDictionaries()
        );
        
        if ( mustUpdate ){
            update( parserOptions, target, scope );
        }
        
        return scope;
    };
    
    var update = function( parserOptions, target, scope ) {
        
        // Get root key
        var rootMap = markAllRoots( parserOptions );
        var rootKeyTag = getRootKeyTag();
        var root = getRoot( parserOptions, target, rootMap );
        var rootKey =  root.getAttribute( rootKeyTag );
        
        var talDefineTag = context.getTags().talDefine;
        var talAutoDefineTag = context.getTags().talAutoDefine;
        
        var node = target.parentNode;
        var c = 0;
        var itemsList = [];
        
        do {
            // Add talDefine
            var talDefine = node.getAttribute( talDefineTag );
            if ( talDefine ){
                itemsList.push( talDefine );
            }
            
            // Add talAutoDefine
            var talAutoDefine = node.getAttribute( talAutoDefineTag );
            if ( talAutoDefine ){
                itemsList.push( talAutoDefine );
            }
            
            var nodeKey = node.getAttribute( rootKeyTag );
            if ( nodeKey && nodeKey === rootKey ){
                return processListOfDefines( 
                    scope, 
                    itemsList, 
                    node,
                    parserOptions.indexExpressions
                );
            }
            
            node = node.parentNode;
            
        } while ( node.nodeType !== 9 && ++c < 100 );
        
        throw 'Error trying to update scope: root not found!';
    };
    
    var processListOfDefines = function( scope, itemsList, node, indexExpressions ){
        
        for ( var c = itemsList.length - 1; c >= 0; c-- ) {
            var talDefine = itemsList[ c ];
            ParserNodeRenderer.processDefine(
                node, 
                talDefine, 
                true,
                scope,
                indexExpressions
            );
        }
    };
    
    var getRoot = function( parserOptions, target, rootMap ){
        
        if ( ! Array.isArray( parserOptions.root ) ){ 
            return parserOptions.root;
        }
        
        var rootKeyTag = getRootKeyTag();
        var node = target;
        var c = 0;
        do {
            var rootKey =  node.getAttribute( rootKeyTag );
            if ( rootKey ){
                return rootMap[ rootKey ];
            }

            node = node.parentNode;

        } while ( node.nodeType !== 9 && ++c < 100 );
        
        throw 'Error trying to get root: not found!';
    };
    
    var markAllRoots = function( parserOptions ){

        var rootMap = {};
        var root = parserOptions.root;

        // Is multiroot?
        if ( Array.isArray( root ) ){ 
            // There are several roots
            for ( var c = 0; c < root.length; c++ ) {
                markAsRoot( root[ c ], rootMap );
            }
        } else {
            // There is only one root
            markAsRoot( root, rootMap );
        }

        return rootMap;
    };
    
    var markAsRoot = function( node, rootMap ){
        
        // Build the key
        var key = buildKey();

        // Put a copy of scope into the cache
        rootMap[ key ] = node;

        // Save the key as an attribute of the node
        node.setAttribute( getRootKeyTag(), key );
    };
    
    var buildKey = function(){
        return utils.generateId( keyLength );
    };
    
    var getRootKeyTag = function(){
        return context.getTags().rootKey;
    };
    
    return {
        build: build
    };
})();

},{"../context.js":27,"../parsers/parserNodeRenderer.js":93,"../utils.js":101,"./scope.js":99}],101:[function(require,module,exports){
/*
    utils singleton class
*/
module.exports = (function() {
    "use strict";
    
    var generateId = function ( len, _charSet ) {
        
        var charSet = _charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var result = '';
        for ( var i = 0; i < len; i++ ) {
            var pos = Math.floor( Math.random() * charSet.length );
            result += charSet.substring( pos, pos + 1 );
        }
        return result;
    };
    
    //var isArray = Array.isArray;
    
    var isFunction = function isFunction( obj ) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };
    
    var isPlainObject = function( obj ) {
        var proto, Ctor;

        // Detect obvious negatives
        // Use toString instead of jQuery.type to catch host objects
        if ( !obj || Object.prototype.toString.call( obj ) !== "[object Object]" ) {
            return false;
        }

        proto = getProto( obj );

        // Objects with no prototype (e.g., `Object.create( null )`) are plain
        if ( !proto ) {
            return true;
        }

        // Objects with prototype are plain iff they were constructed by a global Object function
        Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
        return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
    };
    var getProto = Object.getPrototypeOf;
    var class2type = {};
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call( Object );
    
    var deepExtend = function( out ) {
        out = out || {};

        for ( var i = 1; i < arguments.length; i++ ) {
            var obj = arguments[ i ];

            if ( ! obj ){
                continue;
            }
            
            for ( var key in obj ) {
                if ( obj.hasOwnProperty( key ) ) {
                    if ( typeof obj[ key ] === 'object' ){
                        out[ key ] = deepExtend( out[ key ], obj[ key ] );
                    } else {
                        out[ key ] = obj[ key ];
                    }
                }
            }
        }

        return out;
    };
    
    var extend = function(out) {
        out = out || {};

        for ( var i = 1; i < arguments.length; i++ ) {
            if ( ! arguments[ i ] ){
                continue;
            }

            for ( var key in arguments[ i ] ) {
                if ( arguments[ i ].hasOwnProperty( key ) ){
                    out[ key ] = arguments[ i ][ key ];
                }
            }
        }

        return out;
    };
    
    var ajax = function( conf ){
        
        // Check conf object
        if ( ! conf ){
            throw 'Error trying to process ajax: no arguments!';
        }
        if ( ! conf.url ){
            throw 'Error trying to process ajax: no URL defined!';
        }
        if ( ! conf.done ){
            throw 'Error trying to process ajax: no done callback defined!';
        }
        
        // Do it!
        var oReq = new window.XMLHttpRequest();
        oReq.addEventListener( 
            'load',
            function(){
                if ( this.status >= 200 && this.status < 400 ) {
                    // Success!
                    conf.done( 
                        conf.parseJSON?
                        JSON.parse( oReq.responseText ):
                        oReq.responseText
                    );
                } else {
                    // We reached our target server, but it returned an error
                    conf.fail( undefined, undefined, this.statusText );
                }
            }
        );
        if ( conf.fail ){
            oReq.addEventListener( 'error', conf.fail );
        }
        oReq.open( 'GET', conf.url );
        oReq.send();
    };
    
    var getJSON = function( conf ){
        
        conf.parseJSON = true;
        ajax( conf );
    };
    
    /*
    var getJSON = function( conf ){
        
        // Check conf object
        if ( ! conf ){
            throw 'Error trying to getJSON: no arguments!';
        }
        if ( ! conf.url ){
            throw 'Error trying to getJSON: no URL defined!';
        }
        if ( ! conf.done ){
            throw 'Error trying to getJSON: no done callback defined!';
        }
        
        // Do it!
        var oReq = new window.XMLHttpRequest();
        oReq.addEventListener( 
            'load',
            function(){
                if ( this.status >= 200 && this.status < 400 ) {
                    // Success!
                    conf.done( 
                        JSON.parse( 
                            oReq.responseText 
                        ) 
                    );
                } else {
                    // We reached our target server, but it returned an error
                    conf.fail( undefined, undefined, this.statusText );
                }
            }
        );
        if ( conf.fail ){
            oReq.addEventListener( 'error', conf.fail );
        }
        oReq.open( 'GET', conf.url );
        oReq.send();
    };
    */
    /*
    var getNodeId = function ( node ){
        return node.getAttribute( context.getTags().id );
    };
    */
    var deepEqual = function( x, y ) {
        return (x && y && typeof x === 'object' && typeof y === 'object') ?
            (Object.keys(x).length === Object.keys(y).length) && Object.keys(x).reduce(function(isEqual, key) {return isEqual && deepEqual(x[key], y[key]);}, true):
            (x === y);
    };
    
    var copyArray = function( arrayToCopy ){
        
        var result = [];
        
        for ( var i = 0; i < arrayToCopy.length; ++i ){
            result.push( arrayToCopy[ i ] );
        }
        
        return result;
    };
    
    var genericToString = function( element ){
    
        if ( element == undefined ){
            return 'undefined';
        }
        
        if ( Array.isArray( element ) ){
            var result = 'Array[ ';
            for ( var i = 0; i < element.length; ++i ){
                var separator = i === 0? '': ', ';
                result += separator + genericToString( element[ i ] );
            }
            result += ' ]';
            return result;
        }
        
        if ( isPlainObject( element ) ){
            return JSON.stringify( element );
        }
        
        // Must be numeric or string
        return element;
    };
    
    return {
        generateId: generateId,
        //isArray: isArray,
        isFunction: isFunction,
        isPlainObject: isPlainObject,
        deepExtend: deepExtend,
        extend: extend,
        getJSON: getJSON,
        ajax: ajax,
        deepEqual: deepEqual,
        copyArray: copyArray,
        genericToString: genericToString
        //getNodeId: getNodeId
    };
})();

},{}],102:[function(require,module,exports){
// generated by genversion
module.exports = '0.40.3'

},{}],103:[function(require,module,exports){
/*! zzdom - v0.2.0 - 2020-11-12 13:32:51 */
/**
 * A namespace.
 * @const
 */
var zzDOM = {};

/*
    zz function
    
    zz( '#', 'id' );
    zz( '.', 'className' );
    zz( 't', 'tagName' );
    zz( 'tn', 'namespace', 'tagName' );
    zz( 'n', 'name' );
    zz( 's', 'string selector' );
    zz( document.getElementById( 'id' ) ); // Element
    zz( document.getElementsByClassName( 'className' ) ); // HTMLCollection
    zz( document.getElementsByName( 'name' ) ); // NodeList
    zz( 'table.className tr td' ); // String selector
    zz( '<div>New div</div>' ); // HTML code in string
*/
/**
 * @param {string|Element|HTMLCollection|NodeList} x
 * @param {string=} s1
 * @param {string=} s2 
 */
zzDOM.zz = function( x, s1, s2 ){
    
    // Redefine x if a selector id is found
    if ( s1 ){
        switch ( x ){
        case '#':
            x = document.getElementById( s1 );
            break;
        case '.':
            x = document.getElementsByClassName( s1 );
            break;
        case 't':
            x = document.getElementsByTagName( s1 );
            break;
        case 'tn':
            x = document.getElementsByTagNameNS( s1, s2 || '' );
            break;
        case 'n':
            x = document.getElementsByName( s1 );
            break;
        case 's':
            x = document.querySelector( s1 );
            break;
        default:
            throw 'Unsupported selector id found running zz function: ' + x;
        }
    }
    
    // Is it an Element?
    if ( x instanceof Element ){
        return new zzDOM.SS( x );
    }
    
    // Is it an HTMLCollection or a NodeList?
    if ( x instanceof HTMLCollection || x instanceof NodeList ){
        return zzDOM._build( x );
    }
    
    if ( typeof x === 'string' ){
        x = x.trim();
        return zzDOM._build(
            x.charAt( 0 ) === '<'? // Is it HTML code?
                zzDOM._htmlToElement( x ):
                document.querySelectorAll( x ) // Must be a standard selector
        );
    }
    
    throw 'Unsupported selector type found running zz function.';
};

// Build args array with toInsert as first position and then the arguments of this function
zzDOM._args = function( previousArgs, toInsert ){
    var result = Array.prototype.slice.call( previousArgs );
    result.push( toInsert );
    return result;
};

zzDOM._build = function ( x ) {
    if ( x instanceof Element ){
        return new zzDOM.SS( x );
    }
    if ( x instanceof HTMLCollection || x instanceof NodeList ){
        x = Array.prototype.slice.call( x );
    }
    return x.length === 1? new zzDOM.SS( x[ 0 ] ): new zzDOM.MM( x );
};

zzDOM._getError = function ( method ) {
    return 'Method "' + method + '" not ready for that type!';
};

zzDOM._htmlToElement = function ( html ) {
    var template = document.createElement( 'template' );
    template.innerHTML = html.trim();
    return template.content.childElementCount === 1?
        template.content.firstChild:
        template.content.childNodes;
};

// Register zz function
var zz;
(function() { 
    zz = zzDOM.zz; 
})();

zzDOM._events = {};

zzDOM._addEventListener = function( ss, eventName, listener, useCapture ){
    var el = ss.el;
    var elId = ss._getElId();
    var thisEvents = zzDOM._events[ elId ];
    if ( ! thisEvents ){
        thisEvents = {};
        zzDOM._events[ elId ] = thisEvents;
    }
    var thisListeners = thisEvents[ eventName ];
    if ( ! thisListeners ){
        thisListeners = [];
        thisEvents[ eventName ] = thisListeners;
    }
    thisListeners.push( listener );
    
    // addEventListener
    el.addEventListener( eventName, listener, useCapture );
};

//TODO must remove all listeners when an element is removed
zzDOM._removeEventListener = function( ss, eventName, listener, useCapture ){
    var el = ss.el;
    var elId = ss._getElId();
    var thisEvents = zzDOM._events[ elId ];
    if ( ! thisEvents ){
        return;
    }
    
    if ( ! eventName ){ 
        // Must remove all events
        for ( var currentEventName in thisEvents ){
            var currentListeners = thisEvents[ currentEventName ];
            zzDOM._removeListeners( el, currentListeners, null, useCapture, currentEventName );
        }
        return;
    }
    
    // Must remove listeners of only one event
    var thisListeners = thisEvents[ eventName ];
    zzDOM._removeListeners( el, thisListeners, listener, useCapture, eventName );
};

//TODO test all the listeners are removed
zzDOM._removeListeners = function( el, thisListeners, listener, useCapture, eventName ){
    if ( ! thisListeners ){
        return;
    }
    for ( var i = 0; i < thisListeners.length; ++i ){
        var currentListener = thisListeners[ i ];
        if ( ! listener || currentListener === listener ){
            thisListeners.splice( i, 1 ); // Delete listener at i position
            el.removeEventListener( eventName, currentListener, useCapture );
            if ( listener ){
                return;
            }
        }
    } 
};
/* End of events */

zzDOM._dd = {};

zzDOM._getDefaultDisplay = function( el ) {
    var nodeName = el.nodeName;
    var display = zzDOM._dd[ nodeName ];

    if ( display ) {
        return display;
    }

    var doc = el.ownerDocument;
    var temp = doc.body.appendChild( doc.createElement( nodeName ) );
    display = getComputedStyle( temp )[ 'display' ];

    temp.parentNode.removeChild( temp );

    if ( display === 'none' ) {
        display = 'block';
    }
    zzDOM._dd[ nodeName ] = display;

    return display;
};
/* End of visible */

/* It depends on forms plugin! */
// Serialize a ss instance, a mm instance or an object into a query string
zzDOM._paramItem = function( r, key, value ) {
    r.push( 
        encodeURIComponent( key ) + '=' + encodeURIComponent( value == null? '': value )
    );
};
/** @nocollapse */
zzDOM.param = function( x ) {
	
    if ( x == null ) {
        return '';
    }

    var r = [];
    
    if ( x instanceof zzDOM.SS ){
        zzDOM._paramItem( r, x.attr( 'name' ), x.val() );
    } else if ( x instanceof zzDOM.MM ){
        for ( var c = 0; c < x.list.length; ++c ){
            var ss = x.list[ c ];
            zzDOM._paramItem( r, ss.attr( 'name' ), ss.val() );
        }
    } else if ( typeof x === 'object' ){  
        for ( var i in x ) {
            zzDOM._paramItem( r, i, x[ i ] );
        }
    } else {
        throw zzDOM._getError( 'param' );
    }

    return r.join( '&' );
};
/* end of utils */

/** @constructor */
zzDOM.SS = function ( _el ) {
    this.el = _el;
    this.nodes = [ _el ];
    
    // Array like
    this.length = 1;
    this[ 0 ] = _el;
};

/* Methods NOT included in jquery */
zzDOM.SS.prototype._gcs = function ( self, property ) {
    var x = getComputedStyle( self.el, null )[ property ].replace( 'px', '' );
    return isNaN( x )? x: parseFloat( x );
};

zzDOM.SS.prototype._getElId = function(){
    var elId = this.el.getAttribute( 'data-elId' );
    if ( ! elId ){
        // Generate a random string with 4 chars
        elId = Math.floor( ( 1 + Math.random() ) * 0x10000 )
            .toString( 16 )
            .substring( 1 );
        this.el.setAttribute( 'data-elId', elId );
    }
    return elId;
};

zzDOM.SS.prototype._insertHelper = function ( position, x ) {
    if ( x instanceof Element ){
        this.el.insertAdjacentElement( position, x );
    } else if ( x instanceof zzDOM.SS ){
        this.el.insertAdjacentElement( position, x.el );
    } else if ( typeof x === 'string' ) {
        this.el.insertAdjacentHTML( position, x );
    } else {
        throw 'Insert operation not ready for that type!';
    }
    return this;
};

zzDOM.SS.prototype._iterate = function( value, fn ){
    if ( Array.isArray( value ) ){
        for ( var i = 0; i < value.length; ++i ){
            fn( this, value[ i ] );
        }
    } else {
        fn( this, value );   
    }
    return this;
};

zzDOM.SS.prototype._outer = function ( property, linked1, linked2, withMargin ) {
    if ( this.el[ 'offset' + property ] ) {
        return zzDOM.SS._outerCalc( this, property, linked1, linked2, withMargin );
    }
    
    var self = this;
    return this._swap( 
        this.el, 
        function(){
            return zzDOM.SS._outerCalc( self, property, linked1, linked2, withMargin );
        } 
    );
};

zzDOM.SS._outerCalc = function ( ss, property, linked1, linked2, withMargin ) {
    var value = ss._gcs( ss, property.toLowerCase() );
    var padding = ss._gcs( ss, 'padding' + linked1 ) + ss._gcs( ss, 'padding' + linked2 );
    var border = ss._gcs( ss, 'border' + linked1 + 'Width' ) + ss._gcs( ss, 'border' + linked2 + 'Width' );
    
    var total = value + padding + border;
    
    // No margin
    if ( ! withMargin ){
        return total;
    }
    
    var margin = ss._gcs( ss, 'margin' + linked1 ) + ss._gcs( ss, 'margin' + linked2 );
    return total + margin;
};

zzDOM.SS.prototype._setCssUsingKeyValue = function ( key, value ) {
    if ( typeof value === 'function' ) {
        value = value.call( this.el, this._i === undefined? 0: this._i, this );
    }
    this.el.style[ key ] = 
        typeof value === 'string' && ! /^-?\d+\.?\d*$/.test( value )? // if it is a string and is not a float number
            value: 
            value + 'px';
};

zzDOM.SS.prototype._setCssUsingObject = function ( object ) {
    for ( var key in object ) {
        this._setCssUsingKeyValue( key, object[ key ] );
    }
};

/**
 * @param {string} property
 * @param {string|Function=} value
 */
zzDOM.SS.prototype._styleProperty = function ( property, value ) {
    // get
    if ( value === undefined ){
        var self = this;
        value = this._gcs( this, property );
        return parseFloat( 
            value !== 'auto'? 
                value: 
                this._swap( 
                    this.el, 
                    function(){
                        return self._gcs( self, property );
                    } 
                )
        );
    }

    // set
    this._setCssUsingKeyValue( property, value );
    return this;
};

zzDOM.SS.prototype._swap = function( _el, callback ) {
    var old = {};
    var options = {
        display: 'block',
        position: 'absolute',
        visibility: 'hidden'
    };

    // Remember the old values and insert the new ones
    for ( var name in options ) {
        old[ name ] = _el.style[ name ];
        _el.style[ name ] = options[ name ];
    }

    var val = callback.call( _el );

    // Revert the old values
    for ( name in options ) {
        _el.style[ name ] = old[ name ];
    }

    return val;
};

/* Methods included in jquery */
zzDOM.SS.prototype.addClass = function ( name ) {
    return this._iterate(
        name,
        function( self, v ){
            self.el.classList.add( v ); 
        }
    );
};

zzDOM.SS.prototype.after = function ( x ) {
    return this._insertHelper( 'afterend', x );
};

zzDOM.SS.prototype.append = function ( x ) {
    if ( x instanceof Element ){
        this.el.appendChild( x );
    } else if ( x instanceof zzDOM.SS ){
        this.el.appendChild( x.el );
    } else if ( typeof x === 'string' ) {
        this.el.insertAdjacentHTML( 'beforeend', x );
    } else {
        throw zzDOM._getError( 'append' );
    }
    return this;
};

zzDOM.SS.prototype.appendTo = function ( x ) {
    // Do nothing and return this if it is null
    if ( x == null ){
        return this;    
    }
    
    // Is it a Element?
    if ( x instanceof Element ){
        x.appendChild( this.el );
        return this;
    }
    
    // Is it a string?
    if ( typeof x === 'string' ){
        x = zzDOM._build(
            document.querySelectorAll( x )
        );
    }
    
    // Is it a zzDOM.SS?
    if ( x instanceof zzDOM.SS ) {
        x.el.appendChild( this.el );
        return this;
    }
    
    // Is it a zzDOM.MM?
    if ( x instanceof zzDOM.MM ) {
        for ( var i = 0; i < x.nodes.length; ++i ){
            x.nodes[ i ].appendChild( this.el.cloneNode( true ) );
        }
        return this;
    } 
    
    throw zzDOM._getError( 'is' );
};

//TODO add support of function type in value
/**
 * @param {string|Object} x
 * @param {string=} value
 */
zzDOM.SS.prototype.attr = function ( x, value ) {
    // set using object
    if ( typeof x === 'object' ){
        for ( var key in x ) {
            this.attr( key, x[ key ] );
        }
        return this;
    }
    
    // get
    if ( value === undefined ){
        return this.el.getAttribute( x );
    }
    
    // remove attr
    if ( value === null ){
        return this.removeAttr( x );    
    }
    
    // set
    this.el.setAttribute( x, value );
    return this;
};

zzDOM.SS.prototype.before = function ( x ) {
    return this._insertHelper( 'beforebegin', x );
};

zzDOM.SS.prototype.children = function ( selector ) {
    return zzDOM._build( 
        selector?
            Array.prototype.filter.call(
                this.el.children, 
                function( child ){
                    return child.matches( selector );
                }
            ):
            this.el.children 
    );
};

zzDOM.SS.prototype.clone = function (  ) {
    return new zzDOM.SS( this.el.cloneNode( true ) );
};

//TODO add support of function type in value
/**
 * @param {string|Object} x1
 * @param {string|number=} x2
 */
zzDOM.SS.prototype.css = function ( x1, x2 ) {
    var number = arguments.length;
    
    if ( number === 1 ){
        if ( ! x1 ){
            throw 'Null value not allowed in css method!';
        }
        
        // get
        if ( typeof x1 === 'string' ) {
            return getComputedStyle( this.el )[ x1 ];
        }
        
        // set using object
        if ( typeof x1 === 'object' ){
            this._setCssUsingObject( x1 );
            return this;
        }
        
        throw 'Wrong type or argument in css method!';
    }
    
    // set using key value pair
    if ( number === 2 ){
        this._setCssUsingKeyValue( x1, x2 );
        return this;
    }
    
    throw 'Wrong number of arguments in css method!';
};

zzDOM.SS.prototype.each = function ( eachFn ) {
    eachFn.call( this.el, 0, this, this.nodes );
    return this;
};

zzDOM.SS.prototype.empty = function (  ) {
    while( this.el.firstChild ){
        this.el.removeChild( this.el.firstChild );
    }
    return this;
};

zzDOM.SS.prototype.filter = function ( x ) {
    if ( typeof x === 'string' ){ // Is a string selector
        return zzDOM._build( 
            this.el.matches( x )? [ this.el ]: []
        );
    }
    
    if ( typeof x === 'function' ){ // Is a function
        return zzDOM._build(
            x.call( this.el, this._i === undefined? 0: this._i, this )? [ this.el ]: []
        );
    }  
    
    throw zzDOM._getError( 'filter' );
};

zzDOM.SS.prototype.find = function ( selector ) {
    return zzDOM._build( 
        this.el.querySelectorAll( selector )
    );
};

zzDOM.SS.prototype.hasClass = function ( name ) {
    return this.el.classList.contains( name );
};

zzDOM.SS.prototype.height = function ( value ) {
    return this._styleProperty( 'height', value );
};

//TODO add support of function type in value
zzDOM.SS.prototype.html = function ( value ) {
    // get
    if ( value === undefined ){
        return this.el.innerHTML;
    }

    // set
    this.el.innerHTML = value;
    return this;
};

zzDOM.SS.prototype.index = function () {
    if ( ! this.el ){
        return -1;
    }
    
    var i = 0;
    var currentEl = this.el;
    do {
        i++;
    } while ( currentEl = currentEl.previousElementSibling );
    
    return i;
};

zzDOM.SS.prototype.is = function ( x ) {
    if ( x == null ){
        return false;    
    }
    
    if ( x instanceof Element ){
        return this.el === x;
    }
    
    if ( x instanceof zzDOM.SS ) {
        return this.el === x.el;
    } 

    if ( x instanceof zzDOM.MM ) {
        for ( var i = 0; i < x.nodes.length; ++i ){
            if ( this.el === x.nodes[ i ] ){
                return true;
            }
        }
        return false;
    } 

    if ( typeof x === 'string' ){
        return this.el.matches( x );
    }
    
    return false;
};

zzDOM.SS.prototype.next = function () {
    return new zzDOM.SS( this.el.nextElementSibling );
};

zzDOM.SS.prototype.offset = function ( c ) {
    
    // set top and left using css
    if ( c ){
        this._styleProperty( 'top', c.top );
        this._styleProperty( 'left', c.left );
        return this;
    }
    
    // get
    var rect = this.el.getBoundingClientRect();
    return {
        top: rect.top + document.body.scrollTop,
        left: rect.left + document.body.scrollLeft
    };
};

zzDOM.SS.prototype.offsetParent = function () {
    var offsetParent = this.el.offsetParent;
    return offsetParent? new zzDOM.SS( offsetParent ): this;
};

/**
 * @param {boolean=} withMargin
 */
zzDOM.SS.prototype.outerHeight = function ( withMargin ) {
    return this._outer( 'Height', 'Top', 'Bottom', withMargin );
};

/**
 * @param {boolean=} withMargin
 */
zzDOM.SS.prototype.outerWidth = function ( withMargin ) {
    return this._outer( 'Width', 'Left', 'Right', withMargin );
};

zzDOM.SS.prototype.parent = function () {
    return new zzDOM.SS( this.el.parentNode );
};

zzDOM.SS.prototype.position = function ( relativeToViewport ) {
    return relativeToViewport?
        this.el.getBoundingClientRect():
        { 
            left: this.el.offsetLeft, 
            top: this.el.offsetTop
        };
};

zzDOM.SS.prototype.prepend = function ( x ) {
    if ( x instanceof Element ){
        this.el.insertBefore( x, this.el.firstChild );
    } else if ( x instanceof zzDOM.SS ){
        this.el.insertBefore( x.el, this.el.firstChild );
    } else if ( typeof x === 'string' ){
        this.el.insertAdjacentHTML( 'afterbegin', x );
    } else {
        throw zzDOM._getError( 'prepend' );
    }
    return this;
};

zzDOM.SS.prototype.prev = function () {
    return new zzDOM.SS( this.el.previousElementSibling );
};

zzDOM.SS.prototype.remove = function () {
    this.el.parentNode.removeChild( this.el );
    return this;
};

zzDOM.SS.prototype.removeAttr = function ( name ) {
    this.el.removeAttribute( name );
    return this;
};

zzDOM.SS.prototype.removeClass = function ( name ) {
    if ( ! name ){
        this.el.className = '';
        return this;
    }
    
    return this._iterate(
        name,
        function( self, v ){
            self.el.classList.remove( v );
        }
    );
};

zzDOM.SS.prototype.replaceWith = function ( value ) {
    this.el.outerHTML = value;
    return this;
};

zzDOM.SS.prototype.siblings = function ( selector ) {
    var self = this;
    var nodes = Array.prototype.filter.call( 
        this.el.parentNode.children, 
        selector?
            function( child ){
                return child !== self.el && child.matches( selector );
            }:
            function( child ){
                return child !== self.el;
            }
    );
    return zzDOM._build( nodes );
};

//TODO add support of function type in value
zzDOM.SS.prototype.text = function ( value ) {
    // get
    if ( value === undefined ){
        return this.el.textContent;
    }

    // set
    this.el.textContent = value;
    return this;
};

zzDOM.SS.prototype.toggleClass = function ( name, state ) {
    return this._iterate(
        name,
        state === undefined?
            function( self, v ){
                self.el.classList.toggle( v );
            }:
            function( self, v ){
                self.el.classList.toggle( v, state );
            }
    );
};

zzDOM.SS.prototype.width = function ( value ) {
    return this._styleProperty( 'width', value );
};

zzDOM.SS.prototype.off = function ( eventName, listener, useCapture ) {
    zzDOM._removeEventListener( this, eventName, listener, useCapture );
    return this;
};

zzDOM.SS.prototype.on = function ( eventName, listener, data, useCapture ) {
    zzDOM._addEventListener( 
        this, 
        eventName, 
        data? 
            function( e ){
                e.data = data;
                return listener.call( e.currentTarget, e );
            }:
            listener, 
        useCapture 
    );
    return this;
};

zzDOM.SS.prototype.trigger = function ( eventName ) {
    var event = document.createEvent( 'HTMLEvents' );
    event.initEvent( eventName, true, false );
    this.el.dispatchEvent( event );
    return this;
};
/* End of events */

zzDOM.SS.prototype.hide = function () {
    if ( this.isVisible() ){
        this.attr( 
            'data-display', 
            getComputedStyle( this.el, null )[ 'display' ]
        );
        this.el.style.display = 'none';
    }
    return this;
};

zzDOM.SS.prototype.isVisible = function () {
    return !! this.el.offsetParent;
    //return getComputedStyle( this.el, null ).getPropertyValue( 'display' ) !== 'none';
};

zzDOM.SS.prototype.show = function () {
    if ( ! this.isVisible() ){
        var display = this.attr( 'data-display' );
        this.el.style.display = display? display: zzDOM._getDefaultDisplay( this.el );
    }
    return this;
};

zzDOM.SS.prototype.toggle = function ( state ) {
    var value = state !== undefined? ! state: this.isVisible();
    return value? this.hide(): this.show();
};
/* End of visible */

zzDOM.SS.prototype.checked = function ( check ) {
    if ( this.el.nodeName !== 'INPUT' || ( this.el.type !== 'checkbox' && this.el.type !== 'radio') ) {
        throw zzDOM._getError( 'checked' );
    }
    
    // get
    if ( check === undefined ){
        return !! this.el.checked;
    }
    
    // set
    this.el.checked = check;
    return this;
};

/**
 * @param {Array<?>|String=} value
 */
zzDOM.SS.prototype.val = function ( value ) {
    // get
    if ( value === undefined ){
        switch ( this.el.nodeName ) {
        case 'INPUT':
        case 'TEXTAREA':
        case 'BUTTON':
            return this.el.value;
        case 'SELECT':
            var values = [];
            for ( var i = 0; i < this.el.length; ++i ) {
                if ( this.el[ i ].selected ) {
                    values.push( this.el[ i ].value );
                }
            }
            return values.length > 1? values: values[ 0 ];
        default:
            throw zzDOM._getError( 'val' );
        }
    }
    
    // set
    switch ( this.el.nodeName ) {
    case 'INPUT':
    case 'TEXTAREA':
    case 'BUTTON':
        this.el.value = value;
        break;
    case 'SELECT':
        if ( typeof value === 'string' || typeof value === 'number' ) {
            value = [ value ];
        }
        for ( i = 0; i < this.el.length; ++i ) {
            for ( var j = 0; j < value.length; ++j ) {
                this.el[ i ].selected = '';
                if ( this.el[ i ].value === value[ j ] ) {
                    this.el[ i ].selected = 'selected';
                    break;
                }
            }
        }
        break;
    default:
        throw zzDOM._getError( 'val' );
    }
    
    return this;
};
/* End of forms */

zzDOM.SS.prototype.getXCenter = function() {
    return ( document.documentElement.clientWidth - this.outerWidth() ) / 2;
};

zzDOM.SS.prototype.getYCenter = function() {
    return ( document.documentElement.clientHeight - this.outerHeight() ) / 2;
};

zzDOM.SS.prototype.getCenter = function() {
    return {
        left: this.getXCenter(),
        top: this.getYCenter()
    };
};

zzDOM.SS.prototype.center = function() {
    this.offset( 
        this.getCenter() 
    );
    return this;
};

zzDOM.SS.prototype.centerX = function() {
    this.css( 'left', this.getXCenter() );
    return this;
};

zzDOM.SS.prototype.centerY = function() {
    this.css( 'top', this.getYCenter() );
    return this;
};
/* End of center */

/** @constructor */
zzDOM.MM = function ( _nodes ) {    
    this.list = [];
    this.nodes = _nodes;
    this.length = _nodes.length;
    
    // Init nodes
    for ( var i = 0; i < this.length; i++ ) {
        var el = this.nodes[ i ];
        this[ i ] = el; // for array like
        var ss = new zzDOM.SS( el );
        this.list.push( ss );
        ss._i = i; // for index in functions
    }
};

/*
Unify the definition of a function of zzDOM.SS.prototype and a definition of zzDOM.MM.prototype. Example:

    zzDOM.add( 
        zzDOM.SS.prototype.myCustomFunction = function(){
            ...
            return this;
        },
        zzDOM.MM.constructors.concat
    );
);
*/
/**
 * @param {Function} ssPrototype
 * @param {Function=} constructor
 */
zzDOM.add = function( ssPrototype, constructor ){
    for ( var id in zzDOM.SS.prototype ){
        var current = zzDOM.SS.prototype[ id ];
        if ( ssPrototype === current ){
            var closure = function(){
                var functionId = id;
                return constructor? constructor( functionId ): zzDOM.MM.constructors.default( functionId );
            };
            zzDOM.MM.prototype[ id ] = closure();
            return;
        }
    }
    
    throw 'Error registering zzDOM.MM: zzDOM.SS not found.';
};

zzDOM.MM.constructors = {};
zzDOM.MM.constructors.booleanOr = function( functionId ){
    return function(){
        for ( var i = 0; i < this.list.length; i++ ) {
            var ss = this.list[ i ];
            var x = ss[ functionId ].apply( ss, arguments );
            if ( x ){
                return true;
            }
        }
        return false;
    };
};
zzDOM.MM.constructors.concat = function( functionId ){
    return function(){
        var newNodes = [];
        for ( var i = 0; i < this.list.length; i++ ) {
            var ss = this.list[ i ];
            var x = ss[ functionId ].apply( ss, arguments );
            newNodes = newNodes.concat( x.nodes );
        }
        return zzDOM._build( newNodes );
    };
};
zzDOM.MM.constructors.default = function( functionId ){
    return function(){
        for ( var i = 0; i < this.list.length; i++ ) {
            var ss = this.list[ i ];
            var r = ss[ functionId ].apply( ss, arguments );
            if ( i === 0 && ! ( r instanceof zzDOM.SS ) ){
                return r;
            }
        }
        return this;
    };
};

// Init prototype functions from zzDOM.SS
zzDOM.MM.init = function(){
    // Concat functions
    var concatF = [
        'children',
        'clone',
        'filter',
        'find',
        'next',
        'offsetParent',
        'parent',
        'prev',
        'siblings'
    ];
    // Boolean functions
    var booleanOrF = [
        'hasClass',
        'is'
    ];
    for ( var id in zzDOM.SS.prototype ){
        var closure = function(){
            var functionId = id;
            
            if ( concatF.indexOf( functionId ) !== -1 ){
                return zzDOM.MM.constructors.concat( functionId );
            }
            if ( booleanOrF.indexOf( functionId ) !== -1 ){
                return zzDOM.MM.constructors.booleanOr( functionId );
            }
            return zzDOM.MM.constructors.default( functionId );
        };
        zzDOM.MM.prototype[ id ] = closure();
    }
}();

/* Methods included in jquery */
zzDOM.MM.prototype.each = function ( eachFn ) {
    var self = this;
    Array.prototype.forEach.call( 
        this.list, 
        function( currentValue, index ){
            eachFn.call( currentValue.el, index, currentValue, self.nodes );
        }
    );
    return this;
};

// Register zzDOM if we are using Node
if ( typeof module === 'object' && module.exports ) {
    module.exports = zzDOM;
}

},{}],104:[function(require,module,exports){
var zzDOM = require('./build/zzDOM-closures-full.js');
module.exports = zzDOM.zz;

},{"./build/zzDOM-closures-full.js":103}],105:[function(require,module,exports){
var Qunit = require( 'qunit' );
var zz = require( 'zzdom' );
var zpt = require( 'zpt' );
var blueRouter = require( '../../build/blueRouter.js' );

// Init router
const initRouter = () => {
    // Initialize pages
    const pages = {};

    // Load js of pages
    const dictionary = {};
    pages[ 'renderWithoutWaiting' ] = require( './pages/renderWithoutWaiting.js' )( dictionary );
    pages[ 'renderWaitingForServer' ] = require( './pages/renderWaitingForServer.js' )( dictionary );

    // Initialize options: no animations
    let initializeZPT = true;
    let options = {
        eventsByPage: pages,
        animationOut: false,
        animationIn: false,
        routes: require( './routesInlineForRender.js' )
    };

    // Add renderFunction
    options.renderFunction = ( page ) => {
        if ( initializeZPT ){
            zpt.run({
                'root': document.body,
                'dictionary': dictionary
            });
            initializeZPT = false;
        } else {
            zpt.run({
                'command': 'partialRender',
                'target': page[ 'el' ]
            });
        }
    };

    // Create new router instance
    return new blueRouter.router( options );
};

// Init router
const router = initRouter();

// Unit tests
require( './render.js' )();


},{"../../build/blueRouter.js":1,"./pages/renderWaitingForServer.js":106,"./pages/renderWithoutWaiting.js":107,"./render.js":108,"./routesInlineForRender.js":109,"qunit":6,"zpt":75,"zzdom":104}],106:[function(require,module,exports){
/* renderWithoutWaiting page */
module.exports = function ( dictionary ) {
    
    var zpt = require( 'zpt' );

    const page = {};

    page[ 'preInit' ] = function( event ){

        dictionary[ 'successMessageFromServer' ] = 'Loading...';
    };

    page[ 'init' ] = function( event ){

        setTimeout(
            function(){
                dictionary[ 'successMessageFromServer' ] = 'It works!';
                zpt.run({
                    'command': 'partialRender',
                    'target': document.getElementById( 'renderWaitingForServer_message' )
                });
            },
            300
        );
    };

    return page;
};

},{"zpt":75}],107:[function(require,module,exports){
/* renderWithoutWaiting page */

module.exports = function ( dictionary ) {

    const page = {};

    page[ 'preInit' ] = function( event ){
        //alert( 'EVENT_PRE_INIT' );

        dictionary[ 'successMessage' ] = 'It works!';
    };

    return page;
};

},{}],108:[function(require,module,exports){
// Tests for events

var zz = require( 'zzdom' );
var utils = require( './utils.js' );
var Qunit = require( 'qunit' );

// Unit tests
module.exports = function () {

    // Non waiting render test
    QUnit.test( "Non waiting render test", async function( assert ) {
        
        // Get a reference to finish the qunit test later
        var done = assert.async();

        // Go to page renderWithoutWaiting
        zz('#home_renderWithoutWaitingLink').el.click();
        await utils.waitShort();
        assert.equal( zz('#renderWithoutWaiting_p').text().trim() , "This is Page render without waiting" );

        // Check that render is ok
        assert.equal( zz('#renderWithoutWaiting_message').text().trim() , "It works!" );

        // Go to home page
        zz('#renderWithoutWaiting_homeLink').el.click();
        await utils.waitShort();

        // Finish qunit test
        done();
    });

    // Waiting for server render test
    QUnit.test( "Waiting for server render test", async function( assert ) {
        
        // Get a reference to finish the qunit test later
        var done = assert.async();

        // Go to page renderWithoutWaiting
        zz('#home_renderWaitingForServerLink').el.click();
        await utils.waitShort();
        assert.equal( zz('#renderWaitingForServer_p').text().trim() , "This is Page render waiting for server" );
        await utils.waitShort();
        
        // Check that render is ok
        assert.equal( zz('#renderWaitingForServer_message').text().trim() , "It works!" );

        // Go to home page
        zz('#renderWaitingForServer_homeLink').el.click();
        await utils.waitShort();

        // Finish qunit test
        done();
    });

};

},{"./utils.js":110,"qunit":6,"zzdom":104}],109:[function(require,module,exports){
// Routes for inline content for render tests

const routes = [
    // Home page
    {
        id: '[home]',
        content: `
<h1>Blue router test</h1>

<div class="page-content">
<h3>Home page</h3>
<p>
    This is Home page
</p>

<ul id="home_links">
    <li>
        <a href="!renderWithoutWaiting" id="home_renderWithoutWaitingLink">Page render without waiting</a>. Go to page render without waiting.
    </li>
    <li>
        <a href="!renderWaitingForServer" id="home_renderWaitingForServerLink">Page render waiting for server</a>. Go to page render waiting for server.
    </li>
</ul>
</div>
`
    },
    // page render without waiting
    {
        id: 'renderWithoutWaiting',
        content: `
<h1>Blue router test</h1>

<div>
<a href="!" id="renderWithoutWaiting_homeLink">Home</a>
</div>

<div class="page-content">
<h3>Page render</h3>
<p id="renderWithoutWaiting_p">
    This is Page render without waiting
</p>

<h2 id="renderWithoutWaiting_message" data-content="successMessage">
    Not working!
</h2>
</div>
`
    },
    // page render waiting for server
    {
        id: 'renderWaitingForServer',
        content: `
<h1>Blue router test</h1>

<div>
<a href="!" id="renderWaitingForServer_homeLink">Home</a>
</div>

<div class="page-content">
<h3>Page render</h3>
<p id="renderWaitingForServer_p">
    This is Page render waiting for server
</p>

<h2 id="renderWaitingForServer_message" data-content="successMessageFromServer">
    Not working!
</h2>
</div>
`
    },
    // Default route (404 page)
    {
        id: '[404]',
        content: `
<h1>Blue router test</h1>

<div>
<a href="!" id="e404_homeLink">Home</a>
</div>

<div class="page-content">
<h3>404 page</h3>
<p>
    Sorry
</p>
<p id="e404_p">
    Requested content not found.
</p>
</div>
`
    }
];

module.exports = routes;



},{}],110:[function(require,module,exports){
const utils = {};

utils.waitShort = function() {
    return utils.wait( 1000 );
};

utils.wait = function( timeout ) {
    return new Promise( resolve => {
        setTimeout( resolve, timeout );
    });
};

module.exports = utils;


},{}]},{},[105])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC9ibHVlUm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvYWRqcy9kaXN0L2xvYWRqcy51bWQuanMiLCJub2RlX21vZHVsZXMvbG9nNGphdmFzY3JpcHQvbG9nNGphdmFzY3JpcHQuanMiLCJub2RlX21vZHVsZXMvbWVzc2FnZWZvcm1hdC9tZXNzYWdlZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xdW5pdC9xdW5pdC9xdW5pdC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9JMThOL2kxOG5Eb21haW4uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9hdHRyaWJ1dGVzL0kxOE4vaTE4bkxhbmd1YWdlLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9NRVRBTC9tZXRhbERlZmluZU1hY3JvLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9NRVRBTC9tZXRhbEZpbGxTbG90LmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9NRVRBTC9tZXRhbFVzZU1hY3JvLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9UQUwvY29udGVudEhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2F0dHJpYnV0ZXMvVEFML3RhbEF0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9hdHRyaWJ1dGVzL1RBTC90YWxDb25kaXRpb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9hdHRyaWJ1dGVzL1RBTC90YWxDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9UQUwvdGFsRGVjbGFyZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2F0dHJpYnV0ZXMvVEFML3RhbERlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2F0dHJpYnV0ZXMvVEFML3RhbE9taXRUYWcuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9hdHRyaWJ1dGVzL1RBTC90YWxPbkVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9UQUwvdGFsUmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvYXR0cmlidXRlcy9UQUwvdGFsUmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2F0dHJpYnV0ZXMvYXR0cmlidXRlSW5kZXguanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9jYWNoZS9hdHRyaWJ1dGVDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2NhY2hlL2NhY2hlSGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvY2FjaGUvZXhwcmVzc2lvbkNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2FyaXRobWV0aGljL2FkZEV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9hcml0aG1ldGhpYy9hcml0aG1ldGhpY0hlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2FyaXRobWV0aGljL2RpdmlkZUV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9hcml0aG1ldGhpYy9tb2RFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvYXJpdGhtZXRoaWMvbXVsdGlwbHlFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvYXJpdGhtZXRoaWMvc3Vic3RyYWN0RXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2Jvb2wvYW5kRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2Jvb2wvYm9vbEhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2Jvb2wvY29uZEV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9ib29sL25vdEV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9ib29sL29yRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2NvbXBhcmlzb24vY29tcGFyaXNvbkhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2NvbXBhcmlzb24vZXF1YWxzRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2NvbXBhcmlzb24vZ3JlYXRlckV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9jb21wYXJpc29uL2luRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2NvbXBhcmlzb24vbG93ZXJFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvZXZhbHVhdGVIZWxwZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9leGlzdHNFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvZXhwcmVzc2lvbkJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9leHByZXNzaW9uVG9rZW5pemVyLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2Zvcm1hdEV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9pMThuL3RyQ3VycmVuY3lFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvaTE4bi90ckRhdGVUaW1lRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2kxOG4vdHJIZWxwZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9pMThuL3RyTnVtYmVyRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL2kxOG4vdHJTdHJpbmdFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvcGF0aC9hcnJheUV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9wYXRoL2Z1bmN0aW9uRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL3BhdGgvaW5kaXJlY3Rpb25FeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvcGF0aC9saXN0RXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL3BhdGgvbGl0ZXJhbHMvYm9vbGVhbkxpdGVyYWwuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9wYXRoL2xpdGVyYWxzL251bWVyaWNMaXRlcmFsLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvcGF0aC9saXRlcmFscy9zdHJpbmdMaXRlcmFsLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvcGF0aC9tZXRob2RFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvcGF0aC9wYXRoRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL3BhdGgvcGF0aFNlZ21lbnRFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvcGF0aC9wcm9wZXJ0eUV4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9leHByZXNzaW9ucy9wYXRoL3JhbmdlRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL3BhdGgvdmFyaWFibGVFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvc2NyaXB0aW5nL2phdmFzY3JpcHRFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvZXhwcmVzc2lvbnMvc2NyaXB0aW5nL3F1ZXJ5RXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL2V4cHJlc3Npb25zL3N0cmluZ0V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9pMThuL2kxOG4uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9pMThuL2kxOG5CdW5kbGUuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9pMThuL2kxOG5IZWxwZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9sb2dIZWxwZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9hdXRvRGVmaW5lSGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9kZXBzRGF0YUl0ZW0uanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9wYXJzZXJzL2RpY3Rpb25hcnlBY3Rpb25zL2Fic3RyYWN0QWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9kaWN0aW9uYXJ5QWN0aW9ucy9hYnN0cmFjdEFycmF5QWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9kaWN0aW9uYXJ5QWN0aW9ucy9hYnN0cmFjdE9iamVjdEFjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvZGljdGlvbmFyeUFjdGlvbnMvYXJyYXlDcmVhdGUuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9wYXJzZXJzL2RpY3Rpb25hcnlBY3Rpb25zL2FycmF5RGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9kaWN0aW9uYXJ5QWN0aW9ucy9hcnJheVVwZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvZGljdGlvbmFyeUFjdGlvbnMvY3NzQW5pbWF0aW9uTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvZGljdGlvbmFyeUFjdGlvbnMvZGljdGlvbmFyeUFjdGlvbkJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9wYXJzZXJzL2RpY3Rpb25hcnlBY3Rpb25zL29iamVjdERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvZGljdGlvbmFyeUFjdGlvbnMvb2JqZWN0VXBkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9sb29wLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9sb29wSXRlbS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvbm9kZUF0dHJpYnV0ZXMuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9wYXJzZXJzL25vZGVSZW1vdmVyLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC9wYXJzZXJzL3BhcnNlck5vZGVSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvcGFyc2VyUHJlbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvcGFyc2Vycy9wYXJzZXJSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3BhcnNlcnMvcGFyc2VyVXBkYXRlci5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3Jlc29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL3pwdC9qcy9hcHAvc2NvcGVzL3JlYWN0aXZlRGljdGlvbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3Njb3Blcy9zY29wZS5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3Njb3Blcy9zY29wZUJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvenB0L2pzL2FwcC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy96cHQvanMvYXBwL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvenpkb20vYnVpbGQvenpET00tY2xvc3VyZXMtZnVsbC5qcyIsIm5vZGVfbW9kdWxlcy96emRvbS9pbmRleC5qcyIsInRlc3QvanMvbm9UcmFuc2l0aW9uUmVuZGVyLmpzIiwidGVzdC9qcy9wYWdlcy9yZW5kZXJXYWl0aW5nRm9yU2VydmVyLmpzIiwidGVzdC9qcy9wYWdlcy9yZW5kZXJXaXRob3V0V2FpdGluZy5qcyIsInRlc3QvanMvcmVuZGVyLmpzIiwidGVzdC9qcy9yb3V0ZXNJbmxpbmVGb3JSZW5kZXIuanMiLCJ0ZXN0L2pzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdG9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWlDQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qISBibHVlcm91dGVyIC0gdjAuMS4wIC0gMjAyNS0wMS0xNiAxMzozMToyOCAqL1xuLyoqXG4gKiBBIG5hbWVzcGFjZS5cbiAqIEBjb25zdFxuICovXG5jb25zdCBibHVlUm91dGVyID0ge307XG5cblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuYmx1ZVJvdXRlci5yb3V0ZXIgPSBmdW5jdGlvbiAoIHVzZXJPcHRpb25zICkge1xuXG4gICAgLy8gSW5pdCBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgYmx1ZVJvdXRlci51dGlscy5leHRlbmQoIHRoaXMub3B0aW9ucywgYmx1ZVJvdXRlci5kZWZhdWx0T3B0aW9ucywgdXNlck9wdGlvbnMgKTtcbiAgICB0aGlzLmNoZWNrT3B0aW9ucygpO1xuXG4gICAgLy8gUHJlbG9hZCBwYWdlcyBpZiBuZWVkZWRcbiAgICBpZiAoIHRoaXMub3B0aW9ucy5wcmVsb2FkUGFnZXNPbkxvYWQgKXtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBibHVlUm91dGVyLmh0bWxGZXRjaGVyLmxvYWRBbGxVcmxzKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBwcmVsb2FkIHBhZ2VzLCBydW4gaW5pdFxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuLyogTWV0aG9kcyAqL1xuXG4vKiogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gKi9cbmJsdWVSb3V0ZXIucm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBJbml0IHNvbWUgb3RoZXIgdmFyc1xuICAgIHRoaXMucm91dGVzTWFwID0gdGhpcy5jcmVhdGVSb3V0ZXNNYXAoKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG5cbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyc0ZvcldpbmRvdygpO1xuXG4gICAgLy8gTmF2aWdhdGUgdG8gd2luZG93LmxvY2F0aW9uLmhyZWYgb3IgaG9tZVxuICAgIHRoaXMubmF2aWdhdGVVcmwoXG4gICAgICAgIHRoaXMub3B0aW9ucy51cGRhdGVPbkxvYWQ/IHdpbmRvdy5sb2NhdGlvbi5ocmVmOiAnJyxcbiAgICAgICAgdGhpcy5vcHRpb25zLmFuaW1hdGVUcmFuc2l0aW9uc09uTG9hZFxuICAgICk7XG59O1xuXG4vLyBDaGVjayB0aGF0IG1hbmRhdG9yeSB1c2VyIGRlZmluZWQgcHJvcGVydGllcyBhcmUgZGVmaW5lZFxuLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG5ibHVlUm91dGVyLnJvdXRlci5wcm90b3R5cGUuY2hlY2tPcHRpb25zID0gZnVuY3Rpb24oKSB7XG5cbiAgICBsZXQgZXJyb3JzID0gMDtcbiAgICBsZXQgZXJyb3JNZXNzYWdlcyA9ICcnO1xuXG4gICAgaWYgKCAhIHRoaXMub3B0aW9ucy5yb3V0ZXMgKXtcbiAgICAgICAgKytlcnJvcnM7XG4gICAgICAgIGVycm9yTWVzc2FnZXMgKz0gJ3JvdXRlcyBtdXN0IGJlIGRlZmluZWQuICc7XG4gICAgfVxuXG4gICAgaWYgKCAhIHRoaXMub3B0aW9ucy5ldmVudHNCeVBhZ2UgKXtcbiAgICAgICAgKytlcnJvcnM7XG4gICAgICAgIGVycm9yTWVzc2FnZXMgKz0gJ2V2ZW50c0J5UGFnZSBtdXN0IGJlIGRlZmluZWQuICc7XG4gICAgfVxuXG4gICAgaWYgKCBlcnJvcnMgKXtcbiAgICAgICAgdGhpcy5hbGVydEVycm9yKCAnVW5hYmxlIHRvIGluaXRhbGl6ZSBCbHVlIHJvdXRlci4gJyArIGVycm9ycyArICcgZXJyb3JzIGZvdW5kOiAnICsgZXJyb3JNZXNzYWdlcyApO1xuICAgIH1cbn07XG5cbmJsdWVSb3V0ZXIucm91dGVyLnByb3RvdHlwZS5hbGVydEVycm9yID0gZnVuY3Rpb24oIG1lc3NhZ2UgKXtcbiAgICBhbGVydCggbWVzc2FnZSApO1xuICAgIHRocm93IG1lc3NhZ2U7XG59O1xuXG5ibHVlUm91dGVyLnJvdXRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnNGb3JXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAvKlxuICAgIHdpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubmF2aWdhdGVVcmwoIHRoaXMub3B0aW9ucy51cGRhdGVPbkxvYWQ/IHdpbmRvdy5sb2NhdGlvbi5ocmVmOiAnJywgdHJ1ZSApO1xuICAgIH1cbiAgICAqL1xuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gKCBlICkgPT4ge1xuICAgICAgICB0aGlzLm5hdmlnYXRlVXJsKCB3aW5kb3cubG9jYXRpb24uaHJlZiwgdHJ1ZSApO1xuICAgICAgICAvL3RoaXMubmF2aWdhdGVVcmwoIGUuc3RhdGVbICdwYWdlJyBdLCB0cnVlICk7XG4gICAgfTtcbn07XG5cbi8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzRm9yTGlua3MgPSBmdW5jdGlvbiggcGFnZUlkICkge1xuICAgIFxuICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIGEgZWxlbWVudHNcbiAgICBibHVlUm91dGVyLnV0aWxzLmFkZEV2ZW50TGlzdGVuZXJPbkxpc3QoXG4gICAgICAgIC8vZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdhJyApLFxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggcGFnZUlkICkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdhJyApLFxuICAgICAgICAnY2xpY2snLCBcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoICdocmVmJyApO1xuXG4gICAgICAgICAgICAvLyBGb2xsb3cgdGhlIGxpbmsgaWYgaXQgaXMgZXh0ZXJuYWwgKGlmIGl0IGlzIG1hcmtlZCBhcyBleHRlcm5hbCBpbiB0aGUgY2xhc3MgbGlzdClcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZiAoIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyAoIHNlbGYub3B0aW9ucy5leHRlcm5hbENsYXNzICkgKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gRm9sbG93IHRoZSBsaW5rIGlmIGl0IGlzIGV4dGVybmFsIChpZiBpdCBkb2VzIG5vdCBzdGFydCBieSAhKVxuICAgICAgICAgICAgaWYgKCAhIGhyZWYuc3RhcnRzV2l0aCggc2VsZi5vcHRpb25zLlBBR0VfUFJFRklYICkgKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJ3BhZ2UnOiBocmVmXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncGFnZSAnICsgaHJlZixcbiAgICAgICAgICAgICAgICAnIycgKyBocmVmXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VsZi5uYXZpZ2F0ZVVybCggaHJlZiwgdHJ1ZSApO1xuICAgICAgICB9XG4gICAgKTtcbn07XG5cbi8vIENyZWF0ZSBhIG1hcCB3aXRoIHRoZSBkYXRhIGluIHJvdXRlcywgdXNpbmcgdGhlIHBhdGggYXMgdGhlIGtleVxuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLmNyZWF0ZVJvdXRlc01hcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc3Qgcm91dGVyTWFwID0ge307XG4gICAgY29uc3Qgcm91dGVzID0gdGhpcy5vcHRpb25zLnJvdXRlcyB8fCBbXTtcblxuICAgIHJvdXRlcy5tYXAoIHJvdXRlSXRlbSA9PiB7XG4gICAgICAgIHJvdXRlck1hcFsgcm91dGVJdGVtLmlkIF0gPSByb3V0ZUl0ZW07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm91dGVyTWFwO1xufTtcblxuLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG5ibHVlUm91dGVyLnJvdXRlci5wcm90b3R5cGUuZ2V0Um91dGVJdGVtID0gZnVuY3Rpb24oIHBhZ2VJZCApIHtcblxuICAgIC8vIExvb2sgZm9yIHRoZSByb3V0ZVxuICAgIGxldCByb3V0ZUl0ZW0gPSB0aGlzLnJvdXRlc01hcFsgcGFnZUlkIF07XG4gICAgaWYgKCByb3V0ZUl0ZW0gKXtcbiAgICAgICAgcmV0dXJuIHJvdXRlSXRlbTtcbiAgICB9XG5cbiAgICAvLyBObyByb3V0ZSBmb3VuZCwgNDA0IGVycm9yXG4gICAgcm91dGVJdGVtID0gdGhpcy5yb3V0ZXNNYXBbIHRoaXMub3B0aW9ucy5QQUdFX0lEXzQwNF9FUlJPUiBdO1xuICAgIGlmICggcm91dGVJdGVtICl7XG4gICAgICAgIHJldHVybiByb3V0ZUl0ZW07XG4gICAgfVxuXG4gICAgLy8gTm8gNDA0IHBhZ2UsIGJ1aWxkIGEgNDA0IHJvdXRlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHRoaXMub3B0aW9ucy5QQUdFX0lEXzQwNF9FUlJPUixcbiAgICAgICAgY29udGVudDogJzxoMz40MDQgLSBQYWdlIG5vdCBmb3VuZDogJyArIHBhZ2VJZCArICc8L2gzPidcbiAgICB9O1xuICAgIC8vdGhpcy5hbGVydEVycm9yKCAnTm8gcm91dGUgZm91bmQgd2l0aCBpZCAnICsgcGFnZUlkICsgJyBhbmQgbm8gNDA0IHBhZ2UgZm91bmQuJyApO1xufTtcblxuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlVXJsID0gZnVuY3Rpb24oIHVybCwgbXVzdEFuaW1hdGVCeUNvZGUgKSB7XG4gICAgLy9hbGVydCggJ25hdmlnYXRlVXJsXFxudXJsOiAnICsgdXJsICk7XG5cbiAgICAvLyBDcmVhdGUgYW4gdXJsIG9iamVjdCB0byBtYWtlIGl0IGVhc3kgZXZlcnl0aGluZ1xuICAgIGxldCB1cmxPYmplY3QgPSBibHVlUm91dGVyLnV0aWxzLmFuYWxpemVVcmwoIHVybCwgdGhpcy5vcHRpb25zICk7XG5cbiAgICAvLyBVcGRhdGUgc3RhY2sgYW5kIGdldCBjdXJyZW50UGFnZUlkXG4gICAgbGV0IGN1cnJlbnRQYWdlSWQgPSB0aGlzLnVwZGF0ZVN0YWNrKCB1cmxPYmplY3QucGFnZSApO1xuXG4gICAgLy8gRXhpdCBpZiB0cnlpbmcgdG8gbmF2aWdhdGUgdG8gY3VycmVudCBwYWdlXG4gICAgaWYgKCBjdXJyZW50UGFnZUlkID09IHVybE9iamVjdC5wYWdlICl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGNvbnRlbnRcbiAgICBsZXQgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEZvclBhZ2UoIHVybE9iamVjdC5wYWdlICk7XG4gICAgXG4gICAgLy8gSWYgY29udGVudCBpcyBhIFByb21pc2Ugd2FpdCBhbmQgcmVzb2x2ZSBpdFxuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBpZiAoIGNvbnRlbnQgaW5zdGFuY2VvZiBQcm9taXNlICl7XG4gICAgICAgIGNvbnRlbnQudGhlbiggZnVuY3Rpb24oIHRleHQgKXtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250ZW50IG9mIHJvdXRlXG4gICAgICAgICAgICBsZXQgcm91dGVJdGVtID0gc2VsZi5nZXRSb3V0ZUl0ZW0oIHVybE9iamVjdC5wYWdlICk7XG4gICAgICAgICAgICByb3V0ZUl0ZW0uY29udGVudCA9IHRleHQ7XG5cbiAgICAgICAgICAgIC8vIFJ1biBkb1BhZ2VUcmFuc2l0aW9uXG4gICAgICAgICAgICBzZWxmLmRvUGFnZVRyYW5zaXRpb24oIHRleHQsIHVybE9iamVjdC5wYWdlLCBjdXJyZW50UGFnZUlkLCB1cmxPYmplY3QsIG11c3RBbmltYXRlQnlDb2RlICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29udGVudCBpcyBOT1QgYSBQcm9taXNlOiB1cGRhdGUgY3VycmVudCBwYWdlXG4gICAgdGhpcy5kb1BhZ2VUcmFuc2l0aW9uKCBjb250ZW50LCB1cmxPYmplY3QucGFnZSwgY3VycmVudFBhZ2VJZCwgdXJsT2JqZWN0LCBtdXN0QW5pbWF0ZUJ5Q29kZSApO1xufTtcblxuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLnVwZGF0ZVN0YWNrID0gZnVuY3Rpb24oIHBhZ2VJZCApIHtcbiAgICBcbiAgICAvLyBJZiB0aGUgcGVudWx0aW1hdGUgZWxlbWVudCBpcyB0aGUgcGFnZUlkIHRoZW4gd2UgYXJlIGdvaW5nIGJhY2t3YXJkczsgb3RoZXJ3aXNlIHdlIGFyZSBnb2luZyBmb3J3YXJkXG4gICAgbGV0IGlzQmFja3dhcmQgPSB0aGlzLnN0YWNrWyB0aGlzLnN0YWNrLmxlbmd0aCAtIDIgXSA9PSBwYWdlSWQ7XG5cbiAgICBpZiAoIGlzQmFja3dhcmQgKXtcbiAgICAgICAgLy8gSXMgYmFja3dhcmRcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgLy8gSXMgZm9yd2FyZFxuICAgIHZhciBjdXJyZW50UGFnZUlkID0gdGhpcy5zdGFja1sgdGhpcy5zdGFjay5sZW5ndGggLSAxIF07XG4gICAgdGhpcy5zdGFjay5wdXNoKCBwYWdlSWQgKTtcbiAgICByZXR1cm4gY3VycmVudFBhZ2VJZDtcbn07XG5cbmJsdWVSb3V0ZXIucm91dGVyLnByb3RvdHlwZS5nZXRDb250ZW50Rm9yUGFnZSA9IGZ1bmN0aW9uKCBwYWdlSWQgKSB7XG5cbiAgICAvLyBHZXQgdGhlIHJvdXRlSXRlbSBmcm9tIHRoZSByb3V0ZXNNYXBcbiAgICBsZXQgcm91dGVJdGVtID0gdGhpcy5nZXRSb3V0ZUl0ZW0oIHBhZ2VJZCApO1xuXG4gICAgLy8gR2V0IHRoZSBjb250ZW50IG9mIHRoYXQgcm91dGVcbiAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50Rm9yUm91dGUoIHJvdXRlSXRlbSApO1xufTtcblxuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLmdldENvbnRlbnRGb3JSb3V0ZSA9IGZ1bmN0aW9uKCByb3V0ZUl0ZW0gKSB7XG4gICAgXG4gICAgLy8gQ2hlY2sga2VlcEFsaXZlXG4gICAgaWYgKCByb3V0ZUl0ZW0ua2VlcEFsaXZlICl7XG4gICAgICAgIGxldCBhbGl2ZVBhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggcm91dGVJdGVtLmlkICk7XG4gICAgICAgIGlmICggYWxpdmVQYWdlICl7XG4gICAgICAgICAgICByZXR1cm4gYWxpdmVQYWdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY29udGVudFxuICAgIGxldCBjb250ZW50ID0gcm91dGVJdGVtLmNvbnRlbnQ7XG4gICAgaWYgKCBjb250ZW50ICl7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIC8vIENoZWNrIHVybFxuICAgIGxldCB1cmwgPSByb3V0ZUl0ZW0udXJsO1xuICAgIGlmICggdXJsICl7XG4gICAgICAgIHJldHVybiBibHVlUm91dGVyLmh0bWxGZXRjaGVyLmxvYWRVcmwoIHVybCApO1xuICAgIH1cblxuICAgIHJldHVybiAnPGRpdiBpZD1cImVycm9yXCI+Tm8gY29udGVudCBmb3VuZCBmb3Igcm91dGUgZnJvbSBwYXRoICcgKyByb3V0ZUl0ZW0uaWQgKyAnPC9kaXY+Jztcbn07XG5cbi8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLmRvUGFnZVRyYW5zaXRpb24gPSBmdW5jdGlvbiggY29udGVudCwgbmV4dFBhZ2VJZCwgY3VycmVudFBhZ2VJZCwgdXJsT2JqZWN0LCBtdXN0QW5pbWF0ZUJ5Q29kZSApIHtcblxuICAgIC8vIEdldCBtdXN0QW5pbWF0ZU91dCBhbmQgbXVzdEFuaW1hdGVJblxuICAgIGNvbnN0IG11c3RBbmltYXRlT3V0ID0gbXVzdEFuaW1hdGVCeUNvZGUgJiYgISF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0O1xuICAgIGNvbnN0IG11c3RBbmltYXRlSW4gPSBtdXN0QW5pbWF0ZUJ5Q29kZSAmJiAhIXRoaXMub3B0aW9ucy5hbmltYXRpb25JbjtcblxuICAgIC8vIEdldCB0aGUgaW5pdEV2ZW50XG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50PyBibHVlUm91dGVyLmRlZmF1bHRPcHRpb25zLkVWRU5UX1JFSU5JVDogYmx1ZVJvdXRlci5kZWZhdWx0T3B0aW9ucy5FVkVOVF9JTklUO1xuXG4gICAgLy8gUnVuIGV2ZW50c1xuICAgIHRoaXMucnVuRXZlbnQoIGJsdWVSb3V0ZXIuZGVmYXVsdE9wdGlvbnMuRVZFTlRfQkVGT1JFX09VVCwgY3VycmVudFBhZ2VJZCwge30gKTtcblxuICAgIC8vIEdldCB0aGUgY3VycmVudFBhZ2UgYW5kIGFkZCBuZXh0IHBhZ2VcbiAgICBsZXQgY3VycmVudFBhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCAnY3VycmVudFBhZ2UnIClbMF07XG4gICAgbGV0IG5ld1BhZ2UgPSB0aGlzLmFkZE5leHRQYWdlKCBjdXJyZW50UGFnZSwgY29udGVudCwgbmV4dFBhZ2VJZCApO1xuXG4gICAgLy8gUmVuZGVyIG5leHQgcGFnZVxuICAgIHRoaXMucnVuUmVuZGVyUmVsYXRlZCggaW5pdEV2ZW50LCBuZXh0UGFnZUlkLCB1cmxPYmplY3QgKTtcblxuICAgIC8vIERlZmluZSBjdXJyZW50UGFnZUFuaW1hdGlvbmVuZExpc3RlbmVyIGFuZCBuZXdQYWdlQW5pbWF0aW9uZW5kTGlzdGVuZXJcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGN1cnJlbnRQYWdlQW5pbWF0aW9uZW5kTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnRQYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdhbmltYXRpb25lbmQnLCBjdXJyZW50UGFnZUFuaW1hdGlvbmVuZExpc3RlbmVyICk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgaGlkZGVuIGNsYXNzLCBhZGQgYW5pbWF0aW9uSW4gY2xhc3NcbiAgICAgICAgbmV3UGFnZS5jbGFzc0xpc3QucmVtb3ZlKCAnaGlkZGVuJyApO1xuICAgICAgICBpZiAoIG11c3RBbmltYXRlSW4gKXtcbiAgICAgICAgICAgIG5ld1BhZ2UuY2xhc3NMaXN0LmFkZCggdGhpcy5vcHRpb25zLmFuaW1hdGlvbkluICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRpcmUgY3VycmVudCBwYWdlOiBzYXZlIGl0IGFzIGFuIGFsaXZlIHBhZ2Ugb3IgcmVtb3ZlIGl0XG4gICAgICAgIHRoaXMucmV0aXJlQ3VycmVudFBhZ2UoIGN1cnJlbnRQYWdlSWQsIGN1cnJlbnRQYWdlICk7XG4gICAgICAgIHNlbGYucnVuRXZlbnQoIGJsdWVSb3V0ZXIuZGVmYXVsdE9wdGlvbnMuRVZFTlRfQUZURVJfT1VULCBjdXJyZW50UGFnZUlkLCB7fSApO1xuXG4gICAgICAgIC8vICBSdW4gbmV3UGFnZUFuaW1hdGlvbmVuZExpc3RlbmVyIGlmIGxpc3RlbmVyIG9mIGFtaW1hdGlvbmVuZCBvbiBuZXdQYWdlIHdhcyBub3QgYWRkZWRcbiAgICAgICAgaWYgKCAhIG11c3RBbmltYXRlSW4gKSB7XG4gICAgICAgICAgICBuZXdQYWdlQW5pbWF0aW9uZW5kTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgbmV3UGFnZUFuaW1hdGlvbmVuZExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBuZXdQYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdhbmltYXRpb25lbmQnLCBuZXdQYWdlQW5pbWF0aW9uZW5kTGlzdGVuZXIgKTtcblxuICAgICAgICAvLyBSZW1vdmUgbmV4dFBhZ2UgY2xhc3MsIGFkZCBjdXJyZW50UGFnZSBjbGFzcywgcmVtb3ZlIGFuaW1hdGlvbkluIGNsYXNzXG4gICAgICAgIG5ld1BhZ2UuY2xhc3NMaXN0LnJlbW92ZSggJ25leHRQYWdlJyApO1xuICAgICAgICBuZXdQYWdlLmNsYXNzTGlzdC5hZGQoICdjdXJyZW50UGFnZScgKTtcbiAgICAgICAgaWYgKCBtdXN0QW5pbWF0ZUluICl7XG4gICAgICAgICAgICBuZXdQYWdlLmNsYXNzTGlzdC5yZW1vdmUoIHRoaXMub3B0aW9ucy5hbmltYXRpb25JbiApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVuIEVWRU5UX0lOSVQgb3IgRVZFTlRfUkVJTklUXG4gICAgICAgIHNlbGYucnVuRXZlbnQoIGluaXRFdmVudCwgbmV4dFBhZ2VJZCwgdXJsT2JqZWN0ICk7XG5cbiAgICAgICAgLy8gUnVuIEVWRU5UX01PVU5URURcbiAgICAgICAgc2VsZi5ydW5FdmVudCggYmx1ZVJvdXRlci5kZWZhdWx0T3B0aW9ucy5FVkVOVF9NT1VOVEVELCBuZXh0UGFnZUlkLCB1cmxPYmplY3QgKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmICggbXVzdEFuaW1hdGVPdXQgKXtcbiAgICAgICAgY3VycmVudFBhZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2FuaW1hdGlvbmVuZCcsIGN1cnJlbnRQYWdlQW5pbWF0aW9uZW5kTGlzdGVuZXIgKTtcbiAgICB9XG4gICAgaWYgKCBtdXN0QW5pbWF0ZUluICl7XG4gICAgICAgIG5ld1BhZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2FuaW1hdGlvbmVuZCcsIG5ld1BhZ2VBbmltYXRpb25lbmRMaXN0ZW5lciApO1xuICAgIH1cblxuICAgIC8vIEFuaW1hdGUhXG4gICAgaWYgKCBtdXN0QW5pbWF0ZU91dCApe1xuICAgICAgICBjdXJyZW50UGFnZS5jbGFzc0xpc3QuYWRkKCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBhZ2VBbmltYXRpb25lbmRMaXN0ZW5lcigpO1xuICAgIH1cbn07XG5cbi8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xuYmx1ZVJvdXRlci5yb3V0ZXIucHJvdG90eXBlLnJ1blJlbmRlclJlbGF0ZWQgPSBmdW5jdGlvbiggaW5pdEV2ZW50LCBuZXh0UGFnZUlkLCB1cmxPYmplY3QgKXtcblxuICAgIC8vIFJ1biBwcmVFdmVudCAoRVZFTlRfUFJFX0lOSVQgb3IgRVZFTlRfUFJFX1JFSU5JVClcbiAgICBjb25zdCBwcmVFdmVudCA9IGluaXRFdmVudCA9PT0gIHRoaXMub3B0aW9ucy5FVkVOVF9JTklUP1xuICAgICAgICB0aGlzLm9wdGlvbnMuRVZFTlRfUFJFX0lOSVQ6XG4gICAgICAgIHRoaXMub3B0aW9ucy5FVkVOVF9QUkVfUkVJTklUXG5cbiAgICB0aGlzLnJ1bkV2ZW50KCBwcmVFdmVudCwgbmV4dFBhZ2VJZCwgdXJsT2JqZWN0ICk7XG5cbiAgICAvLyBSdW4gcmVuZGVyIGlmIG5lZWRlZFxuICAgIGNvbnN0IHJvdXRlSXRlbSA9IHRoaXMuZ2V0Um91dGVJdGVtKCBuZXh0UGFnZUlkICk7XG4gICAgY29uc3QgcmVuZGVyT3B0aW9uID0gaW5pdEV2ZW50ID09PSAgdGhpcy5vcHRpb25zLkVWRU5UX0lOSVQ/XG4gICAgICAgIHRoaXMub3B0aW9ucy5SVU5fUkVOREVSX0JFRk9SRV9FVkVOVF9JTklUOlxuICAgICAgICB0aGlzLm9wdGlvbnMuUlVOX1JFTkRFUl9CRUZPUkVfRVZFTlRfUkVJTklUO1xuICAgIGNvbnN0IHJvdXRlUHJvcGVydHkgPSBpbml0RXZlbnQgPT09ICB0aGlzLm9wdGlvbnMuRVZFTlRfSU5JVD9cbiAgICAgICAgJ3J1blJlbmRlckJlZm9yZUluaXQnOlxuICAgICAgICAncnVuUmVuZGVyQmVmb3JlUmVpbml0JztcbiAgICBjb25zdCBtdXN0UnVuUmVuZGVyID0gcm91dGVJdGVtWyByb3V0ZVByb3BlcnR5IF0gPT09IHVuZGVmaW5lZD9cbiAgICAgICAgcmVuZGVyT3B0aW9uOlxuICAgICAgICByb3V0ZUl0ZW1bIHJvdXRlUHJvcGVydHkgXTtcblxuICAgIGlmICggbXVzdFJ1blJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyRnVuY3Rpb24gJiYgYmx1ZVJvdXRlci51dGlscy5pc0Z1bmN0aW9uKCB0aGlzLm9wdGlvbnMucmVuZGVyRnVuY3Rpb24gKSApe1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyRnVuY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUGFnZUluc3RhbmNlKCBuZXh0UGFnZUlkIClcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5ibHVlUm91dGVyLnJvdXRlci5wcm90b3R5cGUuYnVpbGRQYWdlSW5zdGFuY2UgPSBmdW5jdGlvbiggcGFnZUlkICl7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAgJ2lkJzogcGFnZUlkLFxuICAgICAgICAgJ2VsJzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIHBhZ2VJZCApXG4gICAgfTtcbn07XG5cbmJsdWVSb3V0ZXIucm91dGVyLnByb3RvdHlwZS5hZGROZXh0UGFnZSA9IGZ1bmN0aW9uKCBjdXJyZW50UGFnZSwgY29udGVudCwgbmV4dFBhZ2VJZCApe1xuXG4gICAgaWYgKCBjb250ZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKXtcbiAgICAgICAgLy8gY29udGVudCBpcyBIVE1MRWxlbWVudFxuICAgICAgICBjdXJyZW50UGFnZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXG4gICAgICAgICAgICAnYWZ0ZXJlbmQnLFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICApO1xuICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoICduZXh0UGFnZScgKTtcbiAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCAnaGlkZGVuJyApO1xuICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoICdhbGl2ZScgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnRlbnQgbXVzdCBiZSB0ZXh0XG4gICAgICAgIGN1cnJlbnRQYWdlLmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgICAgICdhZnRlcmVuZCcsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cIm5leHRQYWdlIGhpZGRlbiBwYWdlXCIgaWQ9XCInICsgbmV4dFBhZ2VJZCArICdcIj4nXG4gICAgICAgICAgICArIGNvbnRlbnRcbiAgICAgICAgICAgICsgJzwvZGl2PidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG5leHRQYWdlSWQgKTtcbn07XG5cbi8vIFJldGlyZSBjdXJyZW50IHBhZ2U6IHNhdmUgaXQgYXMgYW4gYWxpdmUgcGFnZSBvciByZW1vdmUgaXRcbmJsdWVSb3V0ZXIucm91dGVyLnByb3RvdHlwZS5yZXRpcmVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uKCBjdXJyZW50UGFnZUlkLCBjdXJyZW50UGFnZSApe1xuXG4gICAgbGV0IGN1cnJlbnRSb3V0ZSA9IHRoaXMuZ2V0Um91dGVJdGVtKCBjdXJyZW50UGFnZUlkICk7XG5cbiAgICAvLyBJZiBtdXN0IGtlZXAgYWxpdmUgY3VycmVudCBwYWdlLCBzZXQgcGFnZSBhbmQgYWxpdmUgYXMgY2xhc3NlcyByZW1vdmluZyB0aGUgcmVzdFxuICAgIGlmICggY3VycmVudFJvdXRlICYmIGN1cnJlbnRSb3V0ZS5rZWVwQWxpdmUpe1xuICAgICAgICBjdXJyZW50UGFnZS5yZW1vdmVBdHRyaWJ1dGUoICdjbGFzcycgKTtcbiAgICAgICAgY3VycmVudFBhZ2UuY2xhc3NMaXN0LmFkZCggJ3BhZ2UnICk7XG4gICAgICAgIGN1cnJlbnRQYWdlLmNsYXNzTGlzdC5hZGQoICdhbGl2ZScgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBrZWVwIGFsaXZlIGN1cnJlbnQgcGFnZSwgc28gcmVtb3ZlIGl0XG4gICAgY3VycmVudFBhZ2UucmVtb3ZlKCk7XG59O1xuXG5ibHVlUm91dGVyLnJvdXRlci5wcm90b3R5cGUucnVuRXZlbnQgPSBmdW5jdGlvbiggZXZlbnRJZCwgcGFnZUlkLCB1cmxPYmplY3QgKSB7XG5cbiAgICBpZiAoIGV2ZW50SWQgPT0gYmx1ZVJvdXRlci5kZWZhdWx0T3B0aW9ucy5FVkVOVF9JTklUICl7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnNGb3JMaW5rcyggcGFnZUlkICk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBwYWdlIG9iamVjdCBmcm9tIG9wdGlvbnNcbiAgICAvKiogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gKi9cbiAgICBsZXQgcGFnZSA9IHRoaXMub3B0aW9ucy5ldmVudHNCeVBhZ2VbIHBhZ2VJZCBdO1xuXG4gICAgLy8gSWYgYSBwYWdlIGlzIGZvdW5kLCBydW4gdGhlIGV2ZW50IGhhbmRsZXJcbiAgICBpZiAoIHBhZ2UgKXtcbiAgICAgICAgbGV0IGV2ZW50ID0ge1xuICAgICAgICAgICAgcGFyYW1zOiB1cmxPYmplY3QucGFyYW1zIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICggcGFnZVsgZXZlbnRJZCBdICYmIGJsdWVSb3V0ZXIudXRpbHMuaXNGdW5jdGlvbiggcGFnZVsgZXZlbnRJZCBdICkgKXtcbiAgICAgICAgICAgIHBhZ2VbIGV2ZW50SWQgXSggZXZlbnQgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLy8gRGVmYXVsdCBvcHRpb25zXG5cbmJsdWVSb3V0ZXIuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdXBkYXRlT25Mb2FkOiB0cnVlLFxuICAgIHByZWxvYWRQYWdlc09uTG9hZDogZmFsc2UsXG5cbiAgICAvLyBBbmltYXRpb25zXG4gICAgYW5pbWF0aW9uT3V0OiAnc2xpZGUtb3V0LXRvcCcsXG4gICAgLy9hbmltYXRpb25PdXQ6IGZhbHNlLFxuICAgIGFuaW1hdGlvbkluOiAnc2NhbGUtaW4tY2VudGVyJyxcbiAgICAvL2FuaW1hdGlvbkluOiBmYWxzZSxcbiAgICBhbmltYXRlVHJhbnNpdGlvbnNPbkxvYWQ6IGZhbHNlLFxuICAgIFxuICAgIC8vIE1pc2NcbiAgICBQQUdFX1BSRUZJWDogJyEnLFxuXG4gICAgLy8gU3BlY2lhbCBwYWdlcyBpZHNcbiAgICBQQUdFX0lEX0hPTUU6ICdbaG9tZV0nLFxuICAgIFBBR0VfSURfNDA0X0VSUk9SOiAnWzQwNF0nLFxuXG4gICAgLy8gRXZlbnRzXG4gICAgRVZFTlRfUFJFX0lOSVQ6ICdwcmVJbml0JyxcbiAgICBFVkVOVF9JTklUOiAnaW5pdCcsXG4gICAgRVZFTlRfUFJFX1JFSU5JVDogJ3ByZVJlaW5pdCcsXG4gICAgRVZFTlRfUkVJTklUOiAncmVpbml0JyxcbiAgICBFVkVOVF9NT1VOVEVEOiAnbW91bnRlZCcsXG4gICAgRVZFTlRfQkVGT1JFX09VVDogJ2JlZm9yZU91dCcsXG4gICAgRVZFTlRfQUZURVJfT1VUOiAnYWZ0ZXJPdXQnLFxuXG4gICAgUlVOX1JFTkRFUl9CRUZPUkVfRVZFTlRfSU5JVDogdHJ1ZSxcbiAgICBSVU5fUkVOREVSX0JFRk9SRV9FVkVOVF9SRUlOSVQ6IGZhbHNlXG5cbn07XG5cblxuYmx1ZVJvdXRlci5odG1sRmV0Y2hlciA9IHt9O1xuXG5ibHVlUm91dGVyLmh0bWxGZXRjaGVyLmxvYWRBbGxVcmxzID0gZnVuY3Rpb24oIHJvdXRlciwgY2FsbGJhY2sgKXtcblxuICAgIC8vIEdldCB0aGUgcm91dGVzIHRvIHVzZVxuICAgIGNvbnN0IHJvdXRlcyA9IHJvdXRlci5vcHRpb25zLnJvdXRlcyB8fCBbXTtcblxuICAgIC8vIEluaXQgdGhlIG51bWJlciBvdCB1cmxzIHRvIGdldFxuICAgIGxldCBwZW5kaW5nID0gMDtcblxuICAgIC8vIEl0ZXJhdGUgdXJsUm91dGVzIGFuZCBsb2FkIGVhY2ggcm91dGVJdGVtIGlmIG5lZWRlZFxuICAgIHJvdXRlcy5tYXAoIHJvdXRlSXRlbSA9PiB7XG4gICAgICAgIGxldCB1cmwgPSByb3V0ZUl0ZW0udXJsO1xuICAgICAgICBpZiAoIHVybCApe1xuICAgICAgICAgICAgKytwZW5kaW5nO1xuICAgICAgICAgICAgYmx1ZVJvdXRlci5odG1sRmV0Y2hlci5sb2FkVXJsKCB1cmwgKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCB0ZXh0ICl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250ZW50IG9mIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSXRlbS5jb250ZW50ID0gdGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gY2FsbGJhY2sgd2hlbiBhbGwgZmlsZXMgaGF2ZSBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIC0tcGVuZGluZyA9PSAwICYmIGNhbGxiYWNrICYmIGJsdWVSb3V0ZXIudXRpbHMuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogXG4gKi9cbmJsdWVSb3V0ZXIuaHRtbEZldGNoZXIubG9hZFVybCA9IGFzeW5jIGZ1bmN0aW9uKCB1cmwgKXtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goIHVybCApO1xuXG4gICAgaWYgKCAhIHJlc3BvbnNlLm9rICkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEVycm9yIGZldGNoaW5nICR7dXJsfSBoYXMgb2NjdXJlZDogJHtyZXNwb25zZS5zdGF0dXN9YDtcbiAgICAgICAgYWxlcnQgKCBtZXNzYWdlICk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApO1xuICAgIH1cbiAgXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICByZXR1cm4gdGV4dDtcbn07XG5cbmJsdWVSb3V0ZXIudXRpbHMgPSB7fTtcblxuLypcbiAgICBCdWlsZHMgYW4gb2JqZWN0IHdpdGggZGF0YSBhYm91dCB0aGUgdXJsLiBBbiBleGFtcGxlOlxuXG4gICAgdXJsIDogaHR0cDovLzEyNy4wLjAuMTo5MDAwL3NhbXBsZXMvc2FtcGxlLmh0bWwjIWFib3V0P3BhcmFtMT1hJnBhcmFtMj1iXCJcblxuICAgIHByZXBhZ2U6IGh0dHA6Ly8xMjcuMC4wLjE6OTAwMC9zYW1wbGVzL3NhbXBsZS5odG1sXG4gICAgcGFnZTogYWJvdXRcbiAgICBwYXJhbXM6IHtcbiAgICAgICAgcGFyYW0xOiBhXG4gICAgICAgIHBhcmFtMjogYlxuICAgIH1cbiovXG5ibHVlUm91dGVyLnV0aWxzLmFuYWxpemVVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuICAgIFxuICAgIGxldCByZXN1bHQgPSB7fTtcblxuICAgIC8vIEV4dHJhY3QgdGhlIHBhcnRzIGJlZm9yZSBhbmQgYWZ0ZXIgUEFHRV9QUkVGSVhcbiAgICBsZXQgdXJsUGFydHMgPSB1cmwuc3BsaXQoIG9wdGlvbnMuUEFHRV9QUkVGSVggKTtcbiAgICByZXN1bHQucHJlcGFnZSA9IHVybFBhcnRzWyAwIF07XG4gICAgbGV0IHBvc3RQYXRoID0gdXJsUGFydHNbIDEgXSB8fCAnJztcblxuICAgIC8vIFJlbW92ZSAjIGlmIHByZXNlbnRcbiAgICBpZiAoIHJlc3VsdC5wcmVwYWdlLmVuZHNXaXRoKCAnIycgKSApe1xuICAgICAgICByZXN1bHQucHJlcGFnZSA9IHJlc3VsdC5wcmVwYWdlLnNsaWNlKCAwLCAtMSApO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgdGhlIHBhcnRzIGJlZm9yZSBhbmQgYWZ0ZXIgP1xuICAgIGxldCBwYXRoUGFydHMgPSBwb3N0UGF0aC5zcGxpdCggJz8nICk7XG4gICAgcmVzdWx0LnBhZ2UgPSBwYXRoUGFydHNbIDAgXTtcblxuICAgIC8vIEZpeCBob21lIHBhZ2VcbiAgICBpZiAoIHJlc3VsdC5wYWdlID09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5wYWdlID0gb3B0aW9ucy5QQUdFX0lEX0hPTUU7XG4gICAgfVxuXG4gICAgbGV0IHBhcmFtc1N0cmluZyA9IHBhdGhQYXJ0c1sgMSBdIHx8ICcnO1xuXG4gICAgLy8gQWRkIHBhcmFtc1xuICAgIHJlc3VsdC5wYXJhbXMgPSB7fTtcbiAgICBpZiAoIHBhcmFtc1N0cmluZyA9PSAnJyApe1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdmFycyA9IHBhcmFtc1N0cmluZy5zcGxpdCggJyYnICk7XG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgbGV0IHBhaXIgPSB2YXJzWyBpIF0uc3BsaXQoICc9JyApO1xuICAgICAgICBsZXQgcGFyYW1OYW1lID0gcGFpclsgMCBdO1xuICAgICAgICBsZXQgcGFyYW1WYWx1ZSA9IHBhaXJbIDEgXTtcbiAgICAgICAgcmVzdWx0LnBhcmFtc1sgcGFyYW1OYW1lIF0gPSBwYXJhbVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5ibHVlUm91dGVyLnV0aWxzLmFkZEV2ZW50TGlzdGVuZXJPbkxpc3QgPSBmdW5jdGlvbiggbGlzdCwgZXZlbnQsIGZuICkge1xuXG4gICAgZm9yICggbGV0IGkgPSAwLCBsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICBsaXN0WyBpIF0uYWRkRXZlbnRMaXN0ZW5lciggZXZlbnQsIGZuLCBmYWxzZSApO1xuICAgIH1cbn07XG5cbmJsdWVSb3V0ZXIudXRpbHMuZXh0ZW5kID0gZnVuY3Rpb24oIG91dCwgZnJvbTEsIGZyb20yICkge1xuICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgIGZvciAoIHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCAhIGFyZ3VtZW50c1sgaSBdICl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIHZhciBrZXkgaW4gYXJndW1lbnRzWyBpIF0gKSB7XG4gICAgICAgICAgICBpZiAoIGFyZ3VtZW50c1sgaSBdLmhhc093blByb3BlcnR5KCBrZXkgKSApe1xuICAgICAgICAgICAgICAgIG91dFsga2V5IF0gPSBhcmd1bWVudHNbIGkgXVsga2V5IF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyogZm9ybWF0U3RyaW5nICovXG4vLyBFeGFtcGxlOiBpdGlscy5mb3JtYXRTdHJpbmcoICd7MH0gaXMgZGVhZCwgYnV0IHsxfSBpcyBhbGl2ZSEnLCAnQVNQJywgJ0FTUC5ORVQnIClcbi8qKlxuICogVGFrZXMgMSBvciBtb3JlIHN0cmluZ3MgYW5kIGRvIHNvbWV0aGluZyBjb29sIHdpdGggdGhlbS5cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfG51bWJlcn0gZm9ybWF0XG4gKi9cbmJsdWVSb3V0ZXIudXRpbHMuZm9ybWF0U3RyaW5nID0gZnVuY3Rpb24oIGZvcm1hdCApIHtcbiAgICBcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcbiAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoL3soXFxkKyl9L2csIGZ1bmN0aW9uICggbWF0Y2gsIG51bWJlciApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmdzWyBudW1iZXIgXSAhPSAndW5kZWZpbmVkJz8gYXJnc1sgbnVtYmVyIF0gOiBtYXRjaDtcbiAgICB9KTtcbn07XG5cbmJsdWVSb3V0ZXIudXRpbHMuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG59O1xuLyogZW5kIG9mIHV0aWxzICovXG5cbi8vIFJlZ2lzdGVyIGJsdWVSb3V0ZXIgaWYgd2UgYXJlIHVzaW5nIE5vZGVcbmlmICggdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBibHVlUm91dGVyO1xufVxuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5sb2FkanMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4vKipcbiAqIEdsb2JhbCBkZXBlbmRlbmNpZXMuXG4gKiBAZ2xvYmFsIHtPYmplY3R9IGRvY3VtZW50IC0gRE9NXG4gKi9cblxudmFyIGRldm51bGwgPSBmdW5jdGlvbigpIHt9LFxuICAgIGJ1bmRsZUlkQ2FjaGUgPSB7fSxcbiAgICBidW5kbGVSZXN1bHRDYWNoZSA9IHt9LFxuICAgIGJ1bmRsZUNhbGxiYWNrUXVldWUgPSB7fTtcblxuXG4vKipcbiAqIFN1YnNjcmliZSB0byBidW5kbGUgbG9hZCBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGJ1bmRsZUlkcyAtIEJ1bmRsZSBpZHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrRm4gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3Vic2NyaWJlKGJ1bmRsZUlkcywgY2FsbGJhY2tGbikge1xuICAvLyBsaXN0aWZ5XG4gIGJ1bmRsZUlkcyA9IGJ1bmRsZUlkcy5wdXNoID8gYnVuZGxlSWRzIDogW2J1bmRsZUlkc107XG5cbiAgdmFyIGRlcHNOb3RGb3VuZCA9IFtdLFxuICAgICAgaSA9IGJ1bmRsZUlkcy5sZW5ndGgsXG4gICAgICBudW1XYWl0aW5nID0gaSxcbiAgICAgIGZuLFxuICAgICAgYnVuZGxlSWQsXG4gICAgICByLFxuICAgICAgcTtcblxuICAvLyBkZWZpbmUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgZm4gPSBmdW5jdGlvbiAoYnVuZGxlSWQsIHBhdGhzTm90Rm91bmQpIHtcbiAgICBpZiAocGF0aHNOb3RGb3VuZC5sZW5ndGgpIGRlcHNOb3RGb3VuZC5wdXNoKGJ1bmRsZUlkKTtcblxuICAgIG51bVdhaXRpbmctLTtcbiAgICBpZiAoIW51bVdhaXRpbmcpIGNhbGxiYWNrRm4oZGVwc05vdEZvdW5kKTtcbiAgfTtcblxuICAvLyByZWdpc3RlciBjYWxsYmFja1xuICB3aGlsZSAoaS0tKSB7XG4gICAgYnVuZGxlSWQgPSBidW5kbGVJZHNbaV07XG5cbiAgICAvLyBleGVjdXRlIGNhbGxiYWNrIGlmIGluIHJlc3VsdCBjYWNoZVxuICAgIHIgPSBidW5kbGVSZXN1bHRDYWNoZVtidW5kbGVJZF07XG4gICAgaWYgKHIpIHtcbiAgICAgIGZuKGJ1bmRsZUlkLCByKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGFkZCB0byBjYWxsYmFjayBxdWV1ZVxuICAgIHEgPSBidW5kbGVDYWxsYmFja1F1ZXVlW2J1bmRsZUlkXSA9IGJ1bmRsZUNhbGxiYWNrUXVldWVbYnVuZGxlSWRdIHx8IFtdO1xuICAgIHEucHVzaChmbik7XG4gIH1cbn1cblxuXG4vKipcbiAqIFB1Ymxpc2ggYnVuZGxlIGxvYWQgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBCdW5kbGUgaWRcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzTm90Rm91bmQgLSBMaXN0IG9mIGZpbGVzIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBwdWJsaXNoKGJ1bmRsZUlkLCBwYXRoc05vdEZvdW5kKSB7XG4gIC8vIGV4aXQgaWYgaWQgaXNuJ3QgZGVmaW5lZFxuICBpZiAoIWJ1bmRsZUlkKSByZXR1cm47XG5cbiAgdmFyIHEgPSBidW5kbGVDYWxsYmFja1F1ZXVlW2J1bmRsZUlkXTtcblxuICAvLyBjYWNoZSByZXN1bHRcbiAgYnVuZGxlUmVzdWx0Q2FjaGVbYnVuZGxlSWRdID0gcGF0aHNOb3RGb3VuZDtcblxuICAvLyBleGl0IGlmIHF1ZXVlIGlzIGVtcHR5XG4gIGlmICghcSkgcmV0dXJuO1xuXG4gIC8vIGVtcHR5IGNhbGxiYWNrIHF1ZXVlXG4gIHdoaWxlIChxLmxlbmd0aCkge1xuICAgIHFbMF0oYnVuZGxlSWQsIHBhdGhzTm90Rm91bmQpO1xuICAgIHEuc3BsaWNlKDAsIDEpO1xuICB9XG59XG5cblxuLyoqXG4gKiBFeGVjdXRlIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0IG9yIEZ1bmN0aW9ufSBhcmdzIC0gVGhlIGNhbGxiYWNrIGFyZ3NcbiAqIEBwYXJhbSB7c3RyaW5nW119IGRlcHNOb3RGb3VuZCAtIExpc3Qgb2YgZGVwZW5kZW5jaWVzIG5vdCBmb3VuZFxuICovXG5mdW5jdGlvbiBleGVjdXRlQ2FsbGJhY2tzKGFyZ3MsIGRlcHNOb3RGb3VuZCkge1xuICAvLyBhY2NlcHQgZnVuY3Rpb24gYXMgYXJndW1lbnRcbiAgaWYgKGFyZ3MuY2FsbCkgYXJncyA9IHtzdWNjZXNzOiBhcmdzfTtcblxuICAvLyBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3NcbiAgaWYgKGRlcHNOb3RGb3VuZC5sZW5ndGgpIChhcmdzLmVycm9yIHx8IGRldm51bGwpKGRlcHNOb3RGb3VuZCk7XG4gIGVsc2UgKGFyZ3Muc3VjY2VzcyB8fCBkZXZudWxsKShhcmdzKTtcbn1cblxuXG4vKipcbiAqIExvYWQgaW5kaXZpZHVhbCBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgZmlsZSBwYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja0ZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgsIGNhbGxiYWNrRm4sIGFyZ3MsIG51bVRyaWVzKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudCxcbiAgICAgIGFzeW5jID0gYXJncy5hc3luYyxcbiAgICAgIG1heFRyaWVzID0gKGFyZ3MubnVtUmV0cmllcyB8fCAwKSArIDEsXG4gICAgICBiZWZvcmVDYWxsYmFja0ZuID0gYXJncy5iZWZvcmUgfHwgZGV2bnVsbCxcbiAgICAgIHBhdGhuYW1lID0gcGF0aC5yZXBsYWNlKC9bXFw/fCNdLiokLywgJycpLFxuICAgICAgcGF0aFN0cmlwcGVkID0gcGF0aC5yZXBsYWNlKC9eKGNzc3xpbWd8bW9kdWxlfG5vbW9kdWxlKSEvLCAnJyksXG4gICAgICBpc0xlZ2FjeUlFQ3NzLFxuICAgICAgaGFzTW9kdWxlU3VwcG9ydCxcbiAgICAgIGU7XG5cbiAgbnVtVHJpZXMgPSBudW1UcmllcyB8fCAwO1xuXG4gIGlmICgvKF5jc3MhfFxcLmNzcyQpLy50ZXN0KHBhdGhuYW1lKSkge1xuICAgIC8vIGNzc1xuICAgIGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgIGUucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgIGUuaHJlZiA9IHBhdGhTdHJpcHBlZDtcblxuICAgIC8vIHRhZyBJRTkrXG4gICAgaXNMZWdhY3lJRUNzcyA9ICdoaWRlRm9jdXMnIGluIGU7XG5cbiAgICAvLyB1c2UgcHJlbG9hZCBpbiBJRSBFZGdlICh0byBkZXRlY3QgbG9hZCBlcnJvcnMpXG4gICAgaWYgKGlzTGVnYWN5SUVDc3MgJiYgZS5yZWxMaXN0KSB7XG4gICAgICBpc0xlZ2FjeUlFQ3NzID0gMDtcbiAgICAgIGUucmVsID0gJ3ByZWxvYWQnO1xuICAgICAgZS5hcyA9ICdzdHlsZSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKC8oXmltZyF8XFwuKHBuZ3xnaWZ8anBnfHN2Z3x3ZWJwKSQpLy50ZXN0KHBhdGhuYW1lKSkge1xuICAgIC8vIGltYWdlXG4gICAgZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBlLnNyYyA9IHBhdGhTdHJpcHBlZDsgICAgXG4gIH0gZWxzZSB7XG4gICAgLy8gamF2YXNjcmlwdFxuICAgIGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgZS5zcmMgPSBwYXRoU3RyaXBwZWQ7XG4gICAgZS5hc3luYyA9IGFzeW5jID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXN5bmM7XG5cbiAgICAvLyBoYW5kbGUgZXMgbW9kdWxlc1xuICAgIC8vIG1vZGVybiBicm93c2VyczpcbiAgICAvLyAgIG1vZHVsZTogYWRkIHRvIGRvbSB3aXRoIHR5cGU9XCJtb2R1bGVcIlxuICAgIC8vICAgbm9tb2R1bGU6IGNhbGwgc3VjY2VzcygpIGNhbGxiYWNrIHdpdGhvdXQgYWRkaW5nIHRvIGRvbVxuICAgIC8vIGxlZ2FjeSBicm93c2VyczpcbiAgICAvLyAgIG1vZHVsZTogY2FsbCBzdWNjZXNzKCkgY2FsbGJhY2sgd2l0aG91dCBhZGRpbmcgdG8gZG9tXG4gICAgLy8gICBub21vZHVsZTogYWRkIHRvIGRvbSB3aXRoIGRlZmF1bHQgdHlwZSAoXCJ0ZXh0L2phdmFzY3JpcHRcIilcbiAgICBoYXNNb2R1bGVTdXBwb3J0ID0gJ25vTW9kdWxlJyBpbiBlO1xuICAgIGlmICgvXm1vZHVsZSEvLnRlc3QocGF0aG5hbWUpKSB7XG4gICAgICBpZiAoIWhhc01vZHVsZVN1cHBvcnQpIHJldHVybiBjYWxsYmFja0ZuKHBhdGgsICdsJyk7XG4gICAgICBlLnR5cGUgPSBcIm1vZHVsZVwiO1xuICAgIH0gZWxzZSBpZiAoL15ub21vZHVsZSEvLnRlc3QocGF0aG5hbWUpICYmIGhhc01vZHVsZVN1cHBvcnQpIHJldHVybiBjYWxsYmFja0ZuKHBhdGgsICdsJyk7XG4gIH1cblxuICBlLm9ubG9hZCA9IGUub25lcnJvciA9IGUub25iZWZvcmVsb2FkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIHJlc3VsdCA9IGV2LnR5cGVbMF07XG5cbiAgICAvLyB0cmVhdCBlbXB0eSBzdHlsZXNoZWV0cyBhcyBmYWlsdXJlcyB0byBnZXQgYXJvdW5kIGxhY2sgb2Ygb25lcnJvclxuICAgIC8vIHN1cHBvcnQgaW4gSUU5LTExXG4gICAgaWYgKGlzTGVnYWN5SUVDc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZS5zaGVldC5jc3NUZXh0Lmxlbmd0aCkgcmVzdWx0ID0gJ2UnO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBzaGVldHMgb2JqZWN0cyBjcmVhdGVkIGZyb20gbG9hZCBlcnJvcnMgZG9uJ3QgYWxsb3cgYWNjZXNzIHRvXG4gICAgICAgIC8vIGBjc3NUZXh0YCAodW5sZXNzIGVycm9yIGlzIENvZGU6MTggU2VjdXJpdHlFcnJvcilcbiAgICAgICAgaWYgKHguY29kZSAhPSAxOCkgcmVzdWx0ID0gJ2UnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZXRyaWVzIGluIGNhc2Ugb2YgbG9hZCBmYWlsdXJlXG4gICAgaWYgKHJlc3VsdCA9PSAnZScpIHtcbiAgICAgIC8vIGluY3JlbWVudCBjb3VudGVyXG4gICAgICBudW1UcmllcyArPSAxO1xuXG4gICAgICAvLyBleGl0IGZ1bmN0aW9uIGFuZCB0cnkgYWdhaW5cbiAgICAgIGlmIChudW1UcmllcyA8IG1heFRyaWVzKSB7XG4gICAgICAgIHJldHVybiBsb2FkRmlsZShwYXRoLCBjYWxsYmFja0ZuLCBhcmdzLCBudW1Ucmllcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnJlbCA9PSAncHJlbG9hZCcgJiYgZS5hcyA9PSAnc3R5bGUnKSB7XG4gICAgICAvLyBhY3RpdmF0ZSBwcmVsb2FkZWQgc3R5bGVzaGVldHNcbiAgICAgIHJldHVybiBlLnJlbCA9ICdzdHlsZXNoZWV0JzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgfVxuICAgIFxuICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICBjYWxsYmFja0ZuKHBhdGgsIHJlc3VsdCwgZXYuZGVmYXVsdFByZXZlbnRlZCk7XG4gIH07XG5cbiAgLy8gYWRkIHRvIGRvY3VtZW50ICh1bmxlc3MgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgKVxuICBpZiAoYmVmb3JlQ2FsbGJhY2tGbihwYXRoLCBlKSAhPT0gZmFsc2UpIGRvYy5oZWFkLmFwcGVuZENoaWxkKGUpO1xufVxuXG5cbi8qKlxuICogTG9hZCBtdWx0aXBsZSBmaWxlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIC0gVGhlIGZpbGUgcGF0aHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrRm4gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gbG9hZEZpbGVzKHBhdGhzLCBjYWxsYmFja0ZuLCBhcmdzKSB7XG4gIC8vIGxpc3RpZnkgcGF0aHNcbiAgcGF0aHMgPSBwYXRocy5wdXNoID8gcGF0aHMgOiBbcGF0aHNdO1xuXG4gIHZhciBudW1XYWl0aW5nID0gcGF0aHMubGVuZ3RoLFxuICAgICAgeCA9IG51bVdhaXRpbmcsXG4gICAgICBwYXRoc05vdEZvdW5kID0gW10sXG4gICAgICBmbixcbiAgICAgIGk7XG5cbiAgLy8gZGVmaW5lIGNhbGxiYWNrIGZ1bmN0aW9uXG4gIGZuID0gZnVuY3Rpb24ocGF0aCwgcmVzdWx0LCBkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgLy8gaGFuZGxlIGVycm9yXG4gICAgaWYgKHJlc3VsdCA9PSAnZScpIHBhdGhzTm90Rm91bmQucHVzaChwYXRoKTtcblxuICAgIC8vIGhhbmRsZSBiZWZvcmVsb2FkIGV2ZW50LiBJZiBkZWZhdWx0UHJldmVudGVkIHRoZW4gdGhhdCBtZWFucyB0aGUgbG9hZFxuICAgIC8vIHdpbGwgYmUgYmxvY2tlZCAoZXguIEdob3N0ZXJ5L0FCUCBvbiBTYWZhcmkpXG4gICAgaWYgKHJlc3VsdCA9PSAnYicpIHtcbiAgICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSBwYXRoc05vdEZvdW5kLnB1c2gocGF0aCk7XG4gICAgICBlbHNlIHJldHVybjtcbiAgICB9XG5cbiAgICBudW1XYWl0aW5nLS07XG4gICAgaWYgKCFudW1XYWl0aW5nKSBjYWxsYmFja0ZuKHBhdGhzTm90Rm91bmQpO1xuICB9O1xuXG4gIC8vIGxvYWQgc2NyaXB0c1xuICBmb3IgKGk9MDsgaSA8IHg7IGkrKykgbG9hZEZpbGUocGF0aHNbaV0sIGZuLCBhcmdzKTtcbn1cblxuXG4vKipcbiAqIEluaXRpYXRlIHNjcmlwdCBsb2FkIGFuZCByZWdpc3RlciBidW5kbGUuXG4gKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBwYXRocyAtIFRoZSBmaWxlIHBhdGhzXG4gKiBAcGFyYW0geyhzdHJpbmd8RnVuY3Rpb258T2JqZWN0KX0gW2FyZzFdIC0gVGhlICgxKSBidW5kbGVJZCBvciAoMikgc3VjY2Vzc1xuICogICBjYWxsYmFjayBvciAoMykgb2JqZWN0IGxpdGVyYWwgd2l0aCBzdWNjZXNzL2Vycm9yIGFyZ3VtZW50cywgbnVtUmV0cmllcyxcbiAqICAgZXRjLlxuICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gW2FyZzJdIC0gVGhlICgxKSBzdWNjZXNzIGNhbGxiYWNrIG9yICgyKSBvYmplY3RcbiAqICAgbGl0ZXJhbCB3aXRoIHN1Y2Nlc3MvZXJyb3IgYXJndW1lbnRzLCBudW1SZXRyaWVzLCBldGMuXG4gKi9cbmZ1bmN0aW9uIGxvYWRqcyhwYXRocywgYXJnMSwgYXJnMikge1xuICB2YXIgYnVuZGxlSWQsXG4gICAgICBhcmdzO1xuXG4gIC8vIGJ1bmRsZUlkIChpZiBzdHJpbmcpXG4gIGlmIChhcmcxICYmIGFyZzEudHJpbSkgYnVuZGxlSWQgPSBhcmcxO1xuXG4gIC8vIGFyZ3MgKGRlZmF1bHQgaXMge30pXG4gIGFyZ3MgPSAoYnVuZGxlSWQgPyBhcmcyIDogYXJnMSkgfHwge307XG5cbiAgLy8gdGhyb3cgZXJyb3IgaWYgYnVuZGxlIGlzIGFscmVhZHkgZGVmaW5lZFxuICBpZiAoYnVuZGxlSWQpIHtcbiAgICBpZiAoYnVuZGxlSWQgaW4gYnVuZGxlSWRDYWNoZSkge1xuICAgICAgdGhyb3cgXCJMb2FkSlNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVuZGxlSWRDYWNoZVtidW5kbGVJZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRGbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsb2FkRmlsZXMocGF0aHMsIGZ1bmN0aW9uIChwYXRoc05vdEZvdW5kKSB7XG4gICAgICAvLyBleGVjdXRlIGNhbGxiYWNrc1xuICAgICAgZXhlY3V0ZUNhbGxiYWNrcyhhcmdzLCBwYXRoc05vdEZvdW5kKTtcbiAgICAgIFxuICAgICAgLy8gcmVzb2x2ZSBQcm9taXNlXG4gICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICBleGVjdXRlQ2FsbGJhY2tzKHtzdWNjZXNzOiByZXNvbHZlLCBlcnJvcjogcmVqZWN0fSwgcGF0aHNOb3RGb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHB1Ymxpc2ggYnVuZGxlIGxvYWQgZXZlbnRcbiAgICAgIHB1Ymxpc2goYnVuZGxlSWQsIHBhdGhzTm90Rm91bmQpO1xuICAgIH0sIGFyZ3MpO1xuICB9XG4gIFxuICBpZiAoYXJncy5yZXR1cm5Qcm9taXNlKSByZXR1cm4gbmV3IFByb21pc2UobG9hZEZuKTtcbiAgZWxzZSBsb2FkRm4oKTtcbn1cblxuXG4vKipcbiAqIEV4ZWN1dGUgY2FsbGJhY2tzIHdoZW4gZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiBzYXRpc2ZpZWQuXG4gKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBkZXBzIC0gTGlzdCBvZiBidW5kbGUgaWRzXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIHN1Y2Nlc3MvZXJyb3IgYXJndW1lbnRzXG4gKi9cbmxvYWRqcy5yZWFkeSA9IGZ1bmN0aW9uIHJlYWR5KGRlcHMsIGFyZ3MpIHtcbiAgLy8gc3Vic2NyaWJlIHRvIGJ1bmRsZSBsb2FkIGV2ZW50XG4gIHN1YnNjcmliZShkZXBzLCBmdW5jdGlvbiAoZGVwc05vdEZvdW5kKSB7XG4gICAgLy8gZXhlY3V0ZSBjYWxsYmFja3NcbiAgICBleGVjdXRlQ2FsbGJhY2tzKGFyZ3MsIGRlcHNOb3RGb3VuZCk7XG4gIH0pO1xuXG4gIHJldHVybiBsb2FkanM7XG59O1xuXG5cbi8qKlxuICogTWFudWFsbHkgc2F0aXNmeSBidW5kbGUgZGVwZW5kZW5jaWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGJ1bmRsZUlkIC0gVGhlIGJ1bmRsZSBpZFxuICovXG5sb2FkanMuZG9uZSA9IGZ1bmN0aW9uIGRvbmUoYnVuZGxlSWQpIHtcbiAgcHVibGlzaChidW5kbGVJZCwgW10pO1xufTtcblxuXG4vKipcbiAqIFJlc2V0IGxvYWRqcyBkZXBlbmRlbmNpZXMgc3RhdHVzZXNcbiAqL1xubG9hZGpzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGJ1bmRsZUlkQ2FjaGUgPSB7fTtcbiAgYnVuZGxlUmVzdWx0Q2FjaGUgPSB7fTtcbiAgYnVuZGxlQ2FsbGJhY2tRdWV1ZSA9IHt9O1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiBidW5kbGUgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkXG4gKiBAcGFyYW0gU3RyaW5nfSBidW5kbGVJZCAtIFRoZSBidW5kbGUgaWRcbiAqL1xubG9hZGpzLmlzRGVmaW5lZCA9IGZ1bmN0aW9uIGlzRGVmaW5lZChidW5kbGVJZCkge1xuICByZXR1cm4gYnVuZGxlSWQgaW4gYnVuZGxlSWRDYWNoZTtcbn07XG5cblxuLy8gZXhwb3J0XG5yZXR1cm4gbG9hZGpzO1xuXG59KSk7XG4iLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTUgVGltIERvd24uXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG5cclxuKGZ1bmN0aW9uKGZhY3Rvcnkscm9vdCl7aWYodHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoZmFjdG9yeSk7fWVsc2UgaWYodHlwZW9mIG1vZHVsZSE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGV4cG9ydHM9PVwib2JqZWN0XCIpe21vZHVsZS5leHBvcnRzPWZhY3RvcnkoKTt9ZWxzZXtyb290LmxvZzRqYXZhc2NyaXB0PWZhY3RvcnkoKTt9fSkoZnVuY3Rpb24oKXtpZighQXJyYXkucHJvdG90eXBlLnB1c2gpe0FycmF5LnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciBpPTAsbGVuPWFyZ3VtZW50cy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzW3RoaXMubGVuZ3RoXT1hcmd1bWVudHNbaV07fVxyXG5yZXR1cm4gdGhpcy5sZW5ndGg7fTt9XHJcbmlmKCFBcnJheS5wcm90b3R5cGUuc2hpZnQpe0FycmF5LnByb3RvdHlwZS5zaGlmdD1mdW5jdGlvbigpe2lmKHRoaXMubGVuZ3RoPjApe3ZhciBmaXJzdEl0ZW09dGhpc1swXTtmb3IodmFyIGk9MCxsZW49dGhpcy5sZW5ndGgtMTtpPGxlbjtpKyspe3RoaXNbaV09dGhpc1tpKzFdO31cclxudGhpcy5sZW5ndGg9dGhpcy5sZW5ndGgtMTtyZXR1cm4gZmlyc3RJdGVtO319O31cclxuaWYoIUFycmF5LnByb3RvdHlwZS5zcGxpY2Upe0FycmF5LnByb3RvdHlwZS5zcGxpY2U9ZnVuY3Rpb24oc3RhcnRJbmRleCxkZWxldGVDb3VudCl7dmFyIGl0ZW1zQWZ0ZXJEZWxldGVkPXRoaXMuc2xpY2Uoc3RhcnRJbmRleCtkZWxldGVDb3VudCk7dmFyIGl0ZW1zRGVsZXRlZD10aGlzLnNsaWNlKHN0YXJ0SW5kZXgsc3RhcnRJbmRleCtkZWxldGVDb3VudCk7dGhpcy5sZW5ndGg9c3RhcnRJbmRleDt2YXIgYXJndW1lbnRzQXJyYXk9W107Zm9yKHZhciBpPTAsbGVuPWFyZ3VtZW50cy5sZW5ndGg7aTxsZW47aSsrKXthcmd1bWVudHNBcnJheVtpXT1hcmd1bWVudHNbaV07fVxyXG52YXIgaXRlbXNUb0FwcGVuZD0oYXJndW1lbnRzQXJyYXkubGVuZ3RoPjIpP2l0ZW1zQWZ0ZXJEZWxldGVkPWFyZ3VtZW50c0FycmF5LnNsaWNlKDIpLmNvbmNhdChpdGVtc0FmdGVyRGVsZXRlZCk6aXRlbXNBZnRlckRlbGV0ZWQ7Zm9yKGk9MCxsZW49aXRlbXNUb0FwcGVuZC5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLnB1c2goaXRlbXNUb0FwcGVuZFtpXSk7fVxyXG5yZXR1cm4gaXRlbXNEZWxldGVkO307fVxyXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmope3JldHVybiB0eXBlb2Ygb2JqPT1cInVuZGVmaW5lZFwiO31cclxuZnVuY3Rpb24gRXZlbnRTdXBwb3J0KCl7fVxyXG5FdmVudFN1cHBvcnQucHJvdG90eXBlPXtldmVudFR5cGVzOltdLGV2ZW50TGlzdGVuZXJzOnt9LHNldEV2ZW50VHlwZXM6ZnVuY3Rpb24oZXZlbnRUeXBlc1BhcmFtKXtpZihldmVudFR5cGVzUGFyYW0gaW5zdGFuY2VvZiBBcnJheSl7dGhpcy5ldmVudFR5cGVzPWV2ZW50VHlwZXNQYXJhbTt0aGlzLmV2ZW50TGlzdGVuZXJzPXt9O2Zvcih2YXIgaT0wLGxlbj10aGlzLmV2ZW50VHlwZXMubGVuZ3RoO2k8bGVuO2krKyl7dGhpcy5ldmVudExpc3RlbmVyc1t0aGlzLmV2ZW50VHlwZXNbaV1dPVtdO319ZWxzZXtoYW5kbGVFcnJvcihcImxvZzRqYXZhc2NyaXB0LkV2ZW50U3VwcG9ydCBbXCIrdGhpcytcIl06IHNldEV2ZW50VHlwZXM6IGV2ZW50VHlwZXMgcGFyYW1ldGVyIG11c3QgYmUgYW4gQXJyYXlcIik7fX0sYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihldmVudFR5cGUsbGlzdGVuZXIpe2lmKHR5cGVvZiBsaXN0ZW5lcj09XCJmdW5jdGlvblwiKXtpZighYXJyYXlfY29udGFpbnModGhpcy5ldmVudFR5cGVzLGV2ZW50VHlwZSkpe2hhbmRsZUVycm9yKFwibG9nNGphdmFzY3JpcHQuRXZlbnRTdXBwb3J0IFtcIit0aGlzK1wiXTogYWRkRXZlbnRMaXN0ZW5lcjogbm8gZXZlbnQgY2FsbGVkICdcIitldmVudFR5cGUrXCInXCIpO31cclxudGhpcy5ldmVudExpc3RlbmVyc1tldmVudFR5cGVdLnB1c2gobGlzdGVuZXIpO31lbHNle2hhbmRsZUVycm9yKFwibG9nNGphdmFzY3JpcHQuRXZlbnRTdXBwb3J0IFtcIit0aGlzK1wiXTogYWRkRXZlbnRMaXN0ZW5lcjogbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO319LHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oZXZlbnRUeXBlLGxpc3RlbmVyKXtpZih0eXBlb2YgbGlzdGVuZXI9PVwiZnVuY3Rpb25cIil7aWYoIWFycmF5X2NvbnRhaW5zKHRoaXMuZXZlbnRUeXBlcyxldmVudFR5cGUpKXtoYW5kbGVFcnJvcihcImxvZzRqYXZhc2NyaXB0LkV2ZW50U3VwcG9ydCBbXCIrdGhpcytcIl06IHJlbW92ZUV2ZW50TGlzdGVuZXI6IG5vIGV2ZW50IGNhbGxlZCAnXCIrZXZlbnRUeXBlK1wiJ1wiKTt9XHJcbmFycmF5X3JlbW92ZSh0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50VHlwZV0sbGlzdGVuZXIpO31lbHNle2hhbmRsZUVycm9yKFwibG9nNGphdmFzY3JpcHQuRXZlbnRTdXBwb3J0IFtcIit0aGlzK1wiXTogcmVtb3ZlRXZlbnRMaXN0ZW5lcjogbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO319LGRpc3BhdGNoRXZlbnQ6ZnVuY3Rpb24oZXZlbnRUeXBlLGV2ZW50QXJncyl7aWYoYXJyYXlfY29udGFpbnModGhpcy5ldmVudFR5cGVzLGV2ZW50VHlwZSkpe3ZhciBsaXN0ZW5lcnM9dGhpcy5ldmVudExpc3RlbmVyc1tldmVudFR5cGVdO2Zvcih2YXIgaT0wLGxlbj1saXN0ZW5lcnMubGVuZ3RoO2k8bGVuO2krKyl7bGlzdGVuZXJzW2ldKHRoaXMsZXZlbnRUeXBlLGV2ZW50QXJncyk7fX1lbHNle2hhbmRsZUVycm9yKFwibG9nNGphdmFzY3JpcHQuRXZlbnRTdXBwb3J0IFtcIit0aGlzK1wiXTogZGlzcGF0Y2hFdmVudDogbm8gZXZlbnQgY2FsbGVkICdcIitldmVudFR5cGUrXCInXCIpO319fTt2YXIgYXBwbGljYXRpb25TdGFydERhdGU9bmV3IERhdGUoKTt2YXIgdW5pcXVlSWQ9XCJsb2c0amF2YXNjcmlwdF9cIithcHBsaWNhdGlvblN0YXJ0RGF0ZS5nZXRUaW1lKCkrXCJfXCIrXHJcbk1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDAwMDApO3ZhciBlbXB0eUZ1bmN0aW9uPWZ1bmN0aW9uKCl7fTt2YXIgbmV3TGluZT1cIlxcclxcblwiO3ZhciBwYWdlTG9hZGVkPWZhbHNlO2Z1bmN0aW9uIExvZzRKYXZhU2NyaXB0KCl7fVxyXG5Mb2c0SmF2YVNjcmlwdC5wcm90b3R5cGU9bmV3IEV2ZW50U3VwcG9ydCgpO3ZhciBsb2c0amF2YXNjcmlwdD1uZXcgTG9nNEphdmFTY3JpcHQoKTtsb2c0amF2YXNjcmlwdC52ZXJzaW9uPVwiMS40LjEzXCI7bG9nNGphdmFzY3JpcHQuZWRpdGlvbj1cImxvZzRqYXZhc2NyaXB0XCI7ZnVuY3Rpb24gdG9TdHIob2JqKXtpZihvYmomJm9iai50b1N0cmluZyl7cmV0dXJuIG9iai50b1N0cmluZygpO31lbHNle3JldHVybiBTdHJpbmcob2JqKTt9fVxyXG5mdW5jdGlvbiBnZXRFeGNlcHRpb25NZXNzYWdlKGV4KXtpZihleC5tZXNzYWdlKXtyZXR1cm4gZXgubWVzc2FnZTt9ZWxzZSBpZihleC5kZXNjcmlwdGlvbil7cmV0dXJuIGV4LmRlc2NyaXB0aW9uO31lbHNle3JldHVybiB0b1N0cihleCk7fX1cclxuZnVuY3Rpb24gZ2V0VXJsRmlsZU5hbWUodXJsKXt2YXIgbGFzdFNsYXNoSW5kZXg9TWF0aC5tYXgodXJsLmxhc3RJbmRleE9mKFwiL1wiKSx1cmwubGFzdEluZGV4T2YoXCJcXFxcXCIpKTtyZXR1cm4gdXJsLnN1YnN0cihsYXN0U2xhc2hJbmRleCsxKTt9XHJcbmZ1bmN0aW9uIGdldEV4Y2VwdGlvblN0cmluZ1JlcChleCl7aWYoZXgpe3ZhciBleFN0cj1cIkV4Y2VwdGlvbjogXCIrZ2V0RXhjZXB0aW9uTWVzc2FnZShleCk7dHJ5e2lmKGV4LmxpbmVOdW1iZXIpe2V4U3RyKz1cIiBvbiBsaW5lIG51bWJlciBcIitleC5saW5lTnVtYmVyO31cclxuaWYoZXguZmlsZU5hbWUpe2V4U3RyKz1cIiBpbiBmaWxlIFwiK2dldFVybEZpbGVOYW1lKGV4LmZpbGVOYW1lKTt9fWNhdGNoKGxvY2FsRXgpe2xvZ0xvZy53YXJuKFwiVW5hYmxlIHRvIG9idGFpbiBmaWxlIGFuZCBsaW5lIGluZm9ybWF0aW9uIGZvciBlcnJvclwiKTt9XHJcbmlmKHNob3dTdGFja1RyYWNlcyYmZXguc3RhY2spe2V4U3RyKz1uZXdMaW5lK1wiU3RhY2sgdHJhY2U6XCIrbmV3TGluZStleC5zdGFjazt9XHJcbnJldHVybiBleFN0cjt9XHJcbnJldHVybiBudWxsO31cclxuZnVuY3Rpb24gYm9vbChvYmope3JldHVybiBCb29sZWFuKG9iaik7fVxyXG5mdW5jdGlvbiB0cmltKHN0cil7cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sXCJcIikucmVwbGFjZSgvXFxzKyQvLFwiXCIpO31cclxuZnVuY3Rpb24gc3BsaXRJbnRvTGluZXModGV4dCl7dmFyIHRleHQyPXRleHQucmVwbGFjZSgvXFxyXFxuL2csXCJcXG5cIikucmVwbGFjZSgvXFxyL2csXCJcXG5cIik7cmV0dXJuIHRleHQyLnNwbGl0KFwiXFxuXCIpO31cclxudmFyIHVybEVuY29kZT0odHlwZW9mIHdpbmRvdy5lbmNvZGVVUklDb21wb25lbnQhPVwidW5kZWZpbmVkXCIpP2Z1bmN0aW9uKHN0cil7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpO306ZnVuY3Rpb24oc3RyKXtyZXR1cm4gZXNjYXBlKHN0cikucmVwbGFjZSgvXFwrL2csXCIlMkJcIikucmVwbGFjZSgvXCIvZyxcIiUyMlwiKS5yZXBsYWNlKC8nL2csXCIlMjdcIikucmVwbGFjZSgvXFwvL2csXCIlMkZcIikucmVwbGFjZSgvPS9nLFwiJTNEXCIpO307ZnVuY3Rpb24gYXJyYXlfcmVtb3ZlKGFycix2YWwpe3ZhciBpbmRleD0tMTtmb3IodmFyIGk9MCxsZW49YXJyLmxlbmd0aDtpPGxlbjtpKyspe2lmKGFycltpXT09PXZhbCl7aW5kZXg9aTticmVhazt9fVxyXG5pZihpbmRleD49MCl7YXJyLnNwbGljZShpbmRleCwxKTtyZXR1cm4gdHJ1ZTt9ZWxzZXtyZXR1cm4gZmFsc2U7fX1cclxuZnVuY3Rpb24gYXJyYXlfY29udGFpbnMoYXJyLHZhbCl7Zm9yKHZhciBpPTAsbGVuPWFyci5sZW5ndGg7aTxsZW47aSsrKXtpZihhcnJbaV09PXZhbCl7cmV0dXJuIHRydWU7fX1cclxucmV0dXJuIGZhbHNlO31cclxuZnVuY3Rpb24gZXh0cmFjdEJvb2xlYW5Gcm9tUGFyYW0ocGFyYW0sZGVmYXVsdFZhbHVlKXtpZihpc1VuZGVmaW5lZChwYXJhbSkpe3JldHVybiBkZWZhdWx0VmFsdWU7fWVsc2V7cmV0dXJuIGJvb2wocGFyYW0pO319XHJcbmZ1bmN0aW9uIGV4dHJhY3RTdHJpbmdGcm9tUGFyYW0ocGFyYW0sZGVmYXVsdFZhbHVlKXtpZihpc1VuZGVmaW5lZChwYXJhbSkpe3JldHVybiBkZWZhdWx0VmFsdWU7fWVsc2V7cmV0dXJuIFN0cmluZyhwYXJhbSk7fX1cclxuZnVuY3Rpb24gZXh0cmFjdEludEZyb21QYXJhbShwYXJhbSxkZWZhdWx0VmFsdWUpe2lmKGlzVW5kZWZpbmVkKHBhcmFtKSl7cmV0dXJuIGRlZmF1bHRWYWx1ZTt9ZWxzZXt0cnl7dmFyIHZhbHVlPXBhcnNlSW50KHBhcmFtLDEwKTtyZXR1cm4gaXNOYU4odmFsdWUpP2RlZmF1bHRWYWx1ZTp2YWx1ZTt9Y2F0Y2goZXgpe2xvZ0xvZy53YXJuKFwiSW52YWxpZCBpbnQgcGFyYW0gXCIrcGFyYW0sZXgpO3JldHVybiBkZWZhdWx0VmFsdWU7fX19XHJcbmZ1bmN0aW9uIGV4dHJhY3RGdW5jdGlvbkZyb21QYXJhbShwYXJhbSxkZWZhdWx0VmFsdWUpe2lmKHR5cGVvZiBwYXJhbT09XCJmdW5jdGlvblwiKXtyZXR1cm4gcGFyYW07fWVsc2V7cmV0dXJuIGRlZmF1bHRWYWx1ZTt9fVxyXG5mdW5jdGlvbiBpc0Vycm9yKGVycil7cmV0dXJuKGVyciBpbnN0YW5jZW9mIEVycm9yKTt9XHJcbmlmKCFGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpe0Z1bmN0aW9uLnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihvYmosYXJncyl7dmFyIG1ldGhvZE5hbWU9XCJfX2FwcGx5X19cIjtpZih0eXBlb2Ygb2JqW21ldGhvZE5hbWVdIT1cInVuZGVmaW5lZFwiKXttZXRob2ROYW1lKz1TdHJpbmcoTWF0aC5yYW5kb20oKSkuc3Vic3RyKDIpO31cclxub2JqW21ldGhvZE5hbWVdPXRoaXM7dmFyIGFyZ3NTdHJpbmdzPVtdO2Zvcih2YXIgaT0wLGxlbj1hcmdzLmxlbmd0aDtpPGxlbjtpKyspe2FyZ3NTdHJpbmdzW2ldPVwiYXJnc1tcIitpK1wiXVwiO31cclxudmFyIHNjcmlwdD1cIm9iai5cIittZXRob2ROYW1lK1wiKFwiK2FyZ3NTdHJpbmdzLmpvaW4oXCIsXCIpK1wiKVwiO3ZhciByZXR1cm5WYWx1ZT1ldmFsKHNjcmlwdCk7ZGVsZXRlIG9ialttZXRob2ROYW1lXTtyZXR1cm4gcmV0dXJuVmFsdWU7fTt9XHJcbmlmKCFGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCl7RnVuY3Rpb24ucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24ob2JqKXt2YXIgYXJncz1bXTtmb3IodmFyIGk9MSxsZW49YXJndW1lbnRzLmxlbmd0aDtpPGxlbjtpKyspe2FyZ3NbaS0xXT1hcmd1bWVudHNbaV07fVxyXG5yZXR1cm4gdGhpcy5hcHBseShvYmosYXJncyk7fTt9XHJcbnZhciBsb2dMb2c9e3F1aWV0TW9kZTpmYWxzZSxkZWJ1Z01lc3NhZ2VzOltdLHNldFF1aWV0TW9kZTpmdW5jdGlvbihxdWlldE1vZGUpe3RoaXMucXVpZXRNb2RlPWJvb2wocXVpZXRNb2RlKTt9LG51bWJlck9mRXJyb3JzOjAsYWxlcnRBbGxFcnJvcnM6ZmFsc2Usc2V0QWxlcnRBbGxFcnJvcnM6ZnVuY3Rpb24oYWxlcnRBbGxFcnJvcnMpe3RoaXMuYWxlcnRBbGxFcnJvcnM9YWxlcnRBbGxFcnJvcnM7fSxkZWJ1ZzpmdW5jdGlvbihtZXNzYWdlKXt0aGlzLmRlYnVnTWVzc2FnZXMucHVzaChtZXNzYWdlKTt9LGRpc3BsYXlEZWJ1ZzpmdW5jdGlvbigpe2FsZXJ0KHRoaXMuZGVidWdNZXNzYWdlcy5qb2luKG5ld0xpbmUpKTt9LHdhcm46ZnVuY3Rpb24obWVzc2FnZSxleGNlcHRpb24pe30sZXJyb3I6ZnVuY3Rpb24obWVzc2FnZSxleGNlcHRpb24pe2lmKCsrdGhpcy5udW1iZXJPZkVycm9ycz09MXx8dGhpcy5hbGVydEFsbEVycm9ycyl7aWYoIXRoaXMucXVpZXRNb2RlKXt2YXIgYWxlcnRNZXNzYWdlPVwibG9nNGphdmFzY3JpcHQgZXJyb3I6IFwiK21lc3NhZ2U7aWYoZXhjZXB0aW9uKXthbGVydE1lc3NhZ2UrPW5ld0xpbmUrbmV3TGluZStcIk9yaWdpbmFsIGVycm9yOiBcIitnZXRFeGNlcHRpb25TdHJpbmdSZXAoZXhjZXB0aW9uKTt9XHJcbmFsZXJ0KGFsZXJ0TWVzc2FnZSk7fX19fTtsb2c0amF2YXNjcmlwdC5sb2dMb2c9bG9nTG9nO2xvZzRqYXZhc2NyaXB0LnNldEV2ZW50VHlwZXMoW1wibG9hZFwiLFwiZXJyb3JcIl0pO2Z1bmN0aW9uIGhhbmRsZUVycm9yKG1lc3NhZ2UsZXhjZXB0aW9uKXtsb2dMb2cuZXJyb3IobWVzc2FnZSxleGNlcHRpb24pO2xvZzRqYXZhc2NyaXB0LmRpc3BhdGNoRXZlbnQoXCJlcnJvclwiLHtcIm1lc3NhZ2VcIjptZXNzYWdlLFwiZXhjZXB0aW9uXCI6ZXhjZXB0aW9ufSk7fVxyXG5sb2c0amF2YXNjcmlwdC5oYW5kbGVFcnJvcj1oYW5kbGVFcnJvcjt2YXIgZW5hYmxlZD0hKCh0eXBlb2YgbG9nNGphdmFzY3JpcHRfZGlzYWJsZWQhPVwidW5kZWZpbmVkXCIpJiZsb2c0amF2YXNjcmlwdF9kaXNhYmxlZCk7bG9nNGphdmFzY3JpcHQuc2V0RW5hYmxlZD1mdW5jdGlvbihlbmFibGUpe2VuYWJsZWQ9Ym9vbChlbmFibGUpO307bG9nNGphdmFzY3JpcHQuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGVuYWJsZWQ7fTt2YXIgdXNlVGltZVN0YW1wc0luTWlsbGlzZWNvbmRzPXRydWU7bG9nNGphdmFzY3JpcHQuc2V0VGltZVN0YW1wc0luTWlsbGlzZWNvbmRzPWZ1bmN0aW9uKHRpbWVTdGFtcHNJbk1pbGxpc2Vjb25kcyl7dXNlVGltZVN0YW1wc0luTWlsbGlzZWNvbmRzPWJvb2wodGltZVN0YW1wc0luTWlsbGlzZWNvbmRzKTt9O2xvZzRqYXZhc2NyaXB0LmlzVGltZVN0YW1wc0luTWlsbGlzZWNvbmRzPWZ1bmN0aW9uKCl7cmV0dXJuIHVzZVRpbWVTdGFtcHNJbk1pbGxpc2Vjb25kczt9O2xvZzRqYXZhc2NyaXB0LmV2YWxJblNjb3BlPWZ1bmN0aW9uKGV4cHIpe3JldHVybiBldmFsKGV4cHIpO307dmFyIHNob3dTdGFja1RyYWNlcz1mYWxzZTtsb2c0amF2YXNjcmlwdC5zZXRTaG93U3RhY2tUcmFjZXM9ZnVuY3Rpb24oc2hvdyl7c2hvd1N0YWNrVHJhY2VzPWJvb2woc2hvdyk7fTt2YXIgTGV2ZWw9ZnVuY3Rpb24obGV2ZWwsbmFtZSl7dGhpcy5sZXZlbD1sZXZlbDt0aGlzLm5hbWU9bmFtZTt9O0xldmVsLnByb3RvdHlwZT17dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lO30sZXF1YWxzOmZ1bmN0aW9uKGxldmVsKXtyZXR1cm4gdGhpcy5sZXZlbD09bGV2ZWwubGV2ZWw7fSxpc0dyZWF0ZXJPckVxdWFsOmZ1bmN0aW9uKGxldmVsKXtyZXR1cm4gdGhpcy5sZXZlbD49bGV2ZWwubGV2ZWw7fX07TGV2ZWwuQUxMPW5ldyBMZXZlbChOdW1iZXIuTUlOX1ZBTFVFLFwiQUxMXCIpO0xldmVsLlRSQUNFPW5ldyBMZXZlbCgxMDAwMCxcIlRSQUNFXCIpO0xldmVsLkRFQlVHPW5ldyBMZXZlbCgyMDAwMCxcIkRFQlVHXCIpO0xldmVsLklORk89bmV3IExldmVsKDMwMDAwLFwiSU5GT1wiKTtMZXZlbC5XQVJOPW5ldyBMZXZlbCg0MDAwMCxcIldBUk5cIik7TGV2ZWwuRVJST1I9bmV3IExldmVsKDUwMDAwLFwiRVJST1JcIik7TGV2ZWwuRkFUQUw9bmV3IExldmVsKDYwMDAwLFwiRkFUQUxcIik7TGV2ZWwuT0ZGPW5ldyBMZXZlbChOdW1iZXIuTUFYX1ZBTFVFLFwiT0ZGXCIpO2xvZzRqYXZhc2NyaXB0LkxldmVsPUxldmVsO2Z1bmN0aW9uIFRpbWVyKG5hbWUsbGV2ZWwpe3RoaXMubmFtZT1uYW1lO3RoaXMubGV2ZWw9aXNVbmRlZmluZWQobGV2ZWwpP0xldmVsLklORk86bGV2ZWw7dGhpcy5zdGFydD1uZXcgRGF0ZSgpO31cclxuVGltZXIucHJvdG90eXBlLmdldEVsYXBzZWRUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpLXRoaXMuc3RhcnQuZ2V0VGltZSgpO307dmFyIGFub255bW91c0xvZ2dlck5hbWU9XCJbYW5vbnltb3VzXVwiO3ZhciBkZWZhdWx0TG9nZ2VyTmFtZT1cIltkZWZhdWx0XVwiO3ZhciBudWxsTG9nZ2VyTmFtZT1cIltudWxsXVwiO3ZhciByb290TG9nZ2VyTmFtZT1cInJvb3RcIjtmdW5jdGlvbiBMb2dnZXIobmFtZSl7dGhpcy5uYW1lPW5hbWU7dGhpcy5wYXJlbnQ9bnVsbDt0aGlzLmNoaWxkcmVuPVtdO3ZhciBhcHBlbmRlcnM9W107dmFyIGxvZ2dlckxldmVsPW51bGw7dmFyIGlzUm9vdD0odGhpcy5uYW1lPT09cm9vdExvZ2dlck5hbWUpO3ZhciBpc051bGw9KHRoaXMubmFtZT09PW51bGxMb2dnZXJOYW1lKTt2YXIgYXBwZW5kZXJDYWNoZT1udWxsO3ZhciBhcHBlbmRlckNhY2hlSW52YWxpZGF0ZWQ9ZmFsc2U7dGhpcy5hZGRDaGlsZD1mdW5jdGlvbihjaGlsZExvZ2dlcil7dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkTG9nZ2VyKTtjaGlsZExvZ2dlci5wYXJlbnQ9dGhpcztjaGlsZExvZ2dlci5pbnZhbGlkYXRlQXBwZW5kZXJDYWNoZSgpO307dmFyIGFkZGl0aXZlPXRydWU7dGhpcy5nZXRBZGRpdGl2aXR5PWZ1bmN0aW9uKCl7cmV0dXJuIGFkZGl0aXZlO307dGhpcy5zZXRBZGRpdGl2aXR5PWZ1bmN0aW9uKGFkZGl0aXZpdHkpe3ZhciB2YWx1ZUNoYW5nZWQ9KGFkZGl0aXZlIT1hZGRpdGl2aXR5KTthZGRpdGl2ZT1hZGRpdGl2aXR5O2lmKHZhbHVlQ2hhbmdlZCl7dGhpcy5pbnZhbGlkYXRlQXBwZW5kZXJDYWNoZSgpO319O3RoaXMuYWRkQXBwZW5kZXI9ZnVuY3Rpb24oYXBwZW5kZXIpe2lmKGlzTnVsbCl7aGFuZGxlRXJyb3IoXCJMb2dnZXIuYWRkQXBwZW5kZXI6IHlvdSBtYXkgbm90IGFkZCBhbiBhcHBlbmRlciB0byB0aGUgbnVsbCBsb2dnZXJcIik7fWVsc2V7aWYoYXBwZW5kZXIgaW5zdGFuY2VvZiBsb2c0amF2YXNjcmlwdC5BcHBlbmRlcil7aWYoIWFycmF5X2NvbnRhaW5zKGFwcGVuZGVycyxhcHBlbmRlcikpe2FwcGVuZGVycy5wdXNoKGFwcGVuZGVyKTthcHBlbmRlci5zZXRBZGRlZFRvTG9nZ2VyKHRoaXMpO3RoaXMuaW52YWxpZGF0ZUFwcGVuZGVyQ2FjaGUoKTt9fWVsc2V7aGFuZGxlRXJyb3IoXCJMb2dnZXIuYWRkQXBwZW5kZXI6IGFwcGVuZGVyIHN1cHBsaWVkICgnXCIrXHJcbnRvU3RyKGFwcGVuZGVyKStcIicpIGlzIG5vdCBhIHN1YmNsYXNzIG9mIEFwcGVuZGVyXCIpO319fTt0aGlzLnJlbW92ZUFwcGVuZGVyPWZ1bmN0aW9uKGFwcGVuZGVyKXthcnJheV9yZW1vdmUoYXBwZW5kZXJzLGFwcGVuZGVyKTthcHBlbmRlci5zZXRSZW1vdmVkRnJvbUxvZ2dlcih0aGlzKTt0aGlzLmludmFsaWRhdGVBcHBlbmRlckNhY2hlKCk7fTt0aGlzLnJlbW92ZUFsbEFwcGVuZGVycz1mdW5jdGlvbigpe3ZhciBhcHBlbmRlckNvdW50PWFwcGVuZGVycy5sZW5ndGg7aWYoYXBwZW5kZXJDb3VudD4wKXtmb3IodmFyIGk9MDtpPGFwcGVuZGVyQ291bnQ7aSsrKXthcHBlbmRlcnNbaV0uc2V0UmVtb3ZlZEZyb21Mb2dnZXIodGhpcyk7fVxyXG5hcHBlbmRlcnMubGVuZ3RoPTA7dGhpcy5pbnZhbGlkYXRlQXBwZW5kZXJDYWNoZSgpO319O3RoaXMuZ2V0RWZmZWN0aXZlQXBwZW5kZXJzPWZ1bmN0aW9uKCl7aWYoYXBwZW5kZXJDYWNoZT09PW51bGx8fGFwcGVuZGVyQ2FjaGVJbnZhbGlkYXRlZCl7dmFyIHBhcmVudEVmZmVjdGl2ZUFwcGVuZGVycz0oaXNSb290fHwhdGhpcy5nZXRBZGRpdGl2aXR5KCkpP1tdOnRoaXMucGFyZW50LmdldEVmZmVjdGl2ZUFwcGVuZGVycygpO2FwcGVuZGVyQ2FjaGU9cGFyZW50RWZmZWN0aXZlQXBwZW5kZXJzLmNvbmNhdChhcHBlbmRlcnMpO2FwcGVuZGVyQ2FjaGVJbnZhbGlkYXRlZD1mYWxzZTt9XHJcbnJldHVybiBhcHBlbmRlckNhY2hlO307dGhpcy5pbnZhbGlkYXRlQXBwZW5kZXJDYWNoZT1mdW5jdGlvbigpe2FwcGVuZGVyQ2FjaGVJbnZhbGlkYXRlZD10cnVlO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNoaWxkcmVuLmxlbmd0aDtpPGxlbjtpKyspe3RoaXMuY2hpbGRyZW5baV0uaW52YWxpZGF0ZUFwcGVuZGVyQ2FjaGUoKTt9fTt0aGlzLmxvZz1mdW5jdGlvbihsZXZlbCxwYXJhbXMpe2lmKGVuYWJsZWQmJmxldmVsLmlzR3JlYXRlck9yRXF1YWwodGhpcy5nZXRFZmZlY3RpdmVMZXZlbCgpKSl7dmFyIGV4Y2VwdGlvbjt2YXIgZmluYWxQYXJhbUluZGV4PXBhcmFtcy5sZW5ndGgtMTt2YXIgbGFzdFBhcmFtPXBhcmFtc1tmaW5hbFBhcmFtSW5kZXhdO2lmKHBhcmFtcy5sZW5ndGg+MSYmaXNFcnJvcihsYXN0UGFyYW0pKXtleGNlcHRpb249bGFzdFBhcmFtO2ZpbmFsUGFyYW1JbmRleC0tO31cclxudmFyIG1lc3NhZ2VzPVtdO2Zvcih2YXIgaT0wO2k8PWZpbmFsUGFyYW1JbmRleDtpKyspe21lc3NhZ2VzW2ldPXBhcmFtc1tpXTt9XHJcbnZhciBsb2dnaW5nRXZlbnQ9bmV3IExvZ2dpbmdFdmVudCh0aGlzLG5ldyBEYXRlKCksbGV2ZWwsbWVzc2FnZXMsZXhjZXB0aW9uKTt0aGlzLmNhbGxBcHBlbmRlcnMobG9nZ2luZ0V2ZW50KTt9fTt0aGlzLmNhbGxBcHBlbmRlcnM9ZnVuY3Rpb24obG9nZ2luZ0V2ZW50KXt2YXIgZWZmZWN0aXZlQXBwZW5kZXJzPXRoaXMuZ2V0RWZmZWN0aXZlQXBwZW5kZXJzKCk7Zm9yKHZhciBpPTAsbGVuPWVmZmVjdGl2ZUFwcGVuZGVycy5sZW5ndGg7aTxsZW47aSsrKXtlZmZlY3RpdmVBcHBlbmRlcnNbaV0uZG9BcHBlbmQobG9nZ2luZ0V2ZW50KTt9fTt0aGlzLnNldExldmVsPWZ1bmN0aW9uKGxldmVsKXtpZihpc1Jvb3QmJmxldmVsPT09bnVsbCl7aGFuZGxlRXJyb3IoXCJMb2dnZXIuc2V0TGV2ZWw6IHlvdSBjYW5ub3Qgc2V0IHRoZSBsZXZlbCBvZiB0aGUgcm9vdCBsb2dnZXIgdG8gbnVsbFwiKTt9ZWxzZSBpZihsZXZlbCBpbnN0YW5jZW9mIExldmVsKXtsb2dnZXJMZXZlbD1sZXZlbDt9ZWxzZXtoYW5kbGVFcnJvcihcIkxvZ2dlci5zZXRMZXZlbDogbGV2ZWwgc3VwcGxpZWQgdG8gbG9nZ2VyIFwiK1xyXG50aGlzLm5hbWUrXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mIGxvZzRqYXZhc2NyaXB0LkxldmVsXCIpO319O3RoaXMuZ2V0TGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gbG9nZ2VyTGV2ZWw7fTt0aGlzLmdldEVmZmVjdGl2ZUxldmVsPWZ1bmN0aW9uKCl7Zm9yKHZhciBsb2dnZXI9dGhpcztsb2dnZXIhPT1udWxsO2xvZ2dlcj1sb2dnZXIucGFyZW50KXt2YXIgbGV2ZWw9bG9nZ2VyLmdldExldmVsKCk7aWYobGV2ZWwhPT1udWxsKXtyZXR1cm4gbGV2ZWw7fX19O3RoaXMuZ3JvdXA9ZnVuY3Rpb24obmFtZSxpbml0aWFsbHlFeHBhbmRlZCl7aWYoZW5hYmxlZCl7dmFyIGVmZmVjdGl2ZUFwcGVuZGVycz10aGlzLmdldEVmZmVjdGl2ZUFwcGVuZGVycygpO2Zvcih2YXIgaT0wLGxlbj1lZmZlY3RpdmVBcHBlbmRlcnMubGVuZ3RoO2k8bGVuO2krKyl7ZWZmZWN0aXZlQXBwZW5kZXJzW2ldLmdyb3VwKG5hbWUsaW5pdGlhbGx5RXhwYW5kZWQpO319fTt0aGlzLmdyb3VwRW5kPWZ1bmN0aW9uKCl7aWYoZW5hYmxlZCl7dmFyIGVmZmVjdGl2ZUFwcGVuZGVycz10aGlzLmdldEVmZmVjdGl2ZUFwcGVuZGVycygpO2Zvcih2YXIgaT0wLGxlbj1lZmZlY3RpdmVBcHBlbmRlcnMubGVuZ3RoO2k8bGVuO2krKyl7ZWZmZWN0aXZlQXBwZW5kZXJzW2ldLmdyb3VwRW5kKCk7fX19O3ZhciB0aW1lcnM9e307dGhpcy50aW1lPWZ1bmN0aW9uKG5hbWUsbGV2ZWwpe2lmKGVuYWJsZWQpe2lmKGlzVW5kZWZpbmVkKG5hbWUpKXtoYW5kbGVFcnJvcihcIkxvZ2dlci50aW1lOiBhIG5hbWUgZm9yIHRoZSB0aW1lciBtdXN0IGJlIHN1cHBsaWVkXCIpO31lbHNlIGlmKGxldmVsJiYhKGxldmVsIGluc3RhbmNlb2YgTGV2ZWwpKXtoYW5kbGVFcnJvcihcIkxvZ2dlci50aW1lOiBsZXZlbCBzdXBwbGllZCB0byB0aW1lciBcIitcclxubmFtZStcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgbG9nNGphdmFzY3JpcHQuTGV2ZWxcIik7fWVsc2V7dGltZXJzW25hbWVdPW5ldyBUaW1lcihuYW1lLGxldmVsKTt9fX07dGhpcy50aW1lRW5kPWZ1bmN0aW9uKG5hbWUpe2lmKGVuYWJsZWQpe2lmKGlzVW5kZWZpbmVkKG5hbWUpKXtoYW5kbGVFcnJvcihcIkxvZ2dlci50aW1lRW5kOiBhIG5hbWUgZm9yIHRoZSB0aW1lciBtdXN0IGJlIHN1cHBsaWVkXCIpO31lbHNlIGlmKHRpbWVyc1tuYW1lXSl7dmFyIHRpbWVyPXRpbWVyc1tuYW1lXTt2YXIgbWlsbGlzZWNvbmRzPXRpbWVyLmdldEVsYXBzZWRUaW1lKCk7dGhpcy5sb2codGltZXIubGV2ZWwsW1wiVGltZXIgXCIrdG9TdHIobmFtZSkrXCIgY29tcGxldGVkIGluIFwiK21pbGxpc2Vjb25kcytcIm1zXCJdKTtkZWxldGUgdGltZXJzW25hbWVdO31lbHNle2xvZ0xvZy53YXJuKFwiTG9nZ2VyLnRpbWVFbmQ6IG5vIHRpbWVyIGZvdW5kIHdpdGggbmFtZSBcIituYW1lKTt9fX07dGhpcy5hc3NlcnQ9ZnVuY3Rpb24oZXhwcil7aWYoZW5hYmxlZCYmIWV4cHIpe3ZhciBhcmdzPVtdO2Zvcih2YXIgaT0xLGxlbj1hcmd1bWVudHMubGVuZ3RoO2k8bGVuO2krKyl7YXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7fVxyXG5hcmdzPShhcmdzLmxlbmd0aD4wKT9hcmdzOltcIkFzc2VydGlvbiBGYWlsdXJlXCJdO2FyZ3MucHVzaChuZXdMaW5lKTthcmdzLnB1c2goZXhwcik7dGhpcy5sb2coTGV2ZWwuRVJST1IsYXJncyk7fX07dGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTG9nZ2VyW1wiK3RoaXMubmFtZStcIl1cIjt9O31cclxuTG9nZ2VyLnByb3RvdHlwZT17dHJhY2U6ZnVuY3Rpb24oKXt0aGlzLmxvZyhMZXZlbC5UUkFDRSxhcmd1bWVudHMpO30sZGVidWc6ZnVuY3Rpb24oKXt0aGlzLmxvZyhMZXZlbC5ERUJVRyxhcmd1bWVudHMpO30saW5mbzpmdW5jdGlvbigpe3RoaXMubG9nKExldmVsLklORk8sYXJndW1lbnRzKTt9LHdhcm46ZnVuY3Rpb24oKXt0aGlzLmxvZyhMZXZlbC5XQVJOLGFyZ3VtZW50cyk7fSxlcnJvcjpmdW5jdGlvbigpe3RoaXMubG9nKExldmVsLkVSUk9SLGFyZ3VtZW50cyk7fSxmYXRhbDpmdW5jdGlvbigpe3RoaXMubG9nKExldmVsLkZBVEFMLGFyZ3VtZW50cyk7fSxpc0VuYWJsZWRGb3I6ZnVuY3Rpb24obGV2ZWwpe3JldHVybiBsZXZlbC5pc0dyZWF0ZXJPckVxdWFsKHRoaXMuZ2V0RWZmZWN0aXZlTGV2ZWwoKSk7fSxpc1RyYWNlRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW5hYmxlZEZvcihMZXZlbC5UUkFDRSk7fSxpc0RlYnVnRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW5hYmxlZEZvcihMZXZlbC5ERUJVRyk7fSxpc0luZm9FbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbmFibGVkRm9yKExldmVsLklORk8pO30saXNXYXJuRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW5hYmxlZEZvcihMZXZlbC5XQVJOKTt9LGlzRXJyb3JFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbmFibGVkRm9yKExldmVsLkVSUk9SKTt9LGlzRmF0YWxFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbmFibGVkRm9yKExldmVsLkZBVEFMKTt9fTtMb2dnZXIucHJvdG90eXBlLnRyYWNlLmlzRW50cnlQb2ludD10cnVlO0xvZ2dlci5wcm90b3R5cGUuZGVidWcuaXNFbnRyeVBvaW50PXRydWU7TG9nZ2VyLnByb3RvdHlwZS5pbmZvLmlzRW50cnlQb2ludD10cnVlO0xvZ2dlci5wcm90b3R5cGUud2Fybi5pc0VudHJ5UG9pbnQ9dHJ1ZTtMb2dnZXIucHJvdG90eXBlLmVycm9yLmlzRW50cnlQb2ludD10cnVlO0xvZ2dlci5wcm90b3R5cGUuZmF0YWwuaXNFbnRyeVBvaW50PXRydWU7dmFyIGxvZ2dlcnM9e307dmFyIGxvZ2dlck5hbWVzPVtdO3ZhciBST09UX0xPR0dFUl9ERUZBVUxUX0xFVkVMPUxldmVsLkRFQlVHO3ZhciByb290TG9nZ2VyPW5ldyBMb2dnZXIocm9vdExvZ2dlck5hbWUpO3Jvb3RMb2dnZXIuc2V0TGV2ZWwoUk9PVF9MT0dHRVJfREVGQVVMVF9MRVZFTCk7bG9nNGphdmFzY3JpcHQuZ2V0Um9vdExvZ2dlcj1mdW5jdGlvbigpe3JldHVybiByb290TG9nZ2VyO307bG9nNGphdmFzY3JpcHQuZ2V0TG9nZ2VyPWZ1bmN0aW9uKGxvZ2dlck5hbWUpe2lmKHR5cGVvZiBsb2dnZXJOYW1lIT1cInN0cmluZ1wiKXtsb2dnZXJOYW1lPWFub255bW91c0xvZ2dlck5hbWU7bG9nTG9nLndhcm4oXCJsb2c0amF2YXNjcmlwdC5nZXRMb2dnZXI6IG5vbi1zdHJpbmcgbG9nZ2VyIG5hbWUgXCIrXHJcbnRvU3RyKGxvZ2dlck5hbWUpK1wiIHN1cHBsaWVkLCByZXR1cm5pbmcgYW5vbnltb3VzIGxvZ2dlclwiKTt9XHJcbmlmKGxvZ2dlck5hbWU9PXJvb3RMb2dnZXJOYW1lKXtoYW5kbGVFcnJvcihcImxvZzRqYXZhc2NyaXB0LmdldExvZ2dlcjogcm9vdCBsb2dnZXIgbWF5IG5vdCBiZSBvYnRhaW5lZCBieSBuYW1lXCIpO31cclxuaWYoIWxvZ2dlcnNbbG9nZ2VyTmFtZV0pe3ZhciBsb2dnZXI9bmV3IExvZ2dlcihsb2dnZXJOYW1lKTtsb2dnZXJzW2xvZ2dlck5hbWVdPWxvZ2dlcjtsb2dnZXJOYW1lcy5wdXNoKGxvZ2dlck5hbWUpO3ZhciBsYXN0RG90SW5kZXg9bG9nZ2VyTmFtZS5sYXN0SW5kZXhPZihcIi5cIik7dmFyIHBhcmVudExvZ2dlcjtpZihsYXN0RG90SW5kZXg+LTEpe3ZhciBwYXJlbnRMb2dnZXJOYW1lPWxvZ2dlck5hbWUuc3Vic3RyaW5nKDAsbGFzdERvdEluZGV4KTtwYXJlbnRMb2dnZXI9bG9nNGphdmFzY3JpcHQuZ2V0TG9nZ2VyKHBhcmVudExvZ2dlck5hbWUpO31lbHNle3BhcmVudExvZ2dlcj1yb290TG9nZ2VyO31cclxucGFyZW50TG9nZ2VyLmFkZENoaWxkKGxvZ2dlcik7fVxyXG5yZXR1cm4gbG9nZ2Vyc1tsb2dnZXJOYW1lXTt9O3ZhciBkZWZhdWx0TG9nZ2VyPW51bGw7bG9nNGphdmFzY3JpcHQuZ2V0RGVmYXVsdExvZ2dlcj1mdW5jdGlvbigpe2lmKCFkZWZhdWx0TG9nZ2VyKXtkZWZhdWx0TG9nZ2VyPWNyZWF0ZURlZmF1bHRMb2dnZXIoKTt9XHJcbnJldHVybiBkZWZhdWx0TG9nZ2VyO307dmFyIG51bGxMb2dnZXI9bnVsbDtsb2c0amF2YXNjcmlwdC5nZXROdWxsTG9nZ2VyPWZ1bmN0aW9uKCl7aWYoIW51bGxMb2dnZXIpe251bGxMb2dnZXI9bmV3IExvZ2dlcihudWxsTG9nZ2VyTmFtZSk7bnVsbExvZ2dlci5zZXRMZXZlbChMZXZlbC5PRkYpO31cclxucmV0dXJuIG51bGxMb2dnZXI7fTtsb2c0amF2YXNjcmlwdC5yZXNldENvbmZpZ3VyYXRpb249ZnVuY3Rpb24oKXtyb290TG9nZ2VyLnNldExldmVsKFJPT1RfTE9HR0VSX0RFRkFVTFRfTEVWRUwpO2xvZ2dlcnM9e307fTt2YXIgTG9nZ2luZ0V2ZW50PWZ1bmN0aW9uKGxvZ2dlcix0aW1lU3RhbXAsbGV2ZWwsbWVzc2FnZXMsZXhjZXB0aW9uKXt0aGlzLmxvZ2dlcj1sb2dnZXI7dGhpcy50aW1lU3RhbXA9dGltZVN0YW1wO3RoaXMudGltZVN0YW1wSW5NaWxsaXNlY29uZHM9dGltZVN0YW1wLmdldFRpbWUoKTt0aGlzLnRpbWVTdGFtcEluU2Vjb25kcz1NYXRoLmZsb29yKHRoaXMudGltZVN0YW1wSW5NaWxsaXNlY29uZHMvMTAwMCk7dGhpcy5taWxsaXNlY29uZHM9dGhpcy50aW1lU3RhbXAuZ2V0TWlsbGlzZWNvbmRzKCk7dGhpcy5sZXZlbD1sZXZlbDt0aGlzLm1lc3NhZ2VzPW1lc3NhZ2VzO3RoaXMuZXhjZXB0aW9uPWV4Y2VwdGlvbjt9O0xvZ2dpbmdFdmVudC5wcm90b3R5cGU9e2dldFRocm93YWJsZVN0clJlcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4Y2VwdGlvbj9nZXRFeGNlcHRpb25TdHJpbmdSZXAodGhpcy5leGNlcHRpb24pOlwiXCI7fSxnZXRDb21iaW5lZE1lc3NhZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubWVzc2FnZXMubGVuZ3RoPT0xKT90aGlzLm1lc3NhZ2VzWzBdOnRoaXMubWVzc2FnZXMuam9pbihuZXdMaW5lKTt9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJMb2dnaW5nRXZlbnRbXCIrdGhpcy5sZXZlbCtcIl1cIjt9fTtsb2c0amF2YXNjcmlwdC5Mb2dnaW5nRXZlbnQ9TG9nZ2luZ0V2ZW50O3ZhciBMYXlvdXQ9ZnVuY3Rpb24oKXt9O0xheW91dC5wcm90b3R5cGU9e2RlZmF1bHRzOntsb2dnZXJLZXk6XCJsb2dnZXJcIix0aW1lU3RhbXBLZXk6XCJ0aW1lc3RhbXBcIixtaWxsaXNlY29uZHNLZXk6XCJtaWxsaXNlY29uZHNcIixsZXZlbEtleTpcImxldmVsXCIsbWVzc2FnZUtleTpcIm1lc3NhZ2VcIixleGNlcHRpb25LZXk6XCJleGNlcHRpb25cIix1cmxLZXk6XCJ1cmxcIn0sbG9nZ2VyS2V5OlwibG9nZ2VyXCIsdGltZVN0YW1wS2V5OlwidGltZXN0YW1wXCIsbWlsbGlzZWNvbmRzS2V5OlwibWlsbGlzZWNvbmRzXCIsbGV2ZWxLZXk6XCJsZXZlbFwiLG1lc3NhZ2VLZXk6XCJtZXNzYWdlXCIsZXhjZXB0aW9uS2V5OlwiZXhjZXB0aW9uXCIsdXJsS2V5OlwidXJsXCIsYmF0Y2hIZWFkZXI6XCJcIixiYXRjaEZvb3RlcjpcIlwiLGJhdGNoU2VwYXJhdG9yOlwiXCIscmV0dXJuc1Bvc3REYXRhOmZhbHNlLG92ZXJyaWRlVGltZVN0YW1wc1NldHRpbmc6ZmFsc2UsdXNlVGltZVN0YW1wc0luTWlsbGlzZWNvbmRzOm51bGwsZm9ybWF0OmZ1bmN0aW9uKCl7aGFuZGxlRXJyb3IoXCJMYXlvdXQuZm9ybWF0OiBsYXlvdXQgc3VwcGxpZWQgaGFzIG5vIGZvcm1hdCgpIG1ldGhvZFwiKTt9LGlnbm9yZXNUaHJvd2FibGU6ZnVuY3Rpb24oKXtoYW5kbGVFcnJvcihcIkxheW91dC5pZ25vcmVzVGhyb3dhYmxlOiBsYXlvdXQgc3VwcGxpZWQgaGFzIG5vIGlnbm9yZXNUaHJvd2FibGUoKSBtZXRob2RcIik7fSxnZXRDb250ZW50VHlwZTpmdW5jdGlvbigpe3JldHVyblwidGV4dC9wbGFpblwiO30sYWxsb3dCYXRjaGluZzpmdW5jdGlvbigpe3JldHVybiB0cnVlO30sc2V0VGltZVN0YW1wc0luTWlsbGlzZWNvbmRzOmZ1bmN0aW9uKHRpbWVTdGFtcHNJbk1pbGxpc2Vjb25kcyl7dGhpcy5vdmVycmlkZVRpbWVTdGFtcHNTZXR0aW5nPXRydWU7dGhpcy51c2VUaW1lU3RhbXBzSW5NaWxsaXNlY29uZHM9Ym9vbCh0aW1lU3RhbXBzSW5NaWxsaXNlY29uZHMpO30saXNUaW1lU3RhbXBzSW5NaWxsaXNlY29uZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdmVycmlkZVRpbWVTdGFtcHNTZXR0aW5nP3RoaXMudXNlVGltZVN0YW1wc0luTWlsbGlzZWNvbmRzOnVzZVRpbWVTdGFtcHNJbk1pbGxpc2Vjb25kczt9LGdldFRpbWVTdGFtcFZhbHVlOmZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7cmV0dXJuIHRoaXMuaXNUaW1lU3RhbXBzSW5NaWxsaXNlY29uZHMoKT9sb2dnaW5nRXZlbnQudGltZVN0YW1wSW5NaWxsaXNlY29uZHM6bG9nZ2luZ0V2ZW50LnRpbWVTdGFtcEluU2Vjb25kczt9LGdldERhdGFWYWx1ZXM6ZnVuY3Rpb24obG9nZ2luZ0V2ZW50LGNvbWJpbmVNZXNzYWdlcyl7dmFyIGRhdGFWYWx1ZXM9W1t0aGlzLmxvZ2dlcktleSxsb2dnaW5nRXZlbnQubG9nZ2VyLm5hbWVdLFt0aGlzLnRpbWVTdGFtcEtleSx0aGlzLmdldFRpbWVTdGFtcFZhbHVlKGxvZ2dpbmdFdmVudCldLFt0aGlzLmxldmVsS2V5LGxvZ2dpbmdFdmVudC5sZXZlbC5uYW1lXSxbdGhpcy51cmxLZXksd2luZG93LmxvY2F0aW9uLmhyZWZdLFt0aGlzLm1lc3NhZ2VLZXksY29tYmluZU1lc3NhZ2VzP2xvZ2dpbmdFdmVudC5nZXRDb21iaW5lZE1lc3NhZ2VzKCk6bG9nZ2luZ0V2ZW50Lm1lc3NhZ2VzXV07aWYoIXRoaXMuaXNUaW1lU3RhbXBzSW5NaWxsaXNlY29uZHMoKSl7ZGF0YVZhbHVlcy5wdXNoKFt0aGlzLm1pbGxpc2Vjb25kc0tleSxsb2dnaW5nRXZlbnQubWlsbGlzZWNvbmRzXSk7fVxyXG5pZihsb2dnaW5nRXZlbnQuZXhjZXB0aW9uKXtkYXRhVmFsdWVzLnB1c2goW3RoaXMuZXhjZXB0aW9uS2V5LGdldEV4Y2VwdGlvblN0cmluZ1JlcChsb2dnaW5nRXZlbnQuZXhjZXB0aW9uKV0pO31cclxuaWYodGhpcy5oYXNDdXN0b21GaWVsZHMoKSl7Zm9yKHZhciBpPTAsbGVuPXRoaXMuY3VzdG9tRmllbGRzLmxlbmd0aDtpPGxlbjtpKyspe3ZhciB2YWw9dGhpcy5jdXN0b21GaWVsZHNbaV0udmFsdWU7aWYodHlwZW9mIHZhbD09PVwiZnVuY3Rpb25cIil7dmFsPXZhbCh0aGlzLGxvZ2dpbmdFdmVudCk7fVxyXG5kYXRhVmFsdWVzLnB1c2goW3RoaXMuY3VzdG9tRmllbGRzW2ldLm5hbWUsdmFsXSk7fX1cclxucmV0dXJuIGRhdGFWYWx1ZXM7fSxzZXRLZXlzOmZ1bmN0aW9uKGxvZ2dlcktleSx0aW1lU3RhbXBLZXksbGV2ZWxLZXksbWVzc2FnZUtleSxleGNlcHRpb25LZXksdXJsS2V5LG1pbGxpc2Vjb25kc0tleSl7dGhpcy5sb2dnZXJLZXk9ZXh0cmFjdFN0cmluZ0Zyb21QYXJhbShsb2dnZXJLZXksdGhpcy5kZWZhdWx0cy5sb2dnZXJLZXkpO3RoaXMudGltZVN0YW1wS2V5PWV4dHJhY3RTdHJpbmdGcm9tUGFyYW0odGltZVN0YW1wS2V5LHRoaXMuZGVmYXVsdHMudGltZVN0YW1wS2V5KTt0aGlzLmxldmVsS2V5PWV4dHJhY3RTdHJpbmdGcm9tUGFyYW0obGV2ZWxLZXksdGhpcy5kZWZhdWx0cy5sZXZlbEtleSk7dGhpcy5tZXNzYWdlS2V5PWV4dHJhY3RTdHJpbmdGcm9tUGFyYW0obWVzc2FnZUtleSx0aGlzLmRlZmF1bHRzLm1lc3NhZ2VLZXkpO3RoaXMuZXhjZXB0aW9uS2V5PWV4dHJhY3RTdHJpbmdGcm9tUGFyYW0oZXhjZXB0aW9uS2V5LHRoaXMuZGVmYXVsdHMuZXhjZXB0aW9uS2V5KTt0aGlzLnVybEtleT1leHRyYWN0U3RyaW5nRnJvbVBhcmFtKHVybEtleSx0aGlzLmRlZmF1bHRzLnVybEtleSk7dGhpcy5taWxsaXNlY29uZHNLZXk9ZXh0cmFjdFN0cmluZ0Zyb21QYXJhbShtaWxsaXNlY29uZHNLZXksdGhpcy5kZWZhdWx0cy5taWxsaXNlY29uZHNLZXkpO30sc2V0Q3VzdG9tRmllbGQ6ZnVuY3Rpb24obmFtZSx2YWx1ZSl7dmFyIGZpZWxkVXBkYXRlZD1mYWxzZTtmb3IodmFyIGk9MCxsZW49dGhpcy5jdXN0b21GaWVsZHMubGVuZ3RoO2k8bGVuO2krKyl7aWYodGhpcy5jdXN0b21GaWVsZHNbaV0ubmFtZT09PW5hbWUpe3RoaXMuY3VzdG9tRmllbGRzW2ldLnZhbHVlPXZhbHVlO2ZpZWxkVXBkYXRlZD10cnVlO319XHJcbmlmKCFmaWVsZFVwZGF0ZWQpe3RoaXMuY3VzdG9tRmllbGRzLnB1c2goe1wibmFtZVwiOm5hbWUsXCJ2YWx1ZVwiOnZhbHVlfSk7fX0saGFzQ3VzdG9tRmllbGRzOmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuY3VzdG9tRmllbGRzLmxlbmd0aD4wKTt9LGZvcm1hdFdpdGhFeGNlcHRpb246ZnVuY3Rpb24obG9nZ2luZ0V2ZW50KXt2YXIgZm9ybWF0dGVkPXRoaXMuZm9ybWF0KGxvZ2dpbmdFdmVudCk7aWYobG9nZ2luZ0V2ZW50LmV4Y2VwdGlvbiYmdGhpcy5pZ25vcmVzVGhyb3dhYmxlKCkpe2Zvcm1hdHRlZCs9bG9nZ2luZ0V2ZW50LmdldFRocm93YWJsZVN0clJlcCgpO31cclxucmV0dXJuIGZvcm1hdHRlZDt9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7aGFuZGxlRXJyb3IoXCJMYXlvdXQudG9TdHJpbmc6IGFsbCBsYXlvdXRzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2RcIik7fX07bG9nNGphdmFzY3JpcHQuTGF5b3V0PUxheW91dDt2YXIgQXBwZW5kZXI9ZnVuY3Rpb24oKXt9O0FwcGVuZGVyLnByb3RvdHlwZT1uZXcgRXZlbnRTdXBwb3J0KCk7QXBwZW5kZXIucHJvdG90eXBlLmxheW91dD1uZXcgUGF0dGVybkxheW91dCgpO0FwcGVuZGVyLnByb3RvdHlwZS50aHJlc2hvbGQ9TGV2ZWwuQUxMO0FwcGVuZGVyLnByb3RvdHlwZS5sb2dnZXJzPVtdO0FwcGVuZGVyLnByb3RvdHlwZS5kb0FwcGVuZD1mdW5jdGlvbihsb2dnaW5nRXZlbnQpe2lmKGVuYWJsZWQmJmxvZ2dpbmdFdmVudC5sZXZlbC5sZXZlbD49dGhpcy50aHJlc2hvbGQubGV2ZWwpe3RoaXMuYXBwZW5kKGxvZ2dpbmdFdmVudCk7fX07QXBwZW5kZXIucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbihsb2dnaW5nRXZlbnQpe307QXBwZW5kZXIucHJvdG90eXBlLnNldExheW91dD1mdW5jdGlvbihsYXlvdXQpe2lmKGxheW91dCBpbnN0YW5jZW9mIExheW91dCl7dGhpcy5sYXlvdXQ9bGF5b3V0O31lbHNle2hhbmRsZUVycm9yKFwiQXBwZW5kZXIuc2V0TGF5b3V0OiBsYXlvdXQgc3VwcGxpZWQgdG8gXCIrXHJcbnRoaXMudG9TdHJpbmcoKStcIiBpcyBub3QgYSBzdWJjbGFzcyBvZiBMYXlvdXRcIik7fX07QXBwZW5kZXIucHJvdG90eXBlLmdldExheW91dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxheW91dDt9O0FwcGVuZGVyLnByb3RvdHlwZS5zZXRUaHJlc2hvbGQ9ZnVuY3Rpb24odGhyZXNob2xkKXtpZih0aHJlc2hvbGQgaW5zdGFuY2VvZiBMZXZlbCl7dGhpcy50aHJlc2hvbGQ9dGhyZXNob2xkO31lbHNle2hhbmRsZUVycm9yKFwiQXBwZW5kZXIuc2V0VGhyZXNob2xkOiB0aHJlc2hvbGQgc3VwcGxpZWQgdG8gXCIrXHJcbnRoaXMudG9TdHJpbmcoKStcIiBpcyBub3QgYSBzdWJjbGFzcyBvZiBMZXZlbFwiKTt9fTtBcHBlbmRlci5wcm90b3R5cGUuZ2V0VGhyZXNob2xkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyZXNob2xkO307QXBwZW5kZXIucHJvdG90eXBlLnNldEFkZGVkVG9Mb2dnZXI9ZnVuY3Rpb24obG9nZ2VyKXt0aGlzLmxvZ2dlcnMucHVzaChsb2dnZXIpO307QXBwZW5kZXIucHJvdG90eXBlLnNldFJlbW92ZWRGcm9tTG9nZ2VyPWZ1bmN0aW9uKGxvZ2dlcil7YXJyYXlfcmVtb3ZlKHRoaXMubG9nZ2Vycyxsb2dnZXIpO307QXBwZW5kZXIucHJvdG90eXBlLmdyb3VwPWVtcHR5RnVuY3Rpb247QXBwZW5kZXIucHJvdG90eXBlLmdyb3VwRW5kPWVtcHR5RnVuY3Rpb247QXBwZW5kZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7aGFuZGxlRXJyb3IoXCJBcHBlbmRlci50b1N0cmluZzogYWxsIGFwcGVuZGVycyBtdXN0IG92ZXJyaWRlIHRoaXMgbWV0aG9kXCIpO307bG9nNGphdmFzY3JpcHQuQXBwZW5kZXI9QXBwZW5kZXI7ZnVuY3Rpb24gU2ltcGxlTGF5b3V0KCl7dGhpcy5jdXN0b21GaWVsZHM9W107fVxyXG5TaW1wbGVMYXlvdXQucHJvdG90eXBlPW5ldyBMYXlvdXQoKTtTaW1wbGVMYXlvdXQucHJvdG90eXBlLmZvcm1hdD1mdW5jdGlvbihsb2dnaW5nRXZlbnQpe3JldHVybiBsb2dnaW5nRXZlbnQubGV2ZWwubmFtZStcIiAtIFwiK2xvZ2dpbmdFdmVudC5nZXRDb21iaW5lZE1lc3NhZ2VzKCk7fTtTaW1wbGVMYXlvdXQucHJvdG90eXBlLmlnbm9yZXNUaHJvd2FibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZTt9O1NpbXBsZUxheW91dC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlNpbXBsZUxheW91dFwiO307bG9nNGphdmFzY3JpcHQuU2ltcGxlTGF5b3V0PVNpbXBsZUxheW91dDtmdW5jdGlvbiBOdWxsTGF5b3V0KCl7dGhpcy5jdXN0b21GaWVsZHM9W107fVxyXG5OdWxsTGF5b3V0LnByb3RvdHlwZT1uZXcgTGF5b3V0KCk7TnVsbExheW91dC5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7cmV0dXJuIGxvZ2dpbmdFdmVudC5tZXNzYWdlczt9O051bGxMYXlvdXQucHJvdG90eXBlLmlnbm9yZXNUaHJvd2FibGU9ZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZTt9O051bGxMYXlvdXQucHJvdG90eXBlLmZvcm1hdFdpdGhFeGNlcHRpb249ZnVuY3Rpb24obG9nZ2luZ0V2ZW50KXt2YXIgbWVzc2FnZXM9bG9nZ2luZ0V2ZW50Lm1lc3NhZ2VzLGV4PWxvZ2dpbmdFdmVudC5leGNlcHRpb247cmV0dXJuIGV4P21lc3NhZ2VzLmNvbmNhdChbZXhdKTptZXNzYWdlczt9O051bGxMYXlvdXQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOdWxsTGF5b3V0XCI7fTtsb2c0amF2YXNjcmlwdC5OdWxsTGF5b3V0PU51bGxMYXlvdXQ7ZnVuY3Rpb24gWG1sTGF5b3V0KGNvbWJpbmVNZXNzYWdlcyl7dGhpcy5jb21iaW5lTWVzc2FnZXM9ZXh0cmFjdEJvb2xlYW5Gcm9tUGFyYW0oY29tYmluZU1lc3NhZ2VzLHRydWUpO3RoaXMuY3VzdG9tRmllbGRzPVtdO31cclxuWG1sTGF5b3V0LnByb3RvdHlwZT1uZXcgTGF5b3V0KCk7WG1sTGF5b3V0LnByb3RvdHlwZS5pc0NvbWJpbmVkTWVzc2FnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21iaW5lTWVzc2FnZXM7fTtYbWxMYXlvdXQucHJvdG90eXBlLmdldENvbnRlbnRUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuXCJ0ZXh0L3htbFwiO307WG1sTGF5b3V0LnByb3RvdHlwZS5lc2NhcGVDZGF0YT1mdW5jdGlvbihzdHIpe3JldHVybiBzdHIucmVwbGFjZSgvXFxdXFxdPi8sXCJdXT5dXSZndDs8IVtDREFUQVtcIik7fTtYbWxMYXlvdXQucHJvdG90eXBlLmZvcm1hdD1mdW5jdGlvbihsb2dnaW5nRXZlbnQpe3ZhciBsYXlvdXQ9dGhpczt2YXIgaSxsZW47ZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtZXNzYWdlKXttZXNzYWdlPSh0eXBlb2YgbWVzc2FnZT09PVwic3RyaW5nXCIpP21lc3NhZ2U6dG9TdHIobWVzc2FnZSk7cmV0dXJuXCI8bG9nNGphdmFzY3JpcHQ6bWVzc2FnZT48IVtDREFUQVtcIitcclxubGF5b3V0LmVzY2FwZUNkYXRhKG1lc3NhZ2UpK1wiXV0+PC9sb2c0amF2YXNjcmlwdDptZXNzYWdlPlwiO31cclxudmFyIHN0cj1cIjxsb2c0amF2YXNjcmlwdDpldmVudCBsb2dnZXI9XFxcIlwiK2xvZ2dpbmdFdmVudC5sb2dnZXIubmFtZStcIlxcXCIgdGltZXN0YW1wPVxcXCJcIit0aGlzLmdldFRpbWVTdGFtcFZhbHVlKGxvZ2dpbmdFdmVudCkrXCJcXFwiXCI7aWYoIXRoaXMuaXNUaW1lU3RhbXBzSW5NaWxsaXNlY29uZHMoKSl7c3RyKz1cIiBtaWxsaXNlY29uZHM9XFxcIlwiK2xvZ2dpbmdFdmVudC5taWxsaXNlY29uZHMrXCJcXFwiXCI7fVxyXG5zdHIrPVwiIGxldmVsPVxcXCJcIitsb2dnaW5nRXZlbnQubGV2ZWwubmFtZStcIlxcXCI+XCIrbmV3TGluZTtpZih0aGlzLmNvbWJpbmVNZXNzYWdlcyl7c3RyKz1mb3JtYXRNZXNzYWdlKGxvZ2dpbmdFdmVudC5nZXRDb21iaW5lZE1lc3NhZ2VzKCkpO31lbHNle3N0cis9XCI8bG9nNGphdmFzY3JpcHQ6bWVzc2FnZXM+XCIrbmV3TGluZTtmb3IoaT0wLGxlbj1sb2dnaW5nRXZlbnQubWVzc2FnZXMubGVuZ3RoO2k8bGVuO2krKyl7c3RyKz1mb3JtYXRNZXNzYWdlKGxvZ2dpbmdFdmVudC5tZXNzYWdlc1tpXSkrbmV3TGluZTt9XHJcbnN0cis9XCI8L2xvZzRqYXZhc2NyaXB0Om1lc3NhZ2VzPlwiK25ld0xpbmU7fVxyXG5pZih0aGlzLmhhc0N1c3RvbUZpZWxkcygpKXtmb3IoaT0wLGxlbj10aGlzLmN1c3RvbUZpZWxkcy5sZW5ndGg7aTxsZW47aSsrKXtzdHIrPVwiPGxvZzRqYXZhc2NyaXB0OmN1c3RvbWZpZWxkIG5hbWU9XFxcIlwiK1xyXG50aGlzLmN1c3RvbUZpZWxkc1tpXS5uYW1lK1wiXFxcIj48IVtDREFUQVtcIitcclxudGhpcy5jdXN0b21GaWVsZHNbaV0udmFsdWUudG9TdHJpbmcoKStcIl1dPjwvbG9nNGphdmFzY3JpcHQ6Y3VzdG9tZmllbGQ+XCIrbmV3TGluZTt9fVxyXG5pZihsb2dnaW5nRXZlbnQuZXhjZXB0aW9uKXtzdHIrPVwiPGxvZzRqYXZhc2NyaXB0OmV4Y2VwdGlvbj48IVtDREFUQVtcIitcclxuZ2V0RXhjZXB0aW9uU3RyaW5nUmVwKGxvZ2dpbmdFdmVudC5leGNlcHRpb24pK1wiXV0+PC9sb2c0amF2YXNjcmlwdDpleGNlcHRpb24+XCIrbmV3TGluZTt9XHJcbnN0cis9XCI8L2xvZzRqYXZhc2NyaXB0OmV2ZW50PlwiK25ld0xpbmUrbmV3TGluZTtyZXR1cm4gc3RyO307WG1sTGF5b3V0LnByb3RvdHlwZS5pZ25vcmVzVGhyb3dhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlO307WG1sTGF5b3V0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiWG1sTGF5b3V0XCI7fTtsb2c0amF2YXNjcmlwdC5YbWxMYXlvdXQ9WG1sTGF5b3V0O2Z1bmN0aW9uIGVzY2FwZU5ld0xpbmVzKHN0cil7cmV0dXJuIHN0ci5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLFwiXFxcXHJcXFxcblwiKTt9XHJcbmZ1bmN0aW9uIEpzb25MYXlvdXQocmVhZGFibGUsY29tYmluZU1lc3NhZ2VzKXt0aGlzLnJlYWRhYmxlPWV4dHJhY3RCb29sZWFuRnJvbVBhcmFtKHJlYWRhYmxlLGZhbHNlKTt0aGlzLmNvbWJpbmVNZXNzYWdlcz1leHRyYWN0Qm9vbGVhbkZyb21QYXJhbShjb21iaW5lTWVzc2FnZXMsdHJ1ZSk7dGhpcy5iYXRjaEhlYWRlcj10aGlzLnJlYWRhYmxlP1wiW1wiK25ld0xpbmU6XCJbXCI7dGhpcy5iYXRjaEZvb3Rlcj10aGlzLnJlYWRhYmxlP1wiXVwiK25ld0xpbmU6XCJdXCI7dGhpcy5iYXRjaFNlcGFyYXRvcj10aGlzLnJlYWRhYmxlP1wiLFwiK25ld0xpbmU6XCIsXCI7dGhpcy5zZXRLZXlzKCk7dGhpcy5jb2xvbj10aGlzLnJlYWRhYmxlP1wiOiBcIjpcIjpcIjt0aGlzLnRhYj10aGlzLnJlYWRhYmxlP1wiXFx0XCI6XCJcIjt0aGlzLmxpbmVCcmVhaz10aGlzLnJlYWRhYmxlP25ld0xpbmU6XCJcIjt0aGlzLmN1c3RvbUZpZWxkcz1bXTt9XHJcbkpzb25MYXlvdXQucHJvdG90eXBlPW5ldyBMYXlvdXQoKTtKc29uTGF5b3V0LnByb3RvdHlwZS5pc1JlYWRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZGFibGU7fTtKc29uTGF5b3V0LnByb3RvdHlwZS5pc0NvbWJpbmVkTWVzc2FnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21iaW5lTWVzc2FnZXM7fTtKc29uTGF5b3V0LnByb3RvdHlwZS5mb3JtYXQ9ZnVuY3Rpb24obG9nZ2luZ0V2ZW50KXt2YXIgbGF5b3V0PXRoaXM7dmFyIGRhdGFWYWx1ZXM9dGhpcy5nZXREYXRhVmFsdWVzKGxvZ2dpbmdFdmVudCx0aGlzLmNvbWJpbmVNZXNzYWdlcyk7dmFyIHN0cj1cIntcIit0aGlzLmxpbmVCcmVhazt2YXIgaSxsZW47ZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsLHByZWZpeCxleHBhbmQpe3ZhciBmb3JtYXR0ZWRWYWx1ZTt2YXIgdmFsVHlwZT10eXBlb2YgdmFsO2lmKHZhbCBpbnN0YW5jZW9mIERhdGUpe2Zvcm1hdHRlZFZhbHVlPVN0cmluZyh2YWwuZ2V0VGltZSgpKTt9ZWxzZSBpZihleHBhbmQmJih2YWwgaW5zdGFuY2VvZiBBcnJheSkpe2Zvcm1hdHRlZFZhbHVlPVwiW1wiK2xheW91dC5saW5lQnJlYWs7Zm9yKHZhciBpPTAsbGVuPXZhbC5sZW5ndGg7aTxsZW47aSsrKXt2YXIgY2hpbGRQcmVmaXg9cHJlZml4K2xheW91dC50YWI7Zm9ybWF0dGVkVmFsdWUrPWNoaWxkUHJlZml4K2Zvcm1hdFZhbHVlKHZhbFtpXSxjaGlsZFByZWZpeCxmYWxzZSk7aWYoaTx2YWwubGVuZ3RoLTEpe2Zvcm1hdHRlZFZhbHVlKz1cIixcIjt9XHJcbmZvcm1hdHRlZFZhbHVlKz1sYXlvdXQubGluZUJyZWFrO31cclxuZm9ybWF0dGVkVmFsdWUrPXByZWZpeCtcIl1cIjt9ZWxzZSBpZih2YWxUeXBlIT09XCJudW1iZXJcIiYmdmFsVHlwZSE9PVwiYm9vbGVhblwiKXtmb3JtYXR0ZWRWYWx1ZT1cIlxcXCJcIitlc2NhcGVOZXdMaW5lcyh0b1N0cih2YWwpLnJlcGxhY2UoL1xcXCIvZyxcIlxcXFxcXFwiXCIpKStcIlxcXCJcIjt9ZWxzZXtmb3JtYXR0ZWRWYWx1ZT12YWw7fVxyXG5yZXR1cm4gZm9ybWF0dGVkVmFsdWU7fVxyXG5mb3IoaT0wLGxlbj1kYXRhVmFsdWVzLmxlbmd0aC0xO2k8PWxlbjtpKyspe3N0cis9dGhpcy50YWIrXCJcXFwiXCIrZGF0YVZhbHVlc1tpXVswXStcIlxcXCJcIit0aGlzLmNvbG9uK2Zvcm1hdFZhbHVlKGRhdGFWYWx1ZXNbaV1bMV0sdGhpcy50YWIsdHJ1ZSk7aWYoaTxsZW4pe3N0cis9XCIsXCI7fVxyXG5zdHIrPXRoaXMubGluZUJyZWFrO31cclxuc3RyKz1cIn1cIit0aGlzLmxpbmVCcmVhaztyZXR1cm4gc3RyO307SnNvbkxheW91dC5wcm90b3R5cGUuaWdub3Jlc1Rocm93YWJsZT1mdW5jdGlvbigpe3JldHVybiBmYWxzZTt9O0pzb25MYXlvdXQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJKc29uTGF5b3V0XCI7fTtKc29uTGF5b3V0LnByb3RvdHlwZS5nZXRDb250ZW50VHlwZT1mdW5jdGlvbigpe3JldHVyblwiYXBwbGljYXRpb24vanNvblwiO307bG9nNGphdmFzY3JpcHQuSnNvbkxheW91dD1Kc29uTGF5b3V0O2Z1bmN0aW9uIEh0dHBQb3N0RGF0YUxheW91dCgpe3RoaXMuc2V0S2V5cygpO3RoaXMuY3VzdG9tRmllbGRzPVtdO3RoaXMucmV0dXJuc1Bvc3REYXRhPXRydWU7fVxyXG5IdHRwUG9zdERhdGFMYXlvdXQucHJvdG90eXBlPW5ldyBMYXlvdXQoKTtIdHRwUG9zdERhdGFMYXlvdXQucHJvdG90eXBlLmFsbG93QmF0Y2hpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2U7fTtIdHRwUG9zdERhdGFMYXlvdXQucHJvdG90eXBlLmZvcm1hdD1mdW5jdGlvbihsb2dnaW5nRXZlbnQpe3ZhciBkYXRhVmFsdWVzPXRoaXMuZ2V0RGF0YVZhbHVlcyhsb2dnaW5nRXZlbnQpO3ZhciBxdWVyeUJpdHM9W107Zm9yKHZhciBpPTAsbGVuPWRhdGFWYWx1ZXMubGVuZ3RoO2k8bGVuO2krKyl7dmFyIHZhbD0oZGF0YVZhbHVlc1tpXVsxXWluc3RhbmNlb2YgRGF0ZSk/U3RyaW5nKGRhdGFWYWx1ZXNbaV1bMV0uZ2V0VGltZSgpKTpkYXRhVmFsdWVzW2ldWzFdO3F1ZXJ5Qml0cy5wdXNoKHVybEVuY29kZShkYXRhVmFsdWVzW2ldWzBdKStcIj1cIit1cmxFbmNvZGUodmFsKSk7fVxyXG5yZXR1cm4gcXVlcnlCaXRzLmpvaW4oXCImXCIpO307SHR0cFBvc3REYXRhTGF5b3V0LnByb3RvdHlwZS5pZ25vcmVzVGhyb3dhYmxlPWZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7cmV0dXJuIGZhbHNlO307SHR0cFBvc3REYXRhTGF5b3V0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiSHR0cFBvc3REYXRhTGF5b3V0XCI7fTtsb2c0amF2YXNjcmlwdC5IdHRwUG9zdERhdGFMYXlvdXQ9SHR0cFBvc3REYXRhTGF5b3V0O2Z1bmN0aW9uIGZvcm1hdE9iamVjdEV4cGFuc2lvbihvYmosZGVwdGgsaW5kZW50YXRpb24pe3ZhciBvYmplY3RzRXhwYW5kZWQ9W107ZnVuY3Rpb24gZG9Gb3JtYXQob2JqLGRlcHRoLGluZGVudGF0aW9uKXt2YXIgaSxsZW4sY2hpbGREZXB0aCxjaGlsZEluZGVudGF0aW9uLGNoaWxkTGluZXMsZXhwYW5zaW9uLGNoaWxkRXhwYW5zaW9uO2lmKCFpbmRlbnRhdGlvbil7aW5kZW50YXRpb249XCJcIjt9XHJcbmZ1bmN0aW9uIGZvcm1hdFN0cmluZyh0ZXh0KXt2YXIgbGluZXM9c3BsaXRJbnRvTGluZXModGV4dCk7Zm9yKHZhciBqPTEsakxlbj1saW5lcy5sZW5ndGg7ajxqTGVuO2orKyl7bGluZXNbal09aW5kZW50YXRpb24rbGluZXNbal07fVxyXG5yZXR1cm4gbGluZXMuam9pbihuZXdMaW5lKTt9XHJcbmlmKG9iaj09PW51bGwpe3JldHVyblwibnVsbFwiO31lbHNlIGlmKHR5cGVvZiBvYmo9PVwidW5kZWZpbmVkXCIpe3JldHVyblwidW5kZWZpbmVkXCI7fWVsc2UgaWYodHlwZW9mIG9iaj09XCJzdHJpbmdcIil7cmV0dXJuIGZvcm1hdFN0cmluZyhvYmopO31lbHNlIGlmKHR5cGVvZiBvYmo9PVwib2JqZWN0XCImJmFycmF5X2NvbnRhaW5zKG9iamVjdHNFeHBhbmRlZCxvYmopKXt0cnl7ZXhwYW5zaW9uPXRvU3RyKG9iaik7fWNhdGNoKGV4KXtleHBhbnNpb249XCJFcnJvciBmb3JtYXR0aW5nIHByb3BlcnR5LiBEZXRhaWxzOiBcIitnZXRFeGNlcHRpb25TdHJpbmdSZXAoZXgpO31cclxucmV0dXJuIGV4cGFuc2lvbitcIiBbYWxyZWFkeSBleHBhbmRlZF1cIjt9ZWxzZSBpZigob2JqIGluc3RhbmNlb2YgQXJyYXkpJiZkZXB0aD4wKXtvYmplY3RzRXhwYW5kZWQucHVzaChvYmopO2V4cGFuc2lvbj1cIltcIituZXdMaW5lO2NoaWxkRGVwdGg9ZGVwdGgtMTtjaGlsZEluZGVudGF0aW9uPWluZGVudGF0aW9uK1wiICBcIjtjaGlsZExpbmVzPVtdO2ZvcihpPTAsbGVuPW9iai5sZW5ndGg7aTxsZW47aSsrKXt0cnl7Y2hpbGRFeHBhbnNpb249ZG9Gb3JtYXQob2JqW2ldLGNoaWxkRGVwdGgsY2hpbGRJbmRlbnRhdGlvbik7Y2hpbGRMaW5lcy5wdXNoKGNoaWxkSW5kZW50YXRpb24rY2hpbGRFeHBhbnNpb24pO31jYXRjaChleCl7Y2hpbGRMaW5lcy5wdXNoKGNoaWxkSW5kZW50YXRpb24rXCJFcnJvciBmb3JtYXR0aW5nIGFycmF5IG1lbWJlci4gRGV0YWlsczogXCIrXHJcbmdldEV4Y2VwdGlvblN0cmluZ1JlcChleCkrXCJcIik7fX1cclxuZXhwYW5zaW9uKz1jaGlsZExpbmVzLmpvaW4oXCIsXCIrbmV3TGluZSkrbmV3TGluZStpbmRlbnRhdGlvbitcIl1cIjtyZXR1cm4gZXhwYW5zaW9uO31lbHNlIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopPT1cIltvYmplY3QgRGF0ZV1cIil7cmV0dXJuIG9iai50b1N0cmluZygpO31lbHNlIGlmKHR5cGVvZiBvYmo9PVwib2JqZWN0XCImJmRlcHRoPjApe29iamVjdHNFeHBhbmRlZC5wdXNoKG9iaik7ZXhwYW5zaW9uPVwie1wiK25ld0xpbmU7Y2hpbGREZXB0aD1kZXB0aC0xO2NoaWxkSW5kZW50YXRpb249aW5kZW50YXRpb24rXCIgIFwiO2NoaWxkTGluZXM9W107Zm9yKGkgaW4gb2JqKXt0cnl7Y2hpbGRFeHBhbnNpb249ZG9Gb3JtYXQob2JqW2ldLGNoaWxkRGVwdGgsY2hpbGRJbmRlbnRhdGlvbik7Y2hpbGRMaW5lcy5wdXNoKGNoaWxkSW5kZW50YXRpb24raStcIjogXCIrY2hpbGRFeHBhbnNpb24pO31jYXRjaChleCl7Y2hpbGRMaW5lcy5wdXNoKGNoaWxkSW5kZW50YXRpb24raStcIjogRXJyb3IgZm9ybWF0dGluZyBwcm9wZXJ0eS4gRGV0YWlsczogXCIrXHJcbmdldEV4Y2VwdGlvblN0cmluZ1JlcChleCkpO319XHJcbmV4cGFuc2lvbis9Y2hpbGRMaW5lcy5qb2luKFwiLFwiK25ld0xpbmUpK25ld0xpbmUraW5kZW50YXRpb24rXCJ9XCI7cmV0dXJuIGV4cGFuc2lvbjt9ZWxzZXtyZXR1cm4gZm9ybWF0U3RyaW5nKHRvU3RyKG9iaikpO319XHJcbnJldHVybiBkb0Zvcm1hdChvYmosZGVwdGgsaW5kZW50YXRpb24pO31cclxudmFyIFNpbXBsZURhdGVGb3JtYXQ7KGZ1bmN0aW9uKCl7dmFyIHJlZ2V4PS8oJ1teJ10qJyl8KEcrfHkrfE0rfHcrfFcrfEQrfGQrfEYrfEUrfGErfEgrfGsrfEsrfGgrfG0rfHMrfFMrfForKXwoW2EtekEtWl0rKXwoW15hLXpBLVonXSspLzt2YXIgbW9udGhOYW1lcz1bXCJKYW51YXJ5XCIsXCJGZWJydWFyeVwiLFwiTWFyY2hcIixcIkFwcmlsXCIsXCJNYXlcIixcIkp1bmVcIixcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl07dmFyIGRheU5hbWVzPVtcIlN1bmRheVwiLFwiTW9uZGF5XCIsXCJUdWVzZGF5XCIsXCJXZWRuZXNkYXlcIixcIlRodXJzZGF5XCIsXCJGcmlkYXlcIixcIlNhdHVyZGF5XCJdO3ZhciBURVhUMj0wLFRFWFQzPTEsTlVNQkVSPTIsWUVBUj0zLE1PTlRIPTQsVElNRVpPTkU9NTt2YXIgdHlwZXM9e0c6VEVYVDIseTpZRUFSLE06TU9OVEgsdzpOVU1CRVIsVzpOVU1CRVIsRDpOVU1CRVIsZDpOVU1CRVIsRjpOVU1CRVIsRTpURVhUMyxhOlRFWFQyLEg6TlVNQkVSLGs6TlVNQkVSLEs6TlVNQkVSLGg6TlVNQkVSLG06TlVNQkVSLHM6TlVNQkVSLFM6TlVNQkVSLFo6VElNRVpPTkV9O3ZhciBPTkVfREFZPTI0KjYwKjYwKjEwMDA7dmFyIE9ORV9XRUVLPTcqT05FX0RBWTt2YXIgREVGQVVMVF9NSU5JTUFMX0RBWVNfSU5fRklSU1RfV0VFSz0xO3ZhciBuZXdEYXRlQXRNaWRuaWdodD1mdW5jdGlvbih5ZWFyLG1vbnRoLGRheSl7dmFyIGQ9bmV3IERhdGUoeWVhcixtb250aCxkYXksMCwwLDApO2Quc2V0TWlsbGlzZWNvbmRzKDApO3JldHVybiBkO307RGF0ZS5wcm90b3R5cGUuZ2V0RGlmZmVyZW5jZT1mdW5jdGlvbihkYXRlKXtyZXR1cm4gdGhpcy5nZXRUaW1lKCktZGF0ZS5nZXRUaW1lKCk7fTtEYXRlLnByb3RvdHlwZS5pc0JlZm9yZT1mdW5jdGlvbihkKXtyZXR1cm4gdGhpcy5nZXRUaW1lKCk8ZC5nZXRUaW1lKCk7fTtEYXRlLnByb3RvdHlwZS5nZXRVVENUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIERhdGUuVVRDKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCksdGhpcy5nZXRIb3VycygpLHRoaXMuZ2V0TWludXRlcygpLHRoaXMuZ2V0U2Vjb25kcygpLHRoaXMuZ2V0TWlsbGlzZWNvbmRzKCkpO307RGF0ZS5wcm90b3R5cGUuZ2V0VGltZVNpbmNlPWZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLmdldFVUQ1RpbWUoKS1kLmdldFVUQ1RpbWUoKTt9O0RhdGUucHJvdG90eXBlLmdldFByZXZpb3VzU3VuZGF5PWZ1bmN0aW9uKCl7dmFyIG1pZGRheT1uZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpLDEyLDAsMCk7dmFyIHByZXZpb3VzU3VuZGF5PW5ldyBEYXRlKG1pZGRheS5nZXRUaW1lKCktdGhpcy5nZXREYXkoKSpPTkVfREFZKTtyZXR1cm4gbmV3RGF0ZUF0TWlkbmlnaHQocHJldmlvdXNTdW5kYXkuZ2V0RnVsbFllYXIoKSxwcmV2aW91c1N1bmRheS5nZXRNb250aCgpLHByZXZpb3VzU3VuZGF5LmdldERhdGUoKSk7fTtEYXRlLnByb3RvdHlwZS5nZXRXZWVrSW5ZZWFyPWZ1bmN0aW9uKG1pbmltYWxEYXlzSW5GaXJzdFdlZWspe2lmKGlzVW5kZWZpbmVkKHRoaXMubWluaW1hbERheXNJbkZpcnN0V2Vlaykpe21pbmltYWxEYXlzSW5GaXJzdFdlZWs9REVGQVVMVF9NSU5JTUFMX0RBWVNfSU5fRklSU1RfV0VFSzt9XHJcbnZhciBwcmV2aW91c1N1bmRheT10aGlzLmdldFByZXZpb3VzU3VuZGF5KCk7dmFyIHN0YXJ0T2ZZZWFyPW5ld0RhdGVBdE1pZG5pZ2h0KHRoaXMuZ2V0RnVsbFllYXIoKSwwLDEpO3ZhciBudW1iZXJPZlN1bmRheXM9cHJldmlvdXNTdW5kYXkuaXNCZWZvcmUoc3RhcnRPZlllYXIpPzA6MStNYXRoLmZsb29yKHByZXZpb3VzU3VuZGF5LmdldFRpbWVTaW5jZShzdGFydE9mWWVhcikvT05FX1dFRUspO3ZhciBudW1iZXJPZkRheXNJbkZpcnN0V2Vlaz03LXN0YXJ0T2ZZZWFyLmdldERheSgpO3ZhciB3ZWVrSW5ZZWFyPW51bWJlck9mU3VuZGF5cztpZihudW1iZXJPZkRheXNJbkZpcnN0V2VlazxtaW5pbWFsRGF5c0luRmlyc3RXZWVrKXt3ZWVrSW5ZZWFyLS07fVxyXG5yZXR1cm4gd2Vla0luWWVhcjt9O0RhdGUucHJvdG90eXBlLmdldFdlZWtJbk1vbnRoPWZ1bmN0aW9uKG1pbmltYWxEYXlzSW5GaXJzdFdlZWspe2lmKGlzVW5kZWZpbmVkKHRoaXMubWluaW1hbERheXNJbkZpcnN0V2Vlaykpe21pbmltYWxEYXlzSW5GaXJzdFdlZWs9REVGQVVMVF9NSU5JTUFMX0RBWVNfSU5fRklSU1RfV0VFSzt9XHJcbnZhciBwcmV2aW91c1N1bmRheT10aGlzLmdldFByZXZpb3VzU3VuZGF5KCk7dmFyIHN0YXJ0T2ZNb250aD1uZXdEYXRlQXRNaWRuaWdodCh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpO3ZhciBudW1iZXJPZlN1bmRheXM9cHJldmlvdXNTdW5kYXkuaXNCZWZvcmUoc3RhcnRPZk1vbnRoKT8wOjErTWF0aC5mbG9vcihwcmV2aW91c1N1bmRheS5nZXRUaW1lU2luY2Uoc3RhcnRPZk1vbnRoKS9PTkVfV0VFSyk7dmFyIG51bWJlck9mRGF5c0luRmlyc3RXZWVrPTctc3RhcnRPZk1vbnRoLmdldERheSgpO3ZhciB3ZWVrSW5Nb250aD1udW1iZXJPZlN1bmRheXM7aWYobnVtYmVyT2ZEYXlzSW5GaXJzdFdlZWs+PW1pbmltYWxEYXlzSW5GaXJzdFdlZWspe3dlZWtJbk1vbnRoKys7fVxyXG5yZXR1cm4gd2Vla0luTW9udGg7fTtEYXRlLnByb3RvdHlwZS5nZXREYXlJblllYXI9ZnVuY3Rpb24oKXt2YXIgc3RhcnRPZlllYXI9bmV3RGF0ZUF0TWlkbmlnaHQodGhpcy5nZXRGdWxsWWVhcigpLDAsMSk7cmV0dXJuIDErTWF0aC5mbG9vcih0aGlzLmdldFRpbWVTaW5jZShzdGFydE9mWWVhcikvT05FX0RBWSk7fTtTaW1wbGVEYXRlRm9ybWF0PWZ1bmN0aW9uKGZvcm1hdFN0cmluZyl7dGhpcy5mb3JtYXRTdHJpbmc9Zm9ybWF0U3RyaW5nO307U2ltcGxlRGF0ZUZvcm1hdC5wcm90b3R5cGUuc2V0TWluaW1hbERheXNJbkZpcnN0V2Vlaz1mdW5jdGlvbihkYXlzKXt0aGlzLm1pbmltYWxEYXlzSW5GaXJzdFdlZWs9ZGF5czt9O1NpbXBsZURhdGVGb3JtYXQucHJvdG90eXBlLmdldE1pbmltYWxEYXlzSW5GaXJzdFdlZWs9ZnVuY3Rpb24oKXtyZXR1cm4gaXNVbmRlZmluZWQodGhpcy5taW5pbWFsRGF5c0luRmlyc3RXZWVrKT9ERUZBVUxUX01JTklNQUxfREFZU19JTl9GSVJTVF9XRUVLOnRoaXMubWluaW1hbERheXNJbkZpcnN0V2Vlazt9O3ZhciBwYWRXaXRoWmVyb2VzPWZ1bmN0aW9uKHN0cixsZW4pe3doaWxlKHN0ci5sZW5ndGg8bGVuKXtzdHI9XCIwXCIrc3RyO31cclxucmV0dXJuIHN0cjt9O3ZhciBmb3JtYXRUZXh0PWZ1bmN0aW9uKGRhdGEsbnVtYmVyT2ZMZXR0ZXJzLG1pbkxlbmd0aCl7cmV0dXJuKG51bWJlck9mTGV0dGVycz49NCk/ZGF0YTpkYXRhLnN1YnN0cigwLE1hdGgubWF4KG1pbkxlbmd0aCxudW1iZXJPZkxldHRlcnMpKTt9O3ZhciBmb3JtYXROdW1iZXI9ZnVuY3Rpb24oZGF0YSxudW1iZXJPZkxldHRlcnMpe3ZhciBkYXRhU3RyaW5nPVwiXCIrZGF0YTtyZXR1cm4gcGFkV2l0aFplcm9lcyhkYXRhU3RyaW5nLG51bWJlck9mTGV0dGVycyk7fTtTaW1wbGVEYXRlRm9ybWF0LnByb3RvdHlwZS5mb3JtYXQ9ZnVuY3Rpb24oZGF0ZSl7dmFyIGZvcm1hdHRlZFN0cmluZz1cIlwiO3ZhciByZXN1bHQ7dmFyIHNlYXJjaFN0cmluZz10aGlzLmZvcm1hdFN0cmluZzt3aGlsZSgocmVzdWx0PXJlZ2V4LmV4ZWMoc2VhcmNoU3RyaW5nKSkpe3ZhciBxdW90ZWRTdHJpbmc9cmVzdWx0WzFdO3ZhciBwYXR0ZXJuTGV0dGVycz1yZXN1bHRbMl07dmFyIG90aGVyTGV0dGVycz1yZXN1bHRbM107dmFyIG90aGVyQ2hhcmFjdGVycz1yZXN1bHRbNF07aWYocXVvdGVkU3RyaW5nKXtpZihxdW90ZWRTdHJpbmc9PVwiJydcIil7Zm9ybWF0dGVkU3RyaW5nKz1cIidcIjt9ZWxzZXtmb3JtYXR0ZWRTdHJpbmcrPXF1b3RlZFN0cmluZy5zdWJzdHJpbmcoMSxxdW90ZWRTdHJpbmcubGVuZ3RoLTEpO319ZWxzZSBpZihvdGhlckxldHRlcnMpe31lbHNlIGlmKG90aGVyQ2hhcmFjdGVycyl7Zm9ybWF0dGVkU3RyaW5nKz1vdGhlckNoYXJhY3RlcnM7fWVsc2UgaWYocGF0dGVybkxldHRlcnMpe3ZhciBwYXR0ZXJuTGV0dGVyPXBhdHRlcm5MZXR0ZXJzLmNoYXJBdCgwKTt2YXIgbnVtYmVyT2ZMZXR0ZXJzPXBhdHRlcm5MZXR0ZXJzLmxlbmd0aDt2YXIgcmF3RGF0YT1cIlwiO3N3aXRjaChwYXR0ZXJuTGV0dGVyKXtjYXNlXCJHXCI6cmF3RGF0YT1cIkFEXCI7YnJlYWs7Y2FzZVwieVwiOnJhd0RhdGE9ZGF0ZS5nZXRGdWxsWWVhcigpO2JyZWFrO2Nhc2VcIk1cIjpyYXdEYXRhPWRhdGUuZ2V0TW9udGgoKTticmVhaztjYXNlXCJ3XCI6cmF3RGF0YT1kYXRlLmdldFdlZWtJblllYXIodGhpcy5nZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKCkpO2JyZWFrO2Nhc2VcIldcIjpyYXdEYXRhPWRhdGUuZ2V0V2Vla0luTW9udGgodGhpcy5nZXRNaW5pbWFsRGF5c0luRmlyc3RXZWVrKCkpO2JyZWFrO2Nhc2VcIkRcIjpyYXdEYXRhPWRhdGUuZ2V0RGF5SW5ZZWFyKCk7YnJlYWs7Y2FzZVwiZFwiOnJhd0RhdGE9ZGF0ZS5nZXREYXRlKCk7YnJlYWs7Y2FzZVwiRlwiOnJhd0RhdGE9MStNYXRoLmZsb29yKChkYXRlLmdldERhdGUoKS0xKS83KTticmVhaztjYXNlXCJFXCI6cmF3RGF0YT1kYXlOYW1lc1tkYXRlLmdldERheSgpXTticmVhaztjYXNlXCJhXCI6cmF3RGF0YT0oZGF0ZS5nZXRIb3VycygpPj0xMik/XCJQTVwiOlwiQU1cIjticmVhaztjYXNlXCJIXCI6cmF3RGF0YT1kYXRlLmdldEhvdXJzKCk7YnJlYWs7Y2FzZVwia1wiOnJhd0RhdGE9ZGF0ZS5nZXRIb3VycygpfHwyNDticmVhaztjYXNlXCJLXCI6cmF3RGF0YT1kYXRlLmdldEhvdXJzKCklMTI7YnJlYWs7Y2FzZVwiaFwiOnJhd0RhdGE9KGRhdGUuZ2V0SG91cnMoKSUxMil8fDEyO2JyZWFrO2Nhc2VcIm1cIjpyYXdEYXRhPWRhdGUuZ2V0TWludXRlcygpO2JyZWFrO2Nhc2VcInNcIjpyYXdEYXRhPWRhdGUuZ2V0U2Vjb25kcygpO2JyZWFrO2Nhc2VcIlNcIjpyYXdEYXRhPWRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7YnJlYWs7Y2FzZVwiWlwiOnJhd0RhdGE9ZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO2JyZWFrO31cclxuc3dpdGNoKHR5cGVzW3BhdHRlcm5MZXR0ZXJdKXtjYXNlIFRFWFQyOmZvcm1hdHRlZFN0cmluZys9Zm9ybWF0VGV4dChyYXdEYXRhLG51bWJlck9mTGV0dGVycywyKTticmVhaztjYXNlIFRFWFQzOmZvcm1hdHRlZFN0cmluZys9Zm9ybWF0VGV4dChyYXdEYXRhLG51bWJlck9mTGV0dGVycywzKTticmVhaztjYXNlIE5VTUJFUjpmb3JtYXR0ZWRTdHJpbmcrPWZvcm1hdE51bWJlcihyYXdEYXRhLG51bWJlck9mTGV0dGVycyk7YnJlYWs7Y2FzZSBZRUFSOmlmKG51bWJlck9mTGV0dGVyczw9Myl7dmFyIGRhdGFTdHJpbmc9XCJcIityYXdEYXRhO2Zvcm1hdHRlZFN0cmluZys9ZGF0YVN0cmluZy5zdWJzdHIoMiwyKTt9ZWxzZXtmb3JtYXR0ZWRTdHJpbmcrPWZvcm1hdE51bWJlcihyYXdEYXRhLG51bWJlck9mTGV0dGVycyk7fVxyXG5icmVhaztjYXNlIE1PTlRIOmlmKG51bWJlck9mTGV0dGVycz49Myl7Zm9ybWF0dGVkU3RyaW5nKz1mb3JtYXRUZXh0KG1vbnRoTmFtZXNbcmF3RGF0YV0sbnVtYmVyT2ZMZXR0ZXJzLG51bWJlck9mTGV0dGVycyk7fWVsc2V7Zm9ybWF0dGVkU3RyaW5nKz1mb3JtYXROdW1iZXIocmF3RGF0YSsxLG51bWJlck9mTGV0dGVycyk7fVxyXG5icmVhaztjYXNlIFRJTUVaT05FOnZhciBpc1Bvc2l0aXZlPShyYXdEYXRhPjApO3ZhciBwcmVmaXg9aXNQb3NpdGl2ZT9cIi1cIjpcIitcIjt2YXIgYWJzRGF0YT1NYXRoLmFicyhyYXdEYXRhKTt2YXIgaG91cnM9XCJcIitNYXRoLmZsb29yKGFic0RhdGEvNjApO2hvdXJzPXBhZFdpdGhaZXJvZXMoaG91cnMsMik7dmFyIG1pbnV0ZXM9XCJcIisoYWJzRGF0YSU2MCk7bWludXRlcz1wYWRXaXRoWmVyb2VzKG1pbnV0ZXMsMik7Zm9ybWF0dGVkU3RyaW5nKz1wcmVmaXgraG91cnMrbWludXRlczticmVhazt9fVxyXG5zZWFyY2hTdHJpbmc9c2VhcmNoU3RyaW5nLnN1YnN0cihyZXN1bHQuaW5kZXgrcmVzdWx0WzBdLmxlbmd0aCk7fVxyXG5yZXR1cm4gZm9ybWF0dGVkU3RyaW5nO307fSkoKTtsb2c0amF2YXNjcmlwdC5TaW1wbGVEYXRlRm9ybWF0PVNpbXBsZURhdGVGb3JtYXQ7ZnVuY3Rpb24gUGF0dGVybkxheW91dChwYXR0ZXJuKXtpZihwYXR0ZXJuKXt0aGlzLnBhdHRlcm49cGF0dGVybjt9ZWxzZXt0aGlzLnBhdHRlcm49UGF0dGVybkxheW91dC5ERUZBVUxUX0NPTlZFUlNJT05fUEFUVEVSTjt9XHJcbnRoaXMuY3VzdG9tRmllbGRzPVtdO31cclxuUGF0dGVybkxheW91dC5UVENDX0NPTlZFUlNJT05fUEFUVEVSTj1cIiVyICVwICVjIC0gJW0lblwiO1BhdHRlcm5MYXlvdXQuREVGQVVMVF9DT05WRVJTSU9OX1BBVFRFUk49XCIlbSVuXCI7UGF0dGVybkxheW91dC5JU084NjAxX0RBVEVGT1JNQVQ9XCJ5eXl5LU1NLWRkIEhIOm1tOnNzLFNTU1wiO1BhdHRlcm5MYXlvdXQuREFURVRJTUVfREFURUZPUk1BVD1cImRkIE1NTSB5eXl5IEhIOm1tOnNzLFNTU1wiO1BhdHRlcm5MYXlvdXQuQUJTT0xVVEVUSU1FX0RBVEVGT1JNQVQ9XCJISDptbTpzcyxTU1NcIjtQYXR0ZXJuTGF5b3V0LnByb3RvdHlwZT1uZXcgTGF5b3V0KCk7UGF0dGVybkxheW91dC5wcm90b3R5cGUuZm9ybWF0PWZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7dmFyIHJlZ2V4PS8lKC0/WzAtOV0rKT8oXFwuP1swLTldKyk/KFthY2RmbU1ucHIlXSkoXFx7KFteXFx9XSspXFx9KT98KFteJV0rKS87dmFyIGZvcm1hdHRlZFN0cmluZz1cIlwiO3ZhciByZXN1bHQ7dmFyIHNlYXJjaFN0cmluZz10aGlzLnBhdHRlcm47d2hpbGUoKHJlc3VsdD1yZWdleC5leGVjKHNlYXJjaFN0cmluZykpKXt2YXIgbWF0Y2hlZFN0cmluZz1yZXN1bHRbMF07dmFyIHBhZGRpbmc9cmVzdWx0WzFdO3ZhciB0cnVuY2F0aW9uPXJlc3VsdFsyXTt2YXIgY29udmVyc2lvbkNoYXJhY3Rlcj1yZXN1bHRbM107dmFyIHNwZWNpZmllcj1yZXN1bHRbNV07dmFyIHRleHQ9cmVzdWx0WzZdO2lmKHRleHQpe2Zvcm1hdHRlZFN0cmluZys9XCJcIit0ZXh0O31lbHNle3ZhciByZXBsYWNlbWVudD1cIlwiO3N3aXRjaChjb252ZXJzaW9uQ2hhcmFjdGVyKXtjYXNlXCJhXCI6Y2FzZVwibVwiOnZhciBkZXB0aD0wO2lmKHNwZWNpZmllcil7ZGVwdGg9cGFyc2VJbnQoc3BlY2lmaWVyLDEwKTtpZihpc05hTihkZXB0aCkpe2hhbmRsZUVycm9yKFwiUGF0dGVybkxheW91dC5mb3JtYXQ6IGludmFsaWQgc3BlY2lmaWVyICdcIitcclxuc3BlY2lmaWVyK1wiJyBmb3IgY29udmVyc2lvbiBjaGFyYWN0ZXIgJ1wiK2NvbnZlcnNpb25DaGFyYWN0ZXIrXCInIC0gc2hvdWxkIGJlIGEgbnVtYmVyXCIpO2RlcHRoPTA7fX1cclxudmFyIG1lc3NhZ2VzPShjb252ZXJzaW9uQ2hhcmFjdGVyPT09XCJhXCIpP2xvZ2dpbmdFdmVudC5tZXNzYWdlc1swXTpsb2dnaW5nRXZlbnQubWVzc2FnZXM7Zm9yKHZhciBpPTAsbGVuPW1lc3NhZ2VzLmxlbmd0aDtpPGxlbjtpKyspe2lmKGk+MCYmKHJlcGxhY2VtZW50LmNoYXJBdChyZXBsYWNlbWVudC5sZW5ndGgtMSkhPT1cIiBcIikpe3JlcGxhY2VtZW50Kz1cIiBcIjt9XHJcbmlmKGRlcHRoPT09MCl7cmVwbGFjZW1lbnQrPW1lc3NhZ2VzW2ldO31lbHNle3JlcGxhY2VtZW50Kz1mb3JtYXRPYmplY3RFeHBhbnNpb24obWVzc2FnZXNbaV0sZGVwdGgpO319XHJcbmJyZWFrO2Nhc2VcImNcIjp2YXIgbG9nZ2VyTmFtZT1sb2dnaW5nRXZlbnQubG9nZ2VyLm5hbWU7aWYoc3BlY2lmaWVyKXt2YXIgcHJlY2lzaW9uPXBhcnNlSW50KHNwZWNpZmllciwxMCk7dmFyIGxvZ2dlck5hbWVCaXRzPWxvZ2dpbmdFdmVudC5sb2dnZXIubmFtZS5zcGxpdChcIi5cIik7aWYocHJlY2lzaW9uPj1sb2dnZXJOYW1lQml0cy5sZW5ndGgpe3JlcGxhY2VtZW50PWxvZ2dlck5hbWU7fWVsc2V7cmVwbGFjZW1lbnQ9bG9nZ2VyTmFtZUJpdHMuc2xpY2UobG9nZ2VyTmFtZUJpdHMubGVuZ3RoLXByZWNpc2lvbikuam9pbihcIi5cIik7fX1lbHNle3JlcGxhY2VtZW50PWxvZ2dlck5hbWU7fVxyXG5icmVhaztjYXNlXCJkXCI6dmFyIGRhdGVGb3JtYXQ9UGF0dGVybkxheW91dC5JU084NjAxX0RBVEVGT1JNQVQ7aWYoc3BlY2lmaWVyKXtkYXRlRm9ybWF0PXNwZWNpZmllcjtpZihkYXRlRm9ybWF0PT1cIklTTzg2MDFcIil7ZGF0ZUZvcm1hdD1QYXR0ZXJuTGF5b3V0LklTTzg2MDFfREFURUZPUk1BVDt9ZWxzZSBpZihkYXRlRm9ybWF0PT1cIkFCU09MVVRFXCIpe2RhdGVGb3JtYXQ9UGF0dGVybkxheW91dC5BQlNPTFVURVRJTUVfREFURUZPUk1BVDt9ZWxzZSBpZihkYXRlRm9ybWF0PT1cIkRBVEVcIil7ZGF0ZUZvcm1hdD1QYXR0ZXJuTGF5b3V0LkRBVEVUSU1FX0RBVEVGT1JNQVQ7fX1cclxucmVwbGFjZW1lbnQ9KG5ldyBTaW1wbGVEYXRlRm9ybWF0KGRhdGVGb3JtYXQpKS5mb3JtYXQobG9nZ2luZ0V2ZW50LnRpbWVTdGFtcCk7YnJlYWs7Y2FzZVwiZlwiOmlmKHRoaXMuaGFzQ3VzdG9tRmllbGRzKCkpe3ZhciBmaWVsZEluZGV4PTA7aWYoc3BlY2lmaWVyKXtmaWVsZEluZGV4PXBhcnNlSW50KHNwZWNpZmllciwxMCk7aWYoaXNOYU4oZmllbGRJbmRleCkpe2hhbmRsZUVycm9yKFwiUGF0dGVybkxheW91dC5mb3JtYXQ6IGludmFsaWQgc3BlY2lmaWVyICdcIitcclxuc3BlY2lmaWVyK1wiJyBmb3IgY29udmVyc2lvbiBjaGFyYWN0ZXIgJ2YnIC0gc2hvdWxkIGJlIGEgbnVtYmVyXCIpO31lbHNlIGlmKGZpZWxkSW5kZXg9PT0wKXtoYW5kbGVFcnJvcihcIlBhdHRlcm5MYXlvdXQuZm9ybWF0OiBpbnZhbGlkIHNwZWNpZmllciAnXCIrXHJcbnNwZWNpZmllcitcIicgZm9yIGNvbnZlcnNpb24gY2hhcmFjdGVyICdmJyAtIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm9cIik7fWVsc2UgaWYoZmllbGRJbmRleD50aGlzLmN1c3RvbUZpZWxkcy5sZW5ndGgpe2hhbmRsZUVycm9yKFwiUGF0dGVybkxheW91dC5mb3JtYXQ6IGludmFsaWQgc3BlY2lmaWVyICdcIitcclxuc3BlY2lmaWVyK1wiJyBmb3IgY29udmVyc2lvbiBjaGFyYWN0ZXIgJ2YnIC0gdGhlcmUgYXJlbid0IHRoYXQgbWFueSBjdXN0b20gZmllbGRzXCIpO31lbHNle2ZpZWxkSW5kZXg9ZmllbGRJbmRleC0xO319XHJcbnZhciB2YWw9dGhpcy5jdXN0b21GaWVsZHNbZmllbGRJbmRleF0udmFsdWU7aWYodHlwZW9mIHZhbD09XCJmdW5jdGlvblwiKXt2YWw9dmFsKHRoaXMsbG9nZ2luZ0V2ZW50KTt9XHJcbnJlcGxhY2VtZW50PXZhbDt9XHJcbmJyZWFrO2Nhc2VcIm5cIjpyZXBsYWNlbWVudD1uZXdMaW5lO2JyZWFrO2Nhc2VcInBcIjpyZXBsYWNlbWVudD1sb2dnaW5nRXZlbnQubGV2ZWwubmFtZTticmVhaztjYXNlXCJyXCI6cmVwbGFjZW1lbnQ9XCJcIitsb2dnaW5nRXZlbnQudGltZVN0YW1wLmdldERpZmZlcmVuY2UoYXBwbGljYXRpb25TdGFydERhdGUpO2JyZWFrO2Nhc2VcIiVcIjpyZXBsYWNlbWVudD1cIiVcIjticmVhaztkZWZhdWx0OnJlcGxhY2VtZW50PW1hdGNoZWRTdHJpbmc7YnJlYWs7fVxyXG52YXIgbDtpZih0cnVuY2F0aW9uKXtsPXBhcnNlSW50KHRydW5jYXRpb24uc3Vic3RyKDEpLDEwKTt2YXIgc3RyTGVuPXJlcGxhY2VtZW50Lmxlbmd0aDtpZihsPHN0ckxlbil7cmVwbGFjZW1lbnQ9cmVwbGFjZW1lbnQuc3Vic3RyaW5nKHN0ckxlbi1sLHN0ckxlbik7fX1cclxuaWYocGFkZGluZyl7aWYocGFkZGluZy5jaGFyQXQoMCk9PVwiLVwiKXtsPXBhcnNlSW50KHBhZGRpbmcuc3Vic3RyKDEpLDEwKTt3aGlsZShyZXBsYWNlbWVudC5sZW5ndGg8bCl7cmVwbGFjZW1lbnQrPVwiIFwiO319ZWxzZXtsPXBhcnNlSW50KHBhZGRpbmcsMTApO3doaWxlKHJlcGxhY2VtZW50Lmxlbmd0aDxsKXtyZXBsYWNlbWVudD1cIiBcIityZXBsYWNlbWVudDt9fX1cclxuZm9ybWF0dGVkU3RyaW5nKz1yZXBsYWNlbWVudDt9XHJcbnNlYXJjaFN0cmluZz1zZWFyY2hTdHJpbmcuc3Vic3RyKHJlc3VsdC5pbmRleCtyZXN1bHRbMF0ubGVuZ3RoKTt9XHJcbnJldHVybiBmb3JtYXR0ZWRTdHJpbmc7fTtQYXR0ZXJuTGF5b3V0LnByb3RvdHlwZS5pZ25vcmVzVGhyb3dhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRydWU7fTtQYXR0ZXJuTGF5b3V0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiUGF0dGVybkxheW91dFwiO307bG9nNGphdmFzY3JpcHQuUGF0dGVybkxheW91dD1QYXR0ZXJuTGF5b3V0O2Z1bmN0aW9uIEFsZXJ0QXBwZW5kZXIoKXt9XHJcbkFsZXJ0QXBwZW5kZXIucHJvdG90eXBlPW5ldyBBcHBlbmRlcigpO0FsZXJ0QXBwZW5kZXIucHJvdG90eXBlLmxheW91dD1uZXcgU2ltcGxlTGF5b3V0KCk7QWxlcnRBcHBlbmRlci5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7YWxlcnQodGhpcy5nZXRMYXlvdXQoKS5mb3JtYXRXaXRoRXhjZXB0aW9uKGxvZ2dpbmdFdmVudCkpO307QWxlcnRBcHBlbmRlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkFsZXJ0QXBwZW5kZXJcIjt9O2xvZzRqYXZhc2NyaXB0LkFsZXJ0QXBwZW5kZXI9QWxlcnRBcHBlbmRlcjtmdW5jdGlvbiBCcm93c2VyQ29uc29sZUFwcGVuZGVyKCl7fVxyXG5Ccm93c2VyQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZT1uZXcgbG9nNGphdmFzY3JpcHQuQXBwZW5kZXIoKTtCcm93c2VyQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS5sYXlvdXQ9bmV3IE51bGxMYXlvdXQoKTtCcm93c2VyQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS50aHJlc2hvbGQ9TGV2ZWwuREVCVUc7QnJvd3NlckNvbnNvbGVBcHBlbmRlci5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7dmFyIGFwcGVuZGVyPXRoaXM7dmFyIGdldEZvcm1hdHRlZE1lc3NhZ2U9ZnVuY3Rpb24oY29uY2F0ZW5hdGUpe3ZhciBmb3JtYXR0ZWRNZXNzYWdlPWFwcGVuZGVyLmdldExheW91dCgpLmZvcm1hdFdpdGhFeGNlcHRpb24obG9nZ2luZ0V2ZW50KTtyZXR1cm4odHlwZW9mIGZvcm1hdHRlZE1lc3NhZ2U9PVwic3RyaW5nXCIpPyhjb25jYXRlbmF0ZT9mb3JtYXR0ZWRNZXNzYWdlOltmb3JtYXR0ZWRNZXNzYWdlXSk6KGNvbmNhdGVuYXRlP2Zvcm1hdHRlZE1lc3NhZ2Uuam9pbihcIiBcIik6Zm9ybWF0dGVkTWVzc2FnZSk7fTt2YXIgY29uc29sZT13aW5kb3cuY29uc29sZTtpZihjb25zb2xlJiZjb25zb2xlLmxvZyl7dmFyIGNvbnNvbGVNZXRob2ROYW1lO2lmKGNvbnNvbGUuZGVidWcmJkxldmVsLkRFQlVHLmlzR3JlYXRlck9yRXF1YWwobG9nZ2luZ0V2ZW50LmxldmVsKSl7Y29uc29sZU1ldGhvZE5hbWU9XCJkZWJ1Z1wiO31lbHNlIGlmKGNvbnNvbGUuaW5mbyYmTGV2ZWwuSU5GTy5lcXVhbHMobG9nZ2luZ0V2ZW50LmxldmVsKSl7Y29uc29sZU1ldGhvZE5hbWU9XCJpbmZvXCI7fWVsc2UgaWYoY29uc29sZS53YXJuJiZMZXZlbC5XQVJOLmVxdWFscyhsb2dnaW5nRXZlbnQubGV2ZWwpKXtjb25zb2xlTWV0aG9kTmFtZT1cIndhcm5cIjt9ZWxzZSBpZihjb25zb2xlLmVycm9yJiZsb2dnaW5nRXZlbnQubGV2ZWwuaXNHcmVhdGVyT3JFcXVhbChMZXZlbC5FUlJPUikpe2NvbnNvbGVNZXRob2ROYW1lPVwiZXJyb3JcIjt9ZWxzZXtjb25zb2xlTWV0aG9kTmFtZT1cImxvZ1wiO31cclxuaWYodHlwZW9mIGNvbnNvbGVbY29uc29sZU1ldGhvZE5hbWVdLmFwcGx5PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGVbY29uc29sZU1ldGhvZE5hbWVdLmFwcGx5KGNvbnNvbGUsZ2V0Rm9ybWF0dGVkTWVzc2FnZShmYWxzZSkpO31lbHNle2NvbnNvbGVbY29uc29sZU1ldGhvZE5hbWVdKGdldEZvcm1hdHRlZE1lc3NhZ2UodHJ1ZSkpO319ZWxzZSBpZigodHlwZW9mIG9wZXJhIT1cInVuZGVmaW5lZFwiKSYmb3BlcmEucG9zdEVycm9yKXtvcGVyYS5wb3N0RXJyb3IoZ2V0Rm9ybWF0dGVkTWVzc2FnZSh0cnVlKSk7fX07QnJvd3NlckNvbnNvbGVBcHBlbmRlci5wcm90b3R5cGUuZ3JvdXA9ZnVuY3Rpb24obmFtZSl7aWYod2luZG93LmNvbnNvbGUmJndpbmRvdy5jb25zb2xlLmdyb3VwKXt3aW5kb3cuY29uc29sZS5ncm91cChuYW1lKTt9fTtCcm93c2VyQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS5ncm91cEVuZD1mdW5jdGlvbigpe2lmKHdpbmRvdy5jb25zb2xlJiZ3aW5kb3cuY29uc29sZS5ncm91cEVuZCl7d2luZG93LmNvbnNvbGUuZ3JvdXBFbmQoKTt9fTtCcm93c2VyQ29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiQnJvd3NlckNvbnNvbGVBcHBlbmRlclwiO307bG9nNGphdmFzY3JpcHQuQnJvd3NlckNvbnNvbGVBcHBlbmRlcj1Ccm93c2VyQ29uc29sZUFwcGVuZGVyO3ZhciB4aHJGYWN0b3J5PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO307dmFyIHhtbEh0dHBGYWN0b3JpZXM9W3hockZhY3RvcnksZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKTt9LGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7fV07dmFyIHdpdGhDcmVkZW50aWFsc1N1cHBvcnRlZD1mYWxzZTt2YXIgZ2V0WG1sSHR0cD1mdW5jdGlvbihlcnJvckhhbmRsZXIpe3ZhciB4bWxIdHRwPW51bGwsZmFjdG9yeTtmb3IodmFyIGk9MCxsZW49eG1sSHR0cEZhY3Rvcmllcy5sZW5ndGg7aTxsZW47aSsrKXtmYWN0b3J5PXhtbEh0dHBGYWN0b3JpZXNbaV07dHJ5e3htbEh0dHA9ZmFjdG9yeSgpO3dpdGhDcmVkZW50aWFsc1N1cHBvcnRlZD0oZmFjdG9yeT09eGhyRmFjdG9yeSYmKFwid2l0aENyZWRlbnRpYWxzXCJpbiB4bWxIdHRwKSk7Z2V0WG1sSHR0cD1mYWN0b3J5O3JldHVybiB4bWxIdHRwO31jYXRjaChlKXt9fVxyXG5pZihlcnJvckhhbmRsZXIpe2Vycm9ySGFuZGxlcigpO31lbHNle2hhbmRsZUVycm9yKFwiZ2V0WG1sSHR0cDogdW5hYmxlIHRvIG9idGFpbiBYTUxIdHRwUmVxdWVzdCBvYmplY3RcIik7fX07ZnVuY3Rpb24gaXNIdHRwUmVxdWVzdFN1Y2Nlc3NmdWwoeG1sSHR0cCl7cmV0dXJuIGlzVW5kZWZpbmVkKHhtbEh0dHAuc3RhdHVzKXx8eG1sSHR0cC5zdGF0dXM9PT0wfHwoeG1sSHR0cC5zdGF0dXM+PTIwMCYmeG1sSHR0cC5zdGF0dXM8MzAwKXx8eG1sSHR0cC5zdGF0dXM9PTEyMjM7fVxyXG5mdW5jdGlvbiBBamF4QXBwZW5kZXIodXJsLHdpdGhDcmVkZW50aWFscyl7dmFyIGFwcGVuZGVyPXRoaXM7dmFyIGlzU3VwcG9ydGVkPXRydWU7aWYoIXVybCl7aGFuZGxlRXJyb3IoXCJBamF4QXBwZW5kZXI6IFVSTCBtdXN0IGJlIHNwZWNpZmllZCBpbiBjb25zdHJ1Y3RvclwiKTtpc1N1cHBvcnRlZD1mYWxzZTt9XHJcbnZhciB0aW1lZD10aGlzLmRlZmF1bHRzLnRpbWVkO3ZhciB3YWl0Rm9yUmVzcG9uc2U9dGhpcy5kZWZhdWx0cy53YWl0Rm9yUmVzcG9uc2U7dmFyIGJhdGNoU2l6ZT10aGlzLmRlZmF1bHRzLmJhdGNoU2l6ZTt2YXIgdGltZXJJbnRlcnZhbD10aGlzLmRlZmF1bHRzLnRpbWVySW50ZXJ2YWw7dmFyIHJlcXVlc3RTdWNjZXNzQ2FsbGJhY2s9dGhpcy5kZWZhdWx0cy5yZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrO3ZhciBmYWlsQ2FsbGJhY2s9dGhpcy5kZWZhdWx0cy5mYWlsQ2FsbGJhY2s7dmFyIHBvc3RWYXJOYW1lPXRoaXMuZGVmYXVsdHMucG9zdFZhck5hbWU7dmFyIHNlbmRBbGxPblVubG9hZD10aGlzLmRlZmF1bHRzLnNlbmRBbGxPblVubG9hZDt2YXIgY29udGVudFR5cGU9dGhpcy5kZWZhdWx0cy5jb250ZW50VHlwZTt2YXIgc2Vzc2lvbklkPW51bGw7dmFyIHF1ZXVlZExvZ2dpbmdFdmVudHM9W107dmFyIHF1ZXVlZFJlcXVlc3RzPVtdO3ZhciBoZWFkZXJzPVtdO3ZhciBzZW5kaW5nPWZhbHNlO3ZhciBpbml0aWFsaXplZD1mYWxzZTtmdW5jdGlvbiBjaGVja0NhbkNvbmZpZ3VyZShjb25maWdPcHRpb25OYW1lKXtpZihpbml0aWFsaXplZCl7aGFuZGxlRXJyb3IoXCJBamF4QXBwZW5kZXI6IGNvbmZpZ3VyYXRpb24gb3B0aW9uICdcIitcclxuY29uZmlnT3B0aW9uTmFtZStcIicgbWF5IG5vdCBiZSBzZXQgYWZ0ZXIgdGhlIGFwcGVuZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkXCIpO3JldHVybiBmYWxzZTt9XHJcbnJldHVybiB0cnVlO31cclxudGhpcy5nZXRTZXNzaW9uSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gc2Vzc2lvbklkO307dGhpcy5zZXRTZXNzaW9uSWQ9ZnVuY3Rpb24oc2Vzc2lvbklkUGFyYW0pe3Nlc3Npb25JZD1leHRyYWN0U3RyaW5nRnJvbVBhcmFtKHNlc3Npb25JZFBhcmFtLG51bGwpO3RoaXMubGF5b3V0LnNldEN1c3RvbUZpZWxkKFwic2Vzc2lvbmlkXCIsc2Vzc2lvbklkKTt9O3RoaXMuc2V0TGF5b3V0PWZ1bmN0aW9uKGxheW91dFBhcmFtKXtpZihjaGVja0NhbkNvbmZpZ3VyZShcImxheW91dFwiKSl7dGhpcy5sYXlvdXQ9bGF5b3V0UGFyYW07aWYoc2Vzc2lvbklkIT09bnVsbCl7dGhpcy5zZXRTZXNzaW9uSWQoc2Vzc2lvbklkKTt9fX07dGhpcy5pc1RpbWVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRpbWVkO307dGhpcy5zZXRUaW1lZD1mdW5jdGlvbih0aW1lZFBhcmFtKXtpZihjaGVja0NhbkNvbmZpZ3VyZShcInRpbWVkXCIpKXt0aW1lZD1ib29sKHRpbWVkUGFyYW0pO319O3RoaXMuZ2V0VGltZXJJbnRlcnZhbD1mdW5jdGlvbigpe3JldHVybiB0aW1lckludGVydmFsO307dGhpcy5zZXRUaW1lckludGVydmFsPWZ1bmN0aW9uKHRpbWVySW50ZXJ2YWxQYXJhbSl7aWYoY2hlY2tDYW5Db25maWd1cmUoXCJ0aW1lckludGVydmFsXCIpKXt0aW1lckludGVydmFsPWV4dHJhY3RJbnRGcm9tUGFyYW0odGltZXJJbnRlcnZhbFBhcmFtLHRpbWVySW50ZXJ2YWwpO319O3RoaXMuaXNXYWl0Rm9yUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm4gd2FpdEZvclJlc3BvbnNlO307dGhpcy5zZXRXYWl0Rm9yUmVzcG9uc2U9ZnVuY3Rpb24od2FpdEZvclJlc3BvbnNlUGFyYW0pe2lmKGNoZWNrQ2FuQ29uZmlndXJlKFwid2FpdEZvclJlc3BvbnNlXCIpKXt3YWl0Rm9yUmVzcG9uc2U9Ym9vbCh3YWl0Rm9yUmVzcG9uc2VQYXJhbSk7fX07dGhpcy5nZXRCYXRjaFNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gYmF0Y2hTaXplO307dGhpcy5zZXRCYXRjaFNpemU9ZnVuY3Rpb24oYmF0Y2hTaXplUGFyYW0pe2lmKGNoZWNrQ2FuQ29uZmlndXJlKFwiYmF0Y2hTaXplXCIpKXtiYXRjaFNpemU9ZXh0cmFjdEludEZyb21QYXJhbShiYXRjaFNpemVQYXJhbSxiYXRjaFNpemUpO319O3RoaXMuaXNTZW5kQWxsT25VbmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gc2VuZEFsbE9uVW5sb2FkO307dGhpcy5zZXRTZW5kQWxsT25VbmxvYWQ9ZnVuY3Rpb24oc2VuZEFsbE9uVW5sb2FkUGFyYW0pe2lmKGNoZWNrQ2FuQ29uZmlndXJlKFwic2VuZEFsbE9uVW5sb2FkXCIpKXtzZW5kQWxsT25VbmxvYWQ9ZXh0cmFjdEJvb2xlYW5Gcm9tUGFyYW0oc2VuZEFsbE9uVW5sb2FkUGFyYW0sc2VuZEFsbE9uVW5sb2FkKTt9fTt0aGlzLnNldFJlcXVlc3RTdWNjZXNzQ2FsbGJhY2s9ZnVuY3Rpb24ocmVxdWVzdFN1Y2Nlc3NDYWxsYmFja1BhcmFtKXtyZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrPWV4dHJhY3RGdW5jdGlvbkZyb21QYXJhbShyZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrUGFyYW0scmVxdWVzdFN1Y2Nlc3NDYWxsYmFjayk7fTt0aGlzLnNldEZhaWxDYWxsYmFjaz1mdW5jdGlvbihmYWlsQ2FsbGJhY2tQYXJhbSl7ZmFpbENhbGxiYWNrPWV4dHJhY3RGdW5jdGlvbkZyb21QYXJhbShmYWlsQ2FsbGJhY2tQYXJhbSxmYWlsQ2FsbGJhY2spO307dGhpcy5nZXRQb3N0VmFyTmFtZT1mdW5jdGlvbigpe3JldHVybiBwb3N0VmFyTmFtZTt9O3RoaXMuc2V0UG9zdFZhck5hbWU9ZnVuY3Rpb24ocG9zdFZhck5hbWVQYXJhbSl7aWYoY2hlY2tDYW5Db25maWd1cmUoXCJwb3N0VmFyTmFtZVwiKSl7cG9zdFZhck5hbWU9ZXh0cmFjdFN0cmluZ0Zyb21QYXJhbShwb3N0VmFyTmFtZVBhcmFtLHBvc3RWYXJOYW1lKTt9fTt0aGlzLmdldEhlYWRlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gaGVhZGVyczt9O3RoaXMuYWRkSGVhZGVyPWZ1bmN0aW9uKG5hbWUsdmFsdWUpe2lmKG5hbWUudG9Mb3dlckNhc2UoKT09XCJjb250ZW50LXR5cGVcIil7Y29udGVudFR5cGU9dmFsdWU7fWVsc2V7aGVhZGVycy5wdXNoKHtuYW1lOm5hbWUsdmFsdWU6dmFsdWV9KTt9fTtmdW5jdGlvbiBzZW5kQWxsKCl7aWYoaXNTdXBwb3J0ZWQmJmVuYWJsZWQpe3NlbmRpbmc9dHJ1ZTt2YXIgY3VycmVudFJlcXVlc3RCYXRjaDtpZih3YWl0Rm9yUmVzcG9uc2Upe2lmKHF1ZXVlZFJlcXVlc3RzLmxlbmd0aD4wKXtjdXJyZW50UmVxdWVzdEJhdGNoPXF1ZXVlZFJlcXVlc3RzLnNoaWZ0KCk7c2VuZFJlcXVlc3QocHJlcGFyZVBvc3REYXRhKGN1cnJlbnRSZXF1ZXN0QmF0Y2gpLHNlbmRBbGwpO31lbHNle3NlbmRpbmc9ZmFsc2U7aWYodGltZWQpe3NjaGVkdWxlU2VuZGluZygpO319fWVsc2V7d2hpbGUoKGN1cnJlbnRSZXF1ZXN0QmF0Y2g9cXVldWVkUmVxdWVzdHMuc2hpZnQoKSkpe3NlbmRSZXF1ZXN0KHByZXBhcmVQb3N0RGF0YShjdXJyZW50UmVxdWVzdEJhdGNoKSk7fVxyXG5zZW5kaW5nPWZhbHNlO2lmKHRpbWVkKXtzY2hlZHVsZVNlbmRpbmcoKTt9fX19XHJcbnRoaXMuc2VuZEFsbD1zZW5kQWxsO2Z1bmN0aW9uIHNlbmRBbGxSZW1haW5pbmcoKXt2YXIgc2VuZGluZ0FueXRoaW5nPWZhbHNlO2lmKGlzU3VwcG9ydGVkJiZlbmFibGVkKXt2YXIgYWN0dWFsQmF0Y2hTaXplPWFwcGVuZGVyLmdldExheW91dCgpLmFsbG93QmF0Y2hpbmcoKT9iYXRjaFNpemU6MTt2YXIgY3VycmVudExvZ2dpbmdFdmVudDt2YXIgYmF0Y2hlZExvZ2dpbmdFdmVudHM9W107d2hpbGUoKGN1cnJlbnRMb2dnaW5nRXZlbnQ9cXVldWVkTG9nZ2luZ0V2ZW50cy5zaGlmdCgpKSl7YmF0Y2hlZExvZ2dpbmdFdmVudHMucHVzaChjdXJyZW50TG9nZ2luZ0V2ZW50KTtpZihxdWV1ZWRMb2dnaW5nRXZlbnRzLmxlbmd0aD49YWN0dWFsQmF0Y2hTaXplKXtxdWV1ZWRSZXF1ZXN0cy5wdXNoKGJhdGNoZWRMb2dnaW5nRXZlbnRzKTtiYXRjaGVkTG9nZ2luZ0V2ZW50cz1bXTt9fVxyXG5pZihiYXRjaGVkTG9nZ2luZ0V2ZW50cy5sZW5ndGg+MCl7cXVldWVkUmVxdWVzdHMucHVzaChiYXRjaGVkTG9nZ2luZ0V2ZW50cyk7fVxyXG5zZW5kaW5nQW55dGhpbmc9KHF1ZXVlZFJlcXVlc3RzLmxlbmd0aD4wKTt3YWl0Rm9yUmVzcG9uc2U9ZmFsc2U7dGltZWQ9ZmFsc2U7c2VuZEFsbCgpO31cclxucmV0dXJuIHNlbmRpbmdBbnl0aGluZzt9XHJcbnRoaXMuc2VuZEFsbFJlbWFpbmluZz1zZW5kQWxsUmVtYWluaW5nO2Z1bmN0aW9uIHByZXBhcmVQb3N0RGF0YShiYXRjaGVkTG9nZ2luZ0V2ZW50cyl7dmFyIGZvcm1hdHRlZE1lc3NhZ2VzPVtdO3ZhciBjdXJyZW50TG9nZ2luZ0V2ZW50O3ZhciBwb3N0RGF0YT1cIlwiO3doaWxlKChjdXJyZW50TG9nZ2luZ0V2ZW50PWJhdGNoZWRMb2dnaW5nRXZlbnRzLnNoaWZ0KCkpKXtmb3JtYXR0ZWRNZXNzYWdlcy5wdXNoKGFwcGVuZGVyLmdldExheW91dCgpLmZvcm1hdFdpdGhFeGNlcHRpb24oY3VycmVudExvZ2dpbmdFdmVudCkpO31cclxuaWYoYmF0Y2hlZExvZ2dpbmdFdmVudHMubGVuZ3RoPT0xKXtwb3N0RGF0YT1mb3JtYXR0ZWRNZXNzYWdlcy5qb2luKFwiXCIpO31lbHNle3Bvc3REYXRhPWFwcGVuZGVyLmdldExheW91dCgpLmJhdGNoSGVhZGVyK1xyXG5mb3JtYXR0ZWRNZXNzYWdlcy5qb2luKGFwcGVuZGVyLmdldExheW91dCgpLmJhdGNoU2VwYXJhdG9yKStcclxuYXBwZW5kZXIuZ2V0TGF5b3V0KCkuYmF0Y2hGb290ZXI7fVxyXG5pZihjb250ZW50VHlwZT09YXBwZW5kZXIuZGVmYXVsdHMuY29udGVudFR5cGUpe3Bvc3REYXRhPWFwcGVuZGVyLmdldExheW91dCgpLnJldHVybnNQb3N0RGF0YT9wb3N0RGF0YTp1cmxFbmNvZGUocG9zdFZhck5hbWUpK1wiPVwiK3VybEVuY29kZShwb3N0RGF0YSk7aWYocG9zdERhdGEubGVuZ3RoPjApe3Bvc3REYXRhKz1cIiZcIjt9XHJcbnBvc3REYXRhKz1cImxheW91dD1cIit1cmxFbmNvZGUoYXBwZW5kZXIuZ2V0TGF5b3V0KCkudG9TdHJpbmcoKSk7fVxyXG5yZXR1cm4gcG9zdERhdGE7fVxyXG5mdW5jdGlvbiBzY2hlZHVsZVNlbmRpbmcoKXt3aW5kb3cuc2V0VGltZW91dChzZW5kQWxsLHRpbWVySW50ZXJ2YWwpO31cclxuZnVuY3Rpb24geG1sSHR0cEVycm9ySGFuZGxlcigpe3ZhciBtc2c9XCJBamF4QXBwZW5kZXI6IGNvdWxkIG5vdCBjcmVhdGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiBBamF4QXBwZW5kZXIgZGlzYWJsZWRcIjtoYW5kbGVFcnJvcihtc2cpO2lzU3VwcG9ydGVkPWZhbHNlO2lmKGZhaWxDYWxsYmFjayl7ZmFpbENhbGxiYWNrKG1zZyk7fX1cclxuZnVuY3Rpb24gc2VuZFJlcXVlc3QocG9zdERhdGEsc3VjY2Vzc0NhbGxiYWNrKXt0cnl7dmFyIHhtbEh0dHA9Z2V0WG1sSHR0cCh4bWxIdHRwRXJyb3JIYW5kbGVyKTtpZihpc1N1cHBvcnRlZCl7eG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZih4bWxIdHRwLnJlYWR5U3RhdGU9PTQpe2lmKGlzSHR0cFJlcXVlc3RTdWNjZXNzZnVsKHhtbEh0dHApKXtpZihyZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrKXtyZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrKHhtbEh0dHApO31cclxuaWYoc3VjY2Vzc0NhbGxiYWNrKXtzdWNjZXNzQ2FsbGJhY2soeG1sSHR0cCk7fX1lbHNle3ZhciBtc2c9XCJBamF4QXBwZW5kZXIuYXBwZW5kOiBYTUxIdHRwUmVxdWVzdCByZXF1ZXN0IHRvIFVSTCBcIitcclxudXJsK1wiIHJldHVybmVkIHN0YXR1cyBjb2RlIFwiK3htbEh0dHAuc3RhdHVzO2hhbmRsZUVycm9yKG1zZyk7aWYoZmFpbENhbGxiYWNrKXtmYWlsQ2FsbGJhY2sobXNnKTt9fVxyXG54bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZT1lbXB0eUZ1bmN0aW9uO3htbEh0dHA9bnVsbDt9fTt4bWxIdHRwLm9wZW4oXCJQT1NUXCIsdXJsLHRydWUpO2lmKHdpdGhDcmVkZW50aWFscyYmd2l0aENyZWRlbnRpYWxzU3VwcG9ydGVkKXt4bWxIdHRwLndpdGhDcmVkZW50aWFscz10cnVlO31cclxudHJ5e2Zvcih2YXIgaT0wLGhlYWRlcjtoZWFkZXI9aGVhZGVyc1tpKytdOyl7eG1sSHR0cC5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlci5uYW1lLGhlYWRlci52YWx1ZSk7fVxyXG54bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixjb250ZW50VHlwZSk7fWNhdGNoKGhlYWRlckV4KXt2YXIgbXNnPVwiQWpheEFwcGVuZGVyLmFwcGVuZDogeW91ciBicm93c2VyJ3MgWE1MSHR0cFJlcXVlc3QgaW1wbGVtZW50YXRpb25cIitcIiBkb2VzIG5vdCBzdXBwb3J0IHNldFJlcXVlc3RIZWFkZXIsIHRoZXJlZm9yZSBjYW5ub3QgcG9zdCBkYXRhLiBBamF4QXBwZW5kZXIgZGlzYWJsZWRcIjtoYW5kbGVFcnJvcihtc2cpO2lzU3VwcG9ydGVkPWZhbHNlO2lmKGZhaWxDYWxsYmFjayl7ZmFpbENhbGxiYWNrKG1zZyk7fVxyXG5yZXR1cm47fVxyXG54bWxIdHRwLnNlbmQocG9zdERhdGEpO319Y2F0Y2goZXgpe3ZhciBlcnJNc2c9XCJBamF4QXBwZW5kZXIuYXBwZW5kOiBlcnJvciBzZW5kaW5nIGxvZyBtZXNzYWdlIHRvIFwiK3VybDtoYW5kbGVFcnJvcihlcnJNc2csZXgpO2lzU3VwcG9ydGVkPWZhbHNlO2lmKGZhaWxDYWxsYmFjayl7ZmFpbENhbGxiYWNrKGVyck1zZytcIi4gRGV0YWlsczogXCIrZ2V0RXhjZXB0aW9uU3RyaW5nUmVwKGV4KSk7fX19XHJcbnRoaXMuYXBwZW5kPWZ1bmN0aW9uKGxvZ2dpbmdFdmVudCl7aWYoaXNTdXBwb3J0ZWQpe2lmKCFpbml0aWFsaXplZCl7aW5pdCgpO31cclxucXVldWVkTG9nZ2luZ0V2ZW50cy5wdXNoKGxvZ2dpbmdFdmVudCk7dmFyIGFjdHVhbEJhdGNoU2l6ZT10aGlzLmdldExheW91dCgpLmFsbG93QmF0Y2hpbmcoKT9iYXRjaFNpemU6MTtpZihxdWV1ZWRMb2dnaW5nRXZlbnRzLmxlbmd0aD49YWN0dWFsQmF0Y2hTaXplKXt2YXIgY3VycmVudExvZ2dpbmdFdmVudDt2YXIgYmF0Y2hlZExvZ2dpbmdFdmVudHM9W107d2hpbGUoKGN1cnJlbnRMb2dnaW5nRXZlbnQ9cXVldWVkTG9nZ2luZ0V2ZW50cy5zaGlmdCgpKSl7YmF0Y2hlZExvZ2dpbmdFdmVudHMucHVzaChjdXJyZW50TG9nZ2luZ0V2ZW50KTt9XHJcbnF1ZXVlZFJlcXVlc3RzLnB1c2goYmF0Y2hlZExvZ2dpbmdFdmVudHMpO2lmKCF0aW1lZCYmKCF3YWl0Rm9yUmVzcG9uc2V8fCh3YWl0Rm9yUmVzcG9uc2UmJiFzZW5kaW5nKSkpe3NlbmRBbGwoKTt9fX19O2Z1bmN0aW9uIGluaXQoKXtpbml0aWFsaXplZD10cnVlO2lmKHNlbmRBbGxPblVubG9hZCl7dmFyIG9sZEJlZm9yZVVubG9hZD13aW5kb3cub25iZWZvcmV1bmxvYWQ7d2luZG93Lm9uYmVmb3JldW5sb2FkPWZ1bmN0aW9uKCl7aWYob2xkQmVmb3JlVW5sb2FkKXtvbGRCZWZvcmVVbmxvYWQoKTt9XHJcbnNlbmRBbGxSZW1haW5pbmcoKTt9O31cclxuaWYodGltZWQpe3NjaGVkdWxlU2VuZGluZygpO319fVxyXG5BamF4QXBwZW5kZXIucHJvdG90eXBlPW5ldyBBcHBlbmRlcigpO0FqYXhBcHBlbmRlci5wcm90b3R5cGUuZGVmYXVsdHM9e3dhaXRGb3JSZXNwb25zZTpmYWxzZSx0aW1lZDpmYWxzZSx0aW1lckludGVydmFsOjEwMDAsYmF0Y2hTaXplOjEsc2VuZEFsbE9uVW5sb2FkOmZhbHNlLHJlcXVlc3RTdWNjZXNzQ2FsbGJhY2s6bnVsbCxmYWlsQ2FsbGJhY2s6bnVsbCxwb3N0VmFyTmFtZTpcImRhdGFcIixjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifTtBamF4QXBwZW5kZXIucHJvdG90eXBlLmxheW91dD1uZXcgSHR0cFBvc3REYXRhTGF5b3V0KCk7QWpheEFwcGVuZGVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiQWpheEFwcGVuZGVyXCI7fTtsb2c0amF2YXNjcmlwdC5BamF4QXBwZW5kZXI9QWpheEFwcGVuZGVyO2Z1bmN0aW9uIHNldENvb2tpZShuYW1lLHZhbHVlLGRheXMscGF0aCl7dmFyIGV4cGlyZXM7cGF0aD1wYXRoP1wiOyBwYXRoPVwiK3BhdGg6XCJcIjtpZihkYXlzKXt2YXIgZGF0ZT1uZXcgRGF0ZSgpO2RhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSsoZGF5cyoyNCo2MCo2MCoxMDAwKSk7ZXhwaXJlcz1cIjsgZXhwaXJlcz1cIitkYXRlLnRvR01UU3RyaW5nKCk7fWVsc2V7ZXhwaXJlcz1cIlwiO31cclxuZG9jdW1lbnQuY29va2llPWVzY2FwZShuYW1lKStcIj1cIitlc2NhcGUodmFsdWUpK2V4cGlyZXMrcGF0aDt9XHJcbmZ1bmN0aW9uIGdldENvb2tpZShuYW1lKXt2YXIgbmFtZUVxdWFscz1lc2NhcGUobmFtZSkrXCI9XCI7dmFyIGNhPWRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIik7Zm9yKHZhciBpPTAsbGVuPWNhLmxlbmd0aDtpPGxlbjtpKyspe3ZhciBjPWNhW2ldO3doaWxlKGMuY2hhckF0KDApPT09XCIgXCIpe2M9Yy5zdWJzdHJpbmcoMSxjLmxlbmd0aCk7fVxyXG5pZihjLmluZGV4T2YobmFtZUVxdWFscyk9PT0wKXtyZXR1cm4gdW5lc2NhcGUoYy5zdWJzdHJpbmcobmFtZUVxdWFscy5sZW5ndGgsYy5sZW5ndGgpKTt9fVxyXG5yZXR1cm4gbnVsbDt9XHJcbmZ1bmN0aW9uIGdldEJhc2VVcmwoKXt2YXIgc2NyaXB0cz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtmb3IodmFyIGk9MCxsZW49c2NyaXB0cy5sZW5ndGg7aTxsZW47KytpKXtpZihzY3JpcHRzW2ldLnNyYy5pbmRleE9mKFwibG9nNGphdmFzY3JpcHRcIikhPS0xKXt2YXIgbGFzdFNsYXNoPXNjcmlwdHNbaV0uc3JjLmxhc3RJbmRleE9mKFwiL1wiKTtyZXR1cm4obGFzdFNsYXNoPT0tMSk/XCJcIjpzY3JpcHRzW2ldLnNyYy5zdWJzdHIoMCxsYXN0U2xhc2grMSk7fX1cclxucmV0dXJuIG51bGw7fVxyXG5mdW5jdGlvbiBpc0xvYWRlZCh3aW4pe3RyeXtyZXR1cm4gYm9vbCh3aW4ubG9hZGVkKTt9Y2F0Y2goZXgpe3JldHVybiBmYWxzZTt9fVxyXG52YXIgQ29uc29sZUFwcGVuZGVyOyhmdW5jdGlvbigpe3ZhciBnZXRDb25zb2xlSHRtbExpbmVzPWZ1bmN0aW9uKCl7cmV0dXJuWyc8IURPQ1RZUEUgaHRtbCBQVUJMSUMgXCItLy9XM0MvL0RURCBYSFRNTCAxLjAgU3RyaWN0Ly9FTlwiIFwiaHR0cDovL3d3dy53My5vcmcvVFIveGh0bWwxL0RURC94aHRtbDEtc3RyaWN0LmR0ZFwiPicsJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiIGxhbmc9XCJlblwiIHhtbDpsYW5nPVwiZW5cIj4nLCc8aGVhZD4nLCc8dGl0bGU+bG9nNGphdmFzY3JpcHQ8L3RpdGxlPicsJzxtZXRhIGh0dHAtZXF1aXY9XCJDb250ZW50LVR5cGVcIiBjb250ZW50PVwidGV4dC9odG1sOyBjaGFyc2V0PXV0Zi04XCIgLz4nLCc8IS0tIE1ha2UgSUU4IGJlaGF2ZSBsaWtlIElFNywgaGF2aW5nIGdvbmUgdG8gYWxsIHRoZSB0cm91YmxlIG9mIG1ha2luZyBJRSB3b3JrIC0tPicsJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9N1wiIC8+JywnPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+dmFyIGlzSWUgPSBmYWxzZSwgaXNJZVByZTcgPSBmYWxzZTs8L3NjcmlwdD4nLCc8IS0tW2lmIElFXT48c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj5pc0llID0gdHJ1ZTwvc2NyaXB0PjwhW2VuZGlmXS0tPicsJzwhLS1baWYgbHQgSUUgN10+PHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+aXNJZVByZTcgPSB0cnVlPC9zY3JpcHQ+PCFbZW5kaWZdLS0+JywnPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCI+JywnLy88IVtDREFUQVsnLCd2YXIgbG9nZ2luZ0VuYWJsZWQ9dHJ1ZTt2YXIgbG9nUXVldWVkRXZlbnRzVGltZXI9bnVsbDt2YXIgbG9nRW50cmllcz1bXTt2YXIgbG9nRW50cmllc0FuZFNlcGFyYXRvcnM9W107dmFyIGxvZ0l0ZW1zPVtdO3ZhciByZW5kZXJEZWxheT0xMDA7dmFyIHVucmVuZGVyZWRMb2dJdGVtc0V4aXN0PWZhbHNlO3ZhciByb290R3JvdXAsY3VycmVudEdyb3VwPW51bGw7dmFyIGxvYWRlZD1mYWxzZTt2YXIgY3VycmVudExvZ0l0ZW09bnVsbDt2YXIgbG9nTWFpbkNvbnRhaW5lcjtmdW5jdGlvbiBjb3B5UHJvcGVydGllcyhvYmoscHJvcHMpe2Zvcih2YXIgaSBpbiBwcm9wcyl7b2JqW2ldPXByb3BzW2ldO319JywnZnVuY3Rpb24gTG9nSXRlbSgpe30nLCdMb2dJdGVtLnByb3RvdHlwZT17bWFpbkNvbnRhaW5lcjpudWxsLHdyYXBwZWRDb250YWluZXI6bnVsbCx1bndyYXBwZWRDb250YWluZXI6bnVsbCxncm91cDpudWxsLGFwcGVuZFRvTG9nOmZ1bmN0aW9uKCl7Zm9yKHZhciBpPTAsbGVuPXRoaXMuZWxlbWVudENvbnRhaW5lcnMubGVuZ3RoO2k8bGVuO2krKyl7dGhpcy5lbGVtZW50Q29udGFpbmVyc1tpXS5hcHBlbmRUb0xvZygpO30nLCd0aGlzLmdyb3VwLnVwZGF0ZSgpO30sZG9SZW1vdmU6ZnVuY3Rpb24oZG9VcGRhdGUscmVtb3ZlRnJvbUdyb3VwKXtpZih0aGlzLnJlbmRlcmVkKXtmb3IodmFyIGk9MCxsZW49dGhpcy5lbGVtZW50Q29udGFpbmVycy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLmVsZW1lbnRDb250YWluZXJzW2ldLnJlbW92ZSgpO30nLCd0aGlzLnVud3JhcHBlZEVsZW1lbnRDb250YWluZXI9bnVsbDt0aGlzLndyYXBwZWRFbGVtZW50Q29udGFpbmVyPW51bGw7dGhpcy5tYWluRWxlbWVudENvbnRhaW5lcj1udWxsO30nLCdpZih0aGlzLmdyb3VwJiZyZW1vdmVGcm9tR3JvdXApe3RoaXMuZ3JvdXAucmVtb3ZlQ2hpbGQodGhpcyxkb1VwZGF0ZSk7fScsJ2lmKHRoaXM9PT1jdXJyZW50TG9nSXRlbSl7Y3VycmVudExvZ0l0ZW09bnVsbDt9fSxyZW1vdmU6ZnVuY3Rpb24oZG9VcGRhdGUscmVtb3ZlRnJvbUdyb3VwKXt0aGlzLmRvUmVtb3ZlKGRvVXBkYXRlLHJlbW92ZUZyb21Hcm91cCk7fSxyZW5kZXI6ZnVuY3Rpb24oKXt9LGFjY2VwdDpmdW5jdGlvbih2aXNpdG9yKXt2aXNpdG9yLnZpc2l0KHRoaXMpO30sZ2V0VW53cmFwcGVkRG9tQ29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JvdXAudW53cmFwcGVkRWxlbWVudENvbnRhaW5lci5jb250ZW50RGl2O30sZ2V0V3JhcHBlZERvbUNvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdyb3VwLndyYXBwZWRFbGVtZW50Q29udGFpbmVyLmNvbnRlbnREaXY7fSxnZXRNYWluRG9tQ29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JvdXAubWFpbkVsZW1lbnRDb250YWluZXIuY29udGVudERpdjt9fTtMb2dJdGVtLnNlcmlhbGl6ZWRJdGVtS2V5cz17TE9HX0VOVFJZOjAsR1JPVVBfU1RBUlQ6MSxHUk9VUF9FTkQ6Mn07ZnVuY3Rpb24gTG9nSXRlbUNvbnRhaW5lckVsZW1lbnQoKXt9JywnTG9nSXRlbUNvbnRhaW5lckVsZW1lbnQucHJvdG90eXBlPXthcHBlbmRUb0xvZzpmdW5jdGlvbigpe3ZhciBpbnNlcnRCZWZvcmVGaXJzdD0obmV3ZXN0QXRUb3AmJnRoaXMuY29udGFpbmVyRG9tTm9kZS5oYXNDaGlsZE5vZGVzKCkpO2lmKGluc2VydEJlZm9yZUZpcnN0KXt0aGlzLmNvbnRhaW5lckRvbU5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubWFpbkRpdix0aGlzLmNvbnRhaW5lckRvbU5vZGUuZmlyc3RDaGlsZCk7fWVsc2V7dGhpcy5jb250YWluZXJEb21Ob2RlLmFwcGVuZENoaWxkKHRoaXMubWFpbkRpdik7fX19O2Z1bmN0aW9uIFNlcGFyYXRvckVsZW1lbnRDb250YWluZXIoY29udGFpbmVyRG9tTm9kZSl7dGhpcy5jb250YWluZXJEb21Ob2RlPWNvbnRhaW5lckRvbU5vZGU7dGhpcy5tYWluRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dGhpcy5tYWluRGl2LmNsYXNzTmFtZT1cInNlcGFyYXRvclwiO3RoaXMubWFpbkRpdi5pbm5lckhUTUw9XCImbmJzcDtcIjt9JywnU2VwYXJhdG9yRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGU9bmV3IExvZ0l0ZW1Db250YWluZXJFbGVtZW50KCk7U2VwYXJhdG9yRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhpcy5tYWluRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tYWluRGl2KTt0aGlzLm1haW5EaXY9bnVsbDt9O2Z1bmN0aW9uIFNlcGFyYXRvcigpe3RoaXMucmVuZGVyZWQ9ZmFsc2U7fScsJ1NlcGFyYXRvci5wcm90b3R5cGU9bmV3IExvZ0l0ZW0oKTtjb3B5UHJvcGVydGllcyhTZXBhcmF0b3IucHJvdG90eXBlLHtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgY29udGFpbmVyRG9tTm9kZT10aGlzLmdyb3VwLmNvbnRlbnREaXY7aWYoaXNJZSl7dGhpcy51bndyYXBwZWRFbGVtZW50Q29udGFpbmVyPW5ldyBTZXBhcmF0b3JFbGVtZW50Q29udGFpbmVyKHRoaXMuZ2V0VW53cmFwcGVkRG9tQ29udGFpbmVyKCkpO3RoaXMud3JhcHBlZEVsZW1lbnRDb250YWluZXI9bmV3IFNlcGFyYXRvckVsZW1lbnRDb250YWluZXIodGhpcy5nZXRXcmFwcGVkRG9tQ29udGFpbmVyKCkpO3RoaXMuZWxlbWVudENvbnRhaW5lcnM9W3RoaXMudW53cmFwcGVkRWxlbWVudENvbnRhaW5lcix0aGlzLndyYXBwZWRFbGVtZW50Q29udGFpbmVyXTt9ZWxzZXt0aGlzLm1haW5FbGVtZW50Q29udGFpbmVyPW5ldyBTZXBhcmF0b3JFbGVtZW50Q29udGFpbmVyKHRoaXMuZ2V0TWFpbkRvbUNvbnRhaW5lcigpKTt0aGlzLmVsZW1lbnRDb250YWluZXJzPVt0aGlzLm1haW5FbGVtZW50Q29udGFpbmVyXTt9JywndGhpcy5jb250ZW50PXRoaXMuZm9ybWF0dGVkTWVzc2FnZTt0aGlzLnJlbmRlcmVkPXRydWU7fX0pO2Z1bmN0aW9uIEdyb3VwRWxlbWVudENvbnRhaW5lcihncm91cCxjb250YWluZXJEb21Ob2RlLGlzUm9vdCxpc1dyYXBwZWQpe3RoaXMuZ3JvdXA9Z3JvdXA7dGhpcy5jb250YWluZXJEb21Ob2RlPWNvbnRhaW5lckRvbU5vZGU7dGhpcy5pc1Jvb3Q9aXNSb290O3RoaXMuaXNXcmFwcGVkPWlzV3JhcHBlZDt0aGlzLmV4cGFuZGFibGU9ZmFsc2U7aWYodGhpcy5pc1Jvb3Qpe2lmKGlzSWUpe3RoaXMuY29udGVudERpdj1sb2dNYWluQ29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO3RoaXMuY29udGVudERpdi5pZD10aGlzLmlzV3JhcHBlZD9cImxvZ193cmFwcGVkXCI6XCJsb2dfdW53cmFwcGVkXCI7fWVsc2V7dGhpcy5jb250ZW50RGl2PWxvZ01haW5Db250YWluZXI7fX1lbHNle3ZhciBncm91cEVsZW1lbnRDb250YWluZXI9dGhpczt0aGlzLm1haW5EaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0aGlzLm1haW5EaXYuY2xhc3NOYW1lPVwiZ3JvdXBcIjt0aGlzLmhlYWRpbmdEaXY9dGhpcy5tYWluRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO3RoaXMuaGVhZGluZ0Rpdi5jbGFzc05hbWU9XCJncm91cGhlYWRpbmdcIjt0aGlzLmV4cGFuZGVyPXRoaXMuaGVhZGluZ0Rpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7dGhpcy5leHBhbmRlci5jbGFzc05hbWU9XCJleHBhbmRlciB1bnNlbGVjdGFibGUgZ3JleWVkb3V0XCI7dGhpcy5leHBhbmRlci51bnNlbGVjdGFibGU9dHJ1ZTt2YXIgZXhwYW5kZXJUZXh0PXRoaXMuZ3JvdXAuZXhwYW5kZWQ/XCItXCI6XCIrXCI7dGhpcy5leHBhbmRlclRleHROb2RlPXRoaXMuZXhwYW5kZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZXhwYW5kZXJUZXh0KSk7dGhpcy5oZWFkaW5nRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiK3RoaXMuZ3JvdXAubmFtZSkpO3RoaXMuY29udGVudERpdj10aGlzLm1haW5EaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7dmFyIGNvbnRlbnRDc3NDbGFzcz10aGlzLmdyb3VwLmV4cGFuZGVkP1wiZXhwYW5kZWRcIjpcImNvbGxhcHNlZFwiO3RoaXMuY29udGVudERpdi5jbGFzc05hbWU9XCJncm91cGNvbnRlbnQgXCIrY29udGVudENzc0NsYXNzO3RoaXMuZXhwYW5kZXIub25jbGljaz1mdW5jdGlvbigpe2lmKGdyb3VwRWxlbWVudENvbnRhaW5lci5ncm91cC5leHBhbmRhYmxlKXtncm91cEVsZW1lbnRDb250YWluZXIuZ3JvdXAudG9nZ2xlRXhwYW5kZWQoKTt9fTt9fScsJ0dyb3VwRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGU9bmV3IExvZ0l0ZW1Db250YWluZXJFbGVtZW50KCk7Y29weVByb3BlcnRpZXMoR3JvdXBFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZSx7dG9nZ2xlRXhwYW5kZWQ6ZnVuY3Rpb24oKXtpZighdGhpcy5pc1Jvb3Qpe3ZhciBvbGRDc3NDbGFzcyxuZXdDc3NDbGFzcyxleHBhbmRlclRleHQ7aWYodGhpcy5ncm91cC5leHBhbmRlZCl7bmV3Q3NzQ2xhc3M9XCJleHBhbmRlZFwiO29sZENzc0NsYXNzPVwiY29sbGFwc2VkXCI7ZXhwYW5kZXJUZXh0PVwiLVwiO31lbHNle25ld0Nzc0NsYXNzPVwiY29sbGFwc2VkXCI7b2xkQ3NzQ2xhc3M9XCJleHBhbmRlZFwiO2V4cGFuZGVyVGV4dD1cIitcIjt9JywncmVwbGFjZUNsYXNzKHRoaXMuY29udGVudERpdixuZXdDc3NDbGFzcyxvbGRDc3NDbGFzcyk7dGhpcy5leHBhbmRlclRleHROb2RlLm5vZGVWYWx1ZT1leHBhbmRlclRleHQ7fX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNSb290KXt0aGlzLmhlYWRpbmdEaXY9bnVsbDt0aGlzLmV4cGFuZGVyLm9uY2xpY2s9bnVsbDt0aGlzLmV4cGFuZGVyPW51bGw7dGhpcy5leHBhbmRlclRleHROb2RlPW51bGw7dGhpcy5jb250ZW50RGl2PW51bGw7dGhpcy5jb250YWluZXJEb21Ob2RlPW51bGw7dGhpcy5tYWluRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5tYWluRGl2KTt0aGlzLm1haW5EaXY9bnVsbDt9fSxyZXZlcnNlQ2hpbGRyZW46ZnVuY3Rpb24oKXt2YXIgbm9kZT1udWxsO3ZhciBjaGlsZERvbU5vZGVzPVtdO3doaWxlKChub2RlPXRoaXMuY29udGVudERpdi5maXJzdENoaWxkKSl7dGhpcy5jb250ZW50RGl2LnJlbW92ZUNoaWxkKG5vZGUpO2NoaWxkRG9tTm9kZXMucHVzaChub2RlKTt9Jywnd2hpbGUoKG5vZGU9Y2hpbGREb21Ob2Rlcy5wb3AoKSkpe3RoaXMuY29udGVudERpdi5hcHBlbmRDaGlsZChub2RlKTt9fSx1cGRhdGU6ZnVuY3Rpb24oKXtpZighdGhpcy5pc1Jvb3Qpe2lmKHRoaXMuZ3JvdXAuZXhwYW5kYWJsZSl7cmVtb3ZlQ2xhc3ModGhpcy5leHBhbmRlcixcImdyZXllZG91dFwiKTt9ZWxzZXthZGRDbGFzcyh0aGlzLmV4cGFuZGVyLFwiZ3JleWVkb3V0XCIpO319fSxjbGVhcjpmdW5jdGlvbigpe2lmKHRoaXMuaXNSb290KXt0aGlzLmNvbnRlbnREaXYuaW5uZXJIVE1MPVwiXCI7fX19KTtmdW5jdGlvbiBHcm91cChuYW1lLGlzUm9vdCxpbml0aWFsbHlFeHBhbmRlZCl7dGhpcy5uYW1lPW5hbWU7dGhpcy5ncm91cD1udWxsO3RoaXMuaXNSb290PWlzUm9vdDt0aGlzLmluaXRpYWxseUV4cGFuZGVkPWluaXRpYWxseUV4cGFuZGVkO3RoaXMuZWxlbWVudENvbnRhaW5lcnM9W107dGhpcy5jaGlsZHJlbj1bXTt0aGlzLmV4cGFuZGVkPWluaXRpYWxseUV4cGFuZGVkO3RoaXMucmVuZGVyZWQ9ZmFsc2U7dGhpcy5leHBhbmRhYmxlPWZhbHNlO30nLCdHcm91cC5wcm90b3R5cGU9bmV3IExvZ0l0ZW0oKTtjb3B5UHJvcGVydGllcyhHcm91cC5wcm90b3R5cGUse2FkZENoaWxkOmZ1bmN0aW9uKGxvZ0l0ZW0pe3RoaXMuY2hpbGRyZW4ucHVzaChsb2dJdGVtKTtsb2dJdGVtLmdyb3VwPXRoaXM7fSxyZW5kZXI6ZnVuY3Rpb24oKXtpZihpc0llKXt2YXIgdW53cmFwcGVkRG9tQ29udGFpbmVyLHdyYXBwZWREb21Db250YWluZXI7aWYodGhpcy5pc1Jvb3Qpe3Vud3JhcHBlZERvbUNvbnRhaW5lcj1sb2dNYWluQ29udGFpbmVyO3dyYXBwZWREb21Db250YWluZXI9bG9nTWFpbkNvbnRhaW5lcjt9ZWxzZXt1bndyYXBwZWREb21Db250YWluZXI9dGhpcy5nZXRVbndyYXBwZWREb21Db250YWluZXIoKTt3cmFwcGVkRG9tQ29udGFpbmVyPXRoaXMuZ2V0V3JhcHBlZERvbUNvbnRhaW5lcigpO30nLCd0aGlzLnVud3JhcHBlZEVsZW1lbnRDb250YWluZXI9bmV3IEdyb3VwRWxlbWVudENvbnRhaW5lcih0aGlzLHVud3JhcHBlZERvbUNvbnRhaW5lcix0aGlzLmlzUm9vdCxmYWxzZSk7dGhpcy53cmFwcGVkRWxlbWVudENvbnRhaW5lcj1uZXcgR3JvdXBFbGVtZW50Q29udGFpbmVyKHRoaXMsd3JhcHBlZERvbUNvbnRhaW5lcix0aGlzLmlzUm9vdCx0cnVlKTt0aGlzLmVsZW1lbnRDb250YWluZXJzPVt0aGlzLnVud3JhcHBlZEVsZW1lbnRDb250YWluZXIsdGhpcy53cmFwcGVkRWxlbWVudENvbnRhaW5lcl07fWVsc2V7dmFyIG1haW5Eb21Db250YWluZXI9dGhpcy5pc1Jvb3Q/bG9nTWFpbkNvbnRhaW5lcjp0aGlzLmdldE1haW5Eb21Db250YWluZXIoKTt0aGlzLm1haW5FbGVtZW50Q29udGFpbmVyPW5ldyBHcm91cEVsZW1lbnRDb250YWluZXIodGhpcyxtYWluRG9tQ29udGFpbmVyLHRoaXMuaXNSb290LGZhbHNlKTt0aGlzLmVsZW1lbnRDb250YWluZXJzPVt0aGlzLm1haW5FbGVtZW50Q29udGFpbmVyXTt9JywndGhpcy5yZW5kZXJlZD10cnVlO30sdG9nZ2xlRXhwYW5kZWQ6ZnVuY3Rpb24oKXt0aGlzLmV4cGFuZGVkPSF0aGlzLmV4cGFuZGVkO2Zvcih2YXIgaT0wLGxlbj10aGlzLmVsZW1lbnRDb250YWluZXJzLmxlbmd0aDtpPGxlbjtpKyspe3RoaXMuZWxlbWVudENvbnRhaW5lcnNbaV0udG9nZ2xlRXhwYW5kZWQoKTt9fSxleHBhbmQ6ZnVuY3Rpb24oKXtpZighdGhpcy5leHBhbmRlZCl7dGhpcy50b2dnbGVFeHBhbmRlZCgpO319LGFjY2VwdDpmdW5jdGlvbih2aXNpdG9yKXt2aXNpdG9yLnZpc2l0R3JvdXAodGhpcyk7fSxyZXZlcnNlQ2hpbGRyZW46ZnVuY3Rpb24oKXtpZih0aGlzLnJlbmRlcmVkKXtmb3IodmFyIGk9MCxsZW49dGhpcy5lbGVtZW50Q29udGFpbmVycy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLmVsZW1lbnRDb250YWluZXJzW2ldLnJldmVyc2VDaGlsZHJlbigpO319fSx1cGRhdGU6ZnVuY3Rpb24oKXt2YXIgcHJldmlvdXNseUV4cGFuZGFibGU9dGhpcy5leHBhbmRhYmxlO3RoaXMuZXhwYW5kYWJsZT0odGhpcy5jaGlsZHJlbi5sZW5ndGghPT0wKTtpZih0aGlzLmV4cGFuZGFibGUhPT1wcmV2aW91c2x5RXhwYW5kYWJsZSl7Zm9yKHZhciBpPTAsbGVuPXRoaXMuZWxlbWVudENvbnRhaW5lcnMubGVuZ3RoO2k8bGVuO2krKyl7dGhpcy5lbGVtZW50Q29udGFpbmVyc1tpXS51cGRhdGUoKTt9fX0sZmxhdHRlbjpmdW5jdGlvbigpe3ZhciB2aXNpdG9yPW5ldyBHcm91cEZsYXR0ZW5lcigpO3RoaXMuYWNjZXB0KHZpc2l0b3IpO3JldHVybiB2aXNpdG9yLmxvZ0VudHJpZXNBbmRTZXBhcmF0b3JzO30scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oY2hpbGQsZG9VcGRhdGUpe2FycmF5X3JlbW92ZSh0aGlzLmNoaWxkcmVuLGNoaWxkKTtjaGlsZC5ncm91cD1udWxsO2lmKGRvVXBkYXRlKXt0aGlzLnVwZGF0ZSgpO319LHJlbW92ZTpmdW5jdGlvbihkb1VwZGF0ZSxyZW1vdmVGcm9tR3JvdXApe2Zvcih2YXIgaT0wLGxlbj10aGlzLmNoaWxkcmVuLmxlbmd0aDtpPGxlbjtpKyspe3RoaXMuY2hpbGRyZW5baV0ucmVtb3ZlKGZhbHNlLGZhbHNlKTt9JywndGhpcy5jaGlsZHJlbj1bXTt0aGlzLnVwZGF0ZSgpO2lmKHRoaXM9PT1jdXJyZW50R3JvdXApe2N1cnJlbnRHcm91cD10aGlzLmdyb3VwO30nLCd0aGlzLmRvUmVtb3ZlKGRvVXBkYXRlLHJlbW92ZUZyb21Hcm91cCk7fSxzZXJpYWxpemU6ZnVuY3Rpb24oaXRlbXMpe2l0ZW1zLnB1c2goW0xvZ0l0ZW0uc2VyaWFsaXplZEl0ZW1LZXlzLkdST1VQX1NUQVJULHRoaXMubmFtZV0pO2Zvcih2YXIgaT0wLGxlbj10aGlzLmNoaWxkcmVuLmxlbmd0aDtpPGxlbjtpKyspe3RoaXMuY2hpbGRyZW5baV0uc2VyaWFsaXplKGl0ZW1zKTt9JywnaWYodGhpcyE9PWN1cnJlbnRHcm91cCl7aXRlbXMucHVzaChbTG9nSXRlbS5zZXJpYWxpemVkSXRlbUtleXMuR1JPVVBfRU5EXSk7fX0sY2xlYXI6ZnVuY3Rpb24oKXtmb3IodmFyIGk9MCxsZW49dGhpcy5lbGVtZW50Q29udGFpbmVycy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLmVsZW1lbnRDb250YWluZXJzW2ldLmNsZWFyKCk7fX19KTtmdW5jdGlvbiBMb2dFbnRyeUVsZW1lbnRDb250YWluZXIoKXt9JywnTG9nRW50cnlFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZT1uZXcgTG9nSXRlbUNvbnRhaW5lckVsZW1lbnQoKTtjb3B5UHJvcGVydGllcyhMb2dFbnRyeUVsZW1lbnRDb250YWluZXIucHJvdG90eXBlLHtyZW1vdmU6ZnVuY3Rpb24oKXt0aGlzLmRvUmVtb3ZlKCk7fSxkb1JlbW92ZTpmdW5jdGlvbigpe3RoaXMubWFpbkRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubWFpbkRpdik7dGhpcy5tYWluRGl2PW51bGw7dGhpcy5jb250ZW50RWxlbWVudD1udWxsO3RoaXMuY29udGFpbmVyRG9tTm9kZT1udWxsO30sc2V0Q29udGVudDpmdW5jdGlvbihjb250ZW50LHdyYXBwZWRDb250ZW50KXtpZihjb250ZW50PT09dGhpcy5mb3JtYXR0ZWRNZXNzYWdlKXt0aGlzLmNvbnRlbnRFbGVtZW50LmlubmVySFRNTD1cIlwiO3RoaXMuY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5mb3JtYXR0ZWRNZXNzYWdlKSk7fWVsc2V7dGhpcy5jb250ZW50RWxlbWVudC5pbm5lckhUTUw9Y29udGVudDt9fSxzZXRTZWFyY2hNYXRjaDpmdW5jdGlvbihpc01hdGNoKXt2YXIgb2xkQ3NzQ2xhc3M9aXNNYXRjaD9cInNlYXJjaG5vbm1hdGNoXCI6XCJzZWFyY2htYXRjaFwiO3ZhciBuZXdDc3NDbGFzcz1pc01hdGNoP1wic2VhcmNobWF0Y2hcIjpcInNlYXJjaG5vbm1hdGNoXCI7cmVwbGFjZUNsYXNzKHRoaXMubWFpbkRpdixuZXdDc3NDbGFzcyxvbGRDc3NDbGFzcyk7fSxjbGVhclNlYXJjaDpmdW5jdGlvbigpe3JlbW92ZUNsYXNzKHRoaXMubWFpbkRpdixcInNlYXJjaG1hdGNoXCIpO3JlbW92ZUNsYXNzKHRoaXMubWFpbkRpdixcInNlYXJjaG5vbm1hdGNoXCIpO319KTtmdW5jdGlvbiBMb2dFbnRyeVdyYXBwZWRFbGVtZW50Q29udGFpbmVyKGxvZ0VudHJ5LGNvbnRhaW5lckRvbU5vZGUpe3RoaXMubG9nRW50cnk9bG9nRW50cnk7dGhpcy5jb250YWluZXJEb21Ob2RlPWNvbnRhaW5lckRvbU5vZGU7dGhpcy5tYWluRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dGhpcy5tYWluRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubG9nRW50cnkuZm9ybWF0dGVkTWVzc2FnZSkpO3RoaXMubWFpbkRpdi5jbGFzc05hbWU9XCJsb2dlbnRyeSB3cmFwcGVkIFwiK3RoaXMubG9nRW50cnkubGV2ZWw7dGhpcy5jb250ZW50RWxlbWVudD10aGlzLm1haW5EaXY7fScsJ0xvZ0VudHJ5V3JhcHBlZEVsZW1lbnRDb250YWluZXIucHJvdG90eXBlPW5ldyBMb2dFbnRyeUVsZW1lbnRDb250YWluZXIoKTtMb2dFbnRyeVdyYXBwZWRFbGVtZW50Q29udGFpbmVyLnByb3RvdHlwZS5zZXRDb250ZW50PWZ1bmN0aW9uKGNvbnRlbnQsd3JhcHBlZENvbnRlbnQpe2lmKGNvbnRlbnQ9PT10aGlzLmZvcm1hdHRlZE1lc3NhZ2Upe3RoaXMuY29udGVudEVsZW1lbnQuaW5uZXJIVE1MPVwiXCI7dGhpcy5jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmZvcm1hdHRlZE1lc3NhZ2UpKTt9ZWxzZXt0aGlzLmNvbnRlbnRFbGVtZW50LmlubmVySFRNTD13cmFwcGVkQ29udGVudDt9fTtmdW5jdGlvbiBMb2dFbnRyeVVud3JhcHBlZEVsZW1lbnRDb250YWluZXIobG9nRW50cnksY29udGFpbmVyRG9tTm9kZSl7dGhpcy5sb2dFbnRyeT1sb2dFbnRyeTt0aGlzLmNvbnRhaW5lckRvbU5vZGU9Y29udGFpbmVyRG9tTm9kZTt0aGlzLm1haW5EaXY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0aGlzLm1haW5EaXYuY2xhc3NOYW1lPVwibG9nZW50cnkgdW53cmFwcGVkIFwiK3RoaXMubG9nRW50cnkubGV2ZWw7dGhpcy5wcmU9dGhpcy5tYWluRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIikpO3RoaXMucHJlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMubG9nRW50cnkuZm9ybWF0dGVkTWVzc2FnZSkpO3RoaXMucHJlLmNsYXNzTmFtZT1cInVud3JhcHBlZFwiO3RoaXMuY29udGVudEVsZW1lbnQ9dGhpcy5wcmU7fScsJ0xvZ0VudHJ5VW53cmFwcGVkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGU9bmV3IExvZ0VudHJ5RWxlbWVudENvbnRhaW5lcigpO0xvZ0VudHJ5VW53cmFwcGVkRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhpcy5kb1JlbW92ZSgpO3RoaXMucHJlPW51bGw7fTtmdW5jdGlvbiBMb2dFbnRyeU1haW5FbGVtZW50Q29udGFpbmVyKGxvZ0VudHJ5LGNvbnRhaW5lckRvbU5vZGUpe3RoaXMubG9nRW50cnk9bG9nRW50cnk7dGhpcy5jb250YWluZXJEb21Ob2RlPWNvbnRhaW5lckRvbU5vZGU7dGhpcy5tYWluRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dGhpcy5tYWluRGl2LmNsYXNzTmFtZT1cImxvZ2VudHJ5IG5vbmllbG9nZW50cnkgXCIrdGhpcy5sb2dFbnRyeS5sZXZlbDt0aGlzLmNvbnRlbnRFbGVtZW50PXRoaXMubWFpbkRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7dGhpcy5jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmxvZ0VudHJ5LmZvcm1hdHRlZE1lc3NhZ2UpKTt9JywnTG9nRW50cnlNYWluRWxlbWVudENvbnRhaW5lci5wcm90b3R5cGU9bmV3IExvZ0VudHJ5RWxlbWVudENvbnRhaW5lcigpO2Z1bmN0aW9uIExvZ0VudHJ5KGxldmVsLGZvcm1hdHRlZE1lc3NhZ2Upe3RoaXMubGV2ZWw9bGV2ZWw7dGhpcy5mb3JtYXR0ZWRNZXNzYWdlPWZvcm1hdHRlZE1lc3NhZ2U7dGhpcy5yZW5kZXJlZD1mYWxzZTt9JywnTG9nRW50cnkucHJvdG90eXBlPW5ldyBMb2dJdGVtKCk7Y29weVByb3BlcnRpZXMoTG9nRW50cnkucHJvdG90eXBlLHtyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgbG9nRW50cnk9dGhpczt2YXIgY29udGFpbmVyRG9tTm9kZT10aGlzLmdyb3VwLmNvbnRlbnREaXY7aWYoaXNJZSl7dGhpcy5mb3JtYXR0ZWRNZXNzYWdlPXRoaXMuZm9ybWF0dGVkTWVzc2FnZS5yZXBsYWNlKC9cXFxcclxcXFxuL2csXCJcXFxcclwiKTt0aGlzLnVud3JhcHBlZEVsZW1lbnRDb250YWluZXI9bmV3IExvZ0VudHJ5VW53cmFwcGVkRWxlbWVudENvbnRhaW5lcih0aGlzLHRoaXMuZ2V0VW53cmFwcGVkRG9tQ29udGFpbmVyKCkpO3RoaXMud3JhcHBlZEVsZW1lbnRDb250YWluZXI9bmV3IExvZ0VudHJ5V3JhcHBlZEVsZW1lbnRDb250YWluZXIodGhpcyx0aGlzLmdldFdyYXBwZWREb21Db250YWluZXIoKSk7dGhpcy5lbGVtZW50Q29udGFpbmVycz1bdGhpcy51bndyYXBwZWRFbGVtZW50Q29udGFpbmVyLHRoaXMud3JhcHBlZEVsZW1lbnRDb250YWluZXJdO31lbHNle3RoaXMubWFpbkVsZW1lbnRDb250YWluZXI9bmV3IExvZ0VudHJ5TWFpbkVsZW1lbnRDb250YWluZXIodGhpcyx0aGlzLmdldE1haW5Eb21Db250YWluZXIoKSk7dGhpcy5lbGVtZW50Q29udGFpbmVycz1bdGhpcy5tYWluRWxlbWVudENvbnRhaW5lcl07fScsJ3RoaXMuY29udGVudD10aGlzLmZvcm1hdHRlZE1lc3NhZ2U7dGhpcy5yZW5kZXJlZD10cnVlO30sc2V0Q29udGVudDpmdW5jdGlvbihjb250ZW50LHdyYXBwZWRDb250ZW50KXtpZihjb250ZW50IT10aGlzLmNvbnRlbnQpe2lmKGlzSWUmJihjb250ZW50IT09dGhpcy5mb3JtYXR0ZWRNZXNzYWdlKSl7Y29udGVudD1jb250ZW50LnJlcGxhY2UoL1xcXFxyXFxcXG4vZyxcIlxcXFxyXCIpO30nLCdmb3IodmFyIGk9MCxsZW49dGhpcy5lbGVtZW50Q29udGFpbmVycy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLmVsZW1lbnRDb250YWluZXJzW2ldLnNldENvbnRlbnQoY29udGVudCx3cmFwcGVkQ29udGVudCk7fScsJ3RoaXMuY29udGVudD1jb250ZW50O319LGdldFNlYXJjaE1hdGNoZXM6ZnVuY3Rpb24oKXt2YXIgbWF0Y2hlcz1bXTt2YXIgaSxsZW47aWYoaXNJZSl7dmFyIHVud3JhcHBlZEVscz1nZXRFbGVtZW50c0J5Q2xhc3ModGhpcy51bndyYXBwZWRFbGVtZW50Q29udGFpbmVyLm1haW5EaXYsXCJzZWFyY2h0ZXJtXCIsXCJzcGFuXCIpO3ZhciB3cmFwcGVkRWxzPWdldEVsZW1lbnRzQnlDbGFzcyh0aGlzLndyYXBwZWRFbGVtZW50Q29udGFpbmVyLm1haW5EaXYsXCJzZWFyY2h0ZXJtXCIsXCJzcGFuXCIpO2ZvcihpPTAsbGVuPXVud3JhcHBlZEVscy5sZW5ndGg7aTxsZW47aSsrKXttYXRjaGVzW2ldPW5ldyBNYXRjaCh0aGlzLmxldmVsLG51bGwsdW53cmFwcGVkRWxzW2ldLHdyYXBwZWRFbHNbaV0pO319ZWxzZXt2YXIgZWxzPWdldEVsZW1lbnRzQnlDbGFzcyh0aGlzLm1haW5FbGVtZW50Q29udGFpbmVyLm1haW5EaXYsXCJzZWFyY2h0ZXJtXCIsXCJzcGFuXCIpO2ZvcihpPTAsbGVuPWVscy5sZW5ndGg7aTxsZW47aSsrKXttYXRjaGVzW2ldPW5ldyBNYXRjaCh0aGlzLmxldmVsLGVsc1tpXSk7fX0nLCdyZXR1cm4gbWF0Y2hlczt9LHNldFNlYXJjaE1hdGNoOmZ1bmN0aW9uKGlzTWF0Y2gpe2Zvcih2YXIgaT0wLGxlbj10aGlzLmVsZW1lbnRDb250YWluZXJzLmxlbmd0aDtpPGxlbjtpKyspe3RoaXMuZWxlbWVudENvbnRhaW5lcnNbaV0uc2V0U2VhcmNoTWF0Y2goaXNNYXRjaCk7fX0sY2xlYXJTZWFyY2g6ZnVuY3Rpb24oKXtmb3IodmFyIGk9MCxsZW49dGhpcy5lbGVtZW50Q29udGFpbmVycy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLmVsZW1lbnRDb250YWluZXJzW2ldLmNsZWFyU2VhcmNoKCk7fX0sYWNjZXB0OmZ1bmN0aW9uKHZpc2l0b3Ipe3Zpc2l0b3IudmlzaXRMb2dFbnRyeSh0aGlzKTt9LHNlcmlhbGl6ZTpmdW5jdGlvbihpdGVtcyl7aXRlbXMucHVzaChbTG9nSXRlbS5zZXJpYWxpemVkSXRlbUtleXMuTE9HX0VOVFJZLHRoaXMubGV2ZWwsdGhpcy5mb3JtYXR0ZWRNZXNzYWdlXSk7fX0pO2Z1bmN0aW9uIExvZ0l0ZW1WaXNpdG9yKCl7fScsJ0xvZ0l0ZW1WaXNpdG9yLnByb3RvdHlwZT17dmlzaXQ6ZnVuY3Rpb24obG9nSXRlbSl7fSx2aXNpdFBhcmVudDpmdW5jdGlvbihsb2dJdGVtKXtpZihsb2dJdGVtLmdyb3VwKXtsb2dJdGVtLmdyb3VwLmFjY2VwdCh0aGlzKTt9fSx2aXNpdENoaWxkcmVuOmZ1bmN0aW9uKGxvZ0l0ZW0pe2Zvcih2YXIgaT0wLGxlbj1sb2dJdGVtLmNoaWxkcmVuLmxlbmd0aDtpPGxlbjtpKyspe2xvZ0l0ZW0uY2hpbGRyZW5baV0uYWNjZXB0KHRoaXMpO319LHZpc2l0TG9nRW50cnk6ZnVuY3Rpb24obG9nRW50cnkpe3RoaXMudmlzaXQobG9nRW50cnkpO30sdmlzaXRTZXBhcmF0b3I6ZnVuY3Rpb24oc2VwYXJhdG9yKXt0aGlzLnZpc2l0KHNlcGFyYXRvcik7fSx2aXNpdEdyb3VwOmZ1bmN0aW9uKGdyb3VwKXt0aGlzLnZpc2l0KGdyb3VwKTt9fTtmdW5jdGlvbiBHcm91cEZsYXR0ZW5lcigpe3RoaXMubG9nRW50cmllc0FuZFNlcGFyYXRvcnM9W107fScsJ0dyb3VwRmxhdHRlbmVyLnByb3RvdHlwZT1uZXcgTG9nSXRlbVZpc2l0b3IoKTtHcm91cEZsYXR0ZW5lci5wcm90b3R5cGUudmlzaXRHcm91cD1mdW5jdGlvbihncm91cCl7dGhpcy52aXNpdENoaWxkcmVuKGdyb3VwKTt9O0dyb3VwRmxhdHRlbmVyLnByb3RvdHlwZS52aXNpdExvZ0VudHJ5PWZ1bmN0aW9uKGxvZ0VudHJ5KXt0aGlzLmxvZ0VudHJpZXNBbmRTZXBhcmF0b3JzLnB1c2gobG9nRW50cnkpO307R3JvdXBGbGF0dGVuZXIucHJvdG90eXBlLnZpc2l0U2VwYXJhdG9yPWZ1bmN0aW9uKHNlcGFyYXRvcil7dGhpcy5sb2dFbnRyaWVzQW5kU2VwYXJhdG9ycy5wdXNoKHNlcGFyYXRvcik7fTt3aW5kb3cub25sb2FkPWZ1bmN0aW9uKCl7aWYobG9jYXRpb24uc2VhcmNoKXt2YXIgcXVlcnlCaXRzPXVuZXNjYXBlKGxvY2F0aW9uLnNlYXJjaCkuc3Vic3RyKDEpLnNwbGl0KFwiJlwiKSxuYW1lVmFsdWVCaXRzO2Zvcih2YXIgaT0wLGxlbj1xdWVyeUJpdHMubGVuZ3RoO2k8bGVuO2krKyl7bmFtZVZhbHVlQml0cz1xdWVyeUJpdHNbaV0uc3BsaXQoXCI9XCIpO2lmKG5hbWVWYWx1ZUJpdHNbMF09PVwibG9nNGphdmFzY3JpcHRfZG9tYWluXCIpe2RvY3VtZW50LmRvbWFpbj1uYW1lVmFsdWVCaXRzWzFdO2JyZWFrO319fScsJ2xvZ01haW5Db250YWluZXI9JChcImxvZ1wiKTtpZihpc0llUHJlNyl7YWRkQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixcIm9sZEllXCIpO30nLCdyb290R3JvdXA9bmV3IEdyb3VwKFwicm9vdFwiLHRydWUpO3Jvb3RHcm91cC5yZW5kZXIoKTtjdXJyZW50R3JvdXA9cm9vdEdyb3VwO3NldENvbW1hbmRJbnB1dFdpZHRoKCk7c2V0TG9nQ29udGFpbmVySGVpZ2h0KCk7dG9nZ2xlTG9nZ2luZ0VuYWJsZWQoKTt0b2dnbGVTZWFyY2hFbmFibGVkKCk7dG9nZ2xlU2VhcmNoRmlsdGVyKCk7dG9nZ2xlU2VhcmNoSGlnaGxpZ2h0KCk7YXBwbHlGaWx0ZXJzKCk7Y2hlY2tBbGxMZXZlbHMoKTt0b2dnbGVXcmFwKCk7dG9nZ2xlTmV3ZXN0QXRUb3AoKTt0b2dnbGVTY3JvbGxUb0xhdGVzdCgpO3JlbmRlclF1ZXVlZExvZ0l0ZW1zKCk7bG9hZGVkPXRydWU7JChcImNvbW1hbmRcIikudmFsdWU9XCJcIjskKFwiY29tbWFuZFwiKS5hdXRvY29tcGxldGU9XCJvZmZcIjskKFwiY29tbWFuZFwiKS5vbmtleWRvd249ZnVuY3Rpb24oZXZ0KXtldnQ9Z2V0RXZlbnQoZXZ0KTtpZihldnQua2V5Q29kZT09MTB8fGV2dC5rZXlDb2RlPT0xMyl7ZXZhbENvbW1hbmRMaW5lKCk7c3RvcFByb3BhZ2F0aW9uKGV2dCk7fWVsc2UgaWYoZXZ0LmtleUNvZGU9PTI3KXt0aGlzLnZhbHVlPVwiXCI7dGhpcy5mb2N1cygpO31lbHNlIGlmKGV2dC5rZXlDb2RlPT0zOCYmY29tbWFuZEhpc3RvcnkubGVuZ3RoPjApe2N1cnJlbnRDb21tYW5kSW5kZXg9TWF0aC5tYXgoMCxjdXJyZW50Q29tbWFuZEluZGV4LTEpO3RoaXMudmFsdWU9Y29tbWFuZEhpc3RvcnlbY3VycmVudENvbW1hbmRJbmRleF07bW92ZUNhcmV0VG9FbmQodGhpcyk7fWVsc2UgaWYoZXZ0LmtleUNvZGU9PTQwJiZjb21tYW5kSGlzdG9yeS5sZW5ndGg+MCl7Y3VycmVudENvbW1hbmRJbmRleD1NYXRoLm1pbihjb21tYW5kSGlzdG9yeS5sZW5ndGgtMSxjdXJyZW50Q29tbWFuZEluZGV4KzEpO3RoaXMudmFsdWU9Y29tbWFuZEhpc3RvcnlbY3VycmVudENvbW1hbmRJbmRleF07bW92ZUNhcmV0VG9FbmQodGhpcyk7fX07JChcImNvbW1hbmRcIikub25rZXlwcmVzcz1mdW5jdGlvbihldnQpe2V2dD1nZXRFdmVudChldnQpO2lmKGV2dC5rZXlDb2RlPT0zOCYmY29tbWFuZEhpc3RvcnkubGVuZ3RoPjAmJmV2dC5wcmV2ZW50RGVmYXVsdCl7ZXZ0LnByZXZlbnREZWZhdWx0KCk7fX07JChcImNvbW1hbmRcIikub25rZXl1cD1mdW5jdGlvbihldnQpe2V2dD1nZXRFdmVudChldnQpO2lmKGV2dC5rZXlDb2RlPT0yNyYmZXZ0LnByZXZlbnREZWZhdWx0KXtldnQucHJldmVudERlZmF1bHQoKTt0aGlzLmZvY3VzKCk7fX07ZG9jdW1lbnQub25rZXlkb3duPWZ1bmN0aW9uIGtleUV2ZW50SGFuZGxlcihldnQpe2V2dD1nZXRFdmVudChldnQpO3N3aXRjaChldnQua2V5Q29kZSl7Y2FzZSA2OTppZihldnQuc2hpZnRLZXkmJihldnQuY3RybEtleXx8ZXZ0Lm1ldGFLZXkpKXtldmFsTGFzdENvbW1hbmQoKTtjYW5jZWxLZXlFdmVudChldnQpO3JldHVybiBmYWxzZTt9JywnYnJlYWs7Y2FzZSA3NTppZihldnQuc2hpZnRLZXkmJihldnQuY3RybEtleXx8ZXZ0Lm1ldGFLZXkpKXtmb2N1c1NlYXJjaCgpO2NhbmNlbEtleUV2ZW50KGV2dCk7cmV0dXJuIGZhbHNlO30nLCdicmVhaztjYXNlIDQwOmNhc2UgNzY6aWYoZXZ0LnNoaWZ0S2V5JiYoZXZ0LmN0cmxLZXl8fGV2dC5tZXRhS2V5KSl7Zm9jdXNDb21tYW5kTGluZSgpO2NhbmNlbEtleUV2ZW50KGV2dCk7cmV0dXJuIGZhbHNlO30nLCdicmVhazt9fTtzZXRUaW1lb3V0KHNldExvZ0NvbnRhaW5lckhlaWdodCwyMCk7c2V0U2hvd0NvbW1hbmRMaW5lKHNob3dDb21tYW5kTGluZSk7ZG9TZWFyY2goKTt9O3dpbmRvdy5vbnVubG9hZD1mdW5jdGlvbigpe2lmKG1haW5XaW5kb3dFeGlzdHMoKSl7YXBwZW5kZXIudW5sb2FkKCk7fScsJ2FwcGVuZGVyPW51bGw7fTtmdW5jdGlvbiB0b2dnbGVMb2dnaW5nRW5hYmxlZCgpe3NldExvZ2dpbmdFbmFibGVkKCQoXCJlbmFibGVMb2dnaW5nXCIpLmNoZWNrZWQpO30nLCdmdW5jdGlvbiBzZXRMb2dnaW5nRW5hYmxlZChlbmFibGUpe2xvZ2dpbmdFbmFibGVkPWVuYWJsZTt9JywndmFyIGFwcGVuZGVyPW51bGw7ZnVuY3Rpb24gc2V0QXBwZW5kZXIoYXBwZW5kZXJQYXJhbSl7YXBwZW5kZXI9YXBwZW5kZXJQYXJhbTt9JywnZnVuY3Rpb24gc2V0U2hvd0Nsb3NlQnV0dG9uKHNob3dDbG9zZUJ1dHRvbil7JChcImNsb3NlQnV0dG9uXCIpLnN0eWxlLmRpc3BsYXk9c2hvd0Nsb3NlQnV0dG9uP1wiaW5saW5lXCI6XCJub25lXCI7fScsJ2Z1bmN0aW9uIHNldFNob3dIaWRlQnV0dG9uKHNob3dIaWRlQnV0dG9uKXskKFwiaGlkZUJ1dHRvblwiKS5zdHlsZS5kaXNwbGF5PXNob3dIaWRlQnV0dG9uP1wiaW5saW5lXCI6XCJub25lXCI7fScsJ3ZhciBuZXdlc3RBdFRvcD1mYWxzZTtmdW5jdGlvbiBMb2dJdGVtQ29udGVudFJldmVyc2VyKCl7fScsJ0xvZ0l0ZW1Db250ZW50UmV2ZXJzZXIucHJvdG90eXBlPW5ldyBMb2dJdGVtVmlzaXRvcigpO0xvZ0l0ZW1Db250ZW50UmV2ZXJzZXIucHJvdG90eXBlLnZpc2l0R3JvdXA9ZnVuY3Rpb24oZ3JvdXApe2dyb3VwLnJldmVyc2VDaGlsZHJlbigpO3RoaXMudmlzaXRDaGlsZHJlbihncm91cCk7fTtmdW5jdGlvbiBzZXROZXdlc3RBdFRvcChpc05ld2VzdEF0VG9wKXt2YXIgb2xkTmV3ZXN0QXRUb3A9bmV3ZXN0QXRUb3A7dmFyIGksaUxlbixqLGpMZW47bmV3ZXN0QXRUb3A9Qm9vbGVhbihpc05ld2VzdEF0VG9wKTtpZihvbGROZXdlc3RBdFRvcCE9bmV3ZXN0QXRUb3Ape3ZhciB2aXNpdG9yPW5ldyBMb2dJdGVtQ29udGVudFJldmVyc2VyKCk7cm9vdEdyb3VwLmFjY2VwdCh2aXNpdG9yKTtpZihjdXJyZW50U2VhcmNoKXt2YXIgY3VycmVudE1hdGNoPWN1cnJlbnRTZWFyY2gubWF0Y2hlc1tjdXJyZW50TWF0Y2hJbmRleF07dmFyIG1hdGNoSW5kZXg9MDt2YXIgbWF0Y2hlcz1bXTt2YXIgYWN0T25Mb2dFbnRyeT1mdW5jdGlvbihsb2dFbnRyeSl7dmFyIGxvZ0VudHJ5TWF0Y2hlcz1sb2dFbnRyeS5nZXRTZWFyY2hNYXRjaGVzKCk7Zm9yKGo9MCxqTGVuPWxvZ0VudHJ5TWF0Y2hlcy5sZW5ndGg7ajxqTGVuO2orKyl7bWF0Y2hlc1ttYXRjaEluZGV4XT1sb2dFbnRyeU1hdGNoZXNbal07aWYoY3VycmVudE1hdGNoJiZsb2dFbnRyeU1hdGNoZXNbal0uZXF1YWxzKGN1cnJlbnRNYXRjaCkpe2N1cnJlbnRNYXRjaEluZGV4PW1hdGNoSW5kZXg7fScsJ21hdGNoSW5kZXgrKzt9fTtpZihuZXdlc3RBdFRvcCl7Zm9yKGk9bG9nRW50cmllcy5sZW5ndGgtMTtpPj0wO2ktLSl7YWN0T25Mb2dFbnRyeShsb2dFbnRyaWVzW2ldKTt9fWVsc2V7Zm9yKGk9MCxpTGVuPWxvZ0VudHJpZXMubGVuZ3RoO2k8aUxlbjtpKyspe2FjdE9uTG9nRW50cnkobG9nRW50cmllc1tpXSk7fX0nLCdjdXJyZW50U2VhcmNoLm1hdGNoZXM9bWF0Y2hlcztpZihjdXJyZW50TWF0Y2gpe2N1cnJlbnRNYXRjaC5zZXRDdXJyZW50KCk7fX1lbHNlIGlmKHNjcm9sbFRvTGF0ZXN0KXtkb1Njcm9sbFRvTGF0ZXN0KCk7fX0nLCckKFwibmV3ZXN0QXRUb3BcIikuY2hlY2tlZD1pc05ld2VzdEF0VG9wO30nLCdmdW5jdGlvbiB0b2dnbGVOZXdlc3RBdFRvcCgpe3ZhciBpc05ld2VzdEF0VG9wPSQoXCJuZXdlc3RBdFRvcFwiKS5jaGVja2VkO3NldE5ld2VzdEF0VG9wKGlzTmV3ZXN0QXRUb3ApO30nLCd2YXIgc2Nyb2xsVG9MYXRlc3Q9dHJ1ZTtmdW5jdGlvbiBzZXRTY3JvbGxUb0xhdGVzdChpc1Njcm9sbFRvTGF0ZXN0KXtzY3JvbGxUb0xhdGVzdD1pc1Njcm9sbFRvTGF0ZXN0O2lmKHNjcm9sbFRvTGF0ZXN0KXtkb1Njcm9sbFRvTGF0ZXN0KCk7fScsJyQoXCJzY3JvbGxUb0xhdGVzdFwiKS5jaGVja2VkPWlzU2Nyb2xsVG9MYXRlc3Q7fScsJ2Z1bmN0aW9uIHRvZ2dsZVNjcm9sbFRvTGF0ZXN0KCl7dmFyIGlzU2Nyb2xsVG9MYXRlc3Q9JChcInNjcm9sbFRvTGF0ZXN0XCIpLmNoZWNrZWQ7c2V0U2Nyb2xsVG9MYXRlc3QoaXNTY3JvbGxUb0xhdGVzdCk7fScsJ2Z1bmN0aW9uIGRvU2Nyb2xsVG9MYXRlc3QoKXt2YXIgbD1sb2dNYWluQ29udGFpbmVyO2lmKHR5cGVvZiBsLnNjcm9sbFRvcCE9XCJ1bmRlZmluZWRcIil7aWYobmV3ZXN0QXRUb3Ape2wuc2Nyb2xsVG9wPTA7fWVsc2V7dmFyIGxhdGVzdExvZ0VudHJ5PWwubGFzdENoaWxkO2lmKGxhdGVzdExvZ0VudHJ5KXtsLnNjcm9sbFRvcD1sLnNjcm9sbEhlaWdodDt9fX19JywndmFyIGNsb3NlSWZPcGVuZXJDbG9zZXM9dHJ1ZTtmdW5jdGlvbiBzZXRDbG9zZUlmT3BlbmVyQ2xvc2VzKGlzQ2xvc2VJZk9wZW5lckNsb3Nlcyl7Y2xvc2VJZk9wZW5lckNsb3Nlcz1pc0Nsb3NlSWZPcGVuZXJDbG9zZXM7fScsJ3ZhciBtYXhNZXNzYWdlcz1udWxsO2Z1bmN0aW9uIHNldE1heE1lc3NhZ2VzKG1heCl7bWF4TWVzc2FnZXM9bWF4O3BydW5lTG9nRW50cmllcygpO30nLCd2YXIgc2hvd0NvbW1hbmRMaW5lPWZhbHNlO2Z1bmN0aW9uIHNldFNob3dDb21tYW5kTGluZShpc1Nob3dDb21tYW5kTGluZSl7c2hvd0NvbW1hbmRMaW5lPWlzU2hvd0NvbW1hbmRMaW5lO2lmKGxvYWRlZCl7JChcImNvbW1hbmRMaW5lXCIpLnN0eWxlLmRpc3BsYXk9c2hvd0NvbW1hbmRMaW5lP1wiYmxvY2tcIjpcIm5vbmVcIjtzZXRDb21tYW5kSW5wdXRXaWR0aCgpO3NldExvZ0NvbnRhaW5lckhlaWdodCgpO319JywnZnVuY3Rpb24gZm9jdXNDb21tYW5kTGluZSgpe2lmKGxvYWRlZCl7JChcImNvbW1hbmRcIikuZm9jdXMoKTt9fScsJ2Z1bmN0aW9uIGZvY3VzU2VhcmNoKCl7aWYobG9hZGVkKXskKFwic2VhcmNoQm94XCIpLmZvY3VzKCk7fX0nLCdmdW5jdGlvbiBnZXRMb2dJdGVtcygpe3ZhciBpdGVtcz1bXTtmb3IodmFyIGk9MCxsZW49bG9nSXRlbXMubGVuZ3RoO2k8bGVuO2krKyl7bG9nSXRlbXNbaV0uc2VyaWFsaXplKGl0ZW1zKTt9JywncmV0dXJuIGl0ZW1zO30nLCdmdW5jdGlvbiBzZXRMb2dJdGVtcyhpdGVtcyl7dmFyIGxvZ2dpbmdSZWFsbHlFbmFibGVkPWxvZ2dpbmdFbmFibGVkO2xvZ2dpbmdFbmFibGVkPXRydWU7Zm9yKHZhciBpPTAsbGVuPWl0ZW1zLmxlbmd0aDtpPGxlbjtpKyspe3N3aXRjaChpdGVtc1tpXVswXSl7Y2FzZSBMb2dJdGVtLnNlcmlhbGl6ZWRJdGVtS2V5cy5MT0dfRU5UUlk6bG9nKGl0ZW1zW2ldWzFdLGl0ZW1zW2ldWzJdKTticmVhaztjYXNlIExvZ0l0ZW0uc2VyaWFsaXplZEl0ZW1LZXlzLkdST1VQX1NUQVJUOmdyb3VwKGl0ZW1zW2ldWzFdKTticmVhaztjYXNlIExvZ0l0ZW0uc2VyaWFsaXplZEl0ZW1LZXlzLkdST1VQX0VORDpncm91cEVuZCgpO2JyZWFrO319JywnbG9nZ2luZ0VuYWJsZWQ9bG9nZ2luZ1JlYWxseUVuYWJsZWQ7fScsJ2Z1bmN0aW9uIGxvZyhsb2dMZXZlbCxmb3JtYXR0ZWRNZXNzYWdlKXtpZihsb2dnaW5nRW5hYmxlZCl7dmFyIGxvZ0VudHJ5PW5ldyBMb2dFbnRyeShsb2dMZXZlbCxmb3JtYXR0ZWRNZXNzYWdlKTtsb2dFbnRyaWVzLnB1c2gobG9nRW50cnkpO2xvZ0VudHJpZXNBbmRTZXBhcmF0b3JzLnB1c2gobG9nRW50cnkpO2xvZ0l0ZW1zLnB1c2gobG9nRW50cnkpO2N1cnJlbnRHcm91cC5hZGRDaGlsZChsb2dFbnRyeSk7aWYobG9hZGVkKXtpZihsb2dRdWV1ZWRFdmVudHNUaW1lciE9PW51bGwpe2NsZWFyVGltZW91dChsb2dRdWV1ZWRFdmVudHNUaW1lcik7fScsJ2xvZ1F1ZXVlZEV2ZW50c1RpbWVyPXNldFRpbWVvdXQocmVuZGVyUXVldWVkTG9nSXRlbXMscmVuZGVyRGVsYXkpO3VucmVuZGVyZWRMb2dJdGVtc0V4aXN0PXRydWU7fX19JywnZnVuY3Rpb24gcmVuZGVyUXVldWVkTG9nSXRlbXMoKXtsb2dRdWV1ZWRFdmVudHNUaW1lcj1udWxsO3ZhciBwcnVuZWQ9cHJ1bmVMb2dFbnRyaWVzKCk7dmFyIGluaXRpYWxseUhhc01hdGNoZXM9Y3VycmVudFNlYXJjaD9jdXJyZW50U2VhcmNoLmhhc01hdGNoZXMoKTpmYWxzZTtmb3IodmFyIGk9MCxsZW49bG9nSXRlbXMubGVuZ3RoO2k8bGVuO2krKyl7aWYoIWxvZ0l0ZW1zW2ldLnJlbmRlcmVkKXtsb2dJdGVtc1tpXS5yZW5kZXIoKTtsb2dJdGVtc1tpXS5hcHBlbmRUb0xvZygpO2lmKGN1cnJlbnRTZWFyY2gmJihsb2dJdGVtc1tpXWluc3RhbmNlb2YgTG9nRW50cnkpKXtjdXJyZW50U2VhcmNoLmFwcGx5VG8obG9nSXRlbXNbaV0pO319fScsJ2lmKGN1cnJlbnRTZWFyY2gpe2lmKHBydW5lZCl7aWYoY3VycmVudFNlYXJjaC5oYXNWaXNpYmxlTWF0Y2hlcygpKXtpZihjdXJyZW50TWF0Y2hJbmRleD09PW51bGwpe3NldEN1cnJlbnRNYXRjaEluZGV4KDApO30nLCdkaXNwbGF5TWF0Y2hlcygpO31lbHNle2Rpc3BsYXlOb01hdGNoZXMoKTt9fWVsc2UgaWYoIWluaXRpYWxseUhhc01hdGNoZXMmJmN1cnJlbnRTZWFyY2guaGFzVmlzaWJsZU1hdGNoZXMoKSl7c2V0Q3VycmVudE1hdGNoSW5kZXgoMCk7ZGlzcGxheU1hdGNoZXMoKTt9fScsJ2lmKHNjcm9sbFRvTGF0ZXN0KXtkb1Njcm9sbFRvTGF0ZXN0KCk7fScsJ3VucmVuZGVyZWRMb2dJdGVtc0V4aXN0PWZhbHNlO30nLCdmdW5jdGlvbiBwcnVuZUxvZ0VudHJpZXMoKXtpZigobWF4TWVzc2FnZXMhPT1udWxsKSYmKGxvZ0VudHJpZXNBbmRTZXBhcmF0b3JzLmxlbmd0aD5tYXhNZXNzYWdlcykpe3ZhciBudW1iZXJUb0RlbGV0ZT1sb2dFbnRyaWVzQW5kU2VwYXJhdG9ycy5sZW5ndGgtbWF4TWVzc2FnZXM7dmFyIHBydW5lZExvZ0VudHJpZXM9bG9nRW50cmllc0FuZFNlcGFyYXRvcnMuc2xpY2UoMCxudW1iZXJUb0RlbGV0ZSk7aWYoY3VycmVudFNlYXJjaCl7Y3VycmVudFNlYXJjaC5yZW1vdmVNYXRjaGVzKHBydW5lZExvZ0VudHJpZXMpO30nLCd2YXIgZ3JvdXA7Zm9yKHZhciBpPTA7aTxudW1iZXJUb0RlbGV0ZTtpKyspe2dyb3VwPWxvZ0VudHJpZXNBbmRTZXBhcmF0b3JzW2ldLmdyb3VwO2FycmF5X3JlbW92ZShsb2dJdGVtcyxsb2dFbnRyaWVzQW5kU2VwYXJhdG9yc1tpXSk7YXJyYXlfcmVtb3ZlKGxvZ0VudHJpZXMsbG9nRW50cmllc0FuZFNlcGFyYXRvcnNbaV0pO2xvZ0VudHJpZXNBbmRTZXBhcmF0b3JzW2ldLnJlbW92ZSh0cnVlLHRydWUpO2lmKGdyb3VwLmNoaWxkcmVuLmxlbmd0aD09PTAmJmdyb3VwIT09Y3VycmVudEdyb3VwJiZncm91cCE9PXJvb3RHcm91cCl7YXJyYXlfcmVtb3ZlKGxvZ0l0ZW1zLGdyb3VwKTtncm91cC5yZW1vdmUodHJ1ZSx0cnVlKTt9fScsJ2xvZ0VudHJpZXNBbmRTZXBhcmF0b3JzPWFycmF5X3JlbW92ZUZyb21TdGFydChsb2dFbnRyaWVzQW5kU2VwYXJhdG9ycyxudW1iZXJUb0RlbGV0ZSk7cmV0dXJuIHRydWU7fScsJ3JldHVybiBmYWxzZTt9JywnZnVuY3Rpb24gZ3JvdXAobmFtZSxzdGFydEV4cGFuZGVkKXtpZihsb2dnaW5nRW5hYmxlZCl7aW5pdGlhbGx5RXhwYW5kZWQ9KHR5cGVvZiBzdGFydEV4cGFuZGVkPT09XCJ1bmRlZmluZWRcIik/dHJ1ZTpCb29sZWFuKHN0YXJ0RXhwYW5kZWQpO3ZhciBuZXdHcm91cD1uZXcgR3JvdXAobmFtZSxmYWxzZSxpbml0aWFsbHlFeHBhbmRlZCk7Y3VycmVudEdyb3VwLmFkZENoaWxkKG5ld0dyb3VwKTtjdXJyZW50R3JvdXA9bmV3R3JvdXA7bG9nSXRlbXMucHVzaChuZXdHcm91cCk7aWYobG9hZGVkKXtpZihsb2dRdWV1ZWRFdmVudHNUaW1lciE9PW51bGwpe2NsZWFyVGltZW91dChsb2dRdWV1ZWRFdmVudHNUaW1lcik7fScsJ2xvZ1F1ZXVlZEV2ZW50c1RpbWVyPXNldFRpbWVvdXQocmVuZGVyUXVldWVkTG9nSXRlbXMscmVuZGVyRGVsYXkpO3VucmVuZGVyZWRMb2dJdGVtc0V4aXN0PXRydWU7fX19JywnZnVuY3Rpb24gZ3JvdXBFbmQoKXtjdXJyZW50R3JvdXA9KGN1cnJlbnRHcm91cD09PXJvb3RHcm91cCk/cm9vdEdyb3VwOmN1cnJlbnRHcm91cC5ncm91cDt9JywnZnVuY3Rpb24gbWFpblBhZ2VSZWxvYWRlZCgpe2N1cnJlbnRHcm91cD1yb290R3JvdXA7dmFyIHNlcGFyYXRvcj1uZXcgU2VwYXJhdG9yKCk7bG9nRW50cmllc0FuZFNlcGFyYXRvcnMucHVzaChzZXBhcmF0b3IpO2xvZ0l0ZW1zLnB1c2goc2VwYXJhdG9yKTtjdXJyZW50R3JvdXAuYWRkQ2hpbGQoc2VwYXJhdG9yKTt9JywnZnVuY3Rpb24gY2xvc2VXaW5kb3coKXtpZihhcHBlbmRlciYmbWFpbldpbmRvd0V4aXN0cygpKXthcHBlbmRlci5jbG9zZSh0cnVlKTt9ZWxzZXt3aW5kb3cuY2xvc2UoKTt9fScsJ2Z1bmN0aW9uIGhpZGUoKXtpZihhcHBlbmRlciYmbWFpbldpbmRvd0V4aXN0cygpKXthcHBlbmRlci5oaWRlKCk7fX0nLCd2YXIgbWFpbldpbmRvdz13aW5kb3c7dmFyIHdpbmRvd0lkPVwibG9nNGphdmFzY3JpcHRDb25zb2xlV2luZG93X1wiK25ldyBEYXRlKCkuZ2V0VGltZSgpK1wiX1wiKyhcIlwiK01hdGgucmFuZG9tKCkpLnN1YnN0cigyKTtmdW5jdGlvbiBzZXRNYWluV2luZG93KHdpbil7bWFpbldpbmRvdz13aW47bWFpbldpbmRvd1t3aW5kb3dJZF09d2luZG93O2lmKG9wZW5lciYmY2xvc2VJZk9wZW5lckNsb3Nlcyl7cG9sbE9wZW5lcigpO319JywnZnVuY3Rpb24gcG9sbE9wZW5lcigpe2lmKGNsb3NlSWZPcGVuZXJDbG9zZXMpe2lmKG1haW5XaW5kb3dFeGlzdHMoKSl7c2V0VGltZW91dChwb2xsT3BlbmVyLDUwMCk7fWVsc2V7Y2xvc2VXaW5kb3coKTt9fX0nLCdmdW5jdGlvbiBtYWluV2luZG93RXhpc3RzKCl7dHJ5e3JldHVybihtYWluV2luZG93JiYhbWFpbldpbmRvdy5jbG9zZWQmJm1haW5XaW5kb3dbd2luZG93SWRdPT13aW5kb3cpO31jYXRjaChleCl7fScsJ3JldHVybiBmYWxzZTt9JywndmFyIGxvZ0xldmVscz1bXCJUUkFDRVwiLFwiREVCVUdcIixcIklORk9cIixcIldBUk5cIixcIkVSUk9SXCIsXCJGQVRBTFwiXTtmdW5jdGlvbiBnZXRDaGVja0JveChsb2dMZXZlbCl7cmV0dXJuICQoXCJzd2l0Y2hfXCIrbG9nTGV2ZWwpO30nLCdmdW5jdGlvbiBnZXRJZVdyYXBwZWRMb2dDb250YWluZXIoKXtyZXR1cm4gJChcImxvZ193cmFwcGVkXCIpO30nLCdmdW5jdGlvbiBnZXRJZVVud3JhcHBlZExvZ0NvbnRhaW5lcigpe3JldHVybiAkKFwibG9nX3Vud3JhcHBlZFwiKTt9JywnZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKCl7Zm9yKHZhciBpPTA7aTxsb2dMZXZlbHMubGVuZ3RoO2krKyl7aWYoZ2V0Q2hlY2tCb3gobG9nTGV2ZWxzW2ldKS5jaGVja2VkKXthZGRDbGFzcyhsb2dNYWluQ29udGFpbmVyLGxvZ0xldmVsc1tpXSk7fWVsc2V7cmVtb3ZlQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixsb2dMZXZlbHNbaV0pO319JywndXBkYXRlU2VhcmNoRnJvbUZpbHRlcnMoKTt9JywnZnVuY3Rpb24gdG9nZ2xlQWxsTGV2ZWxzKCl7dmFyIHR1cm5Pbj0kKFwic3dpdGNoX0FMTFwiKS5jaGVja2VkO2Zvcih2YXIgaT0wO2k8bG9nTGV2ZWxzLmxlbmd0aDtpKyspe2dldENoZWNrQm94KGxvZ0xldmVsc1tpXSkuY2hlY2tlZD10dXJuT247aWYodHVybk9uKXthZGRDbGFzcyhsb2dNYWluQ29udGFpbmVyLGxvZ0xldmVsc1tpXSk7fWVsc2V7cmVtb3ZlQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixsb2dMZXZlbHNbaV0pO319fScsJ2Z1bmN0aW9uIGNoZWNrQWxsTGV2ZWxzKCl7Zm9yKHZhciBpPTA7aTxsb2dMZXZlbHMubGVuZ3RoO2krKyl7aWYoIWdldENoZWNrQm94KGxvZ0xldmVsc1tpXSkuY2hlY2tlZCl7Z2V0Q2hlY2tCb3goXCJBTExcIikuY2hlY2tlZD1mYWxzZTtyZXR1cm47fX0nLCdnZXRDaGVja0JveChcIkFMTFwiKS5jaGVja2VkPXRydWU7fScsJ2Z1bmN0aW9uIGNsZWFyTG9nKCl7cm9vdEdyb3VwLmNsZWFyKCk7Y3VycmVudEdyb3VwPXJvb3RHcm91cDtsb2dFbnRyaWVzPVtdO2xvZ0l0ZW1zPVtdO2xvZ0VudHJpZXNBbmRTZXBhcmF0b3JzPVtdO2RvU2VhcmNoKCk7fScsJ2Z1bmN0aW9uIHRvZ2dsZVdyYXAoKXt2YXIgZW5hYmxlPSQoXCJ3cmFwXCIpLmNoZWNrZWQ7aWYoZW5hYmxlKXthZGRDbGFzcyhsb2dNYWluQ29udGFpbmVyLFwid3JhcFwiKTt9ZWxzZXtyZW1vdmVDbGFzcyhsb2dNYWluQ29udGFpbmVyLFwid3JhcFwiKTt9JywncmVmcmVzaEN1cnJlbnRNYXRjaCgpO30nLCd2YXIgc2VhcmNoVGltZXI9bnVsbDtmdW5jdGlvbiBzY2hlZHVsZVNlYXJjaCgpe3RyeXtjbGVhclRpbWVvdXQoc2VhcmNoVGltZXIpO31jYXRjaChleCl7fScsJ3NlYXJjaFRpbWVyPXNldFRpbWVvdXQoZG9TZWFyY2gsNTAwKTt9JywnZnVuY3Rpb24gU2VhcmNoKHNlYXJjaFRlcm0saXNSZWdleCxzZWFyY2hSZWdleCxpc0Nhc2VTZW5zaXRpdmUpe3RoaXMuc2VhcmNoVGVybT1zZWFyY2hUZXJtO3RoaXMuaXNSZWdleD1pc1JlZ2V4O3RoaXMuc2VhcmNoUmVnZXg9c2VhcmNoUmVnZXg7dGhpcy5pc0Nhc2VTZW5zaXRpdmU9aXNDYXNlU2Vuc2l0aXZlO3RoaXMubWF0Y2hlcz1bXTt9JywnU2VhcmNoLnByb3RvdHlwZT17aGFzTWF0Y2hlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hdGNoZXMubGVuZ3RoPjA7fSxoYXNWaXNpYmxlTWF0Y2hlczpmdW5jdGlvbigpe2lmKHRoaXMuaGFzTWF0Y2hlcygpKXtmb3IodmFyIGk9MDtpPHRoaXMubWF0Y2hlcy5sZW5ndGg7aSsrKXtpZih0aGlzLm1hdGNoZXNbaV0uaXNWaXNpYmxlKCkpe3JldHVybiB0cnVlO319fScsJ3JldHVybiBmYWxzZTt9LG1hdGNoOmZ1bmN0aW9uKGxvZ0VudHJ5KXt2YXIgZW50cnlUZXh0PVN0cmluZyhsb2dFbnRyeS5mb3JtYXR0ZWRNZXNzYWdlKTt2YXIgbWF0Y2hlc1NlYXJjaD1mYWxzZTtpZih0aGlzLmlzUmVnZXgpe21hdGNoZXNTZWFyY2g9dGhpcy5zZWFyY2hSZWdleC50ZXN0KGVudHJ5VGV4dCk7fWVsc2UgaWYodGhpcy5pc0Nhc2VTZW5zaXRpdmUpe21hdGNoZXNTZWFyY2g9KGVudHJ5VGV4dC5pbmRleE9mKHRoaXMuc2VhcmNoVGVybSk+LTEpO31lbHNle21hdGNoZXNTZWFyY2g9KGVudHJ5VGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5zZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpPi0xKTt9JywncmV0dXJuIG1hdGNoZXNTZWFyY2g7fSxnZXROZXh0VmlzaWJsZU1hdGNoSW5kZXg6ZnVuY3Rpb24oKXtmb3IodmFyIGk9Y3VycmVudE1hdGNoSW5kZXgrMTtpPHRoaXMubWF0Y2hlcy5sZW5ndGg7aSsrKXtpZih0aGlzLm1hdGNoZXNbaV0uaXNWaXNpYmxlKCkpe3JldHVybiBpO319JywnZm9yKGk9MDtpPD1jdXJyZW50TWF0Y2hJbmRleDtpKyspe2lmKHRoaXMubWF0Y2hlc1tpXS5pc1Zpc2libGUoKSl7cmV0dXJuIGk7fX0nLCdyZXR1cm4tMTt9LGdldFByZXZpb3VzVmlzaWJsZU1hdGNoSW5kZXg6ZnVuY3Rpb24oKXtmb3IodmFyIGk9Y3VycmVudE1hdGNoSW5kZXgtMTtpPj0wO2ktLSl7aWYodGhpcy5tYXRjaGVzW2ldLmlzVmlzaWJsZSgpKXtyZXR1cm4gaTt9fScsJ2Zvcih2YXIgaT10aGlzLm1hdGNoZXMubGVuZ3RoLTE7aT49Y3VycmVudE1hdGNoSW5kZXg7aS0tKXtpZih0aGlzLm1hdGNoZXNbaV0uaXNWaXNpYmxlKCkpe3JldHVybiBpO319JywncmV0dXJuLTE7fSxhcHBseVRvOmZ1bmN0aW9uKGxvZ0VudHJ5KXt2YXIgZG9lc01hdGNoPXRoaXMubWF0Y2gobG9nRW50cnkpO2lmKGRvZXNNYXRjaCl7bG9nRW50cnkuZ3JvdXAuZXhwYW5kKCk7bG9nRW50cnkuc2V0U2VhcmNoTWF0Y2godHJ1ZSk7dmFyIGxvZ0VudHJ5Q29udGVudDt2YXIgd3JhcHBlZExvZ0VudHJ5Q29udGVudDt2YXIgc2VhcmNoVGVybVJlcGxhY2VtZW50U3RhcnRUYWc9XCI8c3BhbiBjbGFzcz1cXFxcXFxcInNlYXJjaHRlcm1cXFxcXFxcIj5cIjt2YXIgc2VhcmNoVGVybVJlcGxhY2VtZW50RW5kVGFnPVwiPFwiK1wiL3NwYW4+XCI7dmFyIHByZVRhZ05hbWU9aXNJZT9cInByZVwiOlwic3BhblwiO3ZhciBwcmVTdGFydFRhZz1cIjxcIitwcmVUYWdOYW1lK1wiIGNsYXNzPVxcXFxcXFwicHJlXFxcXFxcXCI+XCI7dmFyIHByZUVuZFRhZz1cIjxcIitcIi9cIitwcmVUYWdOYW1lK1wiPlwiO3ZhciBzdGFydEluZGV4PTA7dmFyIHNlYXJjaEluZGV4LG1hdGNoZWRUZXh0LHRleHRCZWZvcmVNYXRjaDtpZih0aGlzLmlzUmVnZXgpe3ZhciBmbGFncz10aGlzLmlzQ2FzZVNlbnNpdGl2ZT9cImdcIjpcImdpXCI7dmFyIGNhcHR1cmluZ1JlZ2V4PW5ldyBSZWdFeHAoXCIoXCIrdGhpcy5zZWFyY2hSZWdleC5zb3VyY2UrXCIpXCIsZmxhZ3MpO3ZhciBybmQ9KFwiXCIrTWF0aC5yYW5kb20oKSkuc3Vic3RyKDIpO3ZhciBzdGFydFRva2VuPVwiJSVzXCIrcm5kK1wiJSVcIjt2YXIgZW5kVG9rZW49XCIlJWVcIitybmQrXCIlJVwiO2xvZ0VudHJ5Q29udGVudD1sb2dFbnRyeS5mb3JtYXR0ZWRNZXNzYWdlLnJlcGxhY2UoY2FwdHVyaW5nUmVnZXgsc3RhcnRUb2tlbitcIiQxXCIrZW5kVG9rZW4pO2xvZ0VudHJ5Q29udGVudD1lc2NhcGVIdG1sKGxvZ0VudHJ5Q29udGVudCk7dmFyIHJlc3VsdDt2YXIgc2VhcmNoU3RyaW5nPWxvZ0VudHJ5Q29udGVudDtsb2dFbnRyeUNvbnRlbnQ9XCJcIjt3cmFwcGVkTG9nRW50cnlDb250ZW50PVwiXCI7d2hpbGUoKHNlYXJjaEluZGV4PXNlYXJjaFN0cmluZy5pbmRleE9mKHN0YXJ0VG9rZW4sc3RhcnRJbmRleCkpPi0xKXt2YXIgZW5kVG9rZW5JbmRleD1zZWFyY2hTdHJpbmcuaW5kZXhPZihlbmRUb2tlbixzZWFyY2hJbmRleCk7bWF0Y2hlZFRleHQ9c2VhcmNoU3RyaW5nLnN1YnN0cmluZyhzZWFyY2hJbmRleCtzdGFydFRva2VuLmxlbmd0aCxlbmRUb2tlbkluZGV4KTt0ZXh0QmVmb3JlTWF0Y2g9c2VhcmNoU3RyaW5nLnN1YnN0cmluZyhzdGFydEluZGV4LHNlYXJjaEluZGV4KTtsb2dFbnRyeUNvbnRlbnQrPXByZVN0YXJ0VGFnK3RleHRCZWZvcmVNYXRjaCtwcmVFbmRUYWc7bG9nRW50cnlDb250ZW50Kz1zZWFyY2hUZXJtUmVwbGFjZW1lbnRTdGFydFRhZytwcmVTdGFydFRhZyttYXRjaGVkVGV4dCsnLCdwcmVFbmRUYWcrc2VhcmNoVGVybVJlcGxhY2VtZW50RW5kVGFnO2lmKGlzSWUpe3dyYXBwZWRMb2dFbnRyeUNvbnRlbnQrPXRleHRCZWZvcmVNYXRjaCtzZWFyY2hUZXJtUmVwbGFjZW1lbnRTdGFydFRhZysnLCdtYXRjaGVkVGV4dCtzZWFyY2hUZXJtUmVwbGFjZW1lbnRFbmRUYWc7fScsJ3N0YXJ0SW5kZXg9ZW5kVG9rZW5JbmRleCtlbmRUb2tlbi5sZW5ndGg7fScsJ2xvZ0VudHJ5Q29udGVudCs9cHJlU3RhcnRUYWcrc2VhcmNoU3RyaW5nLnN1YnN0cihzdGFydEluZGV4KStwcmVFbmRUYWc7aWYoaXNJZSl7d3JhcHBlZExvZ0VudHJ5Q29udGVudCs9c2VhcmNoU3RyaW5nLnN1YnN0cihzdGFydEluZGV4KTt9fWVsc2V7bG9nRW50cnlDb250ZW50PVwiXCI7d3JhcHBlZExvZ0VudHJ5Q29udGVudD1cIlwiO3ZhciBzZWFyY2hUZXJtUmVwbGFjZW1lbnRMZW5ndGg9c2VhcmNoVGVybVJlcGxhY2VtZW50U3RhcnRUYWcubGVuZ3RoKycsJ3RoaXMuc2VhcmNoVGVybS5sZW5ndGgrc2VhcmNoVGVybVJlcGxhY2VtZW50RW5kVGFnLmxlbmd0aDt2YXIgc2VhcmNoVGVybUxlbmd0aD10aGlzLnNlYXJjaFRlcm0ubGVuZ3RoO3ZhciBzZWFyY2hUZXJtTG93ZXJDYXNlPXRoaXMuc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpO3ZhciBsb2dUZXh0TG93ZXJDYXNlPWxvZ0VudHJ5LmZvcm1hdHRlZE1lc3NhZ2UudG9Mb3dlckNhc2UoKTt3aGlsZSgoc2VhcmNoSW5kZXg9bG9nVGV4dExvd2VyQ2FzZS5pbmRleE9mKHNlYXJjaFRlcm1Mb3dlckNhc2Usc3RhcnRJbmRleCkpPi0xKXttYXRjaGVkVGV4dD1lc2NhcGVIdG1sKGxvZ0VudHJ5LmZvcm1hdHRlZE1lc3NhZ2Uuc3Vic3RyKHNlYXJjaEluZGV4LHRoaXMuc2VhcmNoVGVybS5sZW5ndGgpKTt0ZXh0QmVmb3JlTWF0Y2g9ZXNjYXBlSHRtbChsb2dFbnRyeS5mb3JtYXR0ZWRNZXNzYWdlLnN1YnN0cmluZyhzdGFydEluZGV4LHNlYXJjaEluZGV4KSk7dmFyIHNlYXJjaFRlcm1SZXBsYWNlbWVudD1zZWFyY2hUZXJtUmVwbGFjZW1lbnRTdGFydFRhZysnLCdwcmVTdGFydFRhZyttYXRjaGVkVGV4dCtwcmVFbmRUYWcrc2VhcmNoVGVybVJlcGxhY2VtZW50RW5kVGFnO2xvZ0VudHJ5Q29udGVudCs9cHJlU3RhcnRUYWcrdGV4dEJlZm9yZU1hdGNoK3ByZUVuZFRhZytzZWFyY2hUZXJtUmVwbGFjZW1lbnQ7aWYoaXNJZSl7d3JhcHBlZExvZ0VudHJ5Q29udGVudCs9dGV4dEJlZm9yZU1hdGNoK3NlYXJjaFRlcm1SZXBsYWNlbWVudFN0YXJ0VGFnKycsJ21hdGNoZWRUZXh0K3NlYXJjaFRlcm1SZXBsYWNlbWVudEVuZFRhZzt9Jywnc3RhcnRJbmRleD1zZWFyY2hJbmRleCtzZWFyY2hUZXJtTGVuZ3RoO30nLCd2YXIgdGV4dEFmdGVyTGFzdE1hdGNoPWVzY2FwZUh0bWwobG9nRW50cnkuZm9ybWF0dGVkTWVzc2FnZS5zdWJzdHIoc3RhcnRJbmRleCkpO2xvZ0VudHJ5Q29udGVudCs9cHJlU3RhcnRUYWcrdGV4dEFmdGVyTGFzdE1hdGNoK3ByZUVuZFRhZztpZihpc0llKXt3cmFwcGVkTG9nRW50cnlDb250ZW50Kz10ZXh0QWZ0ZXJMYXN0TWF0Y2g7fX0nLCdsb2dFbnRyeS5zZXRDb250ZW50KGxvZ0VudHJ5Q29udGVudCx3cmFwcGVkTG9nRW50cnlDb250ZW50KTt2YXIgbG9nRW50cnlNYXRjaGVzPWxvZ0VudHJ5LmdldFNlYXJjaE1hdGNoZXMoKTt0aGlzLm1hdGNoZXM9dGhpcy5tYXRjaGVzLmNvbmNhdChsb2dFbnRyeU1hdGNoZXMpO31lbHNle2xvZ0VudHJ5LnNldFNlYXJjaE1hdGNoKGZhbHNlKTtsb2dFbnRyeS5zZXRDb250ZW50KGxvZ0VudHJ5LmZvcm1hdHRlZE1lc3NhZ2UsbG9nRW50cnkuZm9ybWF0dGVkTWVzc2FnZSk7fScsJ3JldHVybiBkb2VzTWF0Y2g7fSxyZW1vdmVNYXRjaGVzOmZ1bmN0aW9uKGxvZ0VudHJpZXMpe3ZhciBtYXRjaGVzVG9SZW1vdmVDb3VudD0wO3ZhciBjdXJyZW50TWF0Y2hSZW1vdmVkPWZhbHNlO3ZhciBtYXRjaGVzVG9SZW1vdmU9W107dmFyIGksaUxlbixqLGpMZW47Zm9yKGk9MCxpTGVuPXRoaXMubWF0Y2hlcy5sZW5ndGg7aTxpTGVuO2krKyl7Zm9yKGo9MCxqTGVuPWxvZ0VudHJpZXMubGVuZ3RoO2o8akxlbjtqKyspe2lmKHRoaXMubWF0Y2hlc1tpXS5iZWxvbmdzVG8obG9nRW50cmllc1tqXSkpe21hdGNoZXNUb1JlbW92ZS5wdXNoKHRoaXMubWF0Y2hlc1tpXSk7aWYoaT09PWN1cnJlbnRNYXRjaEluZGV4KXtjdXJyZW50TWF0Y2hSZW1vdmVkPXRydWU7fX19fScsJ3ZhciBuZXdNYXRjaD1jdXJyZW50TWF0Y2hSZW1vdmVkP251bGw6dGhpcy5tYXRjaGVzW2N1cnJlbnRNYXRjaEluZGV4XTtpZihjdXJyZW50TWF0Y2hSZW1vdmVkKXtmb3IoaT1jdXJyZW50TWF0Y2hJbmRleCxpTGVuPXRoaXMubWF0Y2hlcy5sZW5ndGg7aTxpTGVuO2krKyl7aWYodGhpcy5tYXRjaGVzW2ldLmlzVmlzaWJsZSgpJiYhYXJyYXlfY29udGFpbnMobWF0Y2hlc1RvUmVtb3ZlLHRoaXMubWF0Y2hlc1tpXSkpe25ld01hdGNoPXRoaXMubWF0Y2hlc1tpXTticmVhazt9fX0nLCdmb3IoaT0wLGlMZW49bWF0Y2hlc1RvUmVtb3ZlLmxlbmd0aDtpPGlMZW47aSsrKXthcnJheV9yZW1vdmUodGhpcy5tYXRjaGVzLG1hdGNoZXNUb1JlbW92ZVtpXSk7bWF0Y2hlc1RvUmVtb3ZlW2ldLnJlbW92ZSgpO30nLCdpZih0aGlzLmhhc1Zpc2libGVNYXRjaGVzKCkpe2lmKG5ld01hdGNoPT09bnVsbCl7c2V0Q3VycmVudE1hdGNoSW5kZXgoMCk7fWVsc2V7dmFyIG5ld01hdGNoSW5kZXg9MDtmb3IoaT0wLGlMZW49dGhpcy5tYXRjaGVzLmxlbmd0aDtpPGlMZW47aSsrKXtpZihuZXdNYXRjaD09PXRoaXMubWF0Y2hlc1tpXSl7bmV3TWF0Y2hJbmRleD1pO2JyZWFrO319Jywnc2V0Q3VycmVudE1hdGNoSW5kZXgobmV3TWF0Y2hJbmRleCk7fX1lbHNle2N1cnJlbnRNYXRjaEluZGV4PW51bGw7ZGlzcGxheU5vTWF0Y2hlcygpO319fTtmdW5jdGlvbiBnZXRQYWdlT2Zmc2V0VG9wKGVsLGNvbnRhaW5lcil7dmFyIGN1cnJlbnRFbD1lbDt2YXIgeT0wO3doaWxlKGN1cnJlbnRFbCYmY3VycmVudEVsIT1jb250YWluZXIpe3krPWN1cnJlbnRFbC5vZmZzZXRUb3A7Y3VycmVudEVsPWN1cnJlbnRFbC5vZmZzZXRQYXJlbnQ7fScsJ3JldHVybiB5O30nLCdmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbCl7dmFyIGxvZ0NvbnRhaW5lcj1sb2dNYWluQ29udGFpbmVyO2lmKCEkKFwid3JhcFwiKS5jaGVja2VkKXt2YXIgbG9nQ29udGFpbmVyTGVmdD1sb2dDb250YWluZXIuc2Nyb2xsTGVmdDt2YXIgbG9nQ29udGFpbmVyUmlnaHQ9bG9nQ29udGFpbmVyTGVmdCtsb2dDb250YWluZXIub2Zmc2V0V2lkdGg7dmFyIGVsTGVmdD1lbC5vZmZzZXRMZWZ0O3ZhciBlbFJpZ2h0PWVsTGVmdCtlbC5vZmZzZXRXaWR0aDtpZihlbExlZnQ8bG9nQ29udGFpbmVyTGVmdHx8ZWxSaWdodD5sb2dDb250YWluZXJSaWdodCl7bG9nQ29udGFpbmVyLnNjcm9sbExlZnQ9ZWxMZWZ0LShsb2dDb250YWluZXIub2Zmc2V0V2lkdGgtZWwub2Zmc2V0V2lkdGgpLzI7fX0nLCd2YXIgbG9nQ29udGFpbmVyVG9wPWxvZ0NvbnRhaW5lci5zY3JvbGxUb3A7dmFyIGxvZ0NvbnRhaW5lckJvdHRvbT1sb2dDb250YWluZXJUb3ArbG9nQ29udGFpbmVyLm9mZnNldEhlaWdodDt2YXIgZWxUb3A9Z2V0UGFnZU9mZnNldFRvcChlbCktZ2V0VG9vbEJhcnNIZWlnaHQoKTt2YXIgZWxCb3R0b209ZWxUb3ArZWwub2Zmc2V0SGVpZ2h0O2lmKGVsVG9wPGxvZ0NvbnRhaW5lclRvcHx8ZWxCb3R0b20+bG9nQ29udGFpbmVyQm90dG9tKXtsb2dDb250YWluZXIuc2Nyb2xsVG9wPWVsVG9wLShsb2dDb250YWluZXIub2Zmc2V0SGVpZ2h0LWVsLm9mZnNldEhlaWdodCkvMjt9fScsJ2Z1bmN0aW9uIE1hdGNoKGxvZ0VudHJ5TGV2ZWwsc3BhbkluTWFpbkRpdixzcGFuSW5VbndyYXBwZWRQcmUsc3BhbkluV3JhcHBlZERpdil7dGhpcy5sb2dFbnRyeUxldmVsPWxvZ0VudHJ5TGV2ZWw7dGhpcy5zcGFuSW5NYWluRGl2PXNwYW5Jbk1haW5EaXY7aWYoaXNJZSl7dGhpcy5zcGFuSW5VbndyYXBwZWRQcmU9c3BhbkluVW53cmFwcGVkUHJlO3RoaXMuc3BhbkluV3JhcHBlZERpdj1zcGFuSW5XcmFwcGVkRGl2O30nLCd0aGlzLm1haW5TcGFuPWlzSWU/c3BhbkluVW53cmFwcGVkUHJlOnNwYW5Jbk1haW5EaXY7fScsJ01hdGNoLnByb3RvdHlwZT17ZXF1YWxzOmZ1bmN0aW9uKG1hdGNoKXtyZXR1cm4gdGhpcy5tYWluU3Bhbj09PW1hdGNoLm1haW5TcGFuO30sc2V0Q3VycmVudDpmdW5jdGlvbigpe2lmKGlzSWUpe2FkZENsYXNzKHRoaXMuc3BhbkluVW53cmFwcGVkUHJlLFwiY3VycmVudG1hdGNoXCIpO2FkZENsYXNzKHRoaXMuc3BhbkluV3JhcHBlZERpdixcImN1cnJlbnRtYXRjaFwiKTt2YXIgZWxlbWVudFRvU2Nyb2xsPSQoXCJ3cmFwXCIpLmNoZWNrZWQ/dGhpcy5zcGFuSW5XcmFwcGVkRGl2OnRoaXMuc3BhbkluVW53cmFwcGVkUHJlO3Njcm9sbEludG9WaWV3KGVsZW1lbnRUb1Njcm9sbCk7fWVsc2V7YWRkQ2xhc3ModGhpcy5zcGFuSW5NYWluRGl2LFwiY3VycmVudG1hdGNoXCIpO3Njcm9sbEludG9WaWV3KHRoaXMuc3BhbkluTWFpbkRpdik7fX0sYmVsb25nc1RvOmZ1bmN0aW9uKGxvZ0VudHJ5KXtpZihpc0llKXtyZXR1cm4gaXNEZXNjZW5kYW50KHRoaXMuc3BhbkluVW53cmFwcGVkUHJlLGxvZ0VudHJ5LnVud3JhcHBlZFByZSk7fWVsc2V7cmV0dXJuIGlzRGVzY2VuZGFudCh0aGlzLnNwYW5Jbk1haW5EaXYsbG9nRW50cnkubWFpbkRpdik7fX0sc2V0Tm90Q3VycmVudDpmdW5jdGlvbigpe2lmKGlzSWUpe3JlbW92ZUNsYXNzKHRoaXMuc3BhbkluVW53cmFwcGVkUHJlLFwiY3VycmVudG1hdGNoXCIpO3JlbW92ZUNsYXNzKHRoaXMuc3BhbkluV3JhcHBlZERpdixcImN1cnJlbnRtYXRjaFwiKTt9ZWxzZXtyZW1vdmVDbGFzcyh0aGlzLnNwYW5Jbk1haW5EaXYsXCJjdXJyZW50bWF0Y2hcIik7fX0saXNPcnBoYW46ZnVuY3Rpb24oKXtyZXR1cm4gaXNPcnBoYW4odGhpcy5tYWluU3Bhbik7fSxpc1Zpc2libGU6ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0Q2hlY2tCb3godGhpcy5sb2dFbnRyeUxldmVsKS5jaGVja2VkO30scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoaXNJZSl7dGhpcy5zcGFuSW5VbndyYXBwZWRQcmU9bnVsbDt0aGlzLnNwYW5JbldyYXBwZWREaXY9bnVsbDt9ZWxzZXt0aGlzLnNwYW5Jbk1haW5EaXY9bnVsbDt9fX07dmFyIGN1cnJlbnRTZWFyY2g9bnVsbDt2YXIgY3VycmVudE1hdGNoSW5kZXg9bnVsbDtmdW5jdGlvbiBkb1NlYXJjaCgpe3ZhciBzZWFyY2hCb3g9JChcInNlYXJjaEJveFwiKTt2YXIgc2VhcmNoVGVybT1zZWFyY2hCb3gudmFsdWU7dmFyIGlzUmVnZXg9JChcInNlYXJjaFJlZ2V4XCIpLmNoZWNrZWQ7dmFyIGlzQ2FzZVNlbnNpdGl2ZT0kKFwic2VhcmNoQ2FzZVNlbnNpdGl2ZVwiKS5jaGVja2VkO3ZhciBpO2lmKHNlYXJjaFRlcm09PT1cIlwiKXskKFwic2VhcmNoUmVzZXRcIikuZGlzYWJsZWQ9dHJ1ZTskKFwic2VhcmNoTmF2XCIpLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7cmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSxcInNlYXJjaGluZ1wiKTtyZW1vdmVDbGFzcyhzZWFyY2hCb3gsXCJoYXNtYXRjaGVzXCIpO3JlbW92ZUNsYXNzKHNlYXJjaEJveCxcIm5vbWF0Y2hlc1wiKTtmb3IoaT0wO2k8bG9nRW50cmllcy5sZW5ndGg7aSsrKXtsb2dFbnRyaWVzW2ldLmNsZWFyU2VhcmNoKCk7bG9nRW50cmllc1tpXS5zZXRDb250ZW50KGxvZ0VudHJpZXNbaV0uZm9ybWF0dGVkTWVzc2FnZSxsb2dFbnRyaWVzW2ldLmZvcm1hdHRlZE1lc3NhZ2UpO30nLCdjdXJyZW50U2VhcmNoPW51bGw7c2V0TG9nQ29udGFpbmVySGVpZ2h0KCk7fWVsc2V7JChcInNlYXJjaFJlc2V0XCIpLmRpc2FibGVkPWZhbHNlOyQoXCJzZWFyY2hOYXZcIikuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7dmFyIHNlYXJjaFJlZ2V4O3ZhciByZWdleFZhbGlkO2lmKGlzUmVnZXgpe3RyeXtzZWFyY2hSZWdleD1pc0Nhc2VTZW5zaXRpdmU/bmV3IFJlZ0V4cChzZWFyY2hUZXJtLFwiZ1wiKTpuZXcgUmVnRXhwKHNlYXJjaFRlcm0sXCJnaVwiKTtyZWdleFZhbGlkPXRydWU7cmVwbGFjZUNsYXNzKHNlYXJjaEJveCxcInZhbGlkcmVnZXhcIixcImludmFsaWRyZWdleFwiKTtzZWFyY2hCb3gudGl0bGU9XCJWYWxpZCByZWdleFwiO31jYXRjaChleCl7cmVnZXhWYWxpZD1mYWxzZTtyZXBsYWNlQ2xhc3Moc2VhcmNoQm94LFwiaW52YWxpZHJlZ2V4XCIsXCJ2YWxpZHJlZ2V4XCIpO3NlYXJjaEJveC50aXRsZT1cIkludmFsaWQgcmVnZXg6IFwiKyhleC5tZXNzYWdlP2V4Lm1lc3NhZ2U6KGV4LmRlc2NyaXB0aW9uP2V4LmRlc2NyaXB0aW9uOlwidW5rbm93biBlcnJvclwiKSk7cmV0dXJuO319ZWxzZXtzZWFyY2hCb3gudGl0bGU9XCJcIjtyZW1vdmVDbGFzcyhzZWFyY2hCb3gsXCJ2YWxpZHJlZ2V4XCIpO3JlbW92ZUNsYXNzKHNlYXJjaEJveCxcImludmFsaWRyZWdleFwiKTt9JywnYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSxcInNlYXJjaGluZ1wiKTtjdXJyZW50U2VhcmNoPW5ldyBTZWFyY2goc2VhcmNoVGVybSxpc1JlZ2V4LHNlYXJjaFJlZ2V4LGlzQ2FzZVNlbnNpdGl2ZSk7Zm9yKGk9MDtpPGxvZ0VudHJpZXMubGVuZ3RoO2krKyl7Y3VycmVudFNlYXJjaC5hcHBseVRvKGxvZ0VudHJpZXNbaV0pO30nLCdzZXRMb2dDb250YWluZXJIZWlnaHQoKTtpZihjdXJyZW50U2VhcmNoLmhhc1Zpc2libGVNYXRjaGVzKCkpe3NldEN1cnJlbnRNYXRjaEluZGV4KDApO2Rpc3BsYXlNYXRjaGVzKCk7fWVsc2V7ZGlzcGxheU5vTWF0Y2hlcygpO319fScsJ2Z1bmN0aW9uIHVwZGF0ZVNlYXJjaEZyb21GaWx0ZXJzKCl7aWYoY3VycmVudFNlYXJjaCl7aWYoY3VycmVudFNlYXJjaC5oYXNNYXRjaGVzKCkpe2lmKGN1cnJlbnRNYXRjaEluZGV4PT09bnVsbCl7Y3VycmVudE1hdGNoSW5kZXg9MDt9JywndmFyIGN1cnJlbnRNYXRjaD1jdXJyZW50U2VhcmNoLm1hdGNoZXNbY3VycmVudE1hdGNoSW5kZXhdO2lmKGN1cnJlbnRNYXRjaC5pc1Zpc2libGUoKSl7ZGlzcGxheU1hdGNoZXMoKTtzZXRDdXJyZW50TWF0Y2hJbmRleChjdXJyZW50TWF0Y2hJbmRleCk7fWVsc2V7Y3VycmVudE1hdGNoLnNldE5vdEN1cnJlbnQoKTt2YXIgbmV4dFZpc2libGVNYXRjaEluZGV4PWN1cnJlbnRTZWFyY2guZ2V0TmV4dFZpc2libGVNYXRjaEluZGV4KCk7aWYobmV4dFZpc2libGVNYXRjaEluZGV4Pi0xKXtzZXRDdXJyZW50TWF0Y2hJbmRleChuZXh0VmlzaWJsZU1hdGNoSW5kZXgpO2Rpc3BsYXlNYXRjaGVzKCk7fWVsc2V7ZGlzcGxheU5vTWF0Y2hlcygpO319fWVsc2V7ZGlzcGxheU5vTWF0Y2hlcygpO319fScsJ2Z1bmN0aW9uIHJlZnJlc2hDdXJyZW50TWF0Y2goKXtpZihjdXJyZW50U2VhcmNoJiZjdXJyZW50U2VhcmNoLmhhc1Zpc2libGVNYXRjaGVzKCkpe3NldEN1cnJlbnRNYXRjaEluZGV4KGN1cnJlbnRNYXRjaEluZGV4KTt9fScsJ2Z1bmN0aW9uIGRpc3BsYXlNYXRjaGVzKCl7cmVwbGFjZUNsYXNzKCQoXCJzZWFyY2hCb3hcIiksXCJoYXNtYXRjaGVzXCIsXCJub21hdGNoZXNcIik7JChcInNlYXJjaEJveFwiKS50aXRsZT1cIlwiK2N1cnJlbnRTZWFyY2gubWF0Y2hlcy5sZW5ndGgrXCIgbWF0Y2hlcyBmb3VuZFwiOyQoXCJzZWFyY2hOYXZcIikuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7c2V0TG9nQ29udGFpbmVySGVpZ2h0KCk7fScsJ2Z1bmN0aW9uIGRpc3BsYXlOb01hdGNoZXMoKXtyZXBsYWNlQ2xhc3MoJChcInNlYXJjaEJveFwiKSxcIm5vbWF0Y2hlc1wiLFwiaGFzbWF0Y2hlc1wiKTskKFwic2VhcmNoQm94XCIpLnRpdGxlPVwiTm8gbWF0Y2hlcyBmb3VuZFwiOyQoXCJzZWFyY2hOYXZcIikuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtzZXRMb2dDb250YWluZXJIZWlnaHQoKTt9JywnZnVuY3Rpb24gdG9nZ2xlU2VhcmNoRW5hYmxlZChlbmFibGUpe2VuYWJsZT0odHlwZW9mIGVuYWJsZT09XCJ1bmRlZmluZWRcIik/ISQoXCJzZWFyY2hEaXNhYmxlXCIpLmNoZWNrZWQ6ZW5hYmxlOyQoXCJzZWFyY2hCb3hcIikuZGlzYWJsZWQ9IWVuYWJsZTskKFwic2VhcmNoUmVzZXRcIikuZGlzYWJsZWQ9IWVuYWJsZTskKFwic2VhcmNoUmVnZXhcIikuZGlzYWJsZWQ9IWVuYWJsZTskKFwic2VhcmNoTmV4dFwiKS5kaXNhYmxlZD0hZW5hYmxlOyQoXCJzZWFyY2hQcmV2aW91c1wiKS5kaXNhYmxlZD0hZW5hYmxlOyQoXCJzZWFyY2hDYXNlU2Vuc2l0aXZlXCIpLmRpc2FibGVkPSFlbmFibGU7JChcInNlYXJjaE5hdlwiKS5zdHlsZS5kaXNwbGF5PShlbmFibGUmJigkKFwic2VhcmNoQm94XCIpLnZhbHVlIT09XCJcIikmJmN1cnJlbnRTZWFyY2gmJmN1cnJlbnRTZWFyY2guaGFzVmlzaWJsZU1hdGNoZXMoKSk/XCJibG9ja1wiOlwibm9uZVwiO2lmKGVuYWJsZSl7cmVtb3ZlQ2xhc3MoJChcInNlYXJjaFwiKSxcImdyZXllZG91dFwiKTthZGRDbGFzcyhkb2N1bWVudC5ib2R5LFwic2VhcmNoaW5nXCIpO2lmKCQoXCJzZWFyY2hIaWdobGlnaHRcIikuY2hlY2tlZCl7YWRkQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixcInNlYXJjaGhpZ2hsaWdodFwiKTt9ZWxzZXtyZW1vdmVDbGFzcyhsb2dNYWluQ29udGFpbmVyLFwic2VhcmNoaGlnaGxpZ2h0XCIpO30nLCdpZigkKFwic2VhcmNoRmlsdGVyXCIpLmNoZWNrZWQpe2FkZENsYXNzKGxvZ01haW5Db250YWluZXIsXCJzZWFyY2hmaWx0ZXJcIik7fWVsc2V7cmVtb3ZlQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixcInNlYXJjaGZpbHRlclwiKTt9JywnJChcInNlYXJjaERpc2FibGVcIikuY2hlY2tlZD0hZW5hYmxlO31lbHNle2FkZENsYXNzKCQoXCJzZWFyY2hcIiksXCJncmV5ZWRvdXRcIik7cmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSxcInNlYXJjaGluZ1wiKTtyZW1vdmVDbGFzcyhsb2dNYWluQ29udGFpbmVyLFwic2VhcmNoaGlnaGxpZ2h0XCIpO3JlbW92ZUNsYXNzKGxvZ01haW5Db250YWluZXIsXCJzZWFyY2hmaWx0ZXJcIik7fScsJ3NldExvZ0NvbnRhaW5lckhlaWdodCgpO30nLCdmdW5jdGlvbiB0b2dnbGVTZWFyY2hGaWx0ZXIoKXt2YXIgZW5hYmxlPSQoXCJzZWFyY2hGaWx0ZXJcIikuY2hlY2tlZDtpZihlbmFibGUpe2FkZENsYXNzKGxvZ01haW5Db250YWluZXIsXCJzZWFyY2hmaWx0ZXJcIik7fWVsc2V7cmVtb3ZlQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixcInNlYXJjaGZpbHRlclwiKTt9JywncmVmcmVzaEN1cnJlbnRNYXRjaCgpO30nLCdmdW5jdGlvbiB0b2dnbGVTZWFyY2hIaWdobGlnaHQoKXt2YXIgZW5hYmxlPSQoXCJzZWFyY2hIaWdobGlnaHRcIikuY2hlY2tlZDtpZihlbmFibGUpe2FkZENsYXNzKGxvZ01haW5Db250YWluZXIsXCJzZWFyY2hoaWdobGlnaHRcIik7fWVsc2V7cmVtb3ZlQ2xhc3MobG9nTWFpbkNvbnRhaW5lcixcInNlYXJjaGhpZ2hsaWdodFwiKTt9fScsJ2Z1bmN0aW9uIGNsZWFyU2VhcmNoKCl7JChcInNlYXJjaEJveFwiKS52YWx1ZT1cIlwiO2RvU2VhcmNoKCk7fScsJ2Z1bmN0aW9uIHNlYXJjaE5leHQoKXtpZihjdXJyZW50U2VhcmNoIT09bnVsbCYmY3VycmVudE1hdGNoSW5kZXghPT1udWxsKXtjdXJyZW50U2VhcmNoLm1hdGNoZXNbY3VycmVudE1hdGNoSW5kZXhdLnNldE5vdEN1cnJlbnQoKTt2YXIgbmV4dE1hdGNoSW5kZXg9Y3VycmVudFNlYXJjaC5nZXROZXh0VmlzaWJsZU1hdGNoSW5kZXgoKTtpZihuZXh0TWF0Y2hJbmRleD5jdXJyZW50TWF0Y2hJbmRleHx8Y29uZmlybShcIlJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFnZS4gU3RhcnQgZnJvbSB0aGUgdG9wP1wiKSl7c2V0Q3VycmVudE1hdGNoSW5kZXgobmV4dE1hdGNoSW5kZXgpO319fScsJ2Z1bmN0aW9uIHNlYXJjaFByZXZpb3VzKCl7aWYoY3VycmVudFNlYXJjaCE9PW51bGwmJmN1cnJlbnRNYXRjaEluZGV4IT09bnVsbCl7Y3VycmVudFNlYXJjaC5tYXRjaGVzW2N1cnJlbnRNYXRjaEluZGV4XS5zZXROb3RDdXJyZW50KCk7dmFyIHByZXZpb3VzTWF0Y2hJbmRleD1jdXJyZW50U2VhcmNoLmdldFByZXZpb3VzVmlzaWJsZU1hdGNoSW5kZXgoKTtpZihwcmV2aW91c01hdGNoSW5kZXg8Y3VycmVudE1hdGNoSW5kZXh8fGNvbmZpcm0oXCJSZWFjaGVkIHRoZSBzdGFydCBvZiB0aGUgcGFnZS4gQ29udGludWUgZnJvbSB0aGUgYm90dG9tP1wiKSl7c2V0Q3VycmVudE1hdGNoSW5kZXgocHJldmlvdXNNYXRjaEluZGV4KTt9fX0nLCdmdW5jdGlvbiBzZXRDdXJyZW50TWF0Y2hJbmRleChpbmRleCl7Y3VycmVudE1hdGNoSW5kZXg9aW5kZXg7Y3VycmVudFNlYXJjaC5tYXRjaGVzW2N1cnJlbnRNYXRjaEluZGV4XS5zZXRDdXJyZW50KCk7fScsJ2Z1bmN0aW9uIGFkZENsYXNzKGVsLGNzc0NsYXNzKXtpZighaGFzQ2xhc3MoZWwsY3NzQ2xhc3MpKXtpZihlbC5jbGFzc05hbWUpe2VsLmNsYXNzTmFtZSs9XCIgXCIrY3NzQ2xhc3M7fWVsc2V7ZWwuY2xhc3NOYW1lPWNzc0NsYXNzO319fScsJ2Z1bmN0aW9uIGhhc0NsYXNzKGVsLGNzc0NsYXNzKXtpZihlbC5jbGFzc05hbWUpe3ZhciBjbGFzc05hbWVzPWVsLmNsYXNzTmFtZS5zcGxpdChcIiBcIik7cmV0dXJuIGFycmF5X2NvbnRhaW5zKGNsYXNzTmFtZXMsY3NzQ2xhc3MpO30nLCdyZXR1cm4gZmFsc2U7fScsJ2Z1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLGNzc0NsYXNzKXtpZihoYXNDbGFzcyhlbCxjc3NDbGFzcykpe3ZhciBleGlzdGluZ0NsYXNzZXM9ZWwuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTt2YXIgbmV3Q2xhc3Nlcz1bXTtmb3IodmFyIGk9MCxsZW49ZXhpc3RpbmdDbGFzc2VzLmxlbmd0aDtpPGxlbjtpKyspe2lmKGV4aXN0aW5nQ2xhc3Nlc1tpXSE9Y3NzQ2xhc3Mpe25ld0NsYXNzZXNbbmV3Q2xhc3Nlcy5sZW5ndGhdPWV4aXN0aW5nQ2xhc3Nlc1tpXTt9fScsJ2VsLmNsYXNzTmFtZT1uZXdDbGFzc2VzLmpvaW4oXCIgXCIpO319JywnZnVuY3Rpb24gcmVwbGFjZUNsYXNzKGVsLG5ld0Nzc0NsYXNzLG9sZENzc0NsYXNzKXtyZW1vdmVDbGFzcyhlbCxvbGRDc3NDbGFzcyk7YWRkQ2xhc3MoZWwsbmV3Q3NzQ2xhc3MpO30nLCdmdW5jdGlvbiBnZXRFbGVtZW50c0J5Q2xhc3MoZWwsY3NzQ2xhc3MsdGFnTmFtZSl7dmFyIGVsZW1lbnRzPWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO3ZhciBtYXRjaGVzPVtdO2Zvcih2YXIgaT0wLGxlbj1lbGVtZW50cy5sZW5ndGg7aTxsZW47aSsrKXtpZihoYXNDbGFzcyhlbGVtZW50c1tpXSxjc3NDbGFzcykpe21hdGNoZXMucHVzaChlbGVtZW50c1tpXSk7fX0nLCdyZXR1cm4gbWF0Y2hlczt9JywnZnVuY3Rpb24gJChpZCl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt9JywnZnVuY3Rpb24gaXNEZXNjZW5kYW50KG5vZGUsYW5jZXN0b3JOb2RlKXt3aGlsZShub2RlIT1udWxsKXtpZihub2RlPT09YW5jZXN0b3JOb2RlKXtyZXR1cm4gdHJ1ZTt9Jywnbm9kZT1ub2RlLnBhcmVudE5vZGU7fScsJ3JldHVybiBmYWxzZTt9JywnZnVuY3Rpb24gaXNPcnBoYW4obm9kZSl7dmFyIGN1cnJlbnROb2RlPW5vZGU7d2hpbGUoY3VycmVudE5vZGUpe2lmKGN1cnJlbnROb2RlPT1kb2N1bWVudC5ib2R5KXtyZXR1cm4gZmFsc2U7fScsJ2N1cnJlbnROb2RlPWN1cnJlbnROb2RlLnBhcmVudE5vZGU7fScsJ3JldHVybiB0cnVlO30nLCdmdW5jdGlvbiBlc2NhcGVIdG1sKHN0cil7cmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csXCImYW1wO1wiKS5yZXBsYWNlKC9bPF0vZyxcIiZsdDtcIikucmVwbGFjZSgvPi9nLFwiJmd0O1wiKTt9JywnZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKXtpZih3aW5kb3cuaW5uZXJXaWR0aCl7cmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoO31lbHNlIGlmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKXtyZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO31lbHNlIGlmKGRvY3VtZW50LmJvZHkpe3JldHVybiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO30nLCdyZXR1cm4gMDt9JywnZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCl7aWYod2luZG93LmlubmVySGVpZ2h0KXtyZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O31lbHNlIGlmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCl7cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7fWVsc2UgaWYoZG9jdW1lbnQuYm9keSl7cmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0O30nLCdyZXR1cm4gMDt9JywnZnVuY3Rpb24gZ2V0VG9vbEJhcnNIZWlnaHQoKXtyZXR1cm4gJChcInN3aXRjaGVzXCIpLm9mZnNldEhlaWdodDt9JywnZnVuY3Rpb24gZ2V0Q2hyb21lSGVpZ2h0KCl7dmFyIGhlaWdodD1nZXRUb29sQmFyc0hlaWdodCgpO2lmKHNob3dDb21tYW5kTGluZSl7aGVpZ2h0Kz0kKFwiY29tbWFuZExpbmVcIikub2Zmc2V0SGVpZ2h0O30nLCdyZXR1cm4gaGVpZ2h0O30nLCdmdW5jdGlvbiBzZXRMb2dDb250YWluZXJIZWlnaHQoKXtpZihsb2dNYWluQ29udGFpbmVyKXt2YXIgd2luZG93SGVpZ2h0PWdldFdpbmRvd0hlaWdodCgpOyQoXCJib2R5XCIpLnN0eWxlLmhlaWdodD1nZXRXaW5kb3dIZWlnaHQoKStcInB4XCI7bG9nTWFpbkNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9XCJcIisnLCdNYXRoLm1heCgwLHdpbmRvd0hlaWdodC1nZXRDaHJvbWVIZWlnaHQoKSkrXCJweFwiO319JywnZnVuY3Rpb24gc2V0Q29tbWFuZElucHV0V2lkdGgoKXtpZihzaG93Q29tbWFuZExpbmUpeyQoXCJjb21tYW5kXCIpLnN0eWxlLndpZHRoPVwiXCIrTWF0aC5tYXgoMCwkKFwiY29tbWFuZExpbmVDb250YWluZXJcIikub2Zmc2V0V2lkdGgtJywnKCQoXCJldmFsdWF0ZUJ1dHRvblwiKS5vZmZzZXRXaWR0aCsxMykpK1wicHhcIjt9fScsJ3dpbmRvdy5vbnJlc2l6ZT1mdW5jdGlvbigpe3NldENvbW1hbmRJbnB1dFdpZHRoKCk7c2V0TG9nQ29udGFpbmVySGVpZ2h0KCk7fTtpZighQXJyYXkucHJvdG90eXBlLnB1c2gpe0FycmF5LnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciBpPTAsbGVuPWFyZ3VtZW50cy5sZW5ndGg7aTxsZW47aSsrKXt0aGlzW3RoaXMubGVuZ3RoXT1hcmd1bWVudHNbaV07fScsJ3JldHVybiB0aGlzLmxlbmd0aDt9O30nLCdpZighQXJyYXkucHJvdG90eXBlLnBvcCl7QXJyYXkucHJvdG90eXBlLnBvcD1mdW5jdGlvbigpe2lmKHRoaXMubGVuZ3RoPjApe3ZhciB2YWw9dGhpc1t0aGlzLmxlbmd0aC0xXTt0aGlzLmxlbmd0aD10aGlzLmxlbmd0aC0xO3JldHVybiB2YWw7fX07fScsJ2lmKCFBcnJheS5wcm90b3R5cGUuc2hpZnQpe0FycmF5LnByb3RvdHlwZS5zaGlmdD1mdW5jdGlvbigpe2lmKHRoaXMubGVuZ3RoPjApe3ZhciBmaXJzdEl0ZW09dGhpc1swXTtmb3IodmFyIGk9MCxsZW49dGhpcy5sZW5ndGgtMTtpPGxlbjtpKyspe3RoaXNbaV09dGhpc1tpKzFdO30nLCd0aGlzLmxlbmd0aD10aGlzLmxlbmd0aC0xO3JldHVybiBmaXJzdEl0ZW07fX07fScsJ2lmKCFBcnJheS5wcm90b3R5cGUuc3BsaWNlKXtBcnJheS5wcm90b3R5cGUuc3BsaWNlPWZ1bmN0aW9uKHN0YXJ0SW5kZXgsZGVsZXRlQ291bnQpe3ZhciBpdGVtc0FmdGVyRGVsZXRlZD10aGlzLnNsaWNlKHN0YXJ0SW5kZXgrZGVsZXRlQ291bnQpO3ZhciBpdGVtc0RlbGV0ZWQ9dGhpcy5zbGljZShzdGFydEluZGV4LHN0YXJ0SW5kZXgrZGVsZXRlQ291bnQpO3RoaXMubGVuZ3RoPXN0YXJ0SW5kZXg7dmFyIGFyZ3VtZW50c0FycmF5PVtdO2Zvcih2YXIgaT0wLGxlbj1hcmd1bWVudHMubGVuZ3RoO2k8bGVuO2krKyl7YXJndW1lbnRzQXJyYXlbaV09YXJndW1lbnRzW2ldO30nLCd2YXIgaXRlbXNUb0FwcGVuZD0oYXJndW1lbnRzQXJyYXkubGVuZ3RoPjIpP2l0ZW1zQWZ0ZXJEZWxldGVkPWFyZ3VtZW50c0FycmF5LnNsaWNlKDIpLmNvbmNhdChpdGVtc0FmdGVyRGVsZXRlZCk6aXRlbXNBZnRlckRlbGV0ZWQ7Zm9yKGk9MCxsZW49aXRlbXNUb0FwcGVuZC5sZW5ndGg7aTxsZW47aSsrKXt0aGlzLnB1c2goaXRlbXNUb0FwcGVuZFtpXSk7fScsJ3JldHVybiBpdGVtc0RlbGV0ZWQ7fTt9JywnZnVuY3Rpb24gYXJyYXlfcmVtb3ZlKGFycix2YWwpe3ZhciBpbmRleD0tMTtmb3IodmFyIGk9MCxsZW49YXJyLmxlbmd0aDtpPGxlbjtpKyspe2lmKGFycltpXT09PXZhbCl7aW5kZXg9aTticmVhazt9fScsJ2lmKGluZGV4Pj0wKXthcnIuc3BsaWNlKGluZGV4LDEpO3JldHVybiBpbmRleDt9ZWxzZXtyZXR1cm4gZmFsc2U7fX0nLCdmdW5jdGlvbiBhcnJheV9yZW1vdmVGcm9tU3RhcnQoYXJyYXksbnVtYmVyVG9SZW1vdmUpe2lmKEFycmF5LnByb3RvdHlwZS5zcGxpY2Upe2FycmF5LnNwbGljZSgwLG51bWJlclRvUmVtb3ZlKTt9ZWxzZXtmb3IodmFyIGk9bnVtYmVyVG9SZW1vdmUsbGVuPWFycmF5Lmxlbmd0aDtpPGxlbjtpKyspe2FycmF5W2ktbnVtYmVyVG9SZW1vdmVdPWFycmF5W2ldO30nLCdhcnJheS5sZW5ndGg9YXJyYXkubGVuZ3RoLW51bWJlclRvUmVtb3ZlO30nLCdyZXR1cm4gYXJyYXk7fScsJ2Z1bmN0aW9uIGFycmF5X2NvbnRhaW5zKGFycix2YWwpe2Zvcih2YXIgaT0wLGxlbj1hcnIubGVuZ3RoO2k8bGVuO2krKyl7aWYoYXJyW2ldPT12YWwpe3JldHVybiB0cnVlO319JywncmV0dXJuIGZhbHNlO30nLCdmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXgpe2lmKGV4Lm1lc3NhZ2Upe3JldHVybiBleC5tZXNzYWdlO31lbHNlIGlmKGV4LmRlc2NyaXB0aW9uKXtyZXR1cm4gZXguZGVzY3JpcHRpb247fScsJ3JldHVyblwiXCIrZXg7fScsJ2Z1bmN0aW9uIG1vdmVDYXJldFRvRW5kKGlucHV0KXtpZihpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSl7aW5wdXQuZm9jdXMoKTt2YXIgbGVuZ3RoPWlucHV0LnZhbHVlLmxlbmd0aDtpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShsZW5ndGgsbGVuZ3RoKTt9ZWxzZSBpZihpbnB1dC5jcmVhdGVUZXh0UmFuZ2Upe3ZhciByYW5nZT1pbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtyYW5nZS5jb2xsYXBzZShmYWxzZSk7cmFuZ2Uuc2VsZWN0KCk7fScsJ2lucHV0LmZvY3VzKCk7fScsJ2Z1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldnQpe2lmKGV2dC5zdG9wUHJvcGFnYXRpb24pe2V2dC5zdG9wUHJvcGFnYXRpb24oKTt9ZWxzZSBpZih0eXBlb2YgZXZ0LmNhbmNlbEJ1YmJsZSE9XCJ1bmRlZmluZWRcIil7ZXZ0LmNhbmNlbEJ1YmJsZT10cnVlO319JywnZnVuY3Rpb24gZ2V0RXZlbnQoZXZ0KXtyZXR1cm4gZXZ0P2V2dDpldmVudDt9JywnZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2dCl7cmV0dXJuIGV2dC50YXJnZXQ/ZXZ0LnRhcmdldDpldnQuc3JjRWxlbWVudDt9JywnZnVuY3Rpb24gZ2V0UmVsYXRlZFRhcmdldChldnQpe2lmKGV2dC5yZWxhdGVkVGFyZ2V0KXtyZXR1cm4gZXZ0LnJlbGF0ZWRUYXJnZXQ7fWVsc2UgaWYoZXZ0LnNyY0VsZW1lbnQpe3N3aXRjaChldnQudHlwZSl7Y2FzZVwibW91c2VvdmVyXCI6cmV0dXJuIGV2dC5mcm9tRWxlbWVudDtjYXNlXCJtb3VzZW91dFwiOnJldHVybiBldnQudG9FbGVtZW50O2RlZmF1bHQ6cmV0dXJuIGV2dC5zcmNFbGVtZW50O319fScsJ2Z1bmN0aW9uIGNhbmNlbEtleUV2ZW50KGV2dCl7ZXZ0LnJldHVyblZhbHVlPWZhbHNlO3N0b3BQcm9wYWdhdGlvbihldnQpO30nLCdmdW5jdGlvbiBldmFsQ29tbWFuZExpbmUoKXt2YXIgZXhwcj0kKFwiY29tbWFuZFwiKS52YWx1ZTtldmFsQ29tbWFuZChleHByKTskKFwiY29tbWFuZFwiKS52YWx1ZT1cIlwiO30nLCdmdW5jdGlvbiBldmFsTGFzdENvbW1hbmQoKXtpZihsYXN0Q29tbWFuZCE9bnVsbCl7ZXZhbENvbW1hbmQobGFzdENvbW1hbmQpO319JywndmFyIGxhc3RDb21tYW5kPW51bGw7dmFyIGNvbW1hbmRIaXN0b3J5PVtdO3ZhciBjdXJyZW50Q29tbWFuZEluZGV4PTA7ZnVuY3Rpb24gZXZhbENvbW1hbmQoZXhwcil7aWYoYXBwZW5kZXIpe2FwcGVuZGVyLmV2YWxDb21tYW5kQW5kQXBwZW5kKGV4cHIpO31lbHNle3ZhciBwcmVmaXg9XCI+Pj4gXCIrZXhwcitcIlxcXFxyXFxcXG5cIjt0cnl7bG9nKFwiSU5GT1wiLHByZWZpeCtldmFsKGV4cHIpKTt9Y2F0Y2goZXgpe2xvZyhcIkVSUk9SXCIscHJlZml4K1wiRXJyb3I6IFwiK2dldEVycm9yTWVzc2FnZShleCkpO319JywnaWYoZXhwciE9Y29tbWFuZEhpc3RvcnlbY29tbWFuZEhpc3RvcnkubGVuZ3RoLTFdKXtjb21tYW5kSGlzdG9yeS5wdXNoKGV4cHIpO2lmKGFwcGVuZGVyKXthcHBlbmRlci5zdG9yZUNvbW1hbmRIaXN0b3J5KGNvbW1hbmRIaXN0b3J5KTt9fScsJ2N1cnJlbnRDb21tYW5kSW5kZXg9KGV4cHI9PWNvbW1hbmRIaXN0b3J5W2N1cnJlbnRDb21tYW5kSW5kZXhdKT9jdXJyZW50Q29tbWFuZEluZGV4KzE6Y29tbWFuZEhpc3RvcnkubGVuZ3RoO2xhc3RDb21tYW5kPWV4cHI7fScsJy8vXV0+JywnPC9zY3JpcHQ+JywnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicsJ2JvZHl7YmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtjb2xvcjpibGFjaztwYWRkaW5nOjA7bWFyZ2luOjA7Zm9udC1mYW1pbHk6dGFob21hLHZlcmRhbmEsYXJpYWwsaGVsdmV0aWNhLHNhbnMtc2VyaWY7b3ZlcmZsb3c6aGlkZGVufWRpdiNzd2l0Y2hlc0NvbnRhaW5lciBpbnB1dHttYXJnaW4tYm90dG9tOjB9ZGl2LnRvb2xiYXJ7Ym9yZGVyLXRvcDpzb2xpZCAjZmZmZmZmIDFweDtib3JkZXItYm90dG9tOnNvbGlkICNhY2E4OTkgMXB4O2JhY2tncm91bmQtY29sb3I6I2YxZWZlNztwYWRkaW5nOjNweCA1cHg7Zm9udC1zaXplOjY4Ljc1JX1kaXYudG9vbGJhcixkaXYjc2VhcmNoIGlucHV0e2ZvbnQtZmFtaWx5OnRhaG9tYSx2ZXJkYW5hLGFyaWFsLGhlbHZldGljYSxzYW5zLXNlcmlmfWRpdi50b29sYmFyIGlucHV0LmJ1dHRvbntwYWRkaW5nOjAgNXB4O2ZvbnQtc2l6ZToxMDAlfWRpdi50b29sYmFyIGlucHV0LmhpZGRlbntkaXNwbGF5Om5vbmV9ZGl2I3N3aXRjaGVzIGlucHV0I2NsZWFyQnV0dG9ue21hcmdpbi1sZWZ0OjIwcHh9ZGl2I2xldmVscyBsYWJlbHtmb250LXdlaWdodDpib2xkfWRpdiNsZXZlbHMgbGFiZWwsZGl2I29wdGlvbnMgbGFiZWx7bWFyZ2luLXJpZ2h0OjVweH1kaXYjbGV2ZWxzIGxhYmVsI3dyYXBMYWJlbHtmb250LXdlaWdodDpub3JtYWx9ZGl2I3NlYXJjaCBsYWJlbHttYXJnaW4tcmlnaHQ6MTBweH1kaXYjc2VhcmNoIGxhYmVsLnNlYXJjaGJveGxhYmVse21hcmdpbi1yaWdodDowfWRpdiNzZWFyY2ggaW5wdXR7Zm9udC1zaXplOjEwMCV9ZGl2I3NlYXJjaCBpbnB1dC52YWxpZHJlZ2V4e2NvbG9yOmdyZWVufWRpdiNzZWFyY2ggaW5wdXQuaW52YWxpZHJlZ2V4e2NvbG9yOnJlZH1kaXYjc2VhcmNoIGlucHV0Lm5vbWF0Y2hlc3tjb2xvcjp3aGl0ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZjY2NjZ9ZGl2I3NlYXJjaCBpbnB1dC5ub21hdGNoZXN7Y29sb3I6d2hpdGU7YmFja2dyb3VuZC1jb2xvcjojZmY2NjY2fWRpdiNzZWFyY2hOYXZ7ZGlzcGxheTpub25lfWRpdiNjb21tYW5kTGluZXtkaXNwbGF5Om5vbmV9ZGl2I2NvbW1hbmRMaW5lIGlucHV0I2NvbW1hbmR7Zm9udC1zaXplOjEwMCU7Zm9udC1mYW1pbHk6Q291cmllciBOZXcsQ291cmllcn1kaXYjY29tbWFuZExpbmUgaW5wdXQjZXZhbHVhdGVCdXR0b257fSouZ3JleWVkb3V0e2NvbG9yOmdyYXkgIWltcG9ydGFudDtib3JkZXItY29sb3I6Z3JheSAhaW1wb3J0YW50fSouZ3JleWVkb3V0ICouYWx3YXlzZW5hYmxlZHtjb2xvcjpibGFja30qLnVuc2VsZWN0YWJsZXsta2h0bWwtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX1kaXYjbG9ne2ZvbnQtZmFtaWx5OkNvdXJpZXIgTmV3LENvdXJpZXI7Zm9udC1zaXplOjc1JTt3aWR0aDoxMDAlO292ZXJmbG93OmF1dG87Y2xlYXI6Ym90aDtwb3NpdGlvbjpyZWxhdGl2ZX1kaXYuZ3JvdXB7Ym9yZGVyLWNvbG9yOiNjY2NjY2M7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDoxcHggMCAxcHggMXB4O292ZXJmbG93OnZpc2libGV9ZGl2Lm9sZEllIGRpdi5ncm91cCxkaXYub2xkSWUgZGl2Lmdyb3VwICosZGl2Lm9sZEllICoubG9nZW50cnl7aGVpZ2h0OjElfWRpdi5ncm91cCBkaXYuZ3JvdXBoZWFkaW5nIHNwYW4uZXhwYW5kZXJ7Ym9yZGVyOnNvbGlkIGJsYWNrIDFweDtmb250LWZhbWlseTpDb3VyaWVyIE5ldyxDb3VyaWVyO2ZvbnQtc2l6ZTowLjgzM2VtO2JhY2tncm91bmQtY29sb3I6I2VlZWVlZTtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6LTFweDtjb2xvcjpibGFjaztwYWRkaW5nOjAgMnB4O2N1cnNvcjpwb2ludGVyO2N1cnNvcjpoYW5kO2hlaWdodDoxJX1kaXYuZ3JvdXAgZGl2Lmdyb3VwY29udGVudHttYXJnaW4tbGVmdDoxMHB4O3BhZGRpbmctYm90dG9tOjJweDtvdmVyZmxvdzp2aXNpYmxlfWRpdi5ncm91cCBkaXYuZXhwYW5kZWR7ZGlzcGxheTpibG9ja31kaXYuZ3JvdXAgZGl2LmNvbGxhcHNlZHtkaXNwbGF5Om5vbmV9Ki5sb2dlbnRyeXtvdmVyZmxvdzp2aXNpYmxlO2Rpc3BsYXk6bm9uZTt3aGl0ZS1zcGFjZTpwcmV9c3Bhbi5wcmV7d2hpdGUtc3BhY2U6cHJlfXByZS51bndyYXBwZWR7ZGlzcGxheTppbmxpbmUgIWltcG9ydGFudH1wcmUudW53cmFwcGVkIHByZS5wcmUsZGl2LndyYXBwZWQgcHJlLnByZXtkaXNwbGF5OmlubGluZX1kaXYud3JhcHBlZCBwcmUucHJle3doaXRlLXNwYWNlOm5vcm1hbH1kaXYud3JhcHBlZHtkaXNwbGF5Om5vbmV9Ym9keS5zZWFyY2hpbmcgKi5sb2dlbnRyeSBzcGFuLmN1cnJlbnRtYXRjaHtjb2xvcjp3aGl0ZSAhaW1wb3J0YW50O2JhY2tncm91bmQtY29sb3I6Z3JlZW4gIWltcG9ydGFudH1ib2R5LnNlYXJjaGluZyBkaXYuc2VhcmNoaGlnaGxpZ2h0ICoubG9nZW50cnkgc3Bhbi5zZWFyY2h0ZXJte2NvbG9yOmJsYWNrO2JhY2tncm91bmQtY29sb3I6eWVsbG93fWRpdi53cmFwICoubG9nZW50cnl7d2hpdGUtc3BhY2U6bm9ybWFsICFpbXBvcnRhbnQ7Ym9yZGVyLXdpZHRoOjAgMCAxcHggMDtib3JkZXItY29sb3I6I2RkZGRkZDtib3JkZXItc3R5bGU6ZG90dGVkfWRpdi53cmFwICNsb2dfd3JhcHBlZCwjbG9nX3Vud3JhcHBlZHtkaXNwbGF5OmJsb2NrfWRpdi53cmFwICNsb2dfdW53cmFwcGVkLCNsb2dfd3JhcHBlZHtkaXNwbGF5Om5vbmV9ZGl2LndyYXAgKi5sb2dlbnRyeSBzcGFuLnByZXtvdmVyZmxvdzp2aXNpYmxlO3doaXRlLXNwYWNlOm5vcm1hbH1kaXYud3JhcCAqLmxvZ2VudHJ5IHByZS51bndyYXBwZWR7ZGlzcGxheTpub25lfWRpdi53cmFwICoubG9nZW50cnkgc3Bhbi53cmFwcGVke2Rpc3BsYXk6aW5saW5lfWRpdi5zZWFyY2hmaWx0ZXIgKi5zZWFyY2hub25tYXRjaHtkaXNwbGF5Om5vbmUgIWltcG9ydGFudH1kaXYjbG9nICouVFJBQ0UsbGFiZWwjbGFiZWxfVFJBQ0V7Y29sb3I6IzY2NjY2Nn1kaXYjbG9nICouREVCVUcsbGFiZWwjbGFiZWxfREVCVUd7Y29sb3I6Z3JlZW59ZGl2I2xvZyAqLklORk8sbGFiZWwjbGFiZWxfSU5GT3tjb2xvcjojMDAwMDk5fWRpdiNsb2cgKi5XQVJOLGxhYmVsI2xhYmVsX1dBUk57Y29sb3I6Izk5OTkwMH1kaXYjbG9nICouRVJST1IsbGFiZWwjbGFiZWxfRVJST1J7Y29sb3I6cmVkfWRpdiNsb2cgKi5GQVRBTCxsYWJlbCNsYWJlbF9GQVRBTHtjb2xvcjojNjYwMDY2fWRpdi5UUkFDRSNsb2cgKi5UUkFDRSxkaXYuREVCVUcjbG9nICouREVCVUcsZGl2LklORk8jbG9nICouSU5GTyxkaXYuV0FSTiNsb2cgKi5XQVJOLGRpdi5FUlJPUiNsb2cgKi5FUlJPUixkaXYuRkFUQUwjbG9nICouRkFUQUx7ZGlzcGxheTpibG9ja31kaXYjbG9nIGRpdi5zZXBhcmF0b3J7YmFja2dyb3VuZC1jb2xvcjojY2NjY2NjO21hcmdpbjo1cHggMDtsaW5lLWhlaWdodDoxcHh9JywnPC9zdHlsZT4nLCc8L2hlYWQ+JywnPGJvZHkgaWQ9XCJib2R5XCI+JywnPGRpdiBpZD1cInN3aXRjaGVzQ29udGFpbmVyXCI+JywnPGRpdiBpZD1cInN3aXRjaGVzXCI+JywnPGRpdiBpZD1cImxldmVsc1wiIGNsYXNzPVwidG9vbGJhclwiPicsJ0ZpbHRlcnM6JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic3dpdGNoX1RSQUNFXCIgb25jbGljaz1cImFwcGx5RmlsdGVycygpOyBjaGVja0FsbExldmVscygpXCIgY2hlY2tlZD1cImNoZWNrZWRcIiB0aXRsZT1cIlNob3cvaGlkZSB0cmFjZSBtZXNzYWdlc1wiIC8+PGxhYmVsIGZvcj1cInN3aXRjaF9UUkFDRVwiIGlkPVwibGFiZWxfVFJBQ0VcIj50cmFjZTwvbGFiZWw+JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic3dpdGNoX0RFQlVHXCIgb25jbGljaz1cImFwcGx5RmlsdGVycygpOyBjaGVja0FsbExldmVscygpXCIgY2hlY2tlZD1cImNoZWNrZWRcIiB0aXRsZT1cIlNob3cvaGlkZSBkZWJ1ZyBtZXNzYWdlc1wiIC8+PGxhYmVsIGZvcj1cInN3aXRjaF9ERUJVR1wiIGlkPVwibGFiZWxfREVCVUdcIj5kZWJ1ZzwvbGFiZWw+JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic3dpdGNoX0lORk9cIiBvbmNsaWNrPVwiYXBwbHlGaWx0ZXJzKCk7IGNoZWNrQWxsTGV2ZWxzKClcIiBjaGVja2VkPVwiY2hlY2tlZFwiIHRpdGxlPVwiU2hvdy9oaWRlIGluZm8gbWVzc2FnZXNcIiAvPjxsYWJlbCBmb3I9XCJzd2l0Y2hfSU5GT1wiIGlkPVwibGFiZWxfSU5GT1wiPmluZm88L2xhYmVsPicsJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInN3aXRjaF9XQVJOXCIgb25jbGljaz1cImFwcGx5RmlsdGVycygpOyBjaGVja0FsbExldmVscygpXCIgY2hlY2tlZD1cImNoZWNrZWRcIiB0aXRsZT1cIlNob3cvaGlkZSB3YXJuIG1lc3NhZ2VzXCIgLz48bGFiZWwgZm9yPVwic3dpdGNoX1dBUk5cIiBpZD1cImxhYmVsX1dBUk5cIj53YXJuPC9sYWJlbD4nLCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzd2l0Y2hfRVJST1JcIiBvbmNsaWNrPVwiYXBwbHlGaWx0ZXJzKCk7IGNoZWNrQWxsTGV2ZWxzKClcIiBjaGVja2VkPVwiY2hlY2tlZFwiIHRpdGxlPVwiU2hvdy9oaWRlIGVycm9yIG1lc3NhZ2VzXCIgLz48bGFiZWwgZm9yPVwic3dpdGNoX0VSUk9SXCIgaWQ9XCJsYWJlbF9FUlJPUlwiPmVycm9yPC9sYWJlbD4nLCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzd2l0Y2hfRkFUQUxcIiBvbmNsaWNrPVwiYXBwbHlGaWx0ZXJzKCk7IGNoZWNrQWxsTGV2ZWxzKClcIiBjaGVja2VkPVwiY2hlY2tlZFwiIHRpdGxlPVwiU2hvdy9oaWRlIGZhdGFsIG1lc3NhZ2VzXCIgLz48bGFiZWwgZm9yPVwic3dpdGNoX0ZBVEFMXCIgaWQ9XCJsYWJlbF9GQVRBTFwiPmZhdGFsPC9sYWJlbD4nLCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzd2l0Y2hfQUxMXCIgb25jbGljaz1cInRvZ2dsZUFsbExldmVscygpOyBhcHBseUZpbHRlcnMoKVwiIGNoZWNrZWQ9XCJjaGVja2VkXCIgdGl0bGU9XCJTaG93L2hpZGUgYWxsIG1lc3NhZ2VzXCIgLz48bGFiZWwgZm9yPVwic3dpdGNoX0FMTFwiIGlkPVwibGFiZWxfQUxMXCI+YWxsPC9sYWJlbD4nLCc8L2Rpdj4nLCc8ZGl2IGlkPVwic2VhcmNoXCIgY2xhc3M9XCJ0b29sYmFyXCI+JywnPGxhYmVsIGZvcj1cInNlYXJjaEJveFwiIGNsYXNzPVwic2VhcmNoYm94bGFiZWxcIj5TZWFyY2g6PC9sYWJlbD4gPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJzZWFyY2hCb3hcIiBvbmNsaWNrPVwidG9nZ2xlU2VhcmNoRW5hYmxlZCh0cnVlKVwiIG9ua2V5dXA9XCJzY2hlZHVsZVNlYXJjaCgpXCIgc2l6ZT1cIjIwXCIgLz4nLCc8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGlkPVwic2VhcmNoUmVzZXRcIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgdmFsdWU9XCJSZXNldFwiIG9uY2xpY2s9XCJjbGVhclNlYXJjaCgpXCIgY2xhc3M9XCJidXR0b25cIiB0aXRsZT1cIlJlc2V0IHRoZSBzZWFyY2hcIiAvPicsJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInNlYXJjaFJlZ2V4XCIgb25jbGljaz1cImRvU2VhcmNoKClcIiB0aXRsZT1cIklmIGNoZWNrZWQsIHNlYXJjaCBpcyB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uXCIgLz48bGFiZWwgZm9yPVwic2VhcmNoUmVnZXhcIj5SZWdleDwvbGFiZWw+JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2VhcmNoQ2FzZVNlbnNpdGl2ZVwiIG9uY2xpY2s9XCJkb1NlYXJjaCgpXCIgdGl0bGU9XCJJZiBjaGVja2VkLCBzZWFyY2ggaXMgY2FzZSBzZW5zaXRpdmVcIiAvPjxsYWJlbCBmb3I9XCJzZWFyY2hDYXNlU2Vuc2l0aXZlXCI+TWF0Y2ggY2FzZTwvbGFiZWw+JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2VhcmNoRGlzYWJsZVwiIG9uY2xpY2s9XCJ0b2dnbGVTZWFyY2hFbmFibGVkKClcIiB0aXRsZT1cIkVuYWJsZS9kaXNhYmxlIHNlYXJjaFwiIC8+PGxhYmVsIGZvcj1cInNlYXJjaERpc2FibGVcIiBjbGFzcz1cImFsd2F5c2VuYWJsZWRcIj5EaXNhYmxlPC9sYWJlbD4nLCc8ZGl2IGlkPVwic2VhcmNoTmF2XCI+JywnPGlucHV0IHR5cGU9XCJidXR0b25cIiBpZD1cInNlYXJjaE5leHRcIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgdmFsdWU9XCJOZXh0XCIgb25jbGljaz1cInNlYXJjaE5leHQoKVwiIGNsYXNzPVwiYnV0dG9uXCIgdGl0bGU9XCJHbyB0byB0aGUgbmV4dCBtYXRjaGluZyBsb2cgZW50cnlcIiAvPicsJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJzZWFyY2hQcmV2aW91c1wiIGRpc2FibGVkPVwiZGlzYWJsZWRcIiB2YWx1ZT1cIlByZXZpb3VzXCIgb25jbGljaz1cInNlYXJjaFByZXZpb3VzKClcIiBjbGFzcz1cImJ1dHRvblwiIHRpdGxlPVwiR28gdG8gdGhlIHByZXZpb3VzIG1hdGNoaW5nIGxvZyBlbnRyeVwiIC8+JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2VhcmNoRmlsdGVyXCIgb25jbGljaz1cInRvZ2dsZVNlYXJjaEZpbHRlcigpXCIgdGl0bGU9XCJJZiBjaGVja2VkLCBub24tbWF0Y2hpbmcgbG9nIGVudHJpZXMgYXJlIGZpbHRlcmVkIG91dFwiIC8+PGxhYmVsIGZvcj1cInNlYXJjaEZpbHRlclwiPkZpbHRlcjwvbGFiZWw+JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2VhcmNoSGlnaGxpZ2h0XCIgb25jbGljaz1cInRvZ2dsZVNlYXJjaEhpZ2hsaWdodCgpXCIgdGl0bGU9XCJIaWdobGlnaHQgbWF0Y2hlZCBzZWFyY2ggdGVybXNcIiAvPjxsYWJlbCBmb3I9XCJzZWFyY2hIaWdobGlnaHRcIiBjbGFzcz1cImFsd2F5c2VuYWJsZWRcIj5IaWdobGlnaHQgYWxsPC9sYWJlbD4nLCc8L2Rpdj4nLCc8L2Rpdj4nLCc8ZGl2IGlkPVwib3B0aW9uc1wiIGNsYXNzPVwidG9vbGJhclwiPicsJ09wdGlvbnM6JywnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZW5hYmxlTG9nZ2luZ1wiIG9uY2xpY2s9XCJ0b2dnbGVMb2dnaW5nRW5hYmxlZCgpXCIgY2hlY2tlZD1cImNoZWNrZWRcIiB0aXRsZT1cIkVuYWJsZS9kaXNhYmxlIGxvZ2dpbmdcIiAvPjxsYWJlbCBmb3I9XCJlbmFibGVMb2dnaW5nXCIgaWQ9XCJlbmFibGVMb2dnaW5nTGFiZWxcIj5Mb2c8L2xhYmVsPicsJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cIndyYXBcIiBvbmNsaWNrPVwidG9nZ2xlV3JhcCgpXCIgdGl0bGU9XCJFbmFibGUgLyBkaXNhYmxlIHdvcmQgd3JhcFwiIC8+PGxhYmVsIGZvcj1cIndyYXBcIiBpZD1cIndyYXBMYWJlbFwiPldyYXA8L2xhYmVsPicsJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cIm5ld2VzdEF0VG9wXCIgb25jbGljaz1cInRvZ2dsZU5ld2VzdEF0VG9wKClcIiB0aXRsZT1cIklmIGNoZWNrZWQsIGNhdXNlcyBuZXdlc3QgbWVzc2FnZXMgdG8gYXBwZWFyIGF0IHRoZSB0b3BcIiAvPjxsYWJlbCBmb3I9XCJuZXdlc3RBdFRvcFwiIGlkPVwibmV3ZXN0QXRUb3BMYWJlbFwiPk5ld2VzdCBhdCB0aGUgdG9wPC9sYWJlbD4nLCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJzY3JvbGxUb0xhdGVzdFwiIG9uY2xpY2s9XCJ0b2dnbGVTY3JvbGxUb0xhdGVzdCgpXCIgY2hlY2tlZD1cImNoZWNrZWRcIiB0aXRsZT1cIklmIGNoZWNrZWQsIHdpbmRvdyBhdXRvbWF0aWNhbGx5IHNjcm9sbHMgdG8gYSBuZXcgbWVzc2FnZSB3aGVuIGl0IGlzIGFkZGVkXCIgLz48bGFiZWwgZm9yPVwic2Nyb2xsVG9MYXRlc3RcIiBpZD1cInNjcm9sbFRvTGF0ZXN0TGFiZWxcIj5TY3JvbGwgdG8gbGF0ZXN0PC9sYWJlbD4nLCc8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGlkPVwiY2xlYXJCdXR0b25cIiB2YWx1ZT1cIkNsZWFyXCIgb25jbGljaz1cImNsZWFyTG9nKClcIiBjbGFzcz1cImJ1dHRvblwiIHRpdGxlPVwiQ2xlYXIgYWxsIGxvZyBtZXNzYWdlc1wiICAvPicsJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJoaWRlQnV0dG9uXCIgdmFsdWU9XCJIaWRlXCIgb25jbGljaz1cImhpZGUoKVwiIGNsYXNzPVwiaGlkZGVuIGJ1dHRvblwiIHRpdGxlPVwiSGlkZSB0aGUgY29uc29sZVwiIC8+JywnPGlucHV0IHR5cGU9XCJidXR0b25cIiBpZD1cImNsb3NlQnV0dG9uXCIgdmFsdWU9XCJDbG9zZVwiIG9uY2xpY2s9XCJjbG9zZVdpbmRvdygpXCIgY2xhc3M9XCJoaWRkZW4gYnV0dG9uXCIgdGl0bGU9XCJDbG9zZSB0aGUgd2luZG93XCIgLz4nLCc8L2Rpdj4nLCc8L2Rpdj4nLCc8L2Rpdj4nLCc8ZGl2IGlkPVwibG9nXCIgY2xhc3M9XCJUUkFDRSBERUJVRyBJTkZPIFdBUk4gRVJST1IgRkFUQUxcIj48L2Rpdj4nLCc8ZGl2IGlkPVwiY29tbWFuZExpbmVcIiBjbGFzcz1cInRvb2xiYXJcIj4nLCc8ZGl2IGlkPVwiY29tbWFuZExpbmVDb250YWluZXJcIj4nLCc8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImNvbW1hbmRcIiB0aXRsZT1cIkVudGVyIGEgSmF2YVNjcmlwdCBjb21tYW5kIGhlcmUgYW5kIGhpdCByZXR1cm4gb3IgcHJlc3MgXFwnRXZhbHVhdGVcXCdcIiAvPicsJzxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJldmFsdWF0ZUJ1dHRvblwiIHZhbHVlPVwiRXZhbHVhdGVcIiBjbGFzcz1cImJ1dHRvblwiIHRpdGxlPVwiRXZhbHVhdGUgdGhlIGNvbW1hbmRcIiBvbmNsaWNrPVwiZXZhbENvbW1hbmRMaW5lKClcIiAvPicsJzwvZGl2PicsJzwvZGl2PicsJzwvYm9keT4nLCc8L2h0bWw+JywnJ107fTt2YXIgZGVmYXVsdENvbW1hbmRMaW5lRnVuY3Rpb25zPVtdO0NvbnNvbGVBcHBlbmRlcj1mdW5jdGlvbigpe307dmFyIGNvbnNvbGVBcHBlbmRlcklkQ291bnRlcj0xO0NvbnNvbGVBcHBlbmRlci5wcm90b3R5cGU9bmV3IEFwcGVuZGVyKCk7Q29uc29sZUFwcGVuZGVyLnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oaW5QYWdlLGNvbnRhaW5lcixsYXp5SW5pdCxpbml0aWFsbHlNaW5pbWl6ZWQsdXNlRG9jdW1lbnRXcml0ZSx3aWR0aCxoZWlnaHQsZm9jdXNDb25zb2xlV2luZG93KXt2YXIgYXBwZW5kZXI9dGhpczt2YXIgaW5pdGlhbGl6ZWQ9ZmFsc2U7dmFyIGNvbnNvbGVXaW5kb3dDcmVhdGVkPWZhbHNlO3ZhciBjb25zb2xlV2luZG93TG9hZGVkPWZhbHNlO3ZhciBjb25zb2xlQ2xvc2VkPWZhbHNlO3ZhciBxdWV1ZWRMb2dnaW5nRXZlbnRzPVtdO3ZhciBpc1N1cHBvcnRlZD10cnVlO3ZhciBjb25zb2xlQXBwZW5kZXJJZD1jb25zb2xlQXBwZW5kZXJJZENvdW50ZXIrKztpbml0aWFsbHlNaW5pbWl6ZWQ9ZXh0cmFjdEJvb2xlYW5Gcm9tUGFyYW0oaW5pdGlhbGx5TWluaW1pemVkLHRoaXMuZGVmYXVsdHMuaW5pdGlhbGx5TWluaW1pemVkKTtsYXp5SW5pdD1leHRyYWN0Qm9vbGVhbkZyb21QYXJhbShsYXp5SW5pdCx0aGlzLmRlZmF1bHRzLmxhenlJbml0KTt1c2VEb2N1bWVudFdyaXRlPWV4dHJhY3RCb29sZWFuRnJvbVBhcmFtKHVzZURvY3VtZW50V3JpdGUsdGhpcy5kZWZhdWx0cy51c2VEb2N1bWVudFdyaXRlKTt2YXIgbmV3ZXN0TWVzc2FnZUF0VG9wPXRoaXMuZGVmYXVsdHMubmV3ZXN0TWVzc2FnZUF0VG9wO3ZhciBzY3JvbGxUb0xhdGVzdE1lc3NhZ2U9dGhpcy5kZWZhdWx0cy5zY3JvbGxUb0xhdGVzdE1lc3NhZ2U7d2lkdGg9d2lkdGg/d2lkdGg6dGhpcy5kZWZhdWx0cy53aWR0aDtoZWlnaHQ9aGVpZ2h0P2hlaWdodDp0aGlzLmRlZmF1bHRzLmhlaWdodDt2YXIgbWF4TWVzc2FnZXM9dGhpcy5kZWZhdWx0cy5tYXhNZXNzYWdlczt2YXIgc2hvd0NvbW1hbmRMaW5lPXRoaXMuZGVmYXVsdHMuc2hvd0NvbW1hbmRMaW5lO3ZhciBjb21tYW5kTGluZU9iamVjdEV4cGFuc2lvbkRlcHRoPXRoaXMuZGVmYXVsdHMuY29tbWFuZExpbmVPYmplY3RFeHBhbnNpb25EZXB0aDt2YXIgc2hvd0hpZGVCdXR0b249dGhpcy5kZWZhdWx0cy5zaG93SGlkZUJ1dHRvbjt2YXIgc2hvd0Nsb3NlQnV0dG9uPXRoaXMuZGVmYXVsdHMuc2hvd0Nsb3NlQnV0dG9uO3RoaXMuc2V0TGF5b3V0KHRoaXMuZGVmYXVsdHMubGF5b3V0KTt2YXIgaW5pdCxjcmVhdGVXaW5kb3csc2FmZVRvQXBwZW5kLGdldENvbnNvbGVXaW5kb3csb3Blbjt2YXIgYXBwZW5kZXJOYW1lPWluUGFnZT9cIkluUGFnZUFwcGVuZGVyXCI6XCJQb3BVcEFwcGVuZGVyXCI7dmFyIGNoZWNrQ2FuQ29uZmlndXJlPWZ1bmN0aW9uKGNvbmZpZ09wdGlvbk5hbWUpe2lmKGNvbnNvbGVXaW5kb3dDcmVhdGVkKXtoYW5kbGVFcnJvcihhcHBlbmRlck5hbWUrXCI6IGNvbmZpZ3VyYXRpb24gb3B0aW9uICdcIitjb25maWdPcHRpb25OYW1lK1wiJyBtYXkgbm90IGJlIHNldCBhZnRlciB0aGUgYXBwZW5kZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcIik7cmV0dXJuIGZhbHNlO31cclxucmV0dXJuIHRydWU7fTt2YXIgY29uc29sZVdpbmRvd0V4aXN0cz1mdW5jdGlvbigpe3JldHVybihjb25zb2xlV2luZG93TG9hZGVkJiZpc1N1cHBvcnRlZCYmIWNvbnNvbGVDbG9zZWQpO307dGhpcy5pc05ld2VzdE1lc3NhZ2VBdFRvcD1mdW5jdGlvbigpe3JldHVybiBuZXdlc3RNZXNzYWdlQXRUb3A7fTt0aGlzLnNldE5ld2VzdE1lc3NhZ2VBdFRvcD1mdW5jdGlvbihuZXdlc3RNZXNzYWdlQXRUb3BQYXJhbSl7bmV3ZXN0TWVzc2FnZUF0VG9wPWJvb2wobmV3ZXN0TWVzc2FnZUF0VG9wUGFyYW0pO2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLnNldE5ld2VzdEF0VG9wKG5ld2VzdE1lc3NhZ2VBdFRvcCk7fX07dGhpcy5pc1Njcm9sbFRvTGF0ZXN0TWVzc2FnZT1mdW5jdGlvbigpe3JldHVybiBzY3JvbGxUb0xhdGVzdE1lc3NhZ2U7fTt0aGlzLnNldFNjcm9sbFRvTGF0ZXN0TWVzc2FnZT1mdW5jdGlvbihzY3JvbGxUb0xhdGVzdE1lc3NhZ2VQYXJhbSl7c2Nyb2xsVG9MYXRlc3RNZXNzYWdlPWJvb2woc2Nyb2xsVG9MYXRlc3RNZXNzYWdlUGFyYW0pO2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLnNldFNjcm9sbFRvTGF0ZXN0KHNjcm9sbFRvTGF0ZXN0TWVzc2FnZSk7fX07dGhpcy5nZXRXaWR0aD1mdW5jdGlvbigpe3JldHVybiB3aWR0aDt9O3RoaXMuc2V0V2lkdGg9ZnVuY3Rpb24od2lkdGhQYXJhbSl7aWYoY2hlY2tDYW5Db25maWd1cmUoXCJ3aWR0aFwiKSl7d2lkdGg9ZXh0cmFjdFN0cmluZ0Zyb21QYXJhbSh3aWR0aFBhcmFtLHdpZHRoKTt9fTt0aGlzLmdldEhlaWdodD1mdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fTt0aGlzLnNldEhlaWdodD1mdW5jdGlvbihoZWlnaHRQYXJhbSl7aWYoY2hlY2tDYW5Db25maWd1cmUoXCJoZWlnaHRcIikpe2hlaWdodD1leHRyYWN0U3RyaW5nRnJvbVBhcmFtKGhlaWdodFBhcmFtLGhlaWdodCk7fX07dGhpcy5nZXRNYXhNZXNzYWdlcz1mdW5jdGlvbigpe3JldHVybiBtYXhNZXNzYWdlczt9O3RoaXMuc2V0TWF4TWVzc2FnZXM9ZnVuY3Rpb24obWF4TWVzc2FnZXNQYXJhbSl7bWF4TWVzc2FnZXM9ZXh0cmFjdEludEZyb21QYXJhbShtYXhNZXNzYWdlc1BhcmFtLG1heE1lc3NhZ2VzKTtpZihjb25zb2xlV2luZG93RXhpc3RzKCkpe2dldENvbnNvbGVXaW5kb3coKS5zZXRNYXhNZXNzYWdlcyhtYXhNZXNzYWdlcyk7fX07dGhpcy5pc1Nob3dDb21tYW5kTGluZT1mdW5jdGlvbigpe3JldHVybiBzaG93Q29tbWFuZExpbmU7fTt0aGlzLnNldFNob3dDb21tYW5kTGluZT1mdW5jdGlvbihzaG93Q29tbWFuZExpbmVQYXJhbSl7c2hvd0NvbW1hbmRMaW5lPWJvb2woc2hvd0NvbW1hbmRMaW5lUGFyYW0pO2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLnNldFNob3dDb21tYW5kTGluZShzaG93Q29tbWFuZExpbmUpO319O3RoaXMuaXNTaG93SGlkZUJ1dHRvbj1mdW5jdGlvbigpe3JldHVybiBzaG93SGlkZUJ1dHRvbjt9O3RoaXMuc2V0U2hvd0hpZGVCdXR0b249ZnVuY3Rpb24oc2hvd0hpZGVCdXR0b25QYXJhbSl7c2hvd0hpZGVCdXR0b249Ym9vbChzaG93SGlkZUJ1dHRvblBhcmFtKTtpZihjb25zb2xlV2luZG93RXhpc3RzKCkpe2dldENvbnNvbGVXaW5kb3coKS5zZXRTaG93SGlkZUJ1dHRvbihzaG93SGlkZUJ1dHRvbik7fX07dGhpcy5pc1Nob3dDbG9zZUJ1dHRvbj1mdW5jdGlvbigpe3JldHVybiBzaG93Q2xvc2VCdXR0b247fTt0aGlzLnNldFNob3dDbG9zZUJ1dHRvbj1mdW5jdGlvbihzaG93Q2xvc2VCdXR0b25QYXJhbSl7c2hvd0Nsb3NlQnV0dG9uPWJvb2woc2hvd0Nsb3NlQnV0dG9uUGFyYW0pO2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLnNldFNob3dDbG9zZUJ1dHRvbihzaG93Q2xvc2VCdXR0b24pO319O3RoaXMuZ2V0Q29tbWFuZExpbmVPYmplY3RFeHBhbnNpb25EZXB0aD1mdW5jdGlvbigpe3JldHVybiBjb21tYW5kTGluZU9iamVjdEV4cGFuc2lvbkRlcHRoO307dGhpcy5zZXRDb21tYW5kTGluZU9iamVjdEV4cGFuc2lvbkRlcHRoPWZ1bmN0aW9uKGNvbW1hbmRMaW5lT2JqZWN0RXhwYW5zaW9uRGVwdGhQYXJhbSl7Y29tbWFuZExpbmVPYmplY3RFeHBhbnNpb25EZXB0aD1leHRyYWN0SW50RnJvbVBhcmFtKGNvbW1hbmRMaW5lT2JqZWN0RXhwYW5zaW9uRGVwdGhQYXJhbSxjb21tYW5kTGluZU9iamVjdEV4cGFuc2lvbkRlcHRoKTt9O3ZhciBtaW5pbWl6ZWQ9aW5pdGlhbGx5TWluaW1pemVkO3RoaXMuaXNJbml0aWFsbHlNaW5pbWl6ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gaW5pdGlhbGx5TWluaW1pemVkO307dGhpcy5zZXRJbml0aWFsbHlNaW5pbWl6ZWQ9ZnVuY3Rpb24oaW5pdGlhbGx5TWluaW1pemVkUGFyYW0pe2lmKGNoZWNrQ2FuQ29uZmlndXJlKFwiaW5pdGlhbGx5TWluaW1pemVkXCIpKXtpbml0aWFsbHlNaW5pbWl6ZWQ9Ym9vbChpbml0aWFsbHlNaW5pbWl6ZWRQYXJhbSk7bWluaW1pemVkPWluaXRpYWxseU1pbmltaXplZDt9fTt0aGlzLmlzVXNlRG9jdW1lbnRXcml0ZT1mdW5jdGlvbigpe3JldHVybiB1c2VEb2N1bWVudFdyaXRlO307dGhpcy5zZXRVc2VEb2N1bWVudFdyaXRlPWZ1bmN0aW9uKHVzZURvY3VtZW50V3JpdGVQYXJhbSl7aWYoY2hlY2tDYW5Db25maWd1cmUoXCJ1c2VEb2N1bWVudFdyaXRlXCIpKXt1c2VEb2N1bWVudFdyaXRlPWJvb2wodXNlRG9jdW1lbnRXcml0ZVBhcmFtKTt9fTtmdW5jdGlvbiBRdWV1ZWRMb2dnaW5nRXZlbnQobG9nZ2luZ0V2ZW50LGZvcm1hdHRlZE1lc3NhZ2Upe3RoaXMubG9nZ2luZ0V2ZW50PWxvZ2dpbmdFdmVudDt0aGlzLmxldmVsTmFtZT1sb2dnaW5nRXZlbnQubGV2ZWwubmFtZTt0aGlzLmZvcm1hdHRlZE1lc3NhZ2U9Zm9ybWF0dGVkTWVzc2FnZTt9XHJcblF1ZXVlZExvZ2dpbmdFdmVudC5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKCl7Z2V0Q29uc29sZVdpbmRvdygpLmxvZyh0aGlzLmxldmVsTmFtZSx0aGlzLmZvcm1hdHRlZE1lc3NhZ2UpO307ZnVuY3Rpb24gUXVldWVkR3JvdXAobmFtZSxpbml0aWFsbHlFeHBhbmRlZCl7dGhpcy5uYW1lPW5hbWU7dGhpcy5pbml0aWFsbHlFeHBhbmRlZD1pbml0aWFsbHlFeHBhbmRlZDt9XHJcblF1ZXVlZEdyb3VwLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oKXtnZXRDb25zb2xlV2luZG93KCkuZ3JvdXAodGhpcy5uYW1lLHRoaXMuaW5pdGlhbGx5RXhwYW5kZWQpO307ZnVuY3Rpb24gUXVldWVkR3JvdXBFbmQoKXt9XHJcblF1ZXVlZEdyb3VwRW5kLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oKXtnZXRDb25zb2xlV2luZG93KCkuZ3JvdXBFbmQoKTt9O3ZhciBjaGVja0FuZEFwcGVuZD1mdW5jdGlvbigpe3NhZmVUb0FwcGVuZCgpO2lmKCFpbml0aWFsaXplZCl7aW5pdCgpO31lbHNlIGlmKGNvbnNvbGVDbG9zZWQmJnJlb3BlbldoZW5DbG9zZWQpe2NyZWF0ZVdpbmRvdygpO31cclxuaWYoc2FmZVRvQXBwZW5kKCkpe2FwcGVuZFF1ZXVlZExvZ2dpbmdFdmVudHMoKTt9fTt0aGlzLmFwcGVuZD1mdW5jdGlvbihsb2dnaW5nRXZlbnQpe2lmKGlzU3VwcG9ydGVkKXt2YXIgZm9ybWF0dGVkTWVzc2FnZT1hcHBlbmRlci5nZXRMYXlvdXQoKS5mb3JtYXRXaXRoRXhjZXB0aW9uKGxvZ2dpbmdFdmVudCk7cXVldWVkTG9nZ2luZ0V2ZW50cy5wdXNoKG5ldyBRdWV1ZWRMb2dnaW5nRXZlbnQobG9nZ2luZ0V2ZW50LGZvcm1hdHRlZE1lc3NhZ2UpKTtjaGVja0FuZEFwcGVuZCgpO319O3RoaXMuZ3JvdXA9ZnVuY3Rpb24obmFtZSxpbml0aWFsbHlFeHBhbmRlZCl7aWYoaXNTdXBwb3J0ZWQpe3F1ZXVlZExvZ2dpbmdFdmVudHMucHVzaChuZXcgUXVldWVkR3JvdXAobmFtZSxpbml0aWFsbHlFeHBhbmRlZCkpO2NoZWNrQW5kQXBwZW5kKCk7fX07dGhpcy5ncm91cEVuZD1mdW5jdGlvbigpe2lmKGlzU3VwcG9ydGVkKXtxdWV1ZWRMb2dnaW5nRXZlbnRzLnB1c2gobmV3IFF1ZXVlZEdyb3VwRW5kKCkpO2NoZWNrQW5kQXBwZW5kKCk7fX07dmFyIGFwcGVuZFF1ZXVlZExvZ2dpbmdFdmVudHM9ZnVuY3Rpb24oKXt3aGlsZShxdWV1ZWRMb2dnaW5nRXZlbnRzLmxlbmd0aD4wKXtxdWV1ZWRMb2dnaW5nRXZlbnRzLnNoaWZ0KCkuYXBwZW5kKCk7fVxyXG5pZihmb2N1c0NvbnNvbGVXaW5kb3cpe2dldENvbnNvbGVXaW5kb3coKS5mb2N1cygpO319O3RoaXMuc2V0QWRkZWRUb0xvZ2dlcj1mdW5jdGlvbihsb2dnZXIpe3RoaXMubG9nZ2Vycy5wdXNoKGxvZ2dlcik7aWYoZW5hYmxlZCYmIWxhenlJbml0KXtpbml0KCk7fX07dGhpcy5jbGVhcj1mdW5jdGlvbigpe2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLmNsZWFyTG9nKCk7fVxyXG5xdWV1ZWRMb2dnaW5nRXZlbnRzLmxlbmd0aD0wO307dGhpcy5mb2N1cz1mdW5jdGlvbigpe2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLmZvY3VzKCk7fX07dGhpcy5mb2N1c0NvbW1hbmRMaW5lPWZ1bmN0aW9uKCl7aWYoY29uc29sZVdpbmRvd0V4aXN0cygpKXtnZXRDb25zb2xlV2luZG93KCkuZm9jdXNDb21tYW5kTGluZSgpO319O3RoaXMuZm9jdXNTZWFyY2g9ZnVuY3Rpb24oKXtpZihjb25zb2xlV2luZG93RXhpc3RzKCkpe2dldENvbnNvbGVXaW5kb3coKS5mb2N1c1NlYXJjaCgpO319O3ZhciBjb21tYW5kV2luZG93PXdpbmRvdzt0aGlzLmdldENvbW1hbmRXaW5kb3c9ZnVuY3Rpb24oKXtyZXR1cm4gY29tbWFuZFdpbmRvdzt9O3RoaXMuc2V0Q29tbWFuZFdpbmRvdz1mdW5jdGlvbihjb21tYW5kV2luZG93UGFyYW0pe2NvbW1hbmRXaW5kb3c9Y29tbWFuZFdpbmRvd1BhcmFtO307dGhpcy5leGVjdXRlTGFzdENvbW1hbmQ9ZnVuY3Rpb24oKXtpZihjb25zb2xlV2luZG93RXhpc3RzKCkpe2dldENvbnNvbGVXaW5kb3coKS5ldmFsTGFzdENvbW1hbmQoKTt9fTt2YXIgY29tbWFuZExheW91dD1uZXcgUGF0dGVybkxheW91dChcIiVtXCIpO3RoaXMuZ2V0Q29tbWFuZExheW91dD1mdW5jdGlvbigpe3JldHVybiBjb21tYW5kTGF5b3V0O307dGhpcy5zZXRDb21tYW5kTGF5b3V0PWZ1bmN0aW9uKGNvbW1hbmRMYXlvdXRQYXJhbSl7Y29tbWFuZExheW91dD1jb21tYW5kTGF5b3V0UGFyYW07fTt0aGlzLmV2YWxDb21tYW5kQW5kQXBwZW5kPWZ1bmN0aW9uKGV4cHIpe3ZhciBjb21tYW5kUmV0dXJuVmFsdWU9e2FwcGVuZFJlc3VsdDp0cnVlLGlzRXJyb3I6ZmFsc2V9O3ZhciBjb21tYW5kT3V0cHV0PVwiXCI7dHJ5e3ZhciByZXN1bHQsaTtpZighY29tbWFuZFdpbmRvdy5ldmFsJiZjb21tYW5kV2luZG93LmV4ZWNTY3JpcHQpe2NvbW1hbmRXaW5kb3cuZXhlY1NjcmlwdChcIm51bGxcIik7fVxyXG52YXIgY29tbWFuZExpbmVGdW5jdGlvbnNIYXNoPXt9O2ZvcihpPTAsbGVuPWNvbW1hbmRMaW5lRnVuY3Rpb25zLmxlbmd0aDtpPGxlbjtpKyspe2NvbW1hbmRMaW5lRnVuY3Rpb25zSGFzaFtjb21tYW5kTGluZUZ1bmN0aW9uc1tpXVswXV09Y29tbWFuZExpbmVGdW5jdGlvbnNbaV1bMV07fVxyXG52YXIgb2JqZWN0c1RvUmVzdG9yZT1bXTt2YXIgYWRkT2JqZWN0VG9SZXN0b3JlPWZ1bmN0aW9uKG5hbWUpe29iamVjdHNUb1Jlc3RvcmUucHVzaChbbmFtZSxjb21tYW5kV2luZG93W25hbWVdXSk7fTthZGRPYmplY3RUb1Jlc3RvcmUoXCJhcHBlbmRlclwiKTtjb21tYW5kV2luZG93LmFwcGVuZGVyPWFwcGVuZGVyO2FkZE9iamVjdFRvUmVzdG9yZShcImNvbW1hbmRSZXR1cm5WYWx1ZVwiKTtjb21tYW5kV2luZG93LmNvbW1hbmRSZXR1cm5WYWx1ZT1jb21tYW5kUmV0dXJuVmFsdWU7YWRkT2JqZWN0VG9SZXN0b3JlKFwiY29tbWFuZExpbmVGdW5jdGlvbnNIYXNoXCIpO2NvbW1hbmRXaW5kb3cuY29tbWFuZExpbmVGdW5jdGlvbnNIYXNoPWNvbW1hbmRMaW5lRnVuY3Rpb25zSGFzaDt2YXIgYWRkRnVuY3Rpb25Ub1dpbmRvdz1mdW5jdGlvbihuYW1lKXthZGRPYmplY3RUb1Jlc3RvcmUobmFtZSk7Y29tbWFuZFdpbmRvd1tuYW1lXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbW1hbmRMaW5lRnVuY3Rpb25zSGFzaFtuYW1lXShhcHBlbmRlcixhcmd1bWVudHMsY29tbWFuZFJldHVyblZhbHVlKTt9O307Zm9yKGk9MCxsZW49Y29tbWFuZExpbmVGdW5jdGlvbnMubGVuZ3RoO2k8bGVuO2krKyl7YWRkRnVuY3Rpb25Ub1dpbmRvdyhjb21tYW5kTGluZUZ1bmN0aW9uc1tpXVswXSk7fVxyXG5pZihjb21tYW5kV2luZG93PT09d2luZG93JiZjb21tYW5kV2luZG93LmV4ZWNTY3JpcHQpe2FkZE9iamVjdFRvUmVzdG9yZShcImV2YWxFeHByXCIpO2FkZE9iamVjdFRvUmVzdG9yZShcInJlc3VsdFwiKTt3aW5kb3cuZXZhbEV4cHI9ZXhwcjtjb21tYW5kV2luZG93LmV4ZWNTY3JpcHQoXCJ3aW5kb3cucmVzdWx0PWV2YWwod2luZG93LmV2YWxFeHByKTtcIik7cmVzdWx0PXdpbmRvdy5yZXN1bHQ7fWVsc2V7cmVzdWx0PWNvbW1hbmRXaW5kb3cuZXZhbChleHByKTt9XHJcbmNvbW1hbmRPdXRwdXQ9aXNVbmRlZmluZWQocmVzdWx0KT9yZXN1bHQ6Zm9ybWF0T2JqZWN0RXhwYW5zaW9uKHJlc3VsdCxjb21tYW5kTGluZU9iamVjdEV4cGFuc2lvbkRlcHRoKTtmb3IoaT0wLGxlbj1vYmplY3RzVG9SZXN0b3JlLmxlbmd0aDtpPGxlbjtpKyspe2NvbW1hbmRXaW5kb3dbb2JqZWN0c1RvUmVzdG9yZVtpXVswXV09b2JqZWN0c1RvUmVzdG9yZVtpXVsxXTt9fWNhdGNoKGV4KXtjb21tYW5kT3V0cHV0PVwiRXJyb3IgZXZhbHVhdGluZyBjb21tYW5kOiBcIitnZXRFeGNlcHRpb25TdHJpbmdSZXAoZXgpO2NvbW1hbmRSZXR1cm5WYWx1ZS5pc0Vycm9yPXRydWU7fVxyXG5pZihjb21tYW5kUmV0dXJuVmFsdWUuYXBwZW5kUmVzdWx0KXt2YXIgbWVzc2FnZT1cIj4+PiBcIitleHByO2lmKCFpc1VuZGVmaW5lZChjb21tYW5kT3V0cHV0KSl7bWVzc2FnZSs9bmV3TGluZStjb21tYW5kT3V0cHV0O31cclxudmFyIGxldmVsPWNvbW1hbmRSZXR1cm5WYWx1ZS5pc0Vycm9yP0xldmVsLkVSUk9SOkxldmVsLklORk87dmFyIGxvZ2dpbmdFdmVudD1uZXcgTG9nZ2luZ0V2ZW50KG51bGwsbmV3IERhdGUoKSxsZXZlbCxbbWVzc2FnZV0sbnVsbCk7dmFyIG1haW5MYXlvdXQ9dGhpcy5nZXRMYXlvdXQoKTt0aGlzLnNldExheW91dChjb21tYW5kTGF5b3V0KTt0aGlzLmFwcGVuZChsb2dnaW5nRXZlbnQpO3RoaXMuc2V0TGF5b3V0KG1haW5MYXlvdXQpO319O3ZhciBjb21tYW5kTGluZUZ1bmN0aW9ucz1kZWZhdWx0Q29tbWFuZExpbmVGdW5jdGlvbnMuY29uY2F0KFtdKTt0aGlzLmFkZENvbW1hbmRMaW5lRnVuY3Rpb249ZnVuY3Rpb24oZnVuY3Rpb25OYW1lLGNvbW1hbmRMaW5lRnVuY3Rpb24pe2NvbW1hbmRMaW5lRnVuY3Rpb25zLnB1c2goW2Z1bmN0aW9uTmFtZSxjb21tYW5kTGluZUZ1bmN0aW9uXSk7fTt2YXIgY29tbWFuZEhpc3RvcnlDb29raWVOYW1lPVwibG9nNGphdmFzY3JpcHRDb21tYW5kSGlzdG9yeVwiO3RoaXMuc3RvcmVDb21tYW5kSGlzdG9yeT1mdW5jdGlvbihjb21tYW5kSGlzdG9yeSl7c2V0Q29va2llKGNvbW1hbmRIaXN0b3J5Q29va2llTmFtZSxjb21tYW5kSGlzdG9yeS5qb2luKFwiLFwiKSk7fTt2YXIgd3JpdGVIdG1sPWZ1bmN0aW9uKGRvYyl7dmFyIGxpbmVzPWdldENvbnNvbGVIdG1sTGluZXMoKTtkb2Mub3BlbigpO2Zvcih2YXIgaT0wLGxlbj1saW5lcy5sZW5ndGg7aTxsZW47aSsrKXtkb2Mud3JpdGVsbihsaW5lc1tpXSk7fVxyXG5kb2MuY2xvc2UoKTt9O3RoaXMuc2V0RXZlbnRUeXBlcyhbXCJsb2FkXCIsXCJ1bmxvYWRcIl0pO3ZhciBjb25zb2xlV2luZG93TG9hZEhhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgd2luPWdldENvbnNvbGVXaW5kb3coKTt3aW4uc2V0QXBwZW5kZXIoYXBwZW5kZXIpO3dpbi5zZXROZXdlc3RBdFRvcChuZXdlc3RNZXNzYWdlQXRUb3ApO3dpbi5zZXRTY3JvbGxUb0xhdGVzdChzY3JvbGxUb0xhdGVzdE1lc3NhZ2UpO3dpbi5zZXRNYXhNZXNzYWdlcyhtYXhNZXNzYWdlcyk7d2luLnNldFNob3dDb21tYW5kTGluZShzaG93Q29tbWFuZExpbmUpO3dpbi5zZXRTaG93SGlkZUJ1dHRvbihzaG93SGlkZUJ1dHRvbik7d2luLnNldFNob3dDbG9zZUJ1dHRvbihzaG93Q2xvc2VCdXR0b24pO3dpbi5zZXRNYWluV2luZG93KHdpbmRvdyk7dmFyIHN0b3JlZFZhbHVlPWdldENvb2tpZShjb21tYW5kSGlzdG9yeUNvb2tpZU5hbWUpO2lmKHN0b3JlZFZhbHVlKXt3aW4uY29tbWFuZEhpc3Rvcnk9c3RvcmVkVmFsdWUuc3BsaXQoXCIsXCIpO3dpbi5jdXJyZW50Q29tbWFuZEluZGV4PXdpbi5jb21tYW5kSGlzdG9yeS5sZW5ndGg7fVxyXG5hcHBlbmRlci5kaXNwYXRjaEV2ZW50KFwibG9hZFwiLHtcIndpblwiOndpbn0pO307dGhpcy51bmxvYWQ9ZnVuY3Rpb24oKXtsb2dMb2cuZGVidWcoXCJ1bmxvYWQgXCIrdGhpcytcIiwgY2FsbGVyOiBcIit0aGlzLnVubG9hZC5jYWxsZXIpO2lmKCFjb25zb2xlQ2xvc2VkKXtsb2dMb2cuZGVidWcoXCJyZWFsbHkgZG9pbmcgdW5sb2FkIFwiK3RoaXMpO2NvbnNvbGVDbG9zZWQ9dHJ1ZTtjb25zb2xlV2luZG93TG9hZGVkPWZhbHNlO2NvbnNvbGVXaW5kb3dDcmVhdGVkPWZhbHNlO2FwcGVuZGVyLmRpc3BhdGNoRXZlbnQoXCJ1bmxvYWRcIix7fSk7fX07dmFyIHBvbGxDb25zb2xlV2luZG93PWZ1bmN0aW9uKHdpbmRvd1Rlc3QsaW50ZXJ2YWwsc3VjY2Vzc0NhbGxiYWNrLGVycm9yTWVzc2FnZSl7ZnVuY3Rpb24gZG9Qb2xsKCl7dHJ5e2lmKGNvbnNvbGVDbG9zZWQpe2NsZWFySW50ZXJ2YWwocG9sbCk7fVxyXG5pZih3aW5kb3dUZXN0KGdldENvbnNvbGVXaW5kb3coKSkpe2NsZWFySW50ZXJ2YWwocG9sbCk7c3VjY2Vzc0NhbGxiYWNrKCk7fX1jYXRjaChleCl7Y2xlYXJJbnRlcnZhbChwb2xsKTtpc1N1cHBvcnRlZD1mYWxzZTtoYW5kbGVFcnJvcihlcnJvck1lc3NhZ2UsZXgpO319XHJcbnZhciBwb2xsPXNldEludGVydmFsKGRvUG9sbCxpbnRlcnZhbCk7fTt2YXIgZ2V0Q29uc29sZVVybD1mdW5jdGlvbigpe3ZhciBkb2N1bWVudERvbWFpblNldD0oZG9jdW1lbnQuZG9tYWluIT1sb2NhdGlvbi5ob3N0bmFtZSk7cmV0dXJuIHVzZURvY3VtZW50V3JpdGU/XCJcIjpnZXRCYXNlVXJsKCkrXCJjb25zb2xlLmh0bWxcIitcclxuKGRvY3VtZW50RG9tYWluU2V0P1wiP2xvZzRqYXZhc2NyaXB0X2RvbWFpbj1cIitlc2NhcGUoZG9jdW1lbnQuZG9tYWluKTpcIlwiKTt9O2lmKGluUGFnZSl7dmFyIGNvbnRhaW5lckVsZW1lbnQ9bnVsbDt2YXIgY3NzUHJvcGVydGllcz1bXTt0aGlzLmFkZENzc1Byb3BlcnR5PWZ1bmN0aW9uKG5hbWUsdmFsdWUpe2lmKGNoZWNrQ2FuQ29uZmlndXJlKFwiY3NzUHJvcGVydGllc1wiKSl7Y3NzUHJvcGVydGllcy5wdXNoKFtuYW1lLHZhbHVlXSk7fX07dmFyIHdpbmRvd0NyZWF0aW9uU3RhcnRlZD1mYWxzZTt2YXIgaWZyYW1lQ29udGFpbmVyRGl2O3ZhciBpZnJhbWVJZD11bmlxdWVJZCtcIl9JblBhZ2VBcHBlbmRlcl9cIitjb25zb2xlQXBwZW5kZXJJZDt0aGlzLmhpZGU9ZnVuY3Rpb24oKXtpZihpbml0aWFsaXplZCYmY29uc29sZVdpbmRvd0NyZWF0ZWQpe2lmKGNvbnNvbGVXaW5kb3dFeGlzdHMoKSl7Z2V0Q29uc29sZVdpbmRvdygpLiQoXCJjb21tYW5kXCIpLmJsdXIoKTt9XHJcbmlmcmFtZUNvbnRhaW5lckRpdi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO21pbmltaXplZD10cnVlO319O3RoaXMuc2hvdz1mdW5jdGlvbigpe2lmKGluaXRpYWxpemVkKXtpZihjb25zb2xlV2luZG93Q3JlYXRlZCl7aWZyYW1lQ29udGFpbmVyRGl2LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiO3RoaXMuc2V0U2hvd0NvbW1hbmRMaW5lKHNob3dDb21tYW5kTGluZSk7bWluaW1pemVkPWZhbHNlO31lbHNlIGlmKCF3aW5kb3dDcmVhdGlvblN0YXJ0ZWQpe2NyZWF0ZVdpbmRvdyh0cnVlKTt9fX07dGhpcy5pc1Zpc2libGU9ZnVuY3Rpb24oKXtyZXR1cm4hbWluaW1pemVkJiYhY29uc29sZUNsb3NlZDt9O3RoaXMuY2xvc2U9ZnVuY3Rpb24oZnJvbUJ1dHRvbil7aWYoIWNvbnNvbGVDbG9zZWQmJighZnJvbUJ1dHRvbnx8Y29uZmlybShcIlRoaXMgd2lsbCBwZXJtYW5lbnRseSByZW1vdmUgdGhlIGNvbnNvbGUgZnJvbSB0aGUgcGFnZS4gTm8gbW9yZSBtZXNzYWdlcyB3aWxsIGJlIGxvZ2dlZC4gRG8geW91IHdpc2ggdG8gY29udGludWU/XCIpKSl7aWZyYW1lQ29udGFpbmVyRGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lQ29udGFpbmVyRGl2KTt0aGlzLnVubG9hZCgpO319O29wZW49ZnVuY3Rpb24oKXt2YXIgaW5pdEVycm9yTWVzc2FnZT1cIkluUGFnZUFwcGVuZGVyLm9wZW46IHVuYWJsZSB0byBjcmVhdGUgY29uc29sZSBpZnJhbWVcIjtmdW5jdGlvbiBmaW5hbEluaXQoKXt0cnl7aWYoIWluaXRpYWxseU1pbmltaXplZCl7YXBwZW5kZXIuc2hvdygpO31cclxuY29uc29sZVdpbmRvd0xvYWRIYW5kbGVyKCk7Y29uc29sZVdpbmRvd0xvYWRlZD10cnVlO2FwcGVuZFF1ZXVlZExvZ2dpbmdFdmVudHMoKTt9Y2F0Y2goZXgpe2lzU3VwcG9ydGVkPWZhbHNlO2hhbmRsZUVycm9yKGluaXRFcnJvck1lc3NhZ2UsZXgpO319XHJcbmZ1bmN0aW9uIHdyaXRlVG9Eb2N1bWVudCgpe3RyeXt2YXIgd2luZG93VGVzdD1mdW5jdGlvbih3aW4pe3JldHVybiBpc0xvYWRlZCh3aW4pO307aWYodXNlRG9jdW1lbnRXcml0ZSl7d3JpdGVIdG1sKGdldENvbnNvbGVXaW5kb3coKS5kb2N1bWVudCk7fVxyXG5pZih3aW5kb3dUZXN0KGdldENvbnNvbGVXaW5kb3coKSkpe2ZpbmFsSW5pdCgpO31lbHNle3BvbGxDb25zb2xlV2luZG93KHdpbmRvd1Rlc3QsMTAwLGZpbmFsSW5pdCxpbml0RXJyb3JNZXNzYWdlKTt9fWNhdGNoKGV4KXtpc1N1cHBvcnRlZD1mYWxzZTtoYW5kbGVFcnJvcihpbml0RXJyb3JNZXNzYWdlLGV4KTt9fVxyXG5taW5pbWl6ZWQ9ZmFsc2U7aWZyYW1lQ29udGFpbmVyRGl2PWNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7aWZyYW1lQ29udGFpbmVyRGl2LnN0eWxlLndpZHRoPXdpZHRoO2lmcmFtZUNvbnRhaW5lckRpdi5zdHlsZS5oZWlnaHQ9aGVpZ2h0O2lmcmFtZUNvbnRhaW5lckRpdi5zdHlsZS5ib3JkZXI9XCJzb2xpZCBncmF5IDFweFwiO2Zvcih2YXIgaT0wLGxlbj1jc3NQcm9wZXJ0aWVzLmxlbmd0aDtpPGxlbjtpKyspe2lmcmFtZUNvbnRhaW5lckRpdi5zdHlsZVtjc3NQcm9wZXJ0aWVzW2ldWzBdXT1jc3NQcm9wZXJ0aWVzW2ldWzFdO31cclxudmFyIGlmcmFtZVNyYz11c2VEb2N1bWVudFdyaXRlP1wiXCI6XCIgc3JjPSdcIitnZXRDb25zb2xlVXJsKCkrXCInXCI7aWZyYW1lQ29udGFpbmVyRGl2LmlubmVySFRNTD1cIjxpZnJhbWUgaWQ9J1wiK2lmcmFtZUlkK1wiJyBuYW1lPSdcIitpZnJhbWVJZCtcIicgd2lkdGg9JzEwMCUnIGhlaWdodD0nMTAwJScgZnJhbWVib3JkZXI9JzAnXCIraWZyYW1lU3JjK1wiIHNjcm9sbGluZz0nbm8nPjwvaWZyYW1lPlwiO2NvbnNvbGVDbG9zZWQ9ZmFsc2U7dmFyIGlmcmFtZURvY3VtZW50RXhpc3RzVGVzdD1mdW5jdGlvbih3aW4pe3RyeXtyZXR1cm4gYm9vbCh3aW4pJiZib29sKHdpbi5kb2N1bWVudCk7fWNhdGNoKGV4KXtyZXR1cm4gZmFsc2U7fX07aWYoaWZyYW1lRG9jdW1lbnRFeGlzdHNUZXN0KGdldENvbnNvbGVXaW5kb3coKSkpe3dyaXRlVG9Eb2N1bWVudCgpO31lbHNle3BvbGxDb25zb2xlV2luZG93KGlmcmFtZURvY3VtZW50RXhpc3RzVGVzdCwxMDAsd3JpdGVUb0RvY3VtZW50LGluaXRFcnJvck1lc3NhZ2UpO31cclxuY29uc29sZVdpbmRvd0NyZWF0ZWQ9dHJ1ZTt9O2NyZWF0ZVdpbmRvdz1mdW5jdGlvbihzaG93KXtpZihzaG93fHwhaW5pdGlhbGx5TWluaW1pemVkKXt2YXIgcGFnZUxvYWRIYW5kbGVyPWZ1bmN0aW9uKCl7aWYoIWNvbnRhaW5lcil7Y29udGFpbmVyRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2NvbnRhaW5lckVsZW1lbnQuc3R5bGUucG9zaXRpb249XCJmaXhlZFwiO2NvbnRhaW5lckVsZW1lbnQuc3R5bGUubGVmdD1cIjBcIjtjb250YWluZXJFbGVtZW50LnN0eWxlLnJpZ2h0PVwiMFwiO2NvbnRhaW5lckVsZW1lbnQuc3R5bGUuYm90dG9tPVwiMFwiO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyRWxlbWVudCk7YXBwZW5kZXIuYWRkQ3NzUHJvcGVydHkoXCJib3JkZXJXaWR0aFwiLFwiMXB4IDAgMCAwXCIpO2FwcGVuZGVyLmFkZENzc1Byb3BlcnR5KFwiekluZGV4XCIsMTAwMDAwMCk7b3BlbigpO31lbHNle3RyeXt2YXIgZWw9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyKTtpZihlbC5ub2RlVHlwZT09MSl7Y29udGFpbmVyRWxlbWVudD1lbDt9XHJcbm9wZW4oKTt9Y2F0Y2goZXgpe2hhbmRsZUVycm9yKFwiSW5QYWdlQXBwZW5kZXIuaW5pdDogaW52YWxpZCBjb250YWluZXIgZWxlbWVudCAnXCIrY29udGFpbmVyK1wiJyBzdXBwbGllZFwiLGV4KTt9fX07aWYocGFnZUxvYWRlZCYmY29udGFpbmVyJiZjb250YWluZXIuYXBwZW5kQ2hpbGQpe2NvbnRhaW5lckVsZW1lbnQ9Y29udGFpbmVyO29wZW4oKTt9ZWxzZSBpZihwYWdlTG9hZGVkKXtwYWdlTG9hZEhhbmRsZXIoKTt9ZWxzZXtsb2c0amF2YXNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHBhZ2VMb2FkSGFuZGxlcik7fVxyXG53aW5kb3dDcmVhdGlvblN0YXJ0ZWQ9dHJ1ZTt9fTtpbml0PWZ1bmN0aW9uKCl7Y3JlYXRlV2luZG93KCk7aW5pdGlhbGl6ZWQ9dHJ1ZTt9O2dldENvbnNvbGVXaW5kb3c9ZnVuY3Rpb24oKXt2YXIgaWZyYW1lPXdpbmRvdy5mcmFtZXNbaWZyYW1lSWRdO2lmKGlmcmFtZSl7cmV0dXJuIGlmcmFtZTt9fTtzYWZlVG9BcHBlbmQ9ZnVuY3Rpb24oKXtpZihpc1N1cHBvcnRlZCYmIWNvbnNvbGVDbG9zZWQpe2lmKGNvbnNvbGVXaW5kb3dDcmVhdGVkJiYhY29uc29sZVdpbmRvd0xvYWRlZCYmZ2V0Q29uc29sZVdpbmRvdygpJiZpc0xvYWRlZChnZXRDb25zb2xlV2luZG93KCkpKXtjb25zb2xlV2luZG93TG9hZGVkPXRydWU7fVxyXG5yZXR1cm4gY29uc29sZVdpbmRvd0xvYWRlZDt9XHJcbnJldHVybiBmYWxzZTt9O31lbHNle3ZhciB1c2VPbGRQb3BVcD1hcHBlbmRlci5kZWZhdWx0cy51c2VPbGRQb3BVcDt2YXIgY29tcGxhaW5BYm91dFBvcFVwQmxvY2tpbmc9YXBwZW5kZXIuZGVmYXVsdHMuY29tcGxhaW5BYm91dFBvcFVwQmxvY2tpbmc7dmFyIHJlb3BlbldoZW5DbG9zZWQ9dGhpcy5kZWZhdWx0cy5yZW9wZW5XaGVuQ2xvc2VkO3RoaXMuaXNVc2VPbGRQb3BVcD1mdW5jdGlvbigpe3JldHVybiB1c2VPbGRQb3BVcDt9O3RoaXMuc2V0VXNlT2xkUG9wVXA9ZnVuY3Rpb24odXNlT2xkUG9wVXBQYXJhbSl7aWYoY2hlY2tDYW5Db25maWd1cmUoXCJ1c2VPbGRQb3BVcFwiKSl7dXNlT2xkUG9wVXA9Ym9vbCh1c2VPbGRQb3BVcFBhcmFtKTt9fTt0aGlzLmlzQ29tcGxhaW5BYm91dFBvcFVwQmxvY2tpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gY29tcGxhaW5BYm91dFBvcFVwQmxvY2tpbmc7fTt0aGlzLnNldENvbXBsYWluQWJvdXRQb3BVcEJsb2NraW5nPWZ1bmN0aW9uKGNvbXBsYWluQWJvdXRQb3BVcEJsb2NraW5nUGFyYW0pe2lmKGNoZWNrQ2FuQ29uZmlndXJlKFwiY29tcGxhaW5BYm91dFBvcFVwQmxvY2tpbmdcIikpe2NvbXBsYWluQWJvdXRQb3BVcEJsb2NraW5nPWJvb2woY29tcGxhaW5BYm91dFBvcFVwQmxvY2tpbmdQYXJhbSk7fX07dGhpcy5pc0ZvY3VzUG9wVXA9ZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNDb25zb2xlV2luZG93O307dGhpcy5zZXRGb2N1c1BvcFVwPWZ1bmN0aW9uKGZvY3VzUG9wVXBQYXJhbSl7Zm9jdXNDb25zb2xlV2luZG93PWJvb2woZm9jdXNQb3BVcFBhcmFtKTt9O3RoaXMuaXNSZW9wZW5XaGVuQ2xvc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIHJlb3BlbldoZW5DbG9zZWQ7fTt0aGlzLnNldFJlb3BlbldoZW5DbG9zZWQ9ZnVuY3Rpb24ocmVvcGVuV2hlbkNsb3NlZFBhcmFtKXtyZW9wZW5XaGVuQ2xvc2VkPWJvb2wocmVvcGVuV2hlbkNsb3NlZFBhcmFtKTt9O3RoaXMuY2xvc2U9ZnVuY3Rpb24oKXtsb2dMb2cuZGVidWcoXCJjbG9zZSBcIit0aGlzKTt0cnl7cG9wVXAuY2xvc2UoKTt0aGlzLnVubG9hZCgpO31jYXRjaChleCl7fX07dGhpcy5oaWRlPWZ1bmN0aW9uKCl7bG9nTG9nLmRlYnVnKFwiaGlkZSBcIit0aGlzKTtpZihjb25zb2xlV2luZG93RXhpc3RzKCkpe3RoaXMuY2xvc2UoKTt9fTt0aGlzLnNob3c9ZnVuY3Rpb24oKXtsb2dMb2cuZGVidWcoXCJzaG93IFwiK3RoaXMpO2lmKCFjb25zb2xlV2luZG93Q3JlYXRlZCl7b3BlbigpO319O3RoaXMuaXNWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHNhZmVUb0FwcGVuZCgpO307dmFyIHBvcFVwO29wZW49ZnVuY3Rpb24oKXt2YXIgd2luZG93UHJvcGVydGllcz1cIndpZHRoPVwiK3dpZHRoK1wiLGhlaWdodD1cIitoZWlnaHQrXCIsc3RhdHVzLHJlc2l6YWJsZVwiO3ZhciBmcmFtZUluZm89XCJcIjt0cnl7dmFyIGZyYW1lRWw9d2luZG93LmZyYW1lRWxlbWVudDtpZihmcmFtZUVsKXtmcmFtZUluZm89XCJfXCIrZnJhbWVFbC50YWdOYW1lK1wiX1wiKyhmcmFtZUVsLm5hbWV8fGZyYW1lRWwuaWR8fFwiXCIpO319Y2F0Y2goZSl7ZnJhbWVJbmZvPVwiX2luYWNjZXNzaWJsZVBhcmVudEZyYW1lXCI7fVxyXG52YXIgd2luZG93TmFtZT1cIlBvcFVwX1wiK2xvY2F0aW9uLmhvc3QucmVwbGFjZSgvW15hLXowLTldL2dpLFwiX1wiKStcIl9cIitjb25zb2xlQXBwZW5kZXJJZCtmcmFtZUluZm87aWYoIXVzZU9sZFBvcFVwfHwhdXNlRG9jdW1lbnRXcml0ZSl7d2luZG93TmFtZT13aW5kb3dOYW1lK1wiX1wiK3VuaXF1ZUlkO31cclxudmFyIGNoZWNrUG9wVXBDbG9zZWQ9ZnVuY3Rpb24od2luKXtpZihjb25zb2xlQ2xvc2VkKXtyZXR1cm4gdHJ1ZTt9ZWxzZXt0cnl7cmV0dXJuIGJvb2wod2luKSYmd2luLmNsb3NlZDt9Y2F0Y2goZXgpe319XHJcbnJldHVybiBmYWxzZTt9O3ZhciBwb3BVcENsb3NlZENhbGxiYWNrPWZ1bmN0aW9uKCl7aWYoIWNvbnNvbGVDbG9zZWQpe2FwcGVuZGVyLnVubG9hZCgpO319O2Z1bmN0aW9uIGZpbmFsSW5pdCgpe2dldENvbnNvbGVXaW5kb3coKS5zZXRDbG9zZUlmT3BlbmVyQ2xvc2VzKCF1c2VPbGRQb3BVcHx8IXVzZURvY3VtZW50V3JpdGUpO2NvbnNvbGVXaW5kb3dMb2FkSGFuZGxlcigpO2NvbnNvbGVXaW5kb3dMb2FkZWQ9dHJ1ZTthcHBlbmRRdWV1ZWRMb2dnaW5nRXZlbnRzKCk7cG9sbENvbnNvbGVXaW5kb3coY2hlY2tQb3BVcENsb3NlZCw1MDAscG9wVXBDbG9zZWRDYWxsYmFjayxcIlBvcFVwQXBwZW5kZXIuY2hlY2tQb3BVcENsb3NlZDogZXJyb3IgY2hlY2tpbmcgcG9wLXVwIHdpbmRvd1wiKTt9XHJcbnRyeXtwb3BVcD13aW5kb3cub3BlbihnZXRDb25zb2xlVXJsKCksd2luZG93TmFtZSx3aW5kb3dQcm9wZXJ0aWVzKTtjb25zb2xlQ2xvc2VkPWZhbHNlO2NvbnNvbGVXaW5kb3dDcmVhdGVkPXRydWU7aWYocG9wVXAmJnBvcFVwLmRvY3VtZW50KXtpZih1c2VEb2N1bWVudFdyaXRlJiZ1c2VPbGRQb3BVcCYmaXNMb2FkZWQocG9wVXApKXtwb3BVcC5tYWluUGFnZVJlbG9hZGVkKCk7ZmluYWxJbml0KCk7fWVsc2V7aWYodXNlRG9jdW1lbnRXcml0ZSl7d3JpdGVIdG1sKHBvcFVwLmRvY3VtZW50KTt9XHJcbnZhciBwb3BVcExvYWRlZFRlc3Q9ZnVuY3Rpb24od2luKXtyZXR1cm4gYm9vbCh3aW4pJiZpc0xvYWRlZCh3aW4pO307aWYoaXNMb2FkZWQocG9wVXApKXtmaW5hbEluaXQoKTt9ZWxzZXtwb2xsQ29uc29sZVdpbmRvdyhwb3BVcExvYWRlZFRlc3QsMTAwLGZpbmFsSW5pdCxcIlBvcFVwQXBwZW5kZXIuaW5pdDogdW5hYmxlIHRvIGNyZWF0ZSBjb25zb2xlIHdpbmRvd1wiKTt9fX1lbHNle2lzU3VwcG9ydGVkPWZhbHNlO2xvZ0xvZy53YXJuKFwiUG9wVXBBcHBlbmRlci5pbml0OiBwb3AtdXBzIGJsb2NrZWQsIHBsZWFzZSB1bmJsb2NrIHRvIHVzZSBQb3BVcEFwcGVuZGVyXCIpO2lmKGNvbXBsYWluQWJvdXRQb3BVcEJsb2NraW5nKXtoYW5kbGVFcnJvcihcImxvZzRqYXZhc2NyaXB0OiBwb3AtdXAgd2luZG93cyBhcHBlYXIgdG8gYmUgYmxvY2tlZC4gUGxlYXNlIHVuYmxvY2sgdGhlbSB0byB1c2UgcG9wLXVwIGxvZ2dpbmcuXCIpO319fWNhdGNoKGV4KXtoYW5kbGVFcnJvcihcIlBvcFVwQXBwZW5kZXIuaW5pdDogZXJyb3IgY3JlYXRpbmcgcG9wLXVwXCIsZXgpO319O2NyZWF0ZVdpbmRvdz1mdW5jdGlvbigpe2lmKCFpbml0aWFsbHlNaW5pbWl6ZWQpe29wZW4oKTt9fTtpbml0PWZ1bmN0aW9uKCl7Y3JlYXRlV2luZG93KCk7aW5pdGlhbGl6ZWQ9dHJ1ZTt9O2dldENvbnNvbGVXaW5kb3c9ZnVuY3Rpb24oKXtyZXR1cm4gcG9wVXA7fTtzYWZlVG9BcHBlbmQ9ZnVuY3Rpb24oKXtpZihpc1N1cHBvcnRlZCYmIWlzVW5kZWZpbmVkKHBvcFVwKSYmIWNvbnNvbGVDbG9zZWQpe2lmKHBvcFVwLmNsb3NlZHx8KGNvbnNvbGVXaW5kb3dMb2FkZWQmJmlzVW5kZWZpbmVkKHBvcFVwLmNsb3NlZCkpKXthcHBlbmRlci51bmxvYWQoKTtsb2dMb2cuZGVidWcoXCJQb3BVcEFwcGVuZGVyOiBwb3AtdXAgY2xvc2VkXCIpO3JldHVybiBmYWxzZTt9XHJcbmlmKCFjb25zb2xlV2luZG93TG9hZGVkJiZpc0xvYWRlZChwb3BVcCkpe2NvbnNvbGVXaW5kb3dMb2FkZWQ9dHJ1ZTt9fVxyXG5yZXR1cm4gaXNTdXBwb3J0ZWQmJmNvbnNvbGVXaW5kb3dMb2FkZWQmJiFjb25zb2xlQ2xvc2VkO307fVxyXG50aGlzLmdldENvbnNvbGVXaW5kb3c9Z2V0Q29uc29sZVdpbmRvdzt9O0NvbnNvbGVBcHBlbmRlci5hZGRHbG9iYWxDb21tYW5kTGluZUZ1bmN0aW9uPWZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSxjb21tYW5kTGluZUZ1bmN0aW9uKXtkZWZhdWx0Q29tbWFuZExpbmVGdW5jdGlvbnMucHVzaChbZnVuY3Rpb25OYW1lLGNvbW1hbmRMaW5lRnVuY3Rpb25dKTt9O2Z1bmN0aW9uIFBvcFVwQXBwZW5kZXIobGF6eUluaXQsaW5pdGlhbGx5TWluaW1pemVkLHVzZURvY3VtZW50V3JpdGUsd2lkdGgsaGVpZ2h0KXt0aGlzLmNyZWF0ZShmYWxzZSxudWxsLGxhenlJbml0LGluaXRpYWxseU1pbmltaXplZCx1c2VEb2N1bWVudFdyaXRlLHdpZHRoLGhlaWdodCx0aGlzLmRlZmF1bHRzLmZvY3VzUG9wVXApO31cclxuUG9wVXBBcHBlbmRlci5wcm90b3R5cGU9bmV3IENvbnNvbGVBcHBlbmRlcigpO1BvcFVwQXBwZW5kZXIucHJvdG90eXBlLmRlZmF1bHRzPXtsYXlvdXQ6bmV3IFBhdHRlcm5MYXlvdXQoXCIlZHtISDptbTpzc30gJS01cCAtICVtezF9JW5cIiksaW5pdGlhbGx5TWluaW1pemVkOmZhbHNlLGZvY3VzUG9wVXA6ZmFsc2UsbGF6eUluaXQ6dHJ1ZSx1c2VPbGRQb3BVcDp0cnVlLGNvbXBsYWluQWJvdXRQb3BVcEJsb2NraW5nOnRydWUsbmV3ZXN0TWVzc2FnZUF0VG9wOmZhbHNlLHNjcm9sbFRvTGF0ZXN0TWVzc2FnZTp0cnVlLHdpZHRoOlwiNjAwXCIsaGVpZ2h0OlwiNDAwXCIscmVvcGVuV2hlbkNsb3NlZDpmYWxzZSxtYXhNZXNzYWdlczpudWxsLHNob3dDb21tYW5kTGluZTp0cnVlLGNvbW1hbmRMaW5lT2JqZWN0RXhwYW5zaW9uRGVwdGg6MSxzaG93SGlkZUJ1dHRvbjpmYWxzZSxzaG93Q2xvc2VCdXR0b246dHJ1ZSx1c2VEb2N1bWVudFdyaXRlOnRydWV9O1BvcFVwQXBwZW5kZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJQb3BVcEFwcGVuZGVyXCI7fTtsb2c0amF2YXNjcmlwdC5Qb3BVcEFwcGVuZGVyPVBvcFVwQXBwZW5kZXI7ZnVuY3Rpb24gSW5QYWdlQXBwZW5kZXIoY29udGFpbmVyLGxhenlJbml0LGluaXRpYWxseU1pbmltaXplZCx1c2VEb2N1bWVudFdyaXRlLHdpZHRoLGhlaWdodCl7dGhpcy5jcmVhdGUodHJ1ZSxjb250YWluZXIsbGF6eUluaXQsaW5pdGlhbGx5TWluaW1pemVkLHVzZURvY3VtZW50V3JpdGUsd2lkdGgsaGVpZ2h0LGZhbHNlKTt9XHJcbkluUGFnZUFwcGVuZGVyLnByb3RvdHlwZT1uZXcgQ29uc29sZUFwcGVuZGVyKCk7SW5QYWdlQXBwZW5kZXIucHJvdG90eXBlLmRlZmF1bHRzPXtsYXlvdXQ6bmV3IFBhdHRlcm5MYXlvdXQoXCIlZHtISDptbTpzc30gJS01cCAtICVtezF9JW5cIiksaW5pdGlhbGx5TWluaW1pemVkOmZhbHNlLGxhenlJbml0OnRydWUsbmV3ZXN0TWVzc2FnZUF0VG9wOmZhbHNlLHNjcm9sbFRvTGF0ZXN0TWVzc2FnZTp0cnVlLHdpZHRoOlwiMTAwJVwiLGhlaWdodDpcIjIyMHB4XCIsbWF4TWVzc2FnZXM6bnVsbCxzaG93Q29tbWFuZExpbmU6dHJ1ZSxjb21tYW5kTGluZU9iamVjdEV4cGFuc2lvbkRlcHRoOjEsc2hvd0hpZGVCdXR0b246ZmFsc2Usc2hvd0Nsb3NlQnV0dG9uOmZhbHNlLHNob3dMb2dFbnRyeURlbGV0ZUJ1dHRvbnM6dHJ1ZSx1c2VEb2N1bWVudFdyaXRlOnRydWV9O0luUGFnZUFwcGVuZGVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiSW5QYWdlQXBwZW5kZXJcIjt9O2xvZzRqYXZhc2NyaXB0LkluUGFnZUFwcGVuZGVyPUluUGFnZUFwcGVuZGVyO2xvZzRqYXZhc2NyaXB0LklubGluZUFwcGVuZGVyPUluUGFnZUFwcGVuZGVyO30pKCk7ZnVuY3Rpb24gcGFkV2l0aFNwYWNlcyhzdHIsbGVuKXtpZihzdHIubGVuZ3RoPGxlbil7dmFyIHNwYWNlcz1bXTt2YXIgbnVtYmVyT2ZTcGFjZXM9TWF0aC5tYXgoMCxsZW4tc3RyLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxudW1iZXJPZlNwYWNlcztpKyspe3NwYWNlc1tpXT1cIiBcIjt9XHJcbnN0cis9c3BhY2VzLmpvaW4oXCJcIik7fVxyXG5yZXR1cm4gc3RyO31cclxuKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGlyKG9iail7dmFyIG1heExlbj0wO2Zvcih2YXIgcCBpbiBvYmope21heExlbj1NYXRoLm1heCh0b1N0cihwKS5sZW5ndGgsbWF4TGVuKTt9XHJcbnZhciBwcm9wTGlzdD1bXTtmb3IocCBpbiBvYmope3ZhciBwcm9wTmFtZVN0cj1cIiAgXCIrcGFkV2l0aFNwYWNlcyh0b1N0cihwKSxtYXhMZW4rMik7dmFyIHByb3BWYWw7dHJ5e3Byb3BWYWw9c3BsaXRJbnRvTGluZXModG9TdHIob2JqW3BdKSkuam9pbihwYWRXaXRoU3BhY2VzKG5ld0xpbmUsbWF4TGVuKzYpKTt9Y2F0Y2goZXgpe3Byb3BWYWw9XCJbRXJyb3Igb2J0YWluaW5nIHByb3BlcnR5LiBEZXRhaWxzOiBcIitnZXRFeGNlcHRpb25NZXNzYWdlKGV4KStcIl1cIjt9XHJcbnByb3BMaXN0LnB1c2gocHJvcE5hbWVTdHIrcHJvcFZhbCk7fVxyXG5yZXR1cm4gcHJvcExpc3Quam9pbihuZXdMaW5lKTt9XHJcbnZhciBub2RlVHlwZXM9e0VMRU1FTlRfTk9ERToxLEFUVFJJQlVURV9OT0RFOjIsVEVYVF9OT0RFOjMsQ0RBVEFfU0VDVElPTl9OT0RFOjQsRU5USVRZX1JFRkVSRU5DRV9OT0RFOjUsRU5USVRZX05PREU6NixQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU6NyxDT01NRU5UX05PREU6OCxET0NVTUVOVF9OT0RFOjksRE9DVU1FTlRfVFlQRV9OT0RFOjEwLERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6MTEsTk9UQVRJT05fTk9ERToxMn07dmFyIHByZUZvcm1hdHRlZEVsZW1lbnRzPVtcInNjcmlwdFwiLFwicHJlXCJdO3ZhciBlbXB0eUVsZW1lbnRzPVtcImJyXCIsXCJpbWdcIixcImhyXCIsXCJwYXJhbVwiLFwibGlua1wiLFwiYXJlYVwiLFwiaW5wdXRcIixcImNvbFwiLFwiYmFzZVwiLFwibWV0YVwiXTt2YXIgaW5kZW50YXRpb25Vbml0PVwiICBcIjtmdW5jdGlvbiBnZXRYaHRtbChyb290Tm9kZSxpbmNsdWRlUm9vdE5vZGUsaW5kZW50YXRpb24sc3RhcnROZXdMaW5lLHByZWZvcm1hdHRlZCl7aW5jbHVkZVJvb3ROb2RlPSh0eXBlb2YgaW5jbHVkZVJvb3ROb2RlPT1cInVuZGVmaW5lZFwiKT90cnVlOiEhaW5jbHVkZVJvb3ROb2RlO2lmKHR5cGVvZiBpbmRlbnRhdGlvbiE9XCJzdHJpbmdcIil7aW5kZW50YXRpb249XCJcIjt9XHJcbnN0YXJ0TmV3TGluZT0hIXN0YXJ0TmV3TGluZTtwcmVmb3JtYXR0ZWQ9ISFwcmVmb3JtYXR0ZWQ7dmFyIHhodG1sO2Z1bmN0aW9uIGlzV2hpdGVzcGFjZShub2RlKXtyZXR1cm4oKG5vZGUubm9kZVR5cGU9PW5vZGVUeXBlcy5URVhUX05PREUpJiYvXlsgXFx0XFxyXFxuXSokLy50ZXN0KG5vZGUubm9kZVZhbHVlKSk7fVxyXG5mdW5jdGlvbiBmaXhBdHRyaWJ1dGVWYWx1ZShhdHRyVmFsdWUpe3JldHVybiBhdHRyVmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC8mL2csXCImYW1wO1wiKS5yZXBsYWNlKC88L2csXCImbHQ7XCIpLnJlcGxhY2UoL1wiL2csXCImcXVvdDtcIik7fVxyXG5mdW5jdGlvbiBnZXRTdHlsZUF0dHJpYnV0ZVZhbHVlKGVsKXt2YXIgc3R5bGVQYWlycz1lbC5zdHlsZS5jc3NUZXh0LnNwbGl0KFwiO1wiKTt2YXIgc3R5bGVWYWx1ZT1cIlwiO2Zvcih2YXIgaj0wLGxlbj1zdHlsZVBhaXJzLmxlbmd0aDtqPGxlbjtqKyspe3ZhciBuYW1lVmFsdWVCaXRzPXN0eWxlUGFpcnNbal0uc3BsaXQoXCI6XCIpO3ZhciBwcm9wcz1bXTtpZighL15cXHMqJC8udGVzdChuYW1lVmFsdWVCaXRzWzBdKSl7cHJvcHMucHVzaCh0cmltKG5hbWVWYWx1ZUJpdHNbMF0pLnRvTG93ZXJDYXNlKCkrXCI6XCIrdHJpbShuYW1lVmFsdWVCaXRzWzFdKSk7fVxyXG5zdHlsZVZhbHVlPXByb3BzLmpvaW4oXCI7XCIpO31cclxucmV0dXJuIHN0eWxlVmFsdWU7fVxyXG5mdW5jdGlvbiBnZXROYW1lc3BhY2UoZWwpe2lmKGVsLnByZWZpeCl7cmV0dXJuIGVsLnByZWZpeDt9ZWxzZSBpZihlbC5vdXRlckhUTUwpe3ZhciByZWdleD1uZXcgUmVnRXhwKFwiPChbXjpdKyk6XCIrZWwudGFnTmFtZStcIltePl0qPlwiLFwiaVwiKTtpZihyZWdleC50ZXN0KGVsLm91dGVySFRNTCkpe3JldHVybiBSZWdFeHAuJDEudG9Mb3dlckNhc2UoKTt9fVxyXG5yZXR1cm5cIlwiO31cclxudmFyIGx0PVwiPFwiO3ZhciBndD1cIj5cIjt2YXIgaSxsZW47aWYoaW5jbHVkZVJvb3ROb2RlJiZyb290Tm9kZS5ub2RlVHlwZSE9bm9kZVR5cGVzLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe3N3aXRjaChyb290Tm9kZS5ub2RlVHlwZSl7Y2FzZSBub2RlVHlwZXMuRUxFTUVOVF9OT0RFOnZhciB0YWdOYW1lPXJvb3ROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTt4aHRtbD1zdGFydE5ld0xpbmU/bmV3TGluZStpbmRlbnRhdGlvbjpcIlwiO3hodG1sKz1sdDt2YXIgcHJlZml4PWdldE5hbWVzcGFjZShyb290Tm9kZSk7dmFyIGhhc1ByZWZpeD0hIXByZWZpeDtpZihoYXNQcmVmaXgpe3hodG1sKz1wcmVmaXgrXCI6XCI7fVxyXG54aHRtbCs9dGFnTmFtZTtmb3IoaT0wLGxlbj1yb290Tm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDtpPGxlbjtpKyspe3ZhciBjdXJyZW50QXR0cj1yb290Tm9kZS5hdHRyaWJ1dGVzW2ldO2lmKCFjdXJyZW50QXR0ci5zcGVjaWZpZWR8fGN1cnJlbnRBdHRyLm5vZGVWYWx1ZT09PW51bGx8fGN1cnJlbnRBdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN0eWxlXCJ8fHR5cGVvZiBjdXJyZW50QXR0ci5ub2RlVmFsdWUhPT1cInN0cmluZ1wifHxjdXJyZW50QXR0ci5ub2RlTmFtZS5pbmRleE9mKFwiX21velwiKT09PTApe2NvbnRpbnVlO31cclxueGh0bWwrPVwiIFwiK2N1cnJlbnRBdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkrXCI9XFxcIlwiO3hodG1sKz1maXhBdHRyaWJ1dGVWYWx1ZShjdXJyZW50QXR0ci5ub2RlVmFsdWUpO3hodG1sKz1cIlxcXCJcIjt9XHJcbmlmKHJvb3ROb2RlLnN0eWxlLmNzc1RleHQpe3ZhciBzdHlsZVZhbHVlPWdldFN0eWxlQXR0cmlidXRlVmFsdWUocm9vdE5vZGUpO2lmKHN0eWxlVmFsdWUhPT1cIlwiKXt4aHRtbCs9XCIgc3R5bGU9XFxcIlwiK2dldFN0eWxlQXR0cmlidXRlVmFsdWUocm9vdE5vZGUpK1wiXFxcIlwiO319XHJcbmlmKGFycmF5X2NvbnRhaW5zKGVtcHR5RWxlbWVudHMsdGFnTmFtZSl8fChoYXNQcmVmaXgmJiFyb290Tm9kZS5oYXNDaGlsZE5vZGVzKCkpKXt4aHRtbCs9XCIvXCIrZ3Q7fWVsc2V7eGh0bWwrPWd0O3ZhciBjaGlsZFN0YXJ0TmV3TGluZT0hKHJvb3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoPT09MSYmcm9vdE5vZGUuY2hpbGROb2Rlc1swXS5ub2RlVHlwZT09PW5vZGVUeXBlcy5URVhUX05PREUpO3ZhciBjaGlsZFByZWZvcm1hdHRlZD1hcnJheV9jb250YWlucyhwcmVGb3JtYXR0ZWRFbGVtZW50cyx0YWdOYW1lKTtmb3IoaT0wLGxlbj1yb290Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtpPGxlbjtpKyspe3hodG1sKz1nZXRYaHRtbChyb290Tm9kZS5jaGlsZE5vZGVzW2ldLHRydWUsaW5kZW50YXRpb24raW5kZW50YXRpb25Vbml0LGNoaWxkU3RhcnROZXdMaW5lLGNoaWxkUHJlZm9ybWF0dGVkKTt9XHJcbnZhciBlbmRUYWc9bHQrXCIvXCIrdGFnTmFtZStndDt4aHRtbCs9Y2hpbGRTdGFydE5ld0xpbmU/bmV3TGluZStpbmRlbnRhdGlvbitlbmRUYWc6ZW5kVGFnO31cclxucmV0dXJuIHhodG1sO2Nhc2Ugbm9kZVR5cGVzLlRFWFRfTk9ERTppZihpc1doaXRlc3BhY2Uocm9vdE5vZGUpKXt4aHRtbD1cIlwiO31lbHNle2lmKHByZWZvcm1hdHRlZCl7eGh0bWw9cm9vdE5vZGUubm9kZVZhbHVlO31lbHNle3ZhciBsaW5lcz1zcGxpdEludG9MaW5lcyh0cmltKHJvb3ROb2RlLm5vZGVWYWx1ZSkpO3ZhciB0cmltbWVkTGluZXM9W107Zm9yKGk9MCxsZW49bGluZXMubGVuZ3RoO2k8bGVuO2krKyl7dHJpbW1lZExpbmVzW2ldPXRyaW0obGluZXNbaV0pO31cclxueGh0bWw9dHJpbW1lZExpbmVzLmpvaW4obmV3TGluZStpbmRlbnRhdGlvbik7fVxyXG5pZihzdGFydE5ld0xpbmUpe3hodG1sPW5ld0xpbmUraW5kZW50YXRpb24reGh0bWw7fX1cclxucmV0dXJuIHhodG1sO2Nhc2Ugbm9kZVR5cGVzLkNEQVRBX1NFQ1RJT05fTk9ERTpyZXR1cm5cIjwhW0NEQVwiK1wiVEFbXCIrcm9vdE5vZGUubm9kZVZhbHVlK1wiXVwiK1wiXT5cIituZXdMaW5lO2Nhc2Ugbm9kZVR5cGVzLkRPQ1VNRU5UX05PREU6eGh0bWw9XCJcIjtmb3IoaT0wLGxlbj1yb290Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtpPGxlbjtpKyspe3hodG1sKz1nZXRYaHRtbChyb290Tm9kZS5jaGlsZE5vZGVzW2ldLHRydWUsaW5kZW50YXRpb24pO31cclxucmV0dXJuIHhodG1sO2RlZmF1bHQ6cmV0dXJuXCJcIjt9fWVsc2V7eGh0bWw9XCJcIjtmb3IoaT0wLGxlbj1yb290Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtpPGxlbjtpKyspe3hodG1sKz1nZXRYaHRtbChyb290Tm9kZS5jaGlsZE5vZGVzW2ldLHRydWUsaW5kZW50YXRpb24raW5kZW50YXRpb25Vbml0KTt9XHJcbnJldHVybiB4aHRtbDt9fVxyXG5mdW5jdGlvbiBjcmVhdGVDb21tYW5kTGluZUZ1bmN0aW9ucygpe0NvbnNvbGVBcHBlbmRlci5hZGRHbG9iYWxDb21tYW5kTGluZUZ1bmN0aW9uKFwiJFwiLGZ1bmN0aW9uKGFwcGVuZGVyLGFyZ3MscmV0dXJuVmFsdWUpe3JldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhcmdzWzBdKTt9KTtDb25zb2xlQXBwZW5kZXIuYWRkR2xvYmFsQ29tbWFuZExpbmVGdW5jdGlvbihcImRpclwiLGZ1bmN0aW9uKGFwcGVuZGVyLGFyZ3MscmV0dXJuVmFsdWUpe3ZhciBsaW5lcz1bXTtmb3IodmFyIGk9MCxsZW49YXJncy5sZW5ndGg7aTxsZW47aSsrKXtsaW5lc1tpXT1kaXIoYXJnc1tpXSk7fVxyXG5yZXR1cm4gbGluZXMuam9pbihuZXdMaW5lK25ld0xpbmUpO30pO0NvbnNvbGVBcHBlbmRlci5hZGRHbG9iYWxDb21tYW5kTGluZUZ1bmN0aW9uKFwiZGlyeG1sXCIsZnVuY3Rpb24oYXBwZW5kZXIsYXJncyxyZXR1cm5WYWx1ZSl7dmFyIGxpbmVzPVtdO2Zvcih2YXIgaT0wLGxlbj1hcmdzLmxlbmd0aDtpPGxlbjtpKyspe2xpbmVzW2ldPWdldFhodG1sKGFyZ3NbaV0pO31cclxucmV0dXJuIGxpbmVzLmpvaW4obmV3TGluZStuZXdMaW5lKTt9KTtDb25zb2xlQXBwZW5kZXIuYWRkR2xvYmFsQ29tbWFuZExpbmVGdW5jdGlvbihcImNkXCIsZnVuY3Rpb24oYXBwZW5kZXIsYXJncyxyZXR1cm5WYWx1ZSl7dmFyIHdpbixtZXNzYWdlO2lmKGFyZ3MubGVuZ3RoPT09MHx8YXJnc1swXT09PVwiXCIpe3dpbj13aW5kb3c7bWVzc2FnZT1cIkNvbW1hbmQgbGluZSBzZXQgdG8gcnVuIGluIG1haW4gd2luZG93XCI7fWVsc2V7aWYoYXJnc1swXS53aW5kb3c9PWFyZ3NbMF0pe3dpbj1hcmdzWzBdO21lc3NhZ2U9XCJDb21tYW5kIGxpbmUgc2V0IHRvIHJ1biBpbiBmcmFtZSAnXCIrYXJnc1swXS5uYW1lK1wiJ1wiO31lbHNle3dpbj13aW5kb3cuZnJhbWVzW2FyZ3NbMF1dO2lmKHdpbil7bWVzc2FnZT1cIkNvbW1hbmQgbGluZSBzZXQgdG8gcnVuIGluIGZyYW1lICdcIithcmdzWzBdK1wiJ1wiO31lbHNle3JldHVyblZhbHVlLmlzRXJyb3I9dHJ1ZTttZXNzYWdlPVwiRnJhbWUgJ1wiK2FyZ3NbMF0rXCInIGRvZXMgbm90IGV4aXN0XCI7d2luPWFwcGVuZGVyLmdldENvbW1hbmRXaW5kb3coKTt9fX1cclxuYXBwZW5kZXIuc2V0Q29tbWFuZFdpbmRvdyh3aW4pO3JldHVybiBtZXNzYWdlO30pO0NvbnNvbGVBcHBlbmRlci5hZGRHbG9iYWxDb21tYW5kTGluZUZ1bmN0aW9uKFwiY2xlYXJcIixmdW5jdGlvbihhcHBlbmRlcixhcmdzLHJldHVyblZhbHVlKXtyZXR1cm5WYWx1ZS5hcHBlbmRSZXN1bHQ9ZmFsc2U7YXBwZW5kZXIuY2xlYXIoKTt9KTtDb25zb2xlQXBwZW5kZXIuYWRkR2xvYmFsQ29tbWFuZExpbmVGdW5jdGlvbihcImtleXNcIixmdW5jdGlvbihhcHBlbmRlcixhcmdzLHJldHVyblZhbHVlKXt2YXIga2V5cz1bXTtmb3IodmFyIGsgaW4gYXJnc1swXSl7a2V5cy5wdXNoKGspO31cclxucmV0dXJuIGtleXM7fSk7Q29uc29sZUFwcGVuZGVyLmFkZEdsb2JhbENvbW1hbmRMaW5lRnVuY3Rpb24oXCJ2YWx1ZXNcIixmdW5jdGlvbihhcHBlbmRlcixhcmdzLHJldHVyblZhbHVlKXt2YXIgdmFsdWVzPVtdO2Zvcih2YXIgayBpbiBhcmdzWzBdKXt0cnl7dmFsdWVzLnB1c2goYXJnc1swXVtrXSk7fWNhdGNoKGV4KXtsb2dMb2cud2FybihcInZhbHVlcygpOiBVbmFibGUgdG8gb2J0YWluIHZhbHVlIGZvciBrZXkgXCIraytcIi4gRGV0YWlsczogXCIrZ2V0RXhjZXB0aW9uTWVzc2FnZShleCkpO319XHJcbnJldHVybiB2YWx1ZXM7fSk7Q29uc29sZUFwcGVuZGVyLmFkZEdsb2JhbENvbW1hbmRMaW5lRnVuY3Rpb24oXCJleHBhbnNpb25EZXB0aFwiLGZ1bmN0aW9uKGFwcGVuZGVyLGFyZ3MscmV0dXJuVmFsdWUpe3ZhciBleHBhbnNpb25EZXB0aD1wYXJzZUludChhcmdzWzBdLDEwKTtpZihpc05hTihleHBhbnNpb25EZXB0aCl8fGV4cGFuc2lvbkRlcHRoPDApe3JldHVyblZhbHVlLmlzRXJyb3I9dHJ1ZTtyZXR1cm5cIlwiK2FyZ3NbMF0rXCIgaXMgbm90IGEgdmFsaWQgZXhwYW5zaW9uIGRlcHRoXCI7fWVsc2V7YXBwZW5kZXIuc2V0Q29tbWFuZExpbmVPYmplY3RFeHBhbnNpb25EZXB0aChleHBhbnNpb25EZXB0aCk7cmV0dXJuXCJPYmplY3QgZXhwYW5zaW9uIGRlcHRoIHNldCB0byBcIitleHBhbnNpb25EZXB0aDt9fSk7fVxyXG5mdW5jdGlvbiBpbml0KCl7Y3JlYXRlQ29tbWFuZExpbmVGdW5jdGlvbnMoKTt9XHJcbmluaXQoKTt9KSgpO2Z1bmN0aW9uIGNyZWF0ZURlZmF1bHRMb2dnZXIoKXt2YXIgbG9nZ2VyPWxvZzRqYXZhc2NyaXB0LmdldExvZ2dlcihkZWZhdWx0TG9nZ2VyTmFtZSk7dmFyIGE9bmV3IGxvZzRqYXZhc2NyaXB0LlBvcFVwQXBwZW5kZXIoKTtsb2dnZXIuYWRkQXBwZW5kZXIoYSk7cmV0dXJuIGxvZ2dlcjt9XHJcbmxvZzRqYXZhc2NyaXB0LnNldERvY3VtZW50UmVhZHk9ZnVuY3Rpb24oKXtwYWdlTG9hZGVkPXRydWU7bG9nNGphdmFzY3JpcHQuZGlzcGF0Y2hFdmVudChcImxvYWRcIix7fSk7fTtpZih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsbG9nNGphdmFzY3JpcHQuc2V0RG9jdW1lbnRSZWFkeSxmYWxzZSk7fWVsc2UgaWYod2luZG93LmF0dGFjaEV2ZW50KXt3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixsb2c0amF2YXNjcmlwdC5zZXREb2N1bWVudFJlYWR5KTt9ZWxzZXt2YXIgb2xkT25sb2FkPXdpbmRvdy5vbmxvYWQ7aWYodHlwZW9mIHdpbmRvdy5vbmxvYWQhPVwiZnVuY3Rpb25cIil7d2luZG93Lm9ubG9hZD1sb2c0amF2YXNjcmlwdC5zZXREb2N1bWVudFJlYWR5O31lbHNle3dpbmRvdy5vbmxvYWQ9ZnVuY3Rpb24oZXZ0KXtpZihvbGRPbmxvYWQpe29sZE9ubG9hZChldnQpO31cclxubG9nNGphdmFzY3JpcHQuc2V0RG9jdW1lbnRSZWFkeSgpO307fX1cclxucmV0dXJuIGxvZzRqYXZhc2NyaXB0O30sdGhpcyk7XHJcbiIsIiFmdW5jdGlvbih0LHIpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXIoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHIpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuTWVzc2FnZUZvcm1hdD1yKCk6dC5NZXNzYWdlRm9ybWF0PXIoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgcj17fTtmdW5jdGlvbiBlKG4pe2lmKHJbbl0pcmV0dXJuIHJbbl0uZXhwb3J0czt2YXIgbz1yW25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtuXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxlKSxvLmw9ITAsby5leHBvcnRzfXJldHVybiBlLm09dCxlLmM9cixlLmQ9ZnVuY3Rpb24odCxyLG4pe2Uubyh0LHIpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LGUucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxlLnQ9ZnVuY3Rpb24odCxyKXtpZigxJnImJih0PWUodCkpLDgmcilyZXR1cm4gdDtpZig0JnImJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImciYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciBvIGluIHQpZS5kKG4sbyxmdW5jdGlvbihyKXtyZXR1cm4gdFtyXX0uYmluZChudWxsLG8pKTtyZXR1cm4gbn0sZS5uPWZ1bmN0aW9uKHQpe3ZhciByPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiBlLmQocixcImFcIixyKSxyfSxlLm89ZnVuY3Rpb24odCxyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscil9LGUucD1cIlwiLGUoZS5zPTgpfShbZnVuY3Rpb24odCxyLGUpe3ZhciBuLG87dm9pZCAwPT09KG89XCJmdW5jdGlvblwiPT10eXBlb2Yobj17YWY6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sYWs6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MD09dHx8MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sYW06ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6dD49MCYmdDw9MT9cIm9uZVwiOlwib3RoZXJcIn0sYXI6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49TnVtYmVyKGVbMF0pPT10LG89biYmZVswXS5zbGljZSgtMik7cmV0dXJuIHI/XCJvdGhlclwiOjA9PXQ/XCJ6ZXJvXCI6MT09dD9cIm9uZVwiOjI9PXQ/XCJ0d29cIjpvPj0zJiZvPD0xMD9cImZld1wiOm8+PTExJiZvPD05OT9cIm1hbnlcIjpcIm90aGVyXCJ9LGFyczpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1OdW1iZXIoZVswXSk9PXQsbz1uJiZlWzBdLnNsaWNlKC0yKTtyZXR1cm4gcj9cIm90aGVyXCI6MD09dD9cInplcm9cIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOm8+PTMmJm88PTEwP1wiZmV3XCI6bz49MTEmJm88PTk5P1wibWFueVwiOlwib3RoZXJcIn0sYXM6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj8xPT10fHw1PT10fHw3PT10fHw4PT10fHw5PT10fHwxMD09dD9cIm9uZVwiOjI9PXR8fDM9PXQ/XCJ0d29cIjo0PT10P1wiZmV3XCI6Nj09dD9cIm1hbnlcIjpcIm90aGVyXCI6dD49MCYmdDw9MT9cIm9uZVwiOlwib3RoZXJcIn0sYXNhOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGFzdDpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sYXo6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPW4uc2xpY2UoLTEpLGk9bi5zbGljZSgtMiksdT1uLnNsaWNlKC0zKTtyZXR1cm4gcj8xPT1vfHwyPT1vfHw1PT1vfHw3PT1vfHw4PT1vfHwyMD09aXx8NTA9PWl8fDcwPT1pfHw4MD09aT9cIm9uZVwiOjM9PW98fDQ9PW98fDEwMD09dXx8MjAwPT11fHwzMDA9PXV8fDQwMD09dXx8NTAwPT11fHw2MDA9PXV8fDcwMD09dXx8ODAwPT11fHw5MDA9PXU/XCJmZXdcIjowPT1ufHw2PT1vfHw0MD09aXx8NjA9PWl8fDkwPT1pP1wibWFueVwiOlwib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxiZTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1OdW1iZXIoZVswXSk9PXQsbz1uJiZlWzBdLnNsaWNlKC0xKSxpPW4mJmVbMF0uc2xpY2UoLTIpO3JldHVybiByPzIhPW8mJjMhPW98fDEyPT1pfHwxMz09aT9cIm90aGVyXCI6XCJmZXdcIjoxPT1vJiYxMSE9aT9cIm9uZVwiOm8+PTImJm88PTQmJihpPDEyfHxpPjE0KT9cImZld1wiOm4mJjA9PW98fG8+PTUmJm88PTl8fGk+PTExJiZpPD0xND9cIm1hbnlcIjpcIm90aGVyXCJ9LGJlbTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxiZXo6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sYmc6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sYmg6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MD09dHx8MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sYm06ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LGJuOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/MT09dHx8NT09dHx8Nz09dHx8OD09dHx8OT09dHx8MTA9PXQ/XCJvbmVcIjoyPT10fHwzPT10P1widHdvXCI6ND09dD9cImZld1wiOjY9PXQ/XCJtYW55XCI6XCJvdGhlclwiOnQ+PTAmJnQ8PTE/XCJvbmVcIjpcIm90aGVyXCJ9LGJvOmZ1bmN0aW9uKHQscil7cmV0dXJuXCJvdGhlclwifSxicjpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1OdW1iZXIoZVswXSk9PXQsbz1uJiZlWzBdLnNsaWNlKC0xKSxpPW4mJmVbMF0uc2xpY2UoLTIpLHU9biYmZVswXS5zbGljZSgtNik7cmV0dXJuIHI/XCJvdGhlclwiOjE9PW8mJjExIT1pJiY3MSE9aSYmOTEhPWk/XCJvbmVcIjoyPT1vJiYxMiE9aSYmNzIhPWkmJjkyIT1pP1widHdvXCI6KDM9PW98fDQ9PW98fDk9PW8pJiYoaTwxMHx8aT4xOSkmJihpPDcwfHxpPjc5KSYmKGk8OTB8fGk+OTkpP1wiZmV3XCI6MCE9dCYmbiYmMD09dT9cIm1hbnlcIjpcIm90aGVyXCJ9LGJyeDpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxiczpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1lWzBdLG89ZVsxXXx8XCJcIixpPSFlWzFdLHU9bi5zbGljZSgtMSksYT1uLnNsaWNlKC0yKSxjPW8uc2xpY2UoLTEpLGg9by5zbGljZSgtMik7cmV0dXJuIHI/XCJvdGhlclwiOmkmJjE9PXUmJjExIT1hfHwxPT1jJiYxMSE9aD9cIm9uZVwiOmkmJnU+PTImJnU8PTQmJihhPDEyfHxhPjE0KXx8Yz49MiYmYzw9NCYmKGg8MTJ8fGg+MTQpP1wiZmV3XCI6XCJvdGhlclwifSxjYTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj8xPT10fHwzPT10P1wib25lXCI6Mj09dD9cInR3b1wiOjQ9PXQ/XCJmZXdcIjpcIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sY2U6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sY2dnOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGNocjpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxja2I6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sY3M6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPSFlWzFdO3JldHVybiByP1wib3RoZXJcIjoxPT10JiZvP1wib25lXCI6bj49MiYmbjw9NCYmbz9cImZld1wiOm8/XCJvdGhlclwiOlwibWFueVwifSxjeTpmdW5jdGlvbih0LHIpe3JldHVybiByPzA9PXR8fDc9PXR8fDg9PXR8fDk9PXQ/XCJ6ZXJvXCI6MT09dD9cIm9uZVwiOjI9PXQ/XCJ0d29cIjozPT10fHw0PT10P1wiZmV3XCI6NT09dHx8Nj09dD9cIm1hbnlcIjpcIm90aGVyXCI6MD09dD9cInplcm9cIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOjM9PXQ/XCJmZXdcIjo2PT10P1wibWFueVwiOlwib3RoZXJcIn0sZGE6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPU51bWJlcihlWzBdKT09dDtyZXR1cm4gcj9cIm90aGVyXCI6MSE9dCYmKG98fDAhPW4mJjEhPW4pP1wib3RoZXJcIjpcIm9uZVwifSxkZTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sZHNiOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz1lWzFdfHxcIlwiLGk9IWVbMV0sdT1uLnNsaWNlKC0yKSxhPW8uc2xpY2UoLTIpO3JldHVybiByP1wib3RoZXJcIjppJiYxPT11fHwxPT1hP1wib25lXCI6aSYmMj09dXx8Mj09YT9cInR3b1wiOmkmJigzPT11fHw0PT11KXx8Mz09YXx8ND09YT9cImZld1wiOlwib3RoZXJcIn0sZHY6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sZHo6ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LGVlOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGVsOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGVuOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPSFlWzFdLG89TnVtYmVyKGVbMF0pPT10LGk9byYmZVswXS5zbGljZSgtMSksdT1vJiZlWzBdLnNsaWNlKC0yKTtyZXR1cm4gcj8xPT1pJiYxMSE9dT9cIm9uZVwiOjI9PWkmJjEyIT11P1widHdvXCI6Mz09aSYmMTMhPXU/XCJmZXdcIjpcIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sZW86ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sZXM6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sZXQ6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV07cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjpcIm90aGVyXCJ9LGV1OmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGZhOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOnQ+PTAmJnQ8PTE/XCJvbmVcIjpcIm90aGVyXCJ9LGZmOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOnQ+PTAmJnQ8Mj9cIm9uZVwiOlwib3RoZXJcIn0sZmk6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV07cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjpcIm90aGVyXCJ9LGZpbDpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1lWzBdLG89ZVsxXXx8XCJcIixpPSFlWzFdLHU9bi5zbGljZSgtMSksYT1vLnNsaWNlKC0xKTtyZXR1cm4gcj8xPT10P1wib25lXCI6XCJvdGhlclwiOmkmJigxPT1ufHwyPT1ufHwzPT1uKXx8aSYmNCE9dSYmNiE9dSYmOSE9dXx8IWkmJjQhPWEmJjYhPWEmJjkhPWE/XCJvbmVcIjpcIm90aGVyXCJ9LGZvOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGZyOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/MT09dD9cIm9uZVwiOlwib3RoZXJcIjp0Pj0wJiZ0PDI/XCJvbmVcIjpcIm90aGVyXCJ9LGZ1cjpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxmeTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sZ2E6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49TnVtYmVyKGVbMF0pPT10O3JldHVybiByPzE9PXQ/XCJvbmVcIjpcIm90aGVyXCI6MT09dD9cIm9uZVwiOjI9PXQ/XCJ0d29cIjpuJiZ0Pj0zJiZ0PD02P1wiZmV3XCI6biYmdD49NyYmdDw9MTA/XCJtYW55XCI6XCJvdGhlclwifSxnZDpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1OdW1iZXIoZVswXSk9PXQ7cmV0dXJuIHI/MT09dHx8MTE9PXQ/XCJvbmVcIjoyPT10fHwxMj09dD9cInR3b1wiOjM9PXR8fDEzPT10P1wiZmV3XCI6XCJvdGhlclwiOjE9PXR8fDExPT10P1wib25lXCI6Mj09dHx8MTI9PXQ/XCJ0d29cIjpuJiZ0Pj0zJiZ0PD0xMHx8biYmdD49MTMmJnQ8PTE5P1wiZmV3XCI6XCJvdGhlclwifSxnbDpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sZ3N3OmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGd1OmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/MT09dD9cIm9uZVwiOjI9PXR8fDM9PXQ/XCJ0d29cIjo0PT10P1wiZmV3XCI6Nj09dD9cIm1hbnlcIjpcIm90aGVyXCI6dD49MCYmdDw9MT9cIm9uZVwiOlwib3RoZXJcIn0sZ3V3OmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjA9PXR8fDE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGd2OmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz0hZVsxXSxpPW4uc2xpY2UoLTEpLHU9bi5zbGljZSgtMik7cmV0dXJuIHI/XCJvdGhlclwiOm8mJjE9PWk/XCJvbmVcIjpvJiYyPT1pP1widHdvXCI6IW98fDAhPXUmJjIwIT11JiY0MCE9dSYmNjAhPXUmJjgwIT11P28/XCJvdGhlclwiOlwibWFueVwiOlwiZmV3XCJ9LGhhOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGhhdzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxoZTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1lWzBdLG89IWVbMV0saT1OdW1iZXIoZVswXSk9PXQsdT1pJiZlWzBdLnNsaWNlKC0xKTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbz9cIm9uZVwiOjI9PW4mJm8/XCJ0d29cIjpvJiYodDwwfHx0PjEwKSYmaSYmMD09dT9cIm1hbnlcIjpcIm90aGVyXCJ9LGhpOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/MT09dD9cIm9uZVwiOjI9PXR8fDM9PXQ/XCJ0d29cIjo0PT10P1wiZmV3XCI6Nj09dD9cIm1hbnlcIjpcIm90aGVyXCI6dD49MCYmdDw9MT9cIm9uZVwiOlwib3RoZXJcIn0saHI6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPWVbMV18fFwiXCIsaT0hZVsxXSx1PW4uc2xpY2UoLTEpLGE9bi5zbGljZSgtMiksYz1vLnNsaWNlKC0xKSxoPW8uc2xpY2UoLTIpO3JldHVybiByP1wib3RoZXJcIjppJiYxPT11JiYxMSE9YXx8MT09YyYmMTEhPWg/XCJvbmVcIjppJiZ1Pj0yJiZ1PD00JiYoYTwxMnx8YT4xNCl8fGM+PTImJmM8PTQmJihoPDEyfHxoPjE0KT9cImZld1wiOlwib3RoZXJcIn0saHNiOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz1lWzFdfHxcIlwiLGk9IWVbMV0sdT1uLnNsaWNlKC0yKSxhPW8uc2xpY2UoLTIpO3JldHVybiByP1wib3RoZXJcIjppJiYxPT11fHwxPT1hP1wib25lXCI6aSYmMj09dXx8Mj09YT9cInR3b1wiOmkmJigzPT11fHw0PT11KXx8Mz09YXx8ND09YT9cImZld1wiOlwib3RoZXJcIn0saHU6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj8xPT10fHw1PT10P1wib25lXCI6XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGh5OmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/MT09dD9cIm9uZVwiOlwib3RoZXJcIjp0Pj0wJiZ0PDI/XCJvbmVcIjpcIm90aGVyXCJ9LGlhOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPSFlWzFdO3JldHVybiByP1wib3RoZXJcIjoxPT10JiZuP1wib25lXCI6XCJvdGhlclwifSxpZDpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0saWc6ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LGlpOmZ1bmN0aW9uKHQscil7cmV0dXJuXCJvdGhlclwifSxpbjpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0saW86ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV07cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjpcIm90aGVyXCJ9LGlzOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz1OdW1iZXIoZVswXSk9PXQsaT1uLnNsaWNlKC0xKSx1PW4uc2xpY2UoLTIpO3JldHVybiByP1wib3RoZXJcIjpvJiYxPT1pJiYxMSE9dXx8IW8/XCJvbmVcIjpcIm90aGVyXCJ9LGl0OmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPSFlWzFdO3JldHVybiByPzExPT10fHw4PT10fHw4MD09dHx8ODAwPT10P1wibWFueVwiOlwib3RoZXJcIjoxPT10JiZuP1wib25lXCI6XCJvdGhlclwifSxpdTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOlwib3RoZXJcIn0saXc6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPSFlWzFdLGk9TnVtYmVyKGVbMF0pPT10LHU9aSYmZVswXS5zbGljZSgtMSk7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQmJm8/XCJvbmVcIjoyPT1uJiZvP1widHdvXCI6byYmKHQ8MHx8dD4xMCkmJmkmJjA9PXU/XCJtYW55XCI6XCJvdGhlclwifSxqYTpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0samJvOmZ1bmN0aW9uKHQscil7cmV0dXJuXCJvdGhlclwifSxqZ286ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0samk6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV07cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjpcIm90aGVyXCJ9LGptYzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxqdjpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0sanc6ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LGthOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz1uLnNsaWNlKC0yKTtyZXR1cm4gcj8xPT1uP1wib25lXCI6MD09bnx8bz49MiYmbzw9MjB8fDQwPT1vfHw2MD09b3x8ODA9PW8/XCJtYW55XCI6XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGthYjpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjp0Pj0wJiZ0PDI/XCJvbmVcIjpcIm90aGVyXCJ9LGthajpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxrY2c6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sa2RlOmZ1bmN0aW9uKHQscil7cmV0dXJuXCJvdGhlclwifSxrZWE6ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LGtrOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPU51bWJlcihlWzBdKT09dCxvPW4mJmVbMF0uc2xpY2UoLTEpO3JldHVybiByPzY9PW98fDk9PW98fG4mJjA9PW8mJjAhPXQ/XCJtYW55XCI6XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGtrajpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxrbDpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxrbTpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0sa246ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6dD49MCYmdDw9MT9cIm9uZVwiOlwib3RoZXJcIn0sa286ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LGtzOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LGtzYjpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxrc2g6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MD09dD9cInplcm9cIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxrdTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxrdzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOlwib3RoZXJcIn0sa3k6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbGFnOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF07cmV0dXJuIHI/XCJvdGhlclwiOjA9PXQ/XCJ6ZXJvXCI6MCE9biYmMSE9bnx8MD09dD9cIm90aGVyXCI6XCJvbmVcIn0sbGI6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbGc6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbGt0OmZ1bmN0aW9uKHQscil7cmV0dXJuXCJvdGhlclwifSxsbjpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjowPT10fHwxPT10P1wib25lXCI6XCJvdGhlclwifSxsbzpmdW5jdGlvbih0LHIpe3JldHVybiByJiYxPT10P1wib25lXCI6XCJvdGhlclwifSxsdDpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1lWzFdfHxcIlwiLG89TnVtYmVyKGVbMF0pPT10LGk9byYmZVswXS5zbGljZSgtMSksdT1vJiZlWzBdLnNsaWNlKC0yKTtyZXR1cm4gcj9cIm90aGVyXCI6MT09aSYmKHU8MTF8fHU+MTkpP1wib25lXCI6aT49MiYmaTw9OSYmKHU8MTF8fHU+MTkpP1wiZmV3XCI6MCE9bj9cIm1hbnlcIjpcIm90aGVyXCJ9LGx2OmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMV18fFwiXCIsbz1uLmxlbmd0aCxpPU51bWJlcihlWzBdKT09dCx1PWkmJmVbMF0uc2xpY2UoLTEpLGE9aSYmZVswXS5zbGljZSgtMiksYz1uLnNsaWNlKC0yKSxoPW4uc2xpY2UoLTEpO3JldHVybiByP1wib3RoZXJcIjppJiYwPT11fHxhPj0xMSYmYTw9MTl8fDI9PW8mJmM+PTExJiZjPD0xOT9cInplcm9cIjoxPT11JiYxMSE9YXx8Mj09byYmMT09aCYmMTEhPWN8fDIhPW8mJjE9PWg/XCJvbmVcIjpcIm90aGVyXCJ9LG1hczpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxtZzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjowPT10fHwxPT10P1wib25lXCI6XCJvdGhlclwifSxtZ286ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbWs6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPWVbMV18fFwiXCIsaT0hZVsxXSx1PW4uc2xpY2UoLTEpLGE9bi5zbGljZSgtMiksYz1vLnNsaWNlKC0xKSxoPW8uc2xpY2UoLTIpO3JldHVybiByPzE9PXUmJjExIT1hP1wib25lXCI6Mj09dSYmMTIhPWE/XCJ0d29cIjo3IT11JiY4IT11fHwxNz09YXx8MTg9PWE/XCJvdGhlclwiOlwibWFueVwiOmkmJjE9PXUmJjExIT1hfHwxPT1jJiYxMSE9aD9cIm9uZVwiOlwib3RoZXJcIn0sbWw6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbW46ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbW86ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV0sbz1OdW1iZXIoZVswXSk9PXQsaT1vJiZlWzBdLnNsaWNlKC0yKTtyZXR1cm4gcj8xPT10P1wib25lXCI6XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjohbnx8MD09dHx8MSE9dCYmaT49MSYmaTw9MTk/XCJmZXdcIjpcIm90aGVyXCJ9LG1yOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/MT09dD9cIm9uZVwiOjI9PXR8fDM9PXQ/XCJ0d29cIjo0PT10P1wiZmV3XCI6XCJvdGhlclwiOnQ+PTAmJnQ8PTE/XCJvbmVcIjpcIm90aGVyXCJ9LG1zOmZ1bmN0aW9uKHQscil7cmV0dXJuIHImJjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LG10OmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPU51bWJlcihlWzBdKT09dCxvPW4mJmVbMF0uc2xpY2UoLTIpO3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6MD09dHx8bz49MiYmbzw9MTA/XCJmZXdcIjpvPj0xMSYmbzw9MTk/XCJtYW55XCI6XCJvdGhlclwifSxteTpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0sbmFoOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LG5hcTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOlwib3RoZXJcIn0sbmI6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbmQ6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbmU6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49TnVtYmVyKGVbMF0pPT10O3JldHVybiByP24mJnQ+PTEmJnQ8PTQ/XCJvbmVcIjpcIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sbmw6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV07cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjpcIm90aGVyXCJ9LG5uOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LG5uaDpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxubzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxucW86ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LG5yOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LG5zbzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjowPT10fHwxPT10P1wib25lXCI6XCJvdGhlclwifSxueTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxueW46ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sb206ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sb3I6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49TnVtYmVyKGVbMF0pPT10O3JldHVybiByPzE9PXR8fDU9PXR8fG4mJnQ+PTcmJnQ8PTk/XCJvbmVcIjoyPT10fHwzPT10P1widHdvXCI6ND09dD9cImZld1wiOjY9PXQ/XCJtYW55XCI6XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LG9zOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHBhOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjA9PXR8fDE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHBhcDpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxwbDpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1lWzBdLG89IWVbMV0saT1uLnNsaWNlKC0xKSx1PW4uc2xpY2UoLTIpO3JldHVybiByP1wib3RoZXJcIjoxPT10JiZvP1wib25lXCI6byYmaT49MiYmaTw9NCYmKHU8MTJ8fHU+MTQpP1wiZmV3XCI6byYmMSE9biYmKDA9PWl8fDE9PWkpfHxvJiZpPj01JiZpPD05fHxvJiZ1Pj0xMiYmdTw9MTQ/XCJtYW55XCI6XCJvdGhlclwifSxwcmc6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVsxXXx8XCJcIixvPW4ubGVuZ3RoLGk9TnVtYmVyKGVbMF0pPT10LHU9aSYmZVswXS5zbGljZSgtMSksYT1pJiZlWzBdLnNsaWNlKC0yKSxjPW4uc2xpY2UoLTIpLGg9bi5zbGljZSgtMSk7cmV0dXJuIHI/XCJvdGhlclwiOmkmJjA9PXV8fGE+PTExJiZhPD0xOXx8Mj09byYmYz49MTEmJmM8PTE5P1wiemVyb1wiOjE9PXUmJjExIT1hfHwyPT1vJiYxPT1oJiYxMSE9Y3x8MiE9byYmMT09aD9cIm9uZVwiOlwib3RoZXJcIn0scHM6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0scHQ6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXTtyZXR1cm4gcj9cIm90aGVyXCI6MD09bnx8MT09bj9cIm9uZVwiOlwib3RoZXJcIn0sXCJwdC1QVFwiOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPSFlWzFdO3JldHVybiByP1wib3RoZXJcIjoxPT10JiZuP1wib25lXCI6XCJvdGhlclwifSxybTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxybzpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXSxvPU51bWJlcihlWzBdKT09dCxpPW8mJmVbMF0uc2xpY2UoLTIpO3JldHVybiByPzE9PXQ/XCJvbmVcIjpcIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOiFufHwwPT10fHwxIT10JiZpPj0xJiZpPD0xOT9cImZld1wiOlwib3RoZXJcIn0scm9mOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHJvb3Q6ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LHJ1OmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz0hZVsxXSxpPW4uc2xpY2UoLTEpLHU9bi5zbGljZSgtMik7cmV0dXJuIHI/XCJvdGhlclwiOm8mJjE9PWkmJjExIT11P1wib25lXCI6byYmaT49MiYmaTw9NCYmKHU8MTJ8fHU+MTQpP1wiZmV3XCI6byYmMD09aXx8byYmaT49NSYmaTw9OXx8byYmdT49MTEmJnU8PTE0P1wibWFueVwiOlwib3RoZXJcIn0scndrOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHNhaDpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0sc2FxOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHNjOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPSFlWzFdO3JldHVybiByPzExPT10fHw4PT10fHw4MD09dHx8ODAwPT10P1wibWFueVwiOlwib3RoZXJcIjoxPT10JiZuP1wib25lXCI6XCJvdGhlclwifSxzY246ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV07cmV0dXJuIHI/MTE9PXR8fDg9PXR8fDgwPT10fHw4MDA9PXQ/XCJtYW55XCI6XCJvdGhlclwiOjE9PXQmJm4/XCJvbmVcIjpcIm90aGVyXCJ9LHNkOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHNkaDpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxzZTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOlwib3RoZXJcIn0sc2VoOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHNlczpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0sc2c6ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LHNoOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz1lWzFdfHxcIlwiLGk9IWVbMV0sdT1uLnNsaWNlKC0xKSxhPW4uc2xpY2UoLTIpLGM9by5zbGljZSgtMSksaD1vLnNsaWNlKC0yKTtyZXR1cm4gcj9cIm90aGVyXCI6aSYmMT09dSYmMTEhPWF8fDE9PWMmJjExIT1oP1wib25lXCI6aSYmdT49MiYmdTw9NCYmKGE8MTJ8fGE+MTQpfHxjPj0yJiZjPD00JiYoaDwxMnx8aD4xNCk/XCJmZXdcIjpcIm90aGVyXCJ9LHNoaTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1OdW1iZXIoZVswXSk9PXQ7cmV0dXJuIHI/XCJvdGhlclwiOnQ+PTAmJnQ8PTE/XCJvbmVcIjpuJiZ0Pj0yJiZ0PD0xMD9cImZld1wiOlwib3RoZXJcIn0sc2k6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPWVbMV18fFwiXCI7cmV0dXJuIHI/XCJvdGhlclwiOjA9PXR8fDE9PXR8fDA9PW4mJjE9PW8/XCJvbmVcIjpcIm90aGVyXCJ9LHNrOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbz9cIm9uZVwiOm4+PTImJm48PTQmJm8/XCJmZXdcIjpvP1wib3RoZXJcIjpcIm1hbnlcIn0sc2w6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPSFlWzFdLGk9bi5zbGljZSgtMik7cmV0dXJuIHI/XCJvdGhlclwiOm8mJjE9PWk/XCJvbmVcIjpvJiYyPT1pP1widHdvXCI6byYmKDM9PWl8fDQ9PWkpfHwhbz9cImZld1wiOlwib3RoZXJcIn0sc21hOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjoyPT10P1widHdvXCI6XCJvdGhlclwifSxzbWk6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOjI9PXQ/XCJ0d29cIjpcIm90aGVyXCJ9LHNtajpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6Mj09dD9cInR3b1wiOlwib3RoZXJcIn0sc21uOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjoyPT10P1widHdvXCI6XCJvdGhlclwifSxzbXM6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOjI9PXQ/XCJ0d29cIjpcIm90aGVyXCJ9LHNuOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHNvOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHNxOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPU51bWJlcihlWzBdKT09dCxvPW4mJmVbMF0uc2xpY2UoLTEpLGk9biYmZVswXS5zbGljZSgtMik7cmV0dXJuIHI/MT09dD9cIm9uZVwiOjQ9PW8mJjE0IT1pP1wibWFueVwiOlwib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxzcjpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1lWzBdLG89ZVsxXXx8XCJcIixpPSFlWzFdLHU9bi5zbGljZSgtMSksYT1uLnNsaWNlKC0yKSxjPW8uc2xpY2UoLTEpLGg9by5zbGljZSgtMik7cmV0dXJuIHI/XCJvdGhlclwiOmkmJjE9PXUmJjExIT1hfHwxPT1jJiYxMSE9aD9cIm9uZVwiOmkmJnU+PTImJnU8PTQmJihhPDEyfHxhPjE0KXx8Yz49MiYmYzw9NCYmKGg8MTJ8fGg+MTQpP1wiZmV3XCI6XCJvdGhlclwifSxzczpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSxzc3k6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sc3Q6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sc3Y6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49IWVbMV0sbz1OdW1iZXIoZVswXSk9PXQsaT1vJiZlWzBdLnNsaWNlKC0xKSx1PW8mJmVbMF0uc2xpY2UoLTIpO3JldHVybiByPzEhPWkmJjIhPWl8fDExPT11fHwxMj09dT9cIm90aGVyXCI6XCJvbmVcIjoxPT10JiZuP1wib25lXCI6XCJvdGhlclwifSxzdzpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sc3lyOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHRhOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHRlOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHRlbzpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSx0aDpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0sdGk6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MD09dHx8MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdGlnOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHRrOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPU51bWJlcihlWzBdKT09dCxvPW4mJmVbMF0uc2xpY2UoLTEpO3JldHVybiByPzY9PW98fDk9PW98fDEwPT10P1wiZmV3XCI6XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHRsOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPWVbMF0sbz1lWzFdfHxcIlwiLGk9IWVbMV0sdT1uLnNsaWNlKC0xKSxhPW8uc2xpY2UoLTEpO3JldHVybiByPzE9PXQ/XCJvbmVcIjpcIm90aGVyXCI6aSYmKDE9PW58fDI9PW58fDM9PW4pfHxpJiY0IT11JiY2IT11JiY5IT11fHwhaSYmNCE9YSYmNiE9YSYmOSE9YT9cIm9uZVwiOlwib3RoZXJcIn0sdG46ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdG86ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm90aGVyXCJ9LHRyOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHRzOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHR6bTpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj1OdW1iZXIoZVswXSk9PXQ7cmV0dXJuIHI/XCJvdGhlclwiOjA9PXR8fDE9PXR8fG4mJnQ+PTExJiZ0PD05OT9cIm9uZVwiOlwib3RoZXJcIn0sdWc6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdWs6ZnVuY3Rpb24odCxyKXt2YXIgZT1TdHJpbmcodCkuc3BsaXQoXCIuXCIpLG49ZVswXSxvPSFlWzFdLGk9TnVtYmVyKGVbMF0pPT10LHU9aSYmZVswXS5zbGljZSgtMSksYT1pJiZlWzBdLnNsaWNlKC0yKSxjPW4uc2xpY2UoLTEpLGg9bi5zbGljZSgtMik7cmV0dXJuIHI/Mz09dSYmMTMhPWE/XCJmZXdcIjpcIm90aGVyXCI6byYmMT09YyYmMTEhPWg/XCJvbmVcIjpvJiZjPj0yJiZjPD00JiYoaDwxMnx8aD4xNCk/XCJmZXdcIjpvJiYwPT1jfHxvJiZjPj01JiZjPD05fHxvJiZoPj0xMSYmaDw9MTQ/XCJtYW55XCI6XCJvdGhlclwifSx1cjpmdW5jdGlvbih0LHIpe3ZhciBlPVN0cmluZyh0KS5zcGxpdChcIi5cIiksbj0hZVsxXTtyZXR1cm4gcj9cIm90aGVyXCI6MT09dCYmbj9cIm9uZVwiOlwib3RoZXJcIn0sdXo6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdmU6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdmk6ZnVuY3Rpb24odCxyKXtyZXR1cm4gciYmMT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdm86ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0sdnVuOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHdhOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjA9PXR8fDE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHdhZTpmdW5jdGlvbih0LHIpe3JldHVybiByP1wib3RoZXJcIjoxPT10P1wib25lXCI6XCJvdGhlclwifSx3bzpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0seGg6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6MT09dD9cIm9uZVwiOlwib3RoZXJcIn0seG9nOmZ1bmN0aW9uKHQscil7cmV0dXJuIHI/XCJvdGhlclwiOjE9PXQ/XCJvbmVcIjpcIm90aGVyXCJ9LHlpOmZ1bmN0aW9uKHQscil7dmFyIGU9U3RyaW5nKHQpLnNwbGl0KFwiLlwiKSxuPSFlWzFdO3JldHVybiByP1wib3RoZXJcIjoxPT10JiZuP1wib25lXCI6XCJvdGhlclwifSx5bzpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0seXVlOmZ1bmN0aW9uKHQscil7cmV0dXJuXCJvdGhlclwifSx6aDpmdW5jdGlvbih0LHIpe3JldHVyblwib3RoZXJcIn0senU6ZnVuY3Rpb24odCxyKXtyZXR1cm4gcj9cIm90aGVyXCI6dD49MCYmdDw9MT9cIm9uZVwiOlwib3RoZXJcIn19KT9uLmNhbGwocixlLHIsdCk6bil8fCh0LmV4cG9ydHM9byl9LGZ1bmN0aW9uKHQscixlKXt0LmV4cG9ydHM9e2RhdGU6ZSg0KSxkdXJhdGlvbjplKDUpLG51bWJlcjplKDYpLHRpbWU6ZSg3KX19LGZ1bmN0aW9uKHQscixlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKHQscixlLG8pe3RoaXMubWVzc2FnZT10LHRoaXMuZXhwZWN0ZWQ9cix0aGlzLmZvdW5kPWUsdGhpcy5sb2NhdGlvbj1vLHRoaXMubmFtZT1cIlN5bnRheEVycm9yXCIsXCJmdW5jdGlvblwiPT10eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsbil9IWZ1bmN0aW9uKHQscil7ZnVuY3Rpb24gZSgpe3RoaXMuY29uc3RydWN0b3I9dH1lLnByb3RvdHlwZT1yLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgZX0obixFcnJvciksbi5idWlsZE1lc3NhZ2U9ZnVuY3Rpb24odCxyKXt2YXIgZT17bGl0ZXJhbDpmdW5jdGlvbih0KXtyZXR1cm4nXCInK28odC50ZXh0KSsnXCInfSxjbGFzczpmdW5jdGlvbih0KXt2YXIgcixlPVwiXCI7Zm9yKHI9MDtyPHQucGFydHMubGVuZ3RoO3IrKyllKz10LnBhcnRzW3JdaW5zdGFuY2VvZiBBcnJheT9pKHQucGFydHNbcl1bMF0pK1wiLVwiK2kodC5wYXJ0c1tyXVsxXSk6aSh0LnBhcnRzW3JdKTtyZXR1cm5cIltcIisodC5pbnZlcnRlZD9cIl5cIjpcIlwiKStlK1wiXVwifSxhbnk6ZnVuY3Rpb24odCl7cmV0dXJuXCJhbnkgY2hhcmFjdGVyXCJ9LGVuZDpmdW5jdGlvbih0KXtyZXR1cm5cImVuZCBvZiBpbnB1dFwifSxvdGhlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXNjcmlwdGlvbn19O2Z1bmN0aW9uIG4odCl7cmV0dXJuIHQuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1mdW5jdGlvbiBvKHQpe3JldHVybiB0LnJlcGxhY2UoL1xcXFwvZyxcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1wiL2csJ1xcXFxcIicpLnJlcGxhY2UoL1xcMC9nLFwiXFxcXDBcIikucmVwbGFjZSgvXFx0L2csXCJcXFxcdFwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLFwiXFxcXHJcIikucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLGZ1bmN0aW9uKHQpe3JldHVyblwiXFxcXHgwXCIrbih0KX0pLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLGZ1bmN0aW9uKHQpe3JldHVyblwiXFxcXHhcIituKHQpfSl9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gdC5yZXBsYWNlKC9cXFxcL2csXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXF0vZyxcIlxcXFxdXCIpLnJlcGxhY2UoL1xcXi9nLFwiXFxcXF5cIikucmVwbGFjZSgvLS9nLFwiXFxcXC1cIikucmVwbGFjZSgvXFwwL2csXCJcXFxcMFwiKS5yZXBsYWNlKC9cXHQvZyxcIlxcXFx0XCIpLnJlcGxhY2UoL1xcbi9nLFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csXCJcXFxcclwiKS5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csZnVuY3Rpb24odCl7cmV0dXJuXCJcXFxceDBcIituKHQpfSkucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csZnVuY3Rpb24odCl7cmV0dXJuXCJcXFxceFwiK24odCl9KX1yZXR1cm5cIkV4cGVjdGVkIFwiK2Z1bmN0aW9uKHQpe3ZhciByLG4sbyxpPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKHI9MDtyPHQubGVuZ3RoO3IrKylpW3JdPShvPXRbcl0sZVtvLnR5cGVdKG8pKTtpZihpLnNvcnQoKSxpLmxlbmd0aD4wKXtmb3Iocj0xLG49MTtyPGkubGVuZ3RoO3IrKylpW3ItMV0hPT1pW3JdJiYoaVtuXT1pW3JdLG4rKyk7aS5sZW5ndGg9bn1zd2l0Y2goaS5sZW5ndGgpe2Nhc2UgMTpyZXR1cm4gaVswXTtjYXNlIDI6cmV0dXJuIGlbMF0rXCIgb3IgXCIraVsxXTtkZWZhdWx0OnJldHVybiBpLnNsaWNlKDAsLTEpLmpvaW4oXCIsIFwiKStcIiwgb3IgXCIraVtpLmxlbmd0aC0xXX19KHQpK1wiIGJ1dCBcIitmdW5jdGlvbih0KXtyZXR1cm4gdD8nXCInK28odCkrJ1wiJzpcImVuZCBvZiBpbnB1dFwifShyKStcIiBmb3VuZC5cIn0sdC5leHBvcnRzPXtTeW50YXhFcnJvcjpuLHBhcnNlOmZ1bmN0aW9uKHQscil7cj12b2lkIDAhPT1yP3I6e307dmFyIGUsbz17fSxpPXtzdGFydDp0cn0sdT10cixhPVwiI1wiLGM9SXQoXCIjXCIsITEpLGg9ZnVuY3Rpb24oKXtyZXR1cm4gcHJbMF19LGY9ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIm9jdG90aG9ycGVcIn19LHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQuam9pbihcIlwiKX0sbD1cIntcIixwPUl0KFwie1wiLCExKSxtPVwifVwiLGQ9SXQoXCJ9XCIsITEpLHk9ZnVuY3Rpb24odCl7cmV0dXJue3R5cGU6XCJhcmd1bWVudFwiLGFyZzp0fX0sZz1cIixcIix2PUl0KFwiLFwiLCExKSx3PVwic2VsZWN0XCIsYj1JdChcInNlbGVjdFwiLCExKSxTPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuc3RyaWN0JiZwci51bnNoaWZ0KCExKSxlfSxrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuc3RyaWN0JiZwci5zaGlmdCgpLHt0eXBlOlwic2VsZWN0XCIsYXJnOnQsY2FzZXM6ZX19LHg9XCJwbHVyYWxcIixBPUl0KFwicGx1cmFsXCIsITEpLGo9XCJzZWxlY3RvcmRpbmFsXCIsTj1JdChcInNlbGVjdG9yZGluYWxcIiwhMSksQz1mdW5jdGlvbih0LHIpe3JldHVybiBwci51bnNoaWZ0KCEwKSxyfSxGPWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBpPShcInNlbGVjdG9yZGluYWxcIj09PWU/ci5vcmRpbmFsOnIuY2FyZGluYWwpfHxbXCJ6ZXJvXCIsXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXTtyZXR1cm4gaSYmaS5sZW5ndGgmJm8uZm9yRWFjaChmdW5jdGlvbihyKXtpZihpc05hTihyLmtleSkmJmkuaW5kZXhPZihyLmtleSk8MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSBgXCIrci5rZXkrXCJgIGZvciBhcmd1bWVudCBgXCIrdCtcImAuIFZhbGlkIFwiK2UrXCIga2V5cyBmb3IgdGhpcyBsb2NhbGUgYXJlIGBcIitpLmpvaW4oXCJgLCBgXCIpK1wiYCwgYW5kIGV4cGxpY2l0IGtleXMgbGlrZSBgPTBgLlwiKX0pLHByLnNoaWZ0KCkse3R5cGU6ZSxhcmc6dCxvZmZzZXQ6bnx8MCxjYXNlczpvfX0sTz1mdW5jdGlvbih0LHIsZSl7cmV0dXJue3R5cGU6XCJmdW5jdGlvblwiLGFyZzp0LGtleTpyLHBhcmFtOmV9fSxFPVZ0KFwiaWRlbnRpZmllclwiKSx6PS9eW15cXHQtXFxyIFxceDg1XFx1MjAwRVxcdTIwMEZcXHUyMDI4XFx1MjAyOSEtXFwvOi1AWy1cXF5gey1+XFx4QTEtXFx4QTdcXHhBOVxceEFCXFx4QUNcXHhBRVxceEIwXFx4QjFcXHhCNlxceEJCXFx4QkZcXHhEN1xceEY3XFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDNFXFx1MjA0MS1cXHUyMDUzXFx1MjA1NS1cXHUyMDVFXFx1MjE5MC1cXHUyNDVGXFx1MjUwMC1cXHUyNzc1XFx1Mjc5NC1cXHUyQkZGXFx1MkUwMC1cXHUyRTdGXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDIwXFx1MzAzMFxcdUZEM0VcXHVGRDNGXFx1RkU0NVxcdUZFNDZdLyxQPVl0KFtbXCJcXHRcIixcIlxcclwiXSxcIiBcIixcIsKFXCIsXCLigI5cIixcIuKAj1wiLFwiXFx1MjAyOFwiLFwiXFx1MjAyOVwiLFtcIiFcIixcIi9cIl0sW1wiOlwiLFwiQFwiXSxbXCJbXCIsXCJeXCJdLFwiYFwiLFtcIntcIixcIn5cIl0sW1wiwqFcIixcIsKnXCJdLFwiwqlcIixcIsKrXCIsXCLCrFwiLFwiwq5cIixcIsKwXCIsXCLCsVwiLFwiwrZcIixcIsK7XCIsXCLCv1wiLFwiw5dcIixcIsO3XCIsW1wi4oCQXCIsXCLigKdcIl0sW1wi4oCwXCIsXCLigL5cIl0sW1wi4oGBXCIsXCLigZNcIl0sW1wi4oGVXCIsXCLigZ5cIl0sW1wi4oaQXCIsXCLikZ9cIl0sW1wi4pSAXCIsXCLinbVcIl0sW1wi4p6UXCIsXCLir79cIl0sW1wi4riAXCIsXCLiub9cIl0sW1wi44CBXCIsXCLjgINcIl0sW1wi44CIXCIsXCLjgKBcIl0sXCLjgLBcIixcIu+0vlwiLFwi77S/XCIsXCLvuYVcIixcIu+5hlwiXSwhMCwhMSksTD1mdW5jdGlvbih0LHIpe3JldHVybntrZXk6dCx0b2tlbnM6cn19LEo9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LEQ9VnQoXCJwbHVyYWwgb2Zmc2V0XCIpLE09XCJvZmZzZXRcIixfPUl0KFwib2Zmc2V0XCIsITEpLFQ9XCI6XCIsUj1JdChcIjpcIiwhMSksQj1mdW5jdGlvbih0KXtyZXR1cm4gdH0scT1cIj1cIiwkPUl0KFwiPVwiLCExKSxLPVwibnVtYmVyXCIsRz1JdChcIm51bWJlclwiLCExKSxVPVwiZGF0ZVwiLFo9SXQoXCJkYXRlXCIsITEpLEk9XCJ0aW1lXCIsWT1JdChcInRpbWVcIiwhMSksVj1cInNwZWxsb3V0XCIsVz1JdChcInNwZWxsb3V0XCIsITEpLEg9XCJvcmRpbmFsXCIsUT1JdChcIm9yZGluYWxcIiwhMSksWD1cImR1cmF0aW9uXCIsdHQ9SXQoXCJkdXJhdGlvblwiLCExKSxydD1mdW5jdGlvbih0KXtpZihyLnN0cmljdHx8L15cXGQvLnRlc3QodCkpcmV0dXJuITE7c3dpdGNoKHQudG9Mb3dlckNhc2UoKSl7Y2FzZVwic2VsZWN0XCI6Y2FzZVwicGx1cmFsXCI6Y2FzZVwic2VsZWN0b3JkaW5hbFwiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fSxldD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIXIuc3RyaWN0fSxvdD1mdW5jdGlvbih0KXtyZXR1cm57dG9rZW5zOnR9fSxpdD1mdW5jdGlvbih0KXtyZXR1cm57dG9rZW5zOlt0LmpvaW4oXCJcIildfX0sdXQ9VnQoXCJhIHZhbGlkIChzdHJpY3QpIGZ1bmN0aW9uIHBhcmFtZXRlclwiKSxhdD0vXlteJ3t9XS8sY3Q9WXQoW1wiJ1wiLFwie1wiLFwifVwiXSwhMCwhMSksaHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQuam9pbihcIlwiKX0sZnQ9XCInXCIsc3Q9SXQoXCInXCIsITEpLGx0PWZ1bmN0aW9uKHQpe3JldHVybiB0fSxwdD1mdW5jdGlvbih0KXtyZXR1cm5cIntcIit0LmpvaW4oXCJcIikrXCJ9XCJ9LG10PVZ0KFwiZG91YmxlZCBhcG9zdHJvcGhlXCIpLGR0PVwiJydcIix5dD1JdChcIicnXCIsITEpLGd0PWZ1bmN0aW9uKCl7cmV0dXJuXCInXCJ9LHZ0PS9eW14nXS8sd3Q9WXQoW1wiJ1wiXSwhMCwhMSksYnQ9XCIne1wiLFN0PUl0KFwiJ3tcIiwhMSksa3Q9ZnVuY3Rpb24odCl7cmV0dXJuXCJ7XCIrdC5qb2luKFwiXCIpfSx4dD1cIid9XCIsQXQ9SXQoXCInfVwiLCExKSxqdD1mdW5jdGlvbih0KXtyZXR1cm5cIn1cIit0LmpvaW4oXCJcIil9LE50PVZ0KFwiZXNjYXBlZCBzdHJpbmdcIiksQ3Q9XCInI1wiLEZ0PUl0KFwiJyNcIiwhMSksT3Q9ZnVuY3Rpb24odCl7cmV0dXJuXCIjXCIrdC5qb2luKFwiXCIpfSxFdD1mdW5jdGlvbih0KXtyZXR1cm4gdFswXX0senQ9VnQoXCJwbGFpbiBjaGFyXCIpLFB0PS9eW157fSNcXDAtXFx4MDhcXHgwRS1cXHgxRlxceDdGXS8sTHQ9WXQoW1wie1wiLFwifVwiLFwiI1wiLFtcIlxcMFwiLFwiXFxiXCJdLFtcIlx1MDAwZVwiLFwiXHUwMDFmXCJdLFwif1wiXSwhMCwhMSksSnQ9ZnVuY3Rpb24odCl7cmV0dXJuIXByWzBdfSxEdD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sTXQ9VnQoXCJpbnRlZ2VyXCIpLF90PS9eWzAtOV0vLFR0PVl0KFtbXCIwXCIsXCI5XCJdXSwhMSwhMSksUnQ9VnQoXCJ3aGl0ZSBzcGFjZVwiKSxCdD0vXltcXHQtXFxyIFxceDg1XFx1MjAwRVxcdTIwMEZcXHUyMDI4XFx1MjAyOV0vLHF0PVl0KFtbXCJcXHRcIixcIlxcclwiXSxcIiBcIixcIsKFXCIsXCLigI5cIixcIuKAj1wiLFwiXFx1MjAyOFwiLFwiXFx1MjAyOVwiXSwhMSwhMSksJHQ9MCxLdD1be2xpbmU6MSxjb2x1bW46MX1dLEd0PTAsVXQ9W10sWnQ9MDtpZihcInN0YXJ0UnVsZVwiaW4gcil7aWYoIShyLnN0YXJ0UnVsZSBpbiBpKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIrci5zdGFydFJ1bGUrJ1wiLicpO3U9aVtyLnN0YXJ0UnVsZV19ZnVuY3Rpb24gSXQodCxyKXtyZXR1cm57dHlwZTpcImxpdGVyYWxcIix0ZXh0OnQsaWdub3JlQ2FzZTpyfX1mdW5jdGlvbiBZdCh0LHIsZSl7cmV0dXJue3R5cGU6XCJjbGFzc1wiLHBhcnRzOnQsaW52ZXJ0ZWQ6cixpZ25vcmVDYXNlOmV9fWZ1bmN0aW9uIFZ0KHQpe3JldHVybnt0eXBlOlwib3RoZXJcIixkZXNjcmlwdGlvbjp0fX1mdW5jdGlvbiBXdChyKXt2YXIgZSxuPUt0W3JdO2lmKG4pcmV0dXJuIG47Zm9yKGU9ci0xOyFLdFtlXTspZS0tO2ZvcihuPXtsaW5lOihuPUt0W2VdKS5saW5lLGNvbHVtbjpuLmNvbHVtbn07ZTxyOykxMD09PXQuY2hhckNvZGVBdChlKT8obi5saW5lKyssbi5jb2x1bW49MSk6bi5jb2x1bW4rKyxlKys7cmV0dXJuIEt0W3JdPW4sbn1mdW5jdGlvbiBIdCh0LHIpe3ZhciBlPVd0KHQpLG49V3Qocik7cmV0dXJue3N0YXJ0OntvZmZzZXQ6dCxsaW5lOmUubGluZSxjb2x1bW46ZS5jb2x1bW59LGVuZDp7b2Zmc2V0OnIsbGluZTpuLmxpbmUsY29sdW1uOm4uY29sdW1ufX19ZnVuY3Rpb24gUXQodCl7JHQ8R3R8fCgkdD5HdCYmKEd0PSR0LFV0PVtdKSxVdC5wdXNoKHQpKX1mdW5jdGlvbiBYdCh0LHIsZSl7cmV0dXJuIG5ldyBuKG4uYnVpbGRNZXNzYWdlKHQsciksdCxyLGUpfWZ1bmN0aW9uIHRyKCl7dmFyIHQscjtmb3IodD1bXSxyPXJyKCk7ciE9PW87KXQucHVzaChyKSxyPXJyKCk7cmV0dXJuIHR9ZnVuY3Rpb24gcnIoKXt2YXIgcixlLG47aWYoKHI9ZnVuY3Rpb24oKXt2YXIgcixlLG4saTtyZXR1cm4gcj0kdCwxMjM9PT10LmNoYXJDb2RlQXQoJHQpPyhlPWwsJHQrKyk6KGU9bywwPT09WnQmJlF0KHApKSxlIT09byYmbHIoKSE9PW8mJihuPWVyKCkpIT09byYmbHIoKSE9PW8/KDEyNT09PXQuY2hhckNvZGVBdCgkdCk/KGk9bSwkdCsrKTooaT1vLDA9PT1adCYmUXQoZCkpLGkhPT1vPyhlPXkobikscj1lKTooJHQ9cixyPW8pKTooJHQ9cixyPW8pLHJ9KCkpPT09byYmKHI9ZnVuY3Rpb24oKXt2YXIgcixlLG4saSx1LGEsYyxoLGY7aWYocj0kdCwxMjM9PT10LmNoYXJDb2RlQXQoJHQpPyhlPWwsJHQrKyk6KGU9bywwPT09WnQmJlF0KHApKSxlIT09bylpZihscigpIT09bylpZigobj1lcigpKSE9PW8paWYobHIoKSE9PW8paWYoNDQ9PT10LmNoYXJDb2RlQXQoJHQpPyhpPWcsJHQrKyk6KGk9bywwPT09WnQmJlF0KHYpKSxpIT09bylpZihscigpIT09bylpZigkdCx0LnN1YnN0cigkdCw2KT09PXc/KHU9dywkdCs9Nik6KHU9bywwPT09WnQmJlF0KGIpKSx1IT09byYmKHU9UyhuLHUpKSx1IT09bylpZigodT1scigpKSE9PW8paWYoNDQ9PT10LmNoYXJDb2RlQXQoJHQpPyhhPWcsJHQrKyk6KGE9bywwPT09WnQmJlF0KHYpKSxhIT09bylpZihscigpIT09byl7aWYoYz1bXSwoaD1ucigpKSE9PW8pZm9yKDtoIT09bzspYy5wdXNoKGgpLGg9bnIoKTtlbHNlIGM9bztjIT09byYmKGg9bHIoKSkhPT1vPygxMjU9PT10LmNoYXJDb2RlQXQoJHQpPyhmPW0sJHQrKyk6KGY9bywwPT09WnQmJlF0KGQpKSxmIT09bz8oZT1rKG4sYykscj1lKTooJHQ9cixyPW8pKTooJHQ9cixyPW8pfWVsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2Vsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2Vsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2Vsc2UgJHQ9cixyPW87cmV0dXJuIHJ9KCkpPT09byYmKHI9ZnVuY3Rpb24oKXt2YXIgcixlLG4saSx1LGEsYyxoLGYscyx5O2lmKHI9JHQsMTIzPT09dC5jaGFyQ29kZUF0KCR0KT8oZT1sLCR0KyspOihlPW8sMD09PVp0JiZRdChwKSksZSE9PW8paWYobHIoKSE9PW8paWYoKG49ZXIoKSkhPT1vKWlmKGxyKCkhPT1vKWlmKDQ0PT09dC5jaGFyQ29kZUF0KCR0KT8oaT1nLCR0KyspOihpPW8sMD09PVp0JiZRdCh2KSksaSE9PW8paWYobHIoKSE9PW8paWYodT0kdCx0LnN1YnN0cigkdCw2KT09PXg/KGE9eCwkdCs9Nik6KGE9bywwPT09WnQmJlF0KEEpKSxhPT09byYmKHQuc3Vic3RyKCR0LDEzKT09PWo/KGE9aiwkdCs9MTMpOihhPW8sMD09PVp0JiZRdChOKSkpLGEhPT1vJiYoYT1DKG4sYSkpLCh1PWEpIT09bylpZigoYT1scigpKSE9PW8paWYoNDQ9PT10LmNoYXJDb2RlQXQoJHQpPyhjPWcsJHQrKyk6KGM9bywwPT09WnQmJlF0KHYpKSxjIT09bylpZihscigpIT09bylpZigoaD1mdW5jdGlvbigpe3ZhciByLGUsbixpLHU7cmV0dXJuIFp0Kysscj0kdCwoZT1scigpKSE9PW8/KHQuc3Vic3RyKCR0LDYpPT09TT8obj1NLCR0Kz02KToobj1vLDA9PT1adCYmUXQoXykpLG4hPT1vJiZscigpIT09bz8oNTg9PT10LmNoYXJDb2RlQXQoJHQpPyhpPVQsJHQrKyk6KGk9bywwPT09WnQmJlF0KFIpKSxpIT09byYmbHIoKSE9PW8mJih1PXNyKCkpIT09byYmbHIoKSE9PW8/KGU9Qih1KSxyPWUpOigkdD1yLHI9bykpOigkdD1yLHI9bykpOigkdD1yLHI9byksWnQtLSxyPT09byYmKGU9bywwPT09WnQmJlF0KEQpKSxyfSgpKT09PW8mJihoPW51bGwpLGghPT1vKXtpZihmPVtdLChzPW9yKCkpIT09bylmb3IoO3MhPT1vOylmLnB1c2gocykscz1vcigpO2Vsc2UgZj1vO2YhPT1vJiYocz1scigpKSE9PW8/KDEyNT09PXQuY2hhckNvZGVBdCgkdCk/KHk9bSwkdCsrKTooeT1vLDA9PT1adCYmUXQoZCkpLHkhPT1vPyhlPUYobix1LGgsZikscj1lKTooJHQ9cixyPW8pKTooJHQ9cixyPW8pfWVsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2Vsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2Vsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2Vsc2UgJHQ9cixyPW87ZWxzZSAkdD1yLHI9bztyZXR1cm4gcn0oKSk9PT1vJiYocj1mdW5jdGlvbigpe3ZhciByLGUsbixpLHUsYSxjO3JldHVybiByPSR0LDEyMz09PXQuY2hhckNvZGVBdCgkdCk/KGU9bCwkdCsrKTooZT1vLDA9PT1adCYmUXQocCkpLGUhPT1vJiZscigpIT09byYmKG49ZXIoKSkhPT1vJiZscigpIT09bz8oNDQ9PT10LmNoYXJDb2RlQXQoJHQpPyhpPWcsJHQrKyk6KGk9bywwPT09WnQmJlF0KHYpKSxpIT09byYmbHIoKSE9PW8mJih1PWZ1bmN0aW9uKCl7dmFyIHIsZSxuLGksdTtyZXR1cm4gdC5zdWJzdHIoJHQsNik9PT1LPyhyPUssJHQrPTYpOihyPW8sMD09PVp0JiZRdChHKSkscj09PW8mJih0LnN1YnN0cigkdCw0KT09PVU/KHI9VSwkdCs9NCk6KHI9bywwPT09WnQmJlF0KFopKSxyPT09byYmKHQuc3Vic3RyKCR0LDQpPT09ST8ocj1JLCR0Kz00KToocj1vLDA9PT1adCYmUXQoWSkpLHI9PT1vJiYodC5zdWJzdHIoJHQsOCk9PT1WPyhyPVYsJHQrPTgpOihyPW8sMD09PVp0JiZRdChXKSkscj09PW8mJih0LnN1YnN0cigkdCw3KT09PUg/KHI9SCwkdCs9Nyk6KHI9bywwPT09WnQmJlF0KFEpKSxyPT09byYmKHQuc3Vic3RyKCR0LDgpPT09WD8ocj1YLCR0Kz04KToocj1vLDA9PT1adCYmUXQodHQpKSxyPT09byYmKHI9JHQsZT0kdCxadCsrLHQuc3Vic3RyKCR0LDYpPT09dz8obj13LCR0Kz02KToobj1vLDA9PT1adCYmUXQoYikpLFp0LS0sbj09PW8/ZT12b2lkIDA6KCR0PWUsZT1vKSxlIT09bz8obj0kdCxadCsrLHQuc3Vic3RyKCR0LDYpPT09eD8oaT14LCR0Kz02KTooaT1vLDA9PT1adCYmUXQoQSkpLFp0LS0saT09PW8/bj12b2lkIDA6KCR0PW4sbj1vKSxuIT09bz8oaT0kdCxadCsrLHQuc3Vic3RyKCR0LDEzKT09PWo/KHU9aiwkdCs9MTMpOih1PW8sMD09PVp0JiZRdChOKSksWnQtLSx1PT09bz9pPXZvaWQgMDooJHQ9aSxpPW8pLGkhPT1vJiYodT1lcigpKSE9PW8mJihydCh1KT92b2lkIDA6bykhPT1vPyhlPWV0KHUpLHI9ZSk6KCR0PXIscj1vKSk6KCR0PXIscj1vKSk6KCR0PXIscj1vKSkpKSkpKSxyfSgpKSE9PW8mJmxyKCkhPT1vPygoYT1mdW5jdGlvbigpe3ZhciByLGUsbixpLHU7aWYocj0kdCwoZT1scigpKSE9PW8paWYoNDQ9PT10LmNoYXJDb2RlQXQoJHQpPyhuPWcsJHQrKyk6KG49bywwPT09WnQmJlF0KHYpKSxuIT09byl7Zm9yKGk9W10sdT1ycigpO3UhPT1vOylpLnB1c2godSksdT1ycigpO2khPT1vJiYodT0odT1udChpKSk/dm9pZCAwOm8pIT09bz8oZT1vdChpKSxyPWUpOigkdD1yLHI9byl9ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO2lmKHI9PT1vKWlmKHI9JHQsKGU9bHIoKSkhPT1vKWlmKDQ0PT09dC5jaGFyQ29kZUF0KCR0KT8obj1nLCR0KyspOihuPW8sMD09PVp0JiZRdCh2KSksbiE9PW8pe2ZvcihpPVtdLHU9dXIoKTt1IT09bzspaS5wdXNoKHUpLHU9dXIoKTtpIT09bz8oZT1pdChpKSxyPWUpOigkdD1yLHI9byl9ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO3JldHVybiByfSgpKT09PW8mJihhPW51bGwpLGEhPT1vPygxMjU9PT10LmNoYXJDb2RlQXQoJHQpPyhjPW0sJHQrKyk6KGM9bywwPT09WnQmJlF0KGQpKSxjIT09bz8oZT1PKG4sdSxhKSxyPWUpOigkdD1yLHI9bykpOigkdD1yLHI9bykpOigkdD1yLHI9bykpOigkdD1yLHI9bykscn0oKSk9PT1vJiYocj0kdCwzNT09PXQuY2hhckNvZGVBdCgkdCk/KGU9YSwkdCsrKTooZT1vLDA9PT1adCYmUXQoYykpLGUhPT1vJiYobj0obj1oKCkpP3ZvaWQgMDpvKSE9PW8/cj1lPWYoKTooJHQ9cixyPW8pLHI9PT1vKSl7aWYocj0kdCxlPVtdLChuPWZyKCkpIT09bylmb3IoO24hPT1vOyllLnB1c2gobiksbj1mcigpO2Vsc2UgZT1vO2UhPT1vJiYoZT1zKGUpKSxyPWV9cmV0dXJuIHJ9ZnVuY3Rpb24gZXIoKXt2YXIgcixlLG47aWYoWnQrKyxyPSR0LGU9W10sei50ZXN0KHQuY2hhckF0KCR0KSk/KG49dC5jaGFyQXQoJHQpLCR0KyspOihuPW8sMD09PVp0JiZRdChQKSksbiE9PW8pZm9yKDtuIT09bzspZS5wdXNoKG4pLHoudGVzdCh0LmNoYXJBdCgkdCkpPyhuPXQuY2hhckF0KCR0KSwkdCsrKToobj1vLDA9PT1adCYmUXQoUCkpO2Vsc2UgZT1vO3JldHVybiByPWUhPT1vP3Quc3Vic3RyaW5nKHIsJHQpOmUsWnQtLSxyPT09byYmKGU9bywwPT09WnQmJlF0KEUpKSxyfWZ1bmN0aW9uIG5yKCl7dmFyIHQscixlO3JldHVybiB0PSR0LGxyKCkhPT1vJiYocj1lcigpKSE9PW8mJmxyKCkhPT1vJiYoZT1pcigpKSE9PW8/dD1MKHIsZSk6KCR0PXQsdD1vKSx0fWZ1bmN0aW9uIG9yKCl7dmFyIHIsZSxuO3JldHVybiByPSR0LGxyKCkhPT1vJiYoZT1mdW5jdGlvbigpe3ZhciByLGUsbjtyZXR1cm4ocj1lcigpKT09PW8mJihyPSR0LDYxPT09dC5jaGFyQ29kZUF0KCR0KT8oZT1xLCR0KyspOihlPW8sMD09PVp0JiZRdCgkKSksZSE9PW8mJihuPXNyKCkpIT09bz8oZT1CKG4pLHI9ZSk6KCR0PXIscj1vKSkscn0oKSkhPT1vJiZscigpIT09byYmKG49aXIoKSkhPT1vP3I9TChlLG4pOigkdD1yLHI9bykscn1mdW5jdGlvbiBpcigpe3ZhciByLGUsbixpLHUsYTtpZihyPSR0LDEyMz09PXQuY2hhckNvZGVBdCgkdCk/KGU9bCwkdCsrKTooZT1vLDA9PT1adCYmUXQocCkpLGUhPT1vKWlmKG49JHQsKGk9bHIoKSkhPT1vPyh1PSR0LFp0KyssMTIzPT09dC5jaGFyQ29kZUF0KCR0KT8oYT1sLCR0KyspOihhPW8sMD09PVp0JiZRdChwKSksWnQtLSxhIT09bz8oJHQ9dSx1PXZvaWQgMCk6dT1vLHUhPT1vP249aT1baSx1XTooJHQ9bixuPW8pKTooJHQ9bixuPW8pLG49PT1vJiYobj1udWxsKSxuIT09byl7Zm9yKGk9W10sdT1ycigpO3UhPT1vOylpLnB1c2godSksdT1ycigpO2khPT1vJiYodT1scigpKSE9PW8/KDEyNT09PXQuY2hhckNvZGVBdCgkdCk/KGE9bSwkdCsrKTooYT1vLDA9PT1adCYmUXQoZCkpLGEhPT1vP3I9ZT1KKGkpOigkdD1yLHI9bykpOigkdD1yLHI9byl9ZWxzZSAkdD1yLHI9bztlbHNlICR0PXIscj1vO3JldHVybiByfWZ1bmN0aW9uIHVyKCl7dmFyIHIsZSxuLGk7aWYoWnQrKyxyPSR0LGU9W10sYXQudGVzdCh0LmNoYXJBdCgkdCkpPyhuPXQuY2hhckF0KCR0KSwkdCsrKToobj1vLDA9PT1adCYmUXQoY3QpKSxuIT09bylmb3IoO24hPT1vOyllLnB1c2gobiksYXQudGVzdCh0LmNoYXJBdCgkdCkpPyhuPXQuY2hhckF0KCR0KSwkdCsrKToobj1vLDA9PT1adCYmUXQoY3QpKTtlbHNlIGU9bztpZihlIT09byYmKGU9aHQoZSkpLChyPWUpPT09byYmKHI9YXIoKSk9PT1vJiYocj0kdCwzOT09PXQuY2hhckNvZGVBdCgkdCk/KGU9ZnQsJHQrKyk6KGU9bywwPT09WnQmJlF0KHN0KSksZSE9PW8mJihuPWNyKCkpIT09bz8oMzk9PT10LmNoYXJDb2RlQXQoJHQpPyhpPWZ0LCR0KyspOihpPW8sMD09PVp0JiZRdChzdCkpLGkhPT1vP3I9ZT1sdChuKTooJHQ9cixyPW8pKTooJHQ9cixyPW8pLHI9PT1vKSlpZihyPSR0LDEyMz09PXQuY2hhckNvZGVBdCgkdCk/KGU9bCwkdCsrKTooZT1vLDA9PT1adCYmUXQocCkpLGUhPT1vKXtmb3Iobj1bXSxpPXVyKCk7aSE9PW87KW4ucHVzaChpKSxpPXVyKCk7biE9PW8/KDEyNT09PXQuY2hhckNvZGVBdCgkdCk/KGk9bSwkdCsrKTooaT1vLDA9PT1adCYmUXQoZCkpLGkhPT1vP3I9ZT1wdChuKTooJHQ9cixyPW8pKTooJHQ9cixyPW8pfWVsc2UgJHQ9cixyPW87cmV0dXJuIFp0LS0scj09PW8mJihlPW8sMD09PVp0JiZRdCh1dCkpLHJ9ZnVuY3Rpb24gYXIoKXt2YXIgcixlO3JldHVybiBadCsrLHI9JHQsdC5zdWJzdHIoJHQsMik9PT1kdD8oZT1kdCwkdCs9Mik6KGU9bywwPT09WnQmJlF0KHl0KSksZSE9PW8mJihlPWd0KCkpLFp0LS0sKHI9ZSk9PT1vJiYoZT1vLDA9PT1adCYmUXQobXQpKSxyfWZ1bmN0aW9uIGNyKCl7dmFyIHIsZSxuO2lmKChyPWFyKCkpPT09byl7aWYocj0kdCxlPVtdLHZ0LnRlc3QodC5jaGFyQXQoJHQpKT8obj10LmNoYXJBdCgkdCksJHQrKyk6KG49bywwPT09WnQmJlF0KHd0KSksbiE9PW8pZm9yKDtuIT09bzspZS5wdXNoKG4pLHZ0LnRlc3QodC5jaGFyQXQoJHQpKT8obj10LmNoYXJBdCgkdCksJHQrKyk6KG49bywwPT09WnQmJlF0KHd0KSk7ZWxzZSBlPW87ZSE9PW8mJihlPXMoZSkpLHI9ZX1yZXR1cm4gcn1mdW5jdGlvbiBocigpe3ZhciByLGUsbixpLHUsYTtpZihadCsrLChyPWZ1bmN0aW9uKCl7dmFyIHIsZSxuLGk7aWYocj0kdCx0LnN1YnN0cigkdCwyKT09PWJ0PyhlPWJ0LCR0Kz0yKTooZT1vLDA9PT1adCYmUXQoU3QpKSxlIT09byl7Zm9yKG49W10saT1jcigpO2khPT1vOyluLnB1c2goaSksaT1jcigpO24hPT1vPygzOT09PXQuY2hhckNvZGVBdCgkdCk/KGk9ZnQsJHQrKyk6KGk9bywwPT09WnQmJlF0KHN0KSksaSE9PW8/cj1lPWt0KG4pOigkdD1yLHI9bykpOigkdD1yLHI9byl9ZWxzZSAkdD1yLHI9bztpZihyPT09bylpZihyPSR0LHQuc3Vic3RyKCR0LDIpPT09eHQ/KGU9eHQsJHQrPTIpOihlPW8sMD09PVp0JiZRdChBdCkpLGUhPT1vKXtmb3Iobj1bXSxpPWNyKCk7aSE9PW87KW4ucHVzaChpKSxpPWNyKCk7biE9PW8/KDM5PT09dC5jaGFyQ29kZUF0KCR0KT8oaT1mdCwkdCsrKTooaT1vLDA9PT1adCYmUXQoc3QpKSxpIT09bz9yPWU9anQobik6KCR0PXIscj1vKSk6KCR0PXIscj1vKX1lbHNlICR0PXIscj1vO3JldHVybiByfSgpKT09PW8pe2lmKHI9JHQsZT0kdCxuPSR0LHQuc3Vic3RyKCR0LDIpPT09Q3Q/KGk9Q3QsJHQrPTIpOihpPW8sMD09PVp0JiZRdChGdCkpLGkhPT1vKXtmb3IodT1bXSxhPWNyKCk7YSE9PW87KXUucHVzaChhKSxhPWNyKCk7dSE9PW8/KDM5PT09dC5jaGFyQ29kZUF0KCR0KT8oYT1mdCwkdCsrKTooYT1vLDA9PT1adCYmUXQoc3QpKSxhIT09bz9uPWk9T3QodSk6KCR0PW4sbj1vKSk6KCR0PW4sbj1vKX1lbHNlICR0PW4sbj1vO24hPT1vJiYoaT0oaT1oKCkpP3ZvaWQgMDpvKSE9PW8/ZT1uPVtuLGldOigkdD1lLGU9byksZSE9PW8mJihlPUV0KGUpKSwocj1lKT09PW8mJigzOT09PXQuY2hhckNvZGVBdCgkdCk/KHI9ZnQsJHQrKyk6KHI9bywwPT09WnQmJlF0KHN0KSkpfXJldHVybiBadC0tLHI9PT1vJiYoZT1vLDA9PT1adCYmUXQoTnQpKSxyfWZ1bmN0aW9uIGZyKCl7dmFyIHIsZTtyZXR1cm4ocj1hcigpKT09PW8mJihyPWhyKCkpPT09byYmKHI9JHQsMzU9PT10LmNoYXJDb2RlQXQoJHQpPyhlPWEsJHQrKyk6KGU9bywwPT09WnQmJlF0KGMpKSxlIT09byYmKEp0KGUpP3ZvaWQgMDpvKSE9PW8/cj1lPUR0KGUpOigkdD1yLHI9bykscj09PW8mJihyPWZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIFp0KyssUHQudGVzdCh0LmNoYXJBdCgkdCkpPyhyPXQuY2hhckF0KCR0KSwkdCsrKToocj1vLDA9PT1adCYmUXQoTHQpKSxadC0tLHI9PT1vJiYwPT09WnQmJlF0KHp0KSxyfSgpKSkscn1mdW5jdGlvbiBzcigpe3ZhciByLGUsbjtpZihadCsrLHI9JHQsZT1bXSxfdC50ZXN0KHQuY2hhckF0KCR0KSk/KG49dC5jaGFyQXQoJHQpLCR0KyspOihuPW8sMD09PVp0JiZRdChUdCkpLG4hPT1vKWZvcig7biE9PW87KWUucHVzaChuKSxfdC50ZXN0KHQuY2hhckF0KCR0KSk/KG49dC5jaGFyQXQoJHQpLCR0KyspOihuPW8sMD09PVp0JiZRdChUdCkpO2Vsc2UgZT1vO3JldHVybiByPWUhPT1vP3Quc3Vic3RyaW5nKHIsJHQpOmUsWnQtLSxyPT09byYmKGU9bywwPT09WnQmJlF0KE10KSkscn1mdW5jdGlvbiBscigpe3ZhciByLGUsbjtmb3IoWnQrKyxyPSR0LGU9W10sQnQudGVzdCh0LmNoYXJBdCgkdCkpPyhuPXQuY2hhckF0KCR0KSwkdCsrKToobj1vLDA9PT1adCYmUXQocXQpKTtuIT09bzspZS5wdXNoKG4pLEJ0LnRlc3QodC5jaGFyQXQoJHQpKT8obj10LmNoYXJBdCgkdCksJHQrKyk6KG49bywwPT09WnQmJlF0KHF0KSk7cmV0dXJuIHI9ZSE9PW8/dC5zdWJzdHJpbmcociwkdCk6ZSxadC0tLHI9PT1vJiYoZT1vLDA9PT1adCYmUXQoUnQpKSxyfXZhciBwcj1bITFdO2lmKChlPXUoKSkhPT1vJiYkdD09PXQubGVuZ3RoKXJldHVybiBlO3Rocm93IGUhPT1vJiYkdDx0Lmxlbmd0aCYmUXQoe3R5cGU6XCJlbmRcIn0pLFh0KFV0LEd0PHQubGVuZ3RoP3QuY2hhckF0KEd0KTpudWxsLEd0PHQubGVuZ3RoP0h0KEd0LEd0KzEpOkh0KEd0LEd0KSl9fX0sZnVuY3Rpb24odCxyLGUpe3ZhciBuLG8saT1be2NhcmRpbmFsOltcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LHtjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LHtjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJvdGhlclwiXX0se2NhcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfV07dm9pZCAwPT09KG89XCJmdW5jdGlvblwiPT10eXBlb2Yobj17YWY6aVsxXSxhazppWzFdLGFtOmlbMV0sYXI6e2NhcmRpbmFsOltcInplcm9cIixcIm9uZVwiLFwidHdvXCIsXCJmZXdcIixcIm1hbnlcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LGFyczp7Y2FyZGluYWw6W1wiemVyb1wiLFwib25lXCIsXCJ0d29cIixcImZld1wiLFwibWFueVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0sYXM6e2NhcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXX0sYXNhOmlbMV0sYXN0OmlbMV0sYXo6e2NhcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvbmVcIixcImZld1wiLFwibWFueVwiLFwib3RoZXJcIl19LGJlOntjYXJkaW5hbDpbXCJvbmVcIixcImZld1wiLFwibWFueVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJmZXdcIixcIm90aGVyXCJdfSxiZW06aVsxXSxiZXo6aVsxXSxiZzppWzFdLGJoOmlbMV0sYm06aVswXSxibjp7Y2FyZGluYWw6W1wib25lXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJmZXdcIixcIm1hbnlcIixcIm90aGVyXCJdfSxibzppWzBdLGJyOntjYXJkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxicng6aVsxXSxiczp7Y2FyZGluYWw6W1wib25lXCIsXCJmZXdcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LGNhOntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJ0d29cIixcImZld1wiLFwib3RoZXJcIl19LGNlOmlbMV0sY2dnOmlbMV0sY2hyOmlbMV0sY2tiOmlbMV0sY3M6e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxjeTp7Y2FyZGluYWw6W1wiemVyb1wiLFwib25lXCIsXCJ0d29cIixcImZld1wiLFwibWFueVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJ6ZXJvXCIsXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXX0sZGE6aVsxXSxkZTppWzFdLGRzYjp7Y2FyZGluYWw6W1wib25lXCIsXCJ0d29cIixcImZld1wiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0sZHY6aVsxXSxkejppWzBdLGVlOmlbMV0sZWw6aVsxXSxlbjp7Y2FyZGluYWw6W1wib25lXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJmZXdcIixcIm90aGVyXCJdfSxlbzppWzFdLGVzOmlbMV0sZXQ6aVsxXSxldTppWzFdLGZhOmlbMV0sZmY6aVsxXSxmaTppWzFdLGZpbDppWzJdLGZvOmlbMV0sZnI6aVsyXSxmdXI6aVsxXSxmeTppWzFdLGdhOntjYXJkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl19LGdkOntjYXJkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJmZXdcIixcIm90aGVyXCJdfSxnbDppWzFdLGdzdzppWzFdLGd1OntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJ0d29cIixcImZld1wiLFwibWFueVwiLFwib3RoZXJcIl19LGd1dzppWzFdLGd2OntjYXJkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxoYTppWzFdLGhhdzppWzFdLGhlOntjYXJkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwibWFueVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0saGk6e2NhcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvbmVcIixcInR3b1wiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXX0saHI6e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxoc2I6e2NhcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJmZXdcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LGh1OmlbMl0saHk6aVsyXSxpYTppWzFdLGlkOmlbMF0saWc6aVswXSxpaTppWzBdLGluOmlbMF0saW86aVsxXSxpczppWzFdLGl0OntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wibWFueVwiLFwib3RoZXJcIl19LGl1OmlbM10saXc6e2NhcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxqYTppWzBdLGpibzppWzBdLGpnbzppWzFdLGppOmlbMV0sam1jOmlbMV0sanY6aVswXSxqdzppWzBdLGthOntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJtYW55XCIsXCJvdGhlclwiXX0sa2FiOmlbMV0sa2FqOmlbMV0sa2NnOmlbMV0sa2RlOmlbMF0sa2VhOmlbMF0sa2s6e2NhcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJtYW55XCIsXCJvdGhlclwiXX0sa2tqOmlbMV0sa2w6aVsxXSxrbTppWzBdLGtuOmlbMV0sa286aVswXSxrczppWzFdLGtzYjppWzFdLGtzaDp7Y2FyZGluYWw6W1wiemVyb1wiLFwib25lXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxrdTppWzFdLGt3OmlbM10sa3k6aVsxXSxsYWc6e2NhcmRpbmFsOltcInplcm9cIixcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0sbGI6aVsxXSxsZzppWzFdLGxrdDppWzBdLGxuOmlbMV0sbG86e2NhcmRpbmFsOltcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJvdGhlclwiXX0sbHQ6e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxsdjp7Y2FyZGluYWw6W1wiemVyb1wiLFwib25lXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxtYXM6aVsxXSxtZzppWzFdLG1nbzppWzFdLG1rOntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJ0d29cIixcIm1hbnlcIixcIm90aGVyXCJdfSxtbDppWzFdLG1uOmlbMV0sbW86e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl19LG1yOntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJ0d29cIixcImZld1wiLFwib3RoZXJcIl19LG1zOntjYXJkaW5hbDpbXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl19LG10OntjYXJkaW5hbDpbXCJvbmVcIixcImZld1wiLFwibWFueVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0sbXk6aVswXSxuYWg6aVsxXSxuYXE6aVszXSxuYjppWzFdLG5kOmlbMV0sbmU6aVsyXSxubDppWzFdLG5uOmlbMV0sbm5oOmlbMV0sbm86aVsxXSxucW86aVswXSxucjppWzFdLG5zbzppWzFdLG55OmlbMV0sbnluOmlbMV0sb206aVsxXSxvcjp7Y2FyZGluYWw6W1wib25lXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwidHdvXCIsXCJmZXdcIixcIm1hbnlcIixcIm90aGVyXCJdfSxvczppWzFdLHBhOmlbMV0scGFwOmlbMV0scGw6e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxwcmc6e2NhcmRpbmFsOltcInplcm9cIixcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0scHM6aVsxXSxwdDppWzFdLFwicHQtUFRcIjppWzFdLHJtOmlbMV0scm86e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl19LHJvZjppWzFdLHJvb3Q6aVswXSxydTp7Y2FyZGluYWw6W1wib25lXCIsXCJmZXdcIixcIm1hbnlcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LHJ3azppWzFdLHNhaDppWzBdLHNhcTppWzFdLHNjOntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wibWFueVwiLFwib3RoZXJcIl19LHNjbjp7Y2FyZGluYWw6W1wib25lXCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm1hbnlcIixcIm90aGVyXCJdfSxzZDppWzFdLHNkaDppWzFdLHNlOmlbM10sc2VoOmlbMV0sc2VzOmlbMF0sc2c6aVswXSxzaDp7Y2FyZGluYWw6W1wib25lXCIsXCJmZXdcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LHNoaTp7Y2FyZGluYWw6W1wib25lXCIsXCJmZXdcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib3RoZXJcIl19LHNpOmlbMV0sc2s6e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJtYW55XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxzbDp7Y2FyZGluYWw6W1wib25lXCIsXCJ0d29cIixcImZld1wiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJvdGhlclwiXX0sc21hOmlbM10sc21pOmlbM10sc21qOmlbM10sc21uOmlbM10sc21zOmlbM10sc246aVsxXSxzbzppWzFdLHNxOntjYXJkaW5hbDpbXCJvbmVcIixcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJtYW55XCIsXCJvdGhlclwiXX0sc3I6e2NhcmRpbmFsOltcIm9uZVwiLFwiZmV3XCIsXCJvdGhlclwiXSxvcmRpbmFsOltcIm90aGVyXCJdfSxzczppWzFdLHNzeTppWzFdLHN0OmlbMV0sc3Y6aVsyXSxzdzppWzFdLHN5cjppWzFdLHRhOmlbMV0sdGU6aVsxXSx0ZW86aVsxXSx0aDppWzBdLHRpOmlbMV0sdGlnOmlbMV0sdGs6e2NhcmRpbmFsOltcIm9uZVwiLFwib3RoZXJcIl0sb3JkaW5hbDpbXCJmZXdcIixcIm90aGVyXCJdfSx0bDppWzJdLHRuOmlbMV0sdG86aVswXSx0cjppWzFdLHRzOmlbMV0sdHptOmlbMV0sdWc6aVsxXSx1azp7Y2FyZGluYWw6W1wib25lXCIsXCJmZXdcIixcIm1hbnlcIixcIm90aGVyXCJdLG9yZGluYWw6W1wiZmV3XCIsXCJvdGhlclwiXX0sdXI6aVsxXSx1ejppWzFdLHZlOmlbMV0sdmk6e2NhcmRpbmFsOltcIm90aGVyXCJdLG9yZGluYWw6W1wib25lXCIsXCJvdGhlclwiXX0sdm86aVsxXSx2dW46aVsxXSx3YTppWzFdLHdhZTppWzFdLHdvOmlbMF0seGg6aVsxXSx4b2c6aVsxXSx5aTppWzFdLHlvOmlbMF0seXVlOmlbMF0semg6aVswXSx6dTppWzFdfSk/bi5jYWxsKHIsZSxyLHQpOm4pfHwodC5leHBvcnRzPW8pfSxmdW5jdGlvbih0LHIpe2Z1bmN0aW9uIGUodCxyLGUpe3ZhciBuPXtkYXk6XCJudW1lcmljXCIsbW9udGg6XCJzaG9ydFwiLHllYXI6XCJudW1lcmljXCJ9O3N3aXRjaChlKXtjYXNlXCJmdWxsXCI6bi53ZWVrZGF5PVwibG9uZ1wiO2Nhc2VcImxvbmdcIjpuLm1vbnRoPVwibG9uZ1wiO2JyZWFrO2Nhc2VcInNob3J0XCI6bi5tb250aD1cIm51bWVyaWNcIn1yZXR1cm4gbmV3IERhdGUodCkudG9Mb2NhbGVEYXRlU3RyaW5nKHIsbil9dC5leHBvcnRzPWZ1bmN0aW9uKCl7cmV0dXJuIGV9fSxmdW5jdGlvbih0LHIpe2Z1bmN0aW9uIGUodCl7aWYoIWlzRmluaXRlKHQpKXJldHVybiBTdHJpbmcodCk7dmFyIHI9XCJcIjt0PDA/KHI9XCItXCIsdD1NYXRoLmFicyh0KSk6dD1OdW1iZXIodCk7dmFyIGU9dCU2MCxuPVtNYXRoLnJvdW5kKGUpPT09ZT9lOmUudG9GaXhlZCgzKV07cmV0dXJuIHQ8NjA/bi51bnNoaWZ0KDApOih0PU1hdGgucm91bmQoKHQtblswXSkvNjApLG4udW5zaGlmdCh0JTYwKSx0Pj02MCYmKHQ9TWF0aC5yb3VuZCgodC1uWzBdKS82MCksbi51bnNoaWZ0KHQpKSkscituLnNoaWZ0KCkrXCI6XCIrbi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQ8MTA/XCIwXCIrU3RyaW5nKHQpOlN0cmluZyh0KX0pLmpvaW4oXCI6XCIpfXQuZXhwb3J0cz1mdW5jdGlvbigpe3JldHVybiBlfX0sZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIHI9ZnVuY3Rpb24odCxyLGUpe3ZhciBuPWUmJmUuc3BsaXQoXCI6XCIpfHxbXSxvPXtpbnRlZ2VyOnttYXhpbXVtRnJhY3Rpb25EaWdpdHM6MH0scGVyY2VudDp7c3R5bGU6XCJwZXJjZW50XCJ9LGN1cnJlbmN5OntzdHlsZTpcImN1cnJlbmN5XCIsY3VycmVuY3k6blsxXSYmblsxXS50cmltKCl8fENVUlJFTkNZLG1pbmltdW1GcmFjdGlvbkRpZ2l0czoyLG1heGltdW1GcmFjdGlvbkRpZ2l0czoyfX07cmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChyLG9bblswXV18fHt9KS5mb3JtYXQodCl9LnRvU3RyaW5nKCkucmVwbGFjZShcIkNVUlJFTkNZXCIsSlNPTi5zdHJpbmdpZnkodC5jdXJyZW5jeXx8XCJVU0RcIikpLm1hdGNoKC9cXCgoW14pXSopXFwpW157XSp7KFtcXHNcXFNdKil9Lyk7cmV0dXJuIG5ldyBGdW5jdGlvbihyWzFdLHJbMl0pfX0sZnVuY3Rpb24odCxyKXtmdW5jdGlvbiBlKHQscixlKXt2YXIgbj17c2Vjb25kOlwibnVtZXJpY1wiLG1pbnV0ZTpcIm51bWVyaWNcIixob3VyOlwibnVtZXJpY1wifTtzd2l0Y2goZSl7Y2FzZVwiZnVsbFwiOmNhc2VcImxvbmdcIjpuLnRpbWVab25lTmFtZT1cInNob3J0XCI7YnJlYWs7Y2FzZVwic2hvcnRcIjpkZWxldGUgbi5zZWNvbmR9cmV0dXJuIG5ldyBEYXRlKHQpLnRvTG9jYWxlVGltZVN0cmluZyhyLG4pfXQuZXhwb3J0cz1mdW5jdGlvbigpe3JldHVybiBlfX0sZnVuY3Rpb24odCxyLGUpe1widXNlIHN0cmljdFwiO2UucihyKTt2YXIgbj1lKDEpLG89ZS5uKG4pLGk9ZSgyKSx1PXticmVhazohMCxjb250aW51ZTohMCxkZWxldGU6ITAsZWxzZTohMCxmb3I6ITAsZnVuY3Rpb246ITAsaWY6ITAsaW46ITAsbmV3OiEwLHJldHVybjohMCx0aGlzOiEwLHR5cGVvZjohMCx2YXI6ITAsdm9pZDohMCx3aGlsZTohMCx3aXRoOiEwLGNhc2U6ITAsY2F0Y2g6ITAsZGVmYXVsdDohMCxkbzohMCxmaW5hbGx5OiEwLGluc3RhbmNlb2Y6ITAsc3dpdGNoOiEwLHRocm93OiEwLHRyeTohMH0sYT17ZGVidWdnZXI6ITAsY2xhc3M6ITAsZW51bTohMCxleHRlbmRzOiEwLHN1cGVyOiEwLGNvbnN0OiEwLGV4cG9ydDohMCxpbXBvcnQ6ITAsbnVsbDohMCx0cnVlOiEwLGZhbHNlOiEwLGltcGxlbWVudHM6ITAsbGV0OiEwLHByaXZhdGU6ITAscHVibGljOiEwLHlpZWxkOiEwLGludGVyZmFjZTohMCxwYWNrYWdlOiEwLHByb3RlY3RlZDohMCxzdGF0aWM6ITB9O2Z1bmN0aW9uIGModCxyKXtpZigvXltBLVpfJF1bMC05QS1aXyRdKiQvaS50ZXN0KHQpJiYhdVt0XSlyZXR1cm4gcj9cIlwiLmNvbmNhdChyLFwiLlwiKS5jb25jYXQodCk6dDt2YXIgZT1KU09OLnN0cmluZ2lmeSh0KTtyZXR1cm4gcj9yK1wiW1wiLmNvbmNhdChlLFwiXVwiKTplfWZ1bmN0aW9uIGgodCl7dmFyIHI9dC50cmltKCkucmVwbGFjZSgvXFxXKy9nLFwiX1wiKTtyZXR1cm4gdVtyXXx8YVtyXXx8L15cXGQvLnRlc3Qocik/XCJfXCIrcjpyfXZhciBmPW5ldyBSZWdFeHAoXCJeXCIrW1wiYXJcIixcImNrYlwiLFwiZmFcIixcImhlXCIsXCJrcygkfFteYmZoXSlcIixcImxyY1wiLFwibXpuXCIsXCJwYS1BcmFiXCIsXCJwc1wiLFwidWdcIixcInVyXCIsXCJ1ei1BcmFiXCIsXCJ5aVwiXS5qb2luKFwifF5cIikpO2Z1bmN0aW9uIHModCl7cmV0dXJuKHM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIGwodCxyKXtmb3IodmFyIGU9MDtlPHIubGVuZ3RoO2UrKyl7dmFyIG49cltlXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXZhciBwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChyKXshZnVuY3Rpb24odCxyKXtpZighKHQgaW5zdGFuY2VvZiByKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHRoaXMubWY9cix0aGlzLmxjPW51bGwsdGhpcy5sb2NhbGVzPXt9LHRoaXMucnVudGltZT17fSx0aGlzLmZvcm1hdHRlcnM9e319dmFyIHIsZSxuO3JldHVybiByPXQsKGU9W3trZXk6XCJjb21waWxlXCIsdmFsdWU6ZnVuY3Rpb24odCxyLGUpe3ZhciBuPXRoaXM7aWYoXCJvYmplY3RcIiE9cyh0KSl7dGhpcy5sYz1yO3ZhciBvPWVbcl18fHtjYXJkaW5hbDpbXSxvcmRpbmFsOltdfTtvLnN0cmljdD0hIXRoaXMubWYub3B0aW9ucy5zdHJpY3ROdW1iZXJTaWduO3ZhciB1PU9iamVjdChpLnBhcnNlKSh0LG8pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbi50b2tlbih0KX0pO3JldHVyblwiZnVuY3Rpb24oZCkgeyByZXR1cm4gXCIuY29uY2F0KHUuam9pbihcIiArIFwiKXx8J1wiXCInLFwiOyB9XCIpfXZhciBhPXt9O2Zvcih2YXIgYyBpbiB0KXt2YXIgaD1lLmhhc093blByb3BlcnR5KGMpP2M6cjthW2NdPXRoaXMuY29tcGlsZSh0W2NdLGgsZSl9cmV0dXJuIGF9fSx7a2V5OlwiY2FzZXNcIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBlPXRoaXMsbj1cInNlbGVjdFwiPT09dC50eXBlfHwhdGhpcy5tZi5oYXNDdXN0b21QbHVyYWxGdW5jcyxvPXQuY2FzZXMubWFwKGZ1bmN0aW9uKHQpe3ZhciBvPXQua2V5LGk9dC50b2tlbnM7XCJvdGhlclwiPT09byYmKG49ITEpO3ZhciB1PWkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRva2VuKHQscil9KTtyZXR1cm4gYyhvKStcIjogXCIrKHUuam9pbihcIiArIFwiKXx8J1wiXCInKX0pO2lmKG4pdGhyb3cgbmV3IEVycm9yKFwiTm8gJ290aGVyJyBmb3JtIGZvdW5kIGluIFwiK0pTT04uc3RyaW5naWZ5KHQpKTtyZXR1cm5cInsgXCIuY29uY2F0KG8uam9pbihcIiwgXCIpLFwiIH1cIil9fSx7a2V5OlwidG9rZW5cIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBlLG49dGhpcztpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4gSlNPTi5zdHJpbmdpZnkodCk7dmFyIG8saSx1LGEscz1bYyh0LmFyZyxcImRcIildO3N3aXRjaCh0LnR5cGUpe2Nhc2VcImFyZ3VtZW50XCI6cmV0dXJuIHRoaXMubWYub3B0aW9ucy5iaURpU3VwcG9ydD8obz1zWzBdLGk9dGhpcy5sYyx1PWYudGVzdChpKSxhPUpTT04uc3RyaW5naWZ5KHU/XCLigI9cIjpcIuKAjlwiKSxcIlwiLmNvbmNhdChhLFwiICsgXCIpLmNvbmNhdChvLFwiICsgXCIpLmNvbmNhdChhKSk6c1swXTtjYXNlXCJzZWxlY3RcIjplPVwic2VsZWN0XCIsciYmdGhpcy5tZi5vcHRpb25zLnN0cmljdE51bWJlclNpZ24mJihyPW51bGwpLHMucHVzaCh0aGlzLmNhc2VzKHQscikpLHRoaXMucnVudGltZS5zZWxlY3Q9ITA7YnJlYWs7Y2FzZVwic2VsZWN0b3JkaW5hbFwiOmU9XCJwbHVyYWxcIixzLnB1c2goMCxoKHRoaXMubGMpLHRoaXMuY2FzZXModCx0KSwxKSx0aGlzLmxvY2FsZXNbdGhpcy5sY109ITAsdGhpcy5ydW50aW1lLnBsdXJhbD0hMDticmVhaztjYXNlXCJwbHVyYWxcIjplPVwicGx1cmFsXCIscy5wdXNoKHQub2Zmc2V0fHwwLGgodGhpcy5sYyksdGhpcy5jYXNlcyh0LHQpKSx0aGlzLmxvY2FsZXNbdGhpcy5sY109ITAsdGhpcy5ydW50aW1lLnBsdXJhbD0hMDticmVhaztjYXNlXCJmdW5jdGlvblwiOmlmKCEodC5rZXkgaW4gdGhpcy5tZi5mbXQpJiZ0LmtleSBpbiB0aGlzLm1mLmNvbnN0cnVjdG9yLmZvcm1hdHRlcnMpe3ZhciBsPXRoaXMubWYuY29uc3RydWN0b3IuZm9ybWF0dGVyc1t0LmtleV07dGhpcy5tZi5mbXRbdC5rZXldPWwodGhpcy5tZil9aWYoIXRoaXMubWYuZm10W3Qua2V5XSl0aHJvdyBuZXcgRXJyb3IoXCJGb3JtYXR0aW5nIGZ1bmN0aW9uIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0LmtleSksXCIgbm90IGZvdW5kIVwiKSk7aWYocy5wdXNoKEpTT04uc3RyaW5naWZ5KHRoaXMubGMpKSx0LnBhcmFtKXtyJiZ0aGlzLm1mLm9wdGlvbnMuc3RyaWN0TnVtYmVyU2lnbiYmKHI9bnVsbCk7dmFyIHA9dC5wYXJhbS50b2tlbnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuLnRva2VuKHQscil9KTtzLnB1c2goXCIoXCIrKHAuam9pbihcIiArIFwiKXx8J1wiXCInKStcIikudHJpbSgpXCIpfWU9Yyh0LmtleSxcImZtdFwiKSx0aGlzLmZvcm1hdHRlcnNbdC5rZXldPSEwO2JyZWFrO2Nhc2VcIm9jdG90aG9ycGVcIjppZighcilyZXR1cm4nXCIjXCInO2U9XCJudW1iZXJcIixzPVtjKHIuYXJnLFwiZFwiKSxKU09OLnN0cmluZ2lmeShyLmFyZyldLHIub2Zmc2V0JiZzLnB1c2goci5vZmZzZXQpLHRoaXMucnVudGltZS5udW1iZXI9ITB9aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIGVycm9yIGZvciB0b2tlbiBcIitKU09OLnN0cmluZ2lmeSh0KSk7cmV0dXJuXCJcIi5jb25jYXQoZSxcIihcIikuY29uY2F0KHMuam9pbihcIiwgXCIpLFwiKVwiKX19XSkmJmwoci5wcm90b3R5cGUsZSksbiYmbChyLG4pLHR9KCksbT1lKDMpLGQ9ZS5uKG0pLHk9ZSgwKSxnPWUubih5KTtmdW5jdGlvbiB2KHQscixlKXt2YXIgbj1mdW5jdGlvbigpe3JldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07aWYobi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiByLnRvU3RyaW5nKCl9LGUpe3ZhciBvPWQuYVt0XXx8e307bi5jYXJkaW5hbD1vLmNhcmRpbmFsLG4ub3JkaW5hbD1vLm9yZGluYWx9ZWxzZSBuLmNhcmRpbmFsPVtdLG4ub3JkaW5hbD1bXTtyZXR1cm4gbn1mdW5jdGlvbiB3KHQscil7Zm9yKHZhciBlPXIucGx1cmFsS2V5Q2hlY2tzLG49U3RyaW5nKHQpO247bj1uLnJlcGxhY2UoL1stX10/W14tX10qJC8sXCJcIikpe3ZhciBvPWcuYVtuXTtpZihvKXJldHVybiB2KG4sbyxlKX10aHJvdyBuZXcgRXJyb3IoXCJMb2NhbGlzYXRpb24gZnVuY3Rpb24gbm90IGZvdW5kIGZvciBsb2NhbGUgXCIrSlNPTi5zdHJpbmdpZnkodCkpfWZ1bmN0aW9uIGIodCl7cmV0dXJuKGI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0pKHQpfWZ1bmN0aW9uIFModCxyKXtmb3IodmFyIGU9MDtlPHIubGVuZ3RoO2UrKyl7dmFyIG49cltlXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbil9fXZhciBrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChyKXshZnVuY3Rpb24odCxyKXtpZighKHQgaW5zdGFuY2VvZiByKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHRoaXMucGx1cmFsPWZ1bmN0aW9uKHQscixlLG4sbyl7aWYoe30uaGFzT3duUHJvcGVydHkuY2FsbChuLHQpKXJldHVybiBuW3RdO3ImJih0LT1yKTt2YXIgaT1lKHQsbyk7cmV0dXJuIGkgaW4gbj9uW2ldOm4ub3RoZXJ9LHRoaXMuc2VsZWN0PWZ1bmN0aW9uKHQscil7cmV0dXJue30uaGFzT3duUHJvcGVydHkuY2FsbChyLHQpP3JbdF06ci5vdGhlcn0sdGhpcy5tZj1yLHRoaXMuc2V0U3RyaWN0TnVtYmVyKHIub3B0aW9ucy5zdHJpY3ROdW1iZXJTaWduKX12YXIgcixlLG47cmV0dXJuIHI9dCwoZT1be2tleTpcInNldFN0cmljdE51bWJlclwiLHZhbHVlOmZ1bmN0aW9uKHIpe3RoaXMubnVtYmVyPXI/dC5zdHJpY3ROdW1iZXI6dC5kZWZhdWx0TnVtYmVyfX0se2tleTpcInRvU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9e30sbj1PYmplY3Qua2V5cyhyLmxvY2FsZXMpLG89MDtvPG4ubGVuZ3RoOysrbyl7dmFyIGk9bltvXTtlW2goaSldPXRbaV19Zm9yKHZhciB1PU9iamVjdC5rZXlzKHIucnVudGltZSksYT0wO2E8dS5sZW5ndGg7KythKXt2YXIgZj11W2FdO2VbZl09dGhpc1tmXX12YXIgcz1PYmplY3Qua2V5cyhyLmZvcm1hdHRlcnMpO2lmKHMubGVuZ3RoPjApe2UuZm10PXt9O2Zvcih2YXIgbD0wO2w8cy5sZW5ndGg7KytsKXt2YXIgcD1zW2xdO2UuZm10W3BdPXRoaXMubWYuZm10W3BdfX1yZXR1cm4gZnVuY3Rpb24gdChyLGUpe2lmKFwib2JqZWN0XCIhPWIocikpe3ZhciBuPXIudG9TdHJpbmcoKS5yZXBsYWNlKC9eKGZ1bmN0aW9uIClcXHcqLyxcIiQxXCIpLG89LyhbIFxcdF0qKVxcUy4qJC8uZXhlYyhuKTtyZXR1cm4gbz9uLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIitvWzFdLFwibWdcIiksXCJcIik6bn12YXIgaT1bXTtmb3IodmFyIHUgaW4gcil7dmFyIGE9dChyW3VdLGUrMSk7aS5wdXNoKDA9PT1lP1widmFyIFwiLmNvbmNhdCh1LFwiID0gXCIpLmNvbmNhdChhLFwiO1xcblwiKTpcIlwiLmNvbmNhdChjKHUpLFwiOiBcIikuY29uY2F0KGEpKX1pZigwPT09ZSlyZXR1cm4gaS5qb2luKFwiXCIpO2lmKDA9PT1pLmxlbmd0aClyZXR1cm5cInt9XCI7Zm9yKHZhciBoPVwiICBcIjstLWU7KWgrPVwiICBcIjt2YXIgZj1pLmpvaW4oXCIsXFxuXCIpLnJlcGxhY2UoL14vZ20saCk7cmV0dXJuXCJ7XFxuXCIuY29uY2F0KGYsXCJcXG59XCIpfShlLDApfX1dKSYmUyhyLnByb3RvdHlwZSxlKSxuJiZTKHIsbiksdH0oKTtmdW5jdGlvbiB4KHQpe3JldHVybih4PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBBKHQscil7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspe3ZhciBuPXJbZV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX1mdW5jdGlvbiBqKHQscixlKXtyZXR1cm4gciYmQSh0LnByb3RvdHlwZSxyKSxlJiZBKHQsZSksdH1rLmRlZmF1bHROdW1iZXI9ZnVuY3Rpb24odCxyLGUpe2lmKCFlKXJldHVybiB0O2lmKGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGFwcGx5IG9mZnNldDpcIitlK1wiIHRvIGFyZ3VtZW50IGBcIityK1wiYCB3aXRoIG5vbi1udW1lcmljYWwgdmFsdWUgXCIrSlNPTi5zdHJpbmdpZnkodCkrXCIuXCIpO3JldHVybiB0LWV9LGsuc3RyaWN0TnVtYmVyPWZ1bmN0aW9uKHQscixlKXtpZihpc05hTih0KSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBgXCIrcitcImAgaGFzIG5vbi1udW1lcmljYWwgdmFsdWUgXCIrSlNPTi5zdHJpbmdpZnkodCkrXCIuXCIpO3JldHVybiB0LShlfHwwKX0sZS5kKHIsXCJkZWZhdWx0XCIsZnVuY3Rpb24oKXtyZXR1cm4gTn0pO3ZhciBOPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChyLGUpe3ZhciBuPXRoaXM7aWYoZnVuY3Rpb24odCxyKXtpZighKHQgaW5zdGFuY2VvZiByKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLHQpLHRoaXMub3B0aW9ucz1PYmplY3QuYXNzaWduKHtiaURpU3VwcG9ydDohMSxjdXN0b21Gb3JtYXR0ZXJzOm51bGwscGx1cmFsS2V5Q2hlY2tzOiEwLHN0cmljdE51bWJlclNpZ246ITF9LGUpLHRoaXMucGx1cmFsRnVuY3M9e30sXCJzdHJpbmdcIj09dHlwZW9mIHIpdGhpcy5wbHVyYWxGdW5jc1tyXT13KHIsdGhpcy5vcHRpb25zKSx0aGlzLmRlZmF1bHRMb2NhbGU9cjtlbHNlIGlmKEFycmF5LmlzQXJyYXkocikpci5mb3JFYWNoKGZ1bmN0aW9uKHQpe24ucGx1cmFsRnVuY3NbdF09dyh0LG4ub3B0aW9ucyl9KSx0aGlzLmRlZmF1bHRMb2NhbGU9clswXTtlbHNle2lmKHIpZm9yKHZhciBvPU9iamVjdC5rZXlzKHIpLGk9MDtpPG8ubGVuZ3RoOysraSl7dmFyIHU9b1tpXTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByW3VdKXt2YXIgYT1cIkV4cGVjdGVkIGZ1bmN0aW9uIHZhbHVlIGZvciBsb2NhbGUgXCIrU3RyaW5nKHUpO3Rocm93IG5ldyBFcnJvcihhKX10aGlzLnBsdXJhbEZ1bmNzW3VdPXJbdV0sdGhpcy5kZWZhdWx0TG9jYWxlfHwodGhpcy5kZWZhdWx0TG9jYWxlPXUpfXRoaXMuZGVmYXVsdExvY2FsZT90aGlzLmhhc0N1c3RvbVBsdXJhbEZ1bmNzPSEwOih0aGlzLmRlZmF1bHRMb2NhbGU9dC5kZWZhdWx0TG9jYWxlLHRoaXMuaGFzQ3VzdG9tUGx1cmFsRnVuY3M9ITEpfXRoaXMuZm10PU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHRpb25zLmN1c3RvbUZvcm1hdHRlcnMpLHRoaXMucnVudGltZT1uZXcgayh0aGlzKX1yZXR1cm4gaih0LG51bGwsW3trZXk6XCJlc2NhcGVcIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBlPXI/L1sje31dL2c6L1t7fV0vZztyZXR1cm4gU3RyaW5nKHQpLnJlcGxhY2UoZSxcIickJidcIil9fV0pLGoodCxbe2tleTpcImFkZEZvcm1hdHRlcnNcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIHI9T2JqZWN0LmtleXModCksZT0wO2U8ci5sZW5ndGg7KytlKXt2YXIgbj1yW2VdO3RoaXMuZm10W25dPXRbbl19cmV0dXJuIHRoaXN9fSx7a2V5OlwiZGlzYWJsZVBsdXJhbEtleUNoZWNrc1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMub3B0aW9ucy5wbHVyYWxLZXlDaGVja3M9ITEsdGhpcy5wbHVyYWxGdW5jcyl7dmFyIHI9dGhpcy5wbHVyYWxGdW5jc1t0XTtyJiYoci5jYXJkaW5hbD1bXSxyLm9yZGluYWw9W10pfXJldHVybiB0aGlzfX0se2tleTpcInNldEJpRGlTdXBwb3J0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5iaURpU3VwcG9ydD0hIXR8fHZvaWQgMD09PXQsdGhpc319LHtrZXk6XCJzZXRTdHJpY3ROdW1iZXJTaWduXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5zdHJpY3ROdW1iZXJTaWduPSEhdHx8dm9pZCAwPT09dCx0aGlzLnJ1bnRpbWUuc2V0U3RyaWN0TnVtYmVyKHRoaXMub3B0aW9ucy5zdHJpY3ROdW1iZXJTaWduKSx0aGlzfX0se2tleTpcImNvbXBpbGVcIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBlPXt9O2lmKDA9PT1PYmplY3Qua2V5cyh0aGlzLnBsdXJhbEZ1bmNzKS5sZW5ndGgpaWYocil7dmFyIG49dyhyLHRoaXMub3B0aW9ucyk7aWYoIW4pe3ZhciBvPUpTT04uc3RyaW5naWZ5KHIpO3Rocm93IG5ldyBFcnJvcihcIkxvY2FsZSBcIi5jb25jYXQobyxcIiBub3QgZm91bmQhXCIpKX1lW3JdPW59ZWxzZSByPXRoaXMuZGVmYXVsdExvY2FsZSxlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10LnBsdXJhbEtleUNoZWNrcyxlPXt9LG49T2JqZWN0LmtleXMoZy5hKSxvPTA7bzxuLmxlbmd0aDsrK28pe3ZhciBpPW5bb107ZVtpXT12KGksZy5hW2ldLHIpfXJldHVybiBlfSh0aGlzLm9wdGlvbnMpO2Vsc2UgaWYocil7dmFyIGk9dGhpcy5wbHVyYWxGdW5jc1tyXTtpZighaSl7dmFyIHU9SlNPTi5zdHJpbmdpZnkociksYT1KU09OLnN0cmluZ2lmeSh0aGlzLnBsdXJhbEZ1bmNzKTt0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbGUgXCIuY29uY2F0KHUsXCIgbm90IGZvdW5kIGluIFwiKS5jb25jYXQoYSxcIiFcIikpfWVbcl09aX1lbHNlIHI9dGhpcy5kZWZhdWx0TG9jYWxlLGU9dGhpcy5wbHVyYWxGdW5jczt2YXIgZj1uZXcgcCh0aGlzKSxzPWYuY29tcGlsZSh0LHIsZSk7aWYoXCJvYmplY3RcIiE9eCh0KSl7dmFyIGw9bmV3IEZ1bmN0aW9uKFwibnVtYmVyLCBwbHVyYWwsIHNlbGVjdCwgZm10XCIsaChyKSxcInJldHVybiBcIitzKSxtPXRoaXMucnVudGltZTtyZXR1cm4gbChtLm51bWJlcixtLnBsdXJhbCxtLnNlbGVjdCx0aGlzLmZtdCxlW3JdKX12YXIgZD10aGlzLnJ1bnRpbWUudG9TdHJpbmcoZSxmKStcIlxcblwiLHk9ZnVuY3Rpb24gdChyLGUpe2lmKGV8fChlPTApLFwib2JqZWN0XCIhPXgocikpcmV0dXJuIHI7Zm9yKHZhciBuPVwiXCIsbz0wO288ZTsrK28pbis9XCIgIFwiO3ZhciBpPVtdO2Zvcih2YXIgdSBpbiByKXt2YXIgYT10KHJbdV0sZSsxKTtpLnB1c2goXCJcXG5cIi5jb25jYXQobixcIiAgXCIpLmNvbmNhdChjKHUpLFwiOiBcIikuY29uY2F0KGEpKX1yZXR1cm5cIntcIi5jb25jYXQoaS5qb2luKFwiLFwiKSxcIlxcblwiKS5jb25jYXQobixcIn1cIil9KHMpLGI9bmV3IEZ1bmN0aW9uKGQrXCJyZXR1cm4gXCIreSkoKTtpZihiLmhhc093blByb3BlcnR5KFwidG9TdHJpbmdcIikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRvcC1sZXZlbCBtZXNzYWdlIGtleSBgdG9TdHJpbmdgIGlzIHJlc2VydmVkXCIpO3JldHVybiBiLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImV4cG9ydCBkZWZhdWx0XCIhPT10P3QuaW5kZXhPZihcIi5cIik+LTE/ZCt0K1wiID0gXCIreTpkK1tcIihmdW5jdGlvbiAocm9vdCwgRykge1wiLCcgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgeyBkZWZpbmUoRyk7IH0nLCcgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7IG1vZHVsZS5leHBvcnRzID0gRzsgfScsXCIgIGVsc2UgeyBcIitjKHQsXCJyb290XCIpK1wiID0gRzsgfVwiLFwifSkodGhpcywgXCIreStcIik7XCJdLmpvaW4oXCJcXG5cIik6ZCtcImV4cG9ydCBkZWZhdWx0IFwiK3l9LGJ9fV0pLHR9KCk7Ti5kZWZhdWx0TG9jYWxlPVwiZW5cIixOLmZvcm1hdHRlcnM9by5hfV0pLmRlZmF1bHR9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2Vmb3JtYXQuanMubWFwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qIVxuICogUVVuaXQgMi4xMS4zXG4gKiBodHRwczovL3F1bml0anMuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0xMC0wNVQwMTozNFpcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwkMSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cblx0dmFyIGdsb2JhbF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koZ2xvYmFsJDEpO1xuXG5cdHZhciB3aW5kb3ckMSA9IGdsb2JhbF9fZGVmYXVsdFsnZGVmYXVsdCddLndpbmRvdztcblx0dmFyIHNlbGYkMSA9IGdsb2JhbF9fZGVmYXVsdFsnZGVmYXVsdCddLnNlbGY7XG5cdHZhciBjb25zb2xlID0gZ2xvYmFsX19kZWZhdWx0WydkZWZhdWx0J10uY29uc29sZTtcblx0dmFyIHNldFRpbWVvdXQkMSA9IGdsb2JhbF9fZGVmYXVsdFsnZGVmYXVsdCddLnNldFRpbWVvdXQ7XG5cdHZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWxfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jbGVhclRpbWVvdXQ7XG5cdHZhciBkb2N1bWVudCQxID0gd2luZG93JDEgJiYgd2luZG93JDEuZG9jdW1lbnQ7XG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3ckMSAmJiB3aW5kb3ckMS5uYXZpZ2F0b3I7XG5cdHZhciBsb2NhbFNlc3Npb25TdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciB4ID0gXCJxdW5pdC10ZXN0LXN0cmluZ1wiO1xuXG5cdCAgdHJ5IHtcblx0ICAgIGdsb2JhbF9fZGVmYXVsdFsnZGVmYXVsdCddLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG5cdCAgICBnbG9iYWxfX2RlZmF1bHRbJ2RlZmF1bHQnXS5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuXHQgICAgcmV0dXJuIGdsb2JhbF9fZGVmYXVsdFsnZGVmYXVsdCddLnNlc3Npb25TdG9yYWdlO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9KCk7IC8vIFN1cHBvcnQgSUUgOS0xMDogRmFsbGJhY2sgZm9yIGZ1enp5c29ydC5qcyB1c2VkIGJ5IC9yZXBvcnRlci9odG1sLmpzXG5cblx0aWYgKCFnbG9iYWxfX2RlZmF1bHRbJ2RlZmF1bHQnXS5NYXApIHtcblx0ICBnbG9iYWxfX2RlZmF1bHRbJ2RlZmF1bHQnXS5NYXAgPSBmdW5jdGlvbiBTdHJpbmdNYXAoKSB7XG5cdCAgICB2YXIgc3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdCAgICB0aGlzLmdldCA9IGZ1bmN0aW9uIChzdHJLZXkpIHtcblx0ICAgICAgcmV0dXJuIHN0b3JlW3N0cktleV07XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLnNldCA9IGZ1bmN0aW9uIChzdHJLZXksIHZhbCkge1xuXHQgICAgICBzdG9yZVtzdHJLZXldID0gdmFsO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgIH07XG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG5cdCAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG5cdCAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG5cdCAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gdHlwZW9mIG9iajtcblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICByZXR1cm4gX3R5cGVvZihvYmopO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuXHQgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuXHQgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuXHQgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuXHQgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG5cdCAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cdCAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuXHQgIHJldHVybiBDb25zdHJ1Y3Rvcjtcblx0fVxuXG5cdGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcblx0ICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuXHQgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG5cdCAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG5cdCAgaWYgKCFvKSByZXR1cm47XG5cdCAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcblx0ICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG5cdCAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcblx0ICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcblx0ICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG5cdH1cblxuXHRmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuXHQgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG5cdCAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG5cdCAgcmV0dXJuIGFycjI7XG5cdH1cblxuXHRmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG5cdCAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG5cdH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuXHQgIHZhciBpdDtcblxuXHQgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgIGlmIChpdCkgbyA9IGl0O1xuXHQgICAgICB2YXIgaSA9IDA7XG5cblx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHM6IEYsXG5cdCAgICAgICAgbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG5cdCAgICAgICAgICAgIGRvbmU6IHRydWVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBkb25lOiBmYWxzZSxcblx0ICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICB0aHJvdyBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZjogRlxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG5cdCAgfVxuXG5cdCAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuXHQgICAgICBkaWRFcnIgPSBmYWxzZSxcblx0ICAgICAgZXJyO1xuXHQgIHJldHVybiB7XG5cdCAgICBzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG5cdCAgICB9LFxuXHQgICAgbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcblx0ICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcblx0ICAgICAgcmV0dXJuIHN0ZXA7XG5cdCAgICB9LFxuXHQgICAgZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgZGlkRXJyID0gdHJ1ZTtcblx0ICAgICAgZXJyID0gZTtcblx0ICAgIH0sXG5cdCAgICBmOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTtcblx0ICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cblx0Ly8gVGhpcyBhbGxvd3Mgc3VwcG9ydCBmb3IgSUUgOSwgd2hpY2ggZG9lc24ndCBoYXZlIGEgY29uc29sZVxuXHQvLyBvYmplY3QgaWYgdGhlIGRldmVsb3BlciB0b29scyBhcmUgbm90IG9wZW4uXG5cblx0dmFyIExvZ2dlciA9IHtcblx0ICB3YXJuOiBjb25zb2xlID8gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSkgOiBmdW5jdGlvbiAoKSB7fVxuXHR9O1xuXG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0fTtcblx0dmFyIGhhc1BlcmZvcm1hbmNlQXBpID0gZGV0ZWN0UGVyZm9ybWFuY2VBcGkoKTtcblx0dmFyIHBlcmZvcm1hbmNlID0gaGFzUGVyZm9ybWFuY2VBcGkgPyB3aW5kb3ckMS5wZXJmb3JtYW5jZSA6IHVuZGVmaW5lZDtcblx0dmFyIHBlcmZvcm1hbmNlTm93ID0gaGFzUGVyZm9ybWFuY2VBcGkgPyBwZXJmb3JtYW5jZS5ub3cuYmluZChwZXJmb3JtYW5jZSkgOiBub3c7XG5cblx0ZnVuY3Rpb24gZGV0ZWN0UGVyZm9ybWFuY2VBcGkoKSB7XG5cdCAgcmV0dXJuIHdpbmRvdyQxICYmIHR5cGVvZiB3aW5kb3ckMS5wZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93JDEucGVyZm9ybWFuY2UubWFyayA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB3aW5kb3ckMS5wZXJmb3JtYW5jZS5tZWFzdXJlID09PSBcImZ1bmN0aW9uXCI7XG5cdH1cblxuXHRmdW5jdGlvbiBtZWFzdXJlKGNvbW1lbnQsIHN0YXJ0TWFyaywgZW5kTWFyaykge1xuXHQgIC8vIGBwZXJmb3JtYW5jZS5tZWFzdXJlYCBtYXkgZmFpbCBpZiB0aGUgbWFyayBjb3VsZCBub3QgYmUgZm91bmQuXG5cdCAgLy8gcmVhc29ucyBhIHNwZWNpZmljIG1hcmsgY291bGQgbm90IGJlIGZvdW5kIGluY2x1ZGU6IG91dHNpZGUgY29kZSBpbnZva2luZyBgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcygpYFxuXHQgIHRyeSB7XG5cdCAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGNvbW1lbnQsIHN0YXJ0TWFyaywgZW5kTWFyayk7XG5cdCAgfSBjYXRjaCAoZXgpIHtcblx0ICAgIExvZ2dlci53YXJuKFwicGVyZm9ybWFuY2UubWVhc3VyZSBjb3VsZCBub3QgYmUgZXhlY3V0ZWQgYmVjYXVzZSBvZiBcIiwgZXgubWVzc2FnZSk7XG5cdCAgfVxuXHR9XG5cdHZhciBkZWZpbmVkID0ge1xuXHQgIGRvY3VtZW50OiB3aW5kb3ckMSAmJiB3aW5kb3ckMS5kb2N1bWVudCAhPT0gdW5kZWZpbmVkLFxuXHQgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQkMSAhPT0gdW5kZWZpbmVkXG5cdH07IC8vIFJldHVybnMgYSBuZXcgQXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgaW4gYSBidXQgbm90IGluIGJcblxuXHRmdW5jdGlvbiBkaWZmKGEsIGIpIHtcblx0ICB2YXIgaSxcblx0ICAgICAgaixcblx0ICAgICAgcmVzdWx0ID0gYS5zbGljZSgpO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHQgICAgZm9yIChqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gYltqXSkge1xuXHQgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgaS0tO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGVsZW1lbnQgZXhpc3RzIGluIGEgZ2l2ZW4gYXJyYXkgb3Igbm90LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluQXJyYXlcblx0ICogQHBhcmFtIHtBbnl9IGVsZW1cblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXlcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cblx0ZnVuY3Rpb24gaW5BcnJheShlbGVtLCBhcnJheSkge1xuXHQgIHJldHVybiBhcnJheS5pbmRleE9mKGVsZW0pICE9PSAtMTtcblx0fVxuXHQvKipcblx0ICogTWFrZXMgYSBjbG9uZSBvZiBhbiBvYmplY3QgdXNpbmcgb25seSBBcnJheSBvciBPYmplY3QgYXMgYmFzZSxcblx0ICogYW5kIGNvcGllcyBvdmVyIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gTmV3IG9iamVjdCB3aXRoIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzIChyZWN1cnNpdmVseSkuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG9iamVjdFZhbHVlcyhvYmopIHtcblx0ICB2YXIga2V5LFxuXHQgICAgICB2YWwsXG5cdCAgICAgIHZhbHMgPSBpcyhcImFycmF5XCIsIG9iaikgPyBbXSA6IHt9O1xuXG5cdCAgZm9yIChrZXkgaW4gb2JqKSB7XG5cdCAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSB7XG5cdCAgICAgIHZhbCA9IG9ialtrZXldO1xuXHQgICAgICB2YWxzW2tleV0gPSB2YWwgPT09IE9iamVjdCh2YWwpID8gb2JqZWN0VmFsdWVzKHZhbCkgOiB2YWw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHZhbHM7XG5cdH1cblx0ZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHVuZGVmT25seSkge1xuXHQgIGZvciAodmFyIHByb3AgaW4gYikge1xuXHQgICAgaWYgKGhhc093bi5jYWxsKGIsIHByb3ApKSB7XG5cdCAgICAgIGlmIChiW3Byb3BdID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBkZWxldGUgYVtwcm9wXTtcblx0ICAgICAgfSBlbHNlIGlmICghKHVuZGVmT25seSAmJiB0eXBlb2YgYVtwcm9wXSAhPT0gXCJ1bmRlZmluZWRcIikpIHtcblx0ICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBhO1xuXHR9XG5cdGZ1bmN0aW9uIG9iamVjdFR5cGUob2JqKSB7XG5cdCAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuXHQgIH0gLy8gQ29uc2lkZXI6IHR5cGVvZiBudWxsID09PSBvYmplY3RcblxuXG5cdCAgaWYgKG9iaiA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIFwibnVsbFwiO1xuXHQgIH1cblxuXHQgIHZhciBtYXRjaCA9IHRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXlxcW29iamVjdFxccyguKilcXF0kLyksXG5cdCAgICAgIHR5cGUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcblxuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSBcIk51bWJlclwiOlxuXHQgICAgICBpZiAoaXNOYU4ob2JqKSkge1xuXHQgICAgICAgIHJldHVybiBcIm5hblwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG5cblx0ICAgIGNhc2UgXCJTdHJpbmdcIjpcblx0ICAgIGNhc2UgXCJCb29sZWFuXCI6XG5cdCAgICBjYXNlIFwiQXJyYXlcIjpcblx0ICAgIGNhc2UgXCJTZXRcIjpcblx0ICAgIGNhc2UgXCJNYXBcIjpcblx0ICAgIGNhc2UgXCJEYXRlXCI6XG5cdCAgICBjYXNlIFwiUmVnRXhwXCI6XG5cdCAgICBjYXNlIFwiRnVuY3Rpb25cIjpcblx0ICAgIGNhc2UgXCJTeW1ib2xcIjpcblx0ICAgICAgcmV0dXJuIHR5cGUudG9Mb3dlckNhc2UoKTtcblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcblx0ICB9XG5cdH0gLy8gU2FmZSBvYmplY3QgdHlwZSBjaGVja2luZ1xuXG5cdGZ1bmN0aW9uIGlzKHR5cGUsIG9iaikge1xuXHQgIHJldHVybiBvYmplY3RUeXBlKG9iaikgPT09IHR5cGU7XG5cdH0gLy8gQmFzZWQgb24gSmF2YSdzIFN0cmluZy5oYXNoQ29kZSwgYSBzaW1wbGUgYnV0IG5vdFxuXHQvLyByaWdvcm91c2x5IGNvbGxpc2lvbiByZXNpc3RhbnQgaGFzaGluZyBmdW5jdGlvblxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlSGFzaChtb2R1bGUsIHRlc3ROYW1lKSB7XG5cdCAgdmFyIHN0ciA9IG1vZHVsZSArIFwiXFx4MUNcIiArIHRlc3ROYW1lO1xuXHQgIHZhciBoYXNoID0gMDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICBoYXNoIHw9IDA7XG5cdCAgfSAvLyBDb252ZXJ0IHRoZSBwb3NzaWJseSBuZWdhdGl2ZSBpbnRlZ2VyIGhhc2ggY29kZSBpbnRvIGFuIDggY2hhcmFjdGVyIGhleCBzdHJpbmcsIHdoaWNoIGlzbid0XG5cdCAgLy8gc3RyaWN0bHkgbmVjZXNzYXJ5IGJ1dCBpbmNyZWFzZXMgdXNlciB1bmRlcnN0YW5kaW5nIHRoYXQgdGhlIGlkIGlzIGEgU0hBLWxpa2UgaGFzaFxuXG5cblx0ICB2YXIgaGV4ID0gKDB4MTAwMDAwMDAwICsgaGFzaCkudG9TdHJpbmcoMTYpO1xuXG5cdCAgaWYgKGhleC5sZW5ndGggPCA4KSB7XG5cdCAgICBoZXggPSBcIjAwMDAwMDBcIiArIGhleDtcblx0ICB9XG5cblx0ICByZXR1cm4gaGV4LnNsaWNlKC04KTtcblx0fVxuXG5cdC8vIEF1dGhvcnM6IFBoaWxpcHBlIFJhdGjDqSA8cHJhdGhlQGdtYWlsLmNvbT4sIERhdmlkIENoYW4gPGRhdmlkQHRyb2kub3JnPlxuXG5cdHZhciBlcXVpdiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgLy8gVmFsdWUgcGFpcnMgcXVldWVkIGZvciBjb21wYXJpc29uLiBVc2VkIGZvciBicmVhZHRoLWZpcnN0IHByb2Nlc3Npbmcgb3JkZXIsIHJlY3Vyc2lvblxuXHQgIC8vIGRldGVjdGlvbiBhbmQgYXZvaWRpbmcgcmVwZWF0ZWQgY29tcGFyaXNvbiAoc2VlIGJlbG93IGZvciBkZXRhaWxzKS5cblx0ICAvLyBFbGVtZW50cyBhcmUgeyBhOiB2YWwsIGI6IHZhbCB9LlxuXHQgIHZhciBwYWlycyA9IFtdO1xuXG5cdCAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHJldHVybiBvYmouX19wcm90b19fO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiB1c2VTdHJpY3RFcXVhbGl0eShhLCBiKSB7XG5cdCAgICAvLyBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgaWYgYSBhbmQgYiBhcmUgbm90IHN0cmljdCBlcXVhbCwgYW5kIGlzIHVzZWQgdG8gY29tcGFyZSBvblxuXHQgICAgLy8gdGhlIHByaW1pdGl2ZSB2YWx1ZXMgaW5zaWRlIG9iamVjdCB3cmFwcGVycy4gRm9yIGV4YW1wbGU6XG5cdCAgICAvLyBgdmFyIGkgPSAxO2Bcblx0ICAgIC8vIGB2YXIgaiA9IG5ldyBOdW1iZXIoMSk7YFxuXHQgICAgLy8gTmVpdGhlciBhIG5vciBiIGNhbiBiZSBudWxsLCBhcyBhICE9PSBiIGFuZCB0aGV5IGhhdmUgdGhlIHNhbWUgdHlwZS5cblx0ICAgIGlmIChfdHlwZW9mKGEpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIGEgPSBhLnZhbHVlT2YoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKF90eXBlb2YoYikgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgYiA9IGIudmFsdWVPZigpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYSA9PT0gYjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjb21wYXJlQ29uc3RydWN0b3JzKGEsIGIpIHtcblx0ICAgIHZhciBwcm90b0EgPSBnZXRQcm90byhhKTtcblx0ICAgIHZhciBwcm90b0IgPSBnZXRQcm90byhiKTsgLy8gQ29tcGFyaW5nIGNvbnN0cnVjdG9ycyBpcyBtb3JlIHN0cmljdCB0aGFuIHVzaW5nIGBpbnN0YW5jZW9mYFxuXG5cdCAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gYi5jb25zdHJ1Y3Rvcikge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0gLy8gUmVmICM4NTFcblx0ICAgIC8vIElmIHRoZSBvYmogcHJvdG90eXBlIGRlc2NlbmRzIGZyb20gYSBudWxsIGNvbnN0cnVjdG9yLCB0cmVhdCBpdFxuXHQgICAgLy8gYXMgYSBudWxsIHByb3RvdHlwZS5cblxuXG5cdCAgICBpZiAocHJvdG9BICYmIHByb3RvQS5jb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuXHQgICAgICBwcm90b0EgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocHJvdG9CICYmIHByb3RvQi5jb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuXHQgICAgICBwcm90b0IgPSBudWxsO1xuXHQgICAgfSAvLyBBbGxvdyBvYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIHRvIGJlIGVxdWl2YWxlbnQgdG9cblx0ICAgIC8vIG9iamVjdHMgd2l0aCBPYmplY3QgYXMgdGhlaXIgY29uc3RydWN0b3IuXG5cblxuXHQgICAgaWYgKHByb3RvQSA9PT0gbnVsbCAmJiBwcm90b0IgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG9CID09PSBudWxsICYmIHByb3RvQSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldFJlZ0V4cEZsYWdzKHJlZ2V4cCkge1xuXHQgICAgcmV0dXJuIFwiZmxhZ3NcIiBpbiByZWdleHAgPyByZWdleHAuZmxhZ3MgOiByZWdleHAudG9TdHJpbmcoKS5tYXRjaCgvW2dpbXV5XSokLylbMF07XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaXNDb250YWluZXIodmFsKSB7XG5cdCAgICByZXR1cm4gW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJtYXBcIiwgXCJzZXRcIl0uaW5kZXhPZihvYmplY3RUeXBlKHZhbCkpICE9PSAtMTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBicmVhZHRoRmlyc3RDb21wYXJlQ2hpbGQoYSwgYikge1xuXHQgICAgLy8gSWYgYSBpcyBhIGNvbnRhaW5lciBub3QgcmVmZXJlbmNlLWVxdWFsIHRvIGIsIHBvc3Rwb25lIHRoZSBjb21wYXJpc29uIHRvIHRoZVxuXHQgICAgLy8gZW5kIG9mIHRoZSBwYWlycyBxdWV1ZSAtLSB1bmxlc3MgKGEsIGIpIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBpbiB3aGljaCBjYXNlIHNraXBcblx0ICAgIC8vIG92ZXIgdGhlIHBhaXIuXG5cdCAgICBpZiAoYSA9PT0gYikge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFpc0NvbnRhaW5lcihhKSkge1xuXHQgICAgICByZXR1cm4gdHlwZUVxdWl2KGEsIGIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocGFpcnMuZXZlcnkoZnVuY3Rpb24gKHBhaXIpIHtcblx0ICAgICAgcmV0dXJuIHBhaXIuYSAhPT0gYSB8fCBwYWlyLmIgIT09IGI7XG5cdCAgICB9KSkge1xuXHQgICAgICAvLyBOb3QgeWV0IHN0YXJ0ZWQgY29tcGFyaW5nIHRoaXMgcGFpclxuXHQgICAgICBwYWlycy5wdXNoKHtcblx0ICAgICAgICBhOiBhLFxuXHQgICAgICAgIGI6IGJcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHZhciBjYWxsYmFja3MgPSB7XG5cdCAgICBcInN0cmluZ1wiOiB1c2VTdHJpY3RFcXVhbGl0eSxcblx0ICAgIFwiYm9vbGVhblwiOiB1c2VTdHJpY3RFcXVhbGl0eSxcblx0ICAgIFwibnVtYmVyXCI6IHVzZVN0cmljdEVxdWFsaXR5LFxuXHQgICAgXCJudWxsXCI6IHVzZVN0cmljdEVxdWFsaXR5LFxuXHQgICAgXCJ1bmRlZmluZWRcIjogdXNlU3RyaWN0RXF1YWxpdHksXG5cdCAgICBcInN5bWJvbFwiOiB1c2VTdHJpY3RFcXVhbGl0eSxcblx0ICAgIFwiZGF0ZVwiOiB1c2VTdHJpY3RFcXVhbGl0eSxcblx0ICAgIFwibmFuXCI6IGZ1bmN0aW9uIG5hbigpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9LFxuXHQgICAgXCJyZWdleHBcIjogZnVuY3Rpb24gcmVnZXhwKGEsIGIpIHtcblx0ICAgICAgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiAvLyBJbmNsdWRlIGZsYWdzIGluIHRoZSBjb21wYXJpc29uXG5cdCAgICAgIGdldFJlZ0V4cEZsYWdzKGEpID09PSBnZXRSZWdFeHBGbGFncyhiKTtcblx0ICAgIH0sXG5cdCAgICAvLyBhYm9ydCAoaWRlbnRpY2FsIHJlZmVyZW5jZXMgLyBpbnN0YW5jZSBtZXRob2RzIHdlcmUgc2tpcHBlZCBlYXJsaWVyKVxuXHQgICAgXCJmdW5jdGlvblwiOiBmdW5jdGlvbiBfZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0sXG5cdCAgICBcImFycmF5XCI6IGZ1bmN0aW9uIGFycmF5KGEsIGIpIHtcblx0ICAgICAgdmFyIGksIGxlbjtcblx0ICAgICAgbGVuID0gYS5sZW5ndGg7XG5cblx0ICAgICAgaWYgKGxlbiAhPT0gYi5sZW5ndGgpIHtcblx0ICAgICAgICAvLyBTYWZlIGFuZCBmYXN0ZXJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAvLyBDb21wYXJlIG5vbi1jb250YWluZXJzOyBxdWV1ZSBub24tcmVmZXJlbmNlLWVxdWFsIGNvbnRhaW5lcnNcblx0ICAgICAgICBpZiAoIWJyZWFkdGhGaXJzdENvbXBhcmVDaGlsZChhW2ldLCBiW2ldKSkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSxcblx0ICAgIC8vIERlZmluZSBzZXRzIGEgYW5kIGIgdG8gYmUgZXF1aXZhbGVudCBpZiBmb3IgZWFjaCBlbGVtZW50IGFWYWwgaW4gYSwgdGhlcmVcblx0ICAgIC8vIGlzIHNvbWUgZWxlbWVudCBiVmFsIGluIGIgc3VjaCB0aGF0IGFWYWwgYW5kIGJWYWwgYXJlIGVxdWl2YWxlbnQuIEVsZW1lbnRcblx0ICAgIC8vIHJlcGV0aXRpb25zIGFyZSBub3QgY291bnRlZCwgc28gdGhlc2UgYXJlIGVxdWl2YWxlbnQ6XG5cdCAgICAvLyBhID0gbmV3IFNldCggWyB7fSwgW10sIFtdIF0gKTtcblx0ICAgIC8vIGIgPSBuZXcgU2V0KCBbIHt9LCB7fSwgW10gXSApO1xuXHQgICAgXCJzZXRcIjogZnVuY3Rpb24gc2V0KGEsIGIpIHtcblx0ICAgICAgdmFyIGlubmVyRXEsXG5cdCAgICAgICAgICBvdXRlckVxID0gdHJ1ZTtcblxuXHQgICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcblx0ICAgICAgICAvLyBUaGlzIG9wdGltaXphdGlvbiBoYXMgY2VydGFpbiBxdWlya3MgYmVjYXVzZSBvZiB0aGUgbGFjayBvZlxuXHQgICAgICAgIC8vIHJlcGV0aXRpb24gY291bnRpbmcuIEZvciBpbnN0YW5jZSwgYWRkaW5nIHRoZSBzYW1lXG5cdCAgICAgICAgLy8gKHJlZmVyZW5jZS1pZGVudGljYWwpIGVsZW1lbnQgdG8gdHdvIGVxdWl2YWxlbnQgc2V0cyBjYW5cblx0ICAgICAgICAvLyBtYWtlIHRoZW0gbm9uLWVxdWl2YWxlbnQuXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhVmFsKSB7XG5cdCAgICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB0aGUgcmVzdWx0IGlzIGFscmVhZHkga25vd24uIChVc2luZyBmb3IuLi5vZlxuXHQgICAgICAgIC8vIHdpdGggYSBicmVhayBjbGF1c2Ugd291bGQgYmUgY2xlYW5lciBoZXJlLCBidXQgaXQgd291bGQgY2F1c2Vcblx0ICAgICAgICAvLyBhIHN5bnRheCBlcnJvciBvbiBvbGRlciBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9ucyBldmVuIGlmXG5cdCAgICAgICAgLy8gU2V0IGlzIHVudXNlZClcblx0ICAgICAgICBpZiAoIW91dGVyRXEpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpbm5lckVxID0gZmFsc2U7XG5cdCAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiVmFsKSB7XG5cdCAgICAgICAgICB2YXIgcGFyZW50UGFpcnM7IC8vIExpa2V3aXNlLCBzaG9ydC1jaXJjdWl0IGlmIHRoZSByZXN1bHQgaXMgYWxyZWFkeSBrbm93blxuXG5cdCAgICAgICAgICBpZiAoaW5uZXJFcSkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICB9IC8vIFN3YXAgb3V0IHRoZSBnbG9iYWwgcGFpcnMgbGlzdCwgYXMgdGhlIG5lc3RlZCBjYWxsIHRvXG5cdCAgICAgICAgICAvLyBpbm5lckVxdWl2IHdpbGwgY2xvYmJlciBpdHMgY29udGVudHNcblxuXG5cdCAgICAgICAgICBwYXJlbnRQYWlycyA9IHBhaXJzO1xuXG5cdCAgICAgICAgICBpZiAoaW5uZXJFcXVpdihiVmFsLCBhVmFsKSkge1xuXHQgICAgICAgICAgICBpbm5lckVxID0gdHJ1ZTtcblx0ICAgICAgICAgIH0gLy8gUmVwbGFjZSB0aGUgZ2xvYmFsIHBhaXJzIGxpc3RcblxuXG5cdCAgICAgICAgICBwYWlycyA9IHBhcmVudFBhaXJzO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKCFpbm5lckVxKSB7XG5cdCAgICAgICAgICBvdXRlckVxID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIG91dGVyRXE7XG5cdCAgICB9LFxuXHQgICAgLy8gRGVmaW5lIG1hcHMgYSBhbmQgYiB0byBiZSBlcXVpdmFsZW50IGlmIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyIChhS2V5LCBhVmFsKVxuXHQgICAgLy8gaW4gYSwgdGhlcmUgaXMgc29tZSBrZXktdmFsdWUgcGFpciAoYktleSwgYlZhbCkgaW4gYiBzdWNoIHRoYXRcblx0ICAgIC8vIFsgYUtleSwgYVZhbCBdIGFuZCBbIGJLZXksIGJWYWwgXSBhcmUgZXF1aXZhbGVudC4gS2V5IHJlcGV0aXRpb25zIGFyZSBub3Rcblx0ICAgIC8vIGNvdW50ZWQsIHNvIHRoZXNlIGFyZSBlcXVpdmFsZW50OlxuXHQgICAgLy8gYSA9IG5ldyBNYXAoIFsgWyB7fSwgMSBdLCBbIHt9LCAxIF0sIFsgW10sIDEgXSBdICk7XG5cdCAgICAvLyBiID0gbmV3IE1hcCggWyBbIHt9LCAxIF0sIFsgW10sIDEgXSwgWyBbXSwgMSBdIF0gKTtcblx0ICAgIFwibWFwXCI6IGZ1bmN0aW9uIG1hcChhLCBiKSB7XG5cdCAgICAgIHZhciBpbm5lckVxLFxuXHQgICAgICAgICAgb3V0ZXJFcSA9IHRydWU7XG5cblx0ICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG5cdCAgICAgICAgLy8gVGhpcyBvcHRpbWl6YXRpb24gaGFzIGNlcnRhaW4gcXVpcmtzIGJlY2F1c2Ugb2YgdGhlIGxhY2sgb2Zcblx0ICAgICAgICAvLyByZXBldGl0aW9uIGNvdW50aW5nLiBGb3IgaW5zdGFuY2UsIGFkZGluZyB0aGUgc2FtZVxuXHQgICAgICAgIC8vIChyZWZlcmVuY2UtaWRlbnRpY2FsKSBrZXktdmFsdWUgcGFpciB0byB0d28gZXF1aXZhbGVudCBtYXBzXG5cdCAgICAgICAgLy8gY2FuIG1ha2UgdGhlbSBub24tZXF1aXZhbGVudC5cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKGFWYWwsIGFLZXkpIHtcblx0ICAgICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHRoZSByZXN1bHQgaXMgYWxyZWFkeSBrbm93bi4gKFVzaW5nIGZvci4uLm9mXG5cdCAgICAgICAgLy8gd2l0aCBhIGJyZWFrIGNsYXVzZSB3b3VsZCBiZSBjbGVhbmVyIGhlcmUsIGJ1dCBpdCB3b3VsZCBjYXVzZVxuXHQgICAgICAgIC8vIGEgc3ludGF4IGVycm9yIG9uIG9sZGVyIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb25zIGV2ZW4gaWZcblx0ICAgICAgICAvLyBNYXAgaXMgdW51c2VkKVxuXHQgICAgICAgIGlmICghb3V0ZXJFcSkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlubmVyRXEgPSBmYWxzZTtcblx0ICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGJWYWwsIGJLZXkpIHtcblx0ICAgICAgICAgIHZhciBwYXJlbnRQYWlyczsgLy8gTGlrZXdpc2UsIHNob3J0LWNpcmN1aXQgaWYgdGhlIHJlc3VsdCBpcyBhbHJlYWR5IGtub3duXG5cblx0ICAgICAgICAgIGlmIChpbm5lckVxKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgIH0gLy8gU3dhcCBvdXQgdGhlIGdsb2JhbCBwYWlycyBsaXN0LCBhcyB0aGUgbmVzdGVkIGNhbGwgdG9cblx0ICAgICAgICAgIC8vIGlubmVyRXF1aXYgd2lsbCBjbG9iYmVyIGl0cyBjb250ZW50c1xuXG5cblx0ICAgICAgICAgIHBhcmVudFBhaXJzID0gcGFpcnM7XG5cblx0ICAgICAgICAgIGlmIChpbm5lckVxdWl2KFtiVmFsLCBiS2V5XSwgW2FWYWwsIGFLZXldKSkge1xuXHQgICAgICAgICAgICBpbm5lckVxID0gdHJ1ZTtcblx0ICAgICAgICAgIH0gLy8gUmVwbGFjZSB0aGUgZ2xvYmFsIHBhaXJzIGxpc3RcblxuXG5cdCAgICAgICAgICBwYWlycyA9IHBhcmVudFBhaXJzO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKCFpbm5lckVxKSB7XG5cdCAgICAgICAgICBvdXRlckVxID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIG91dGVyRXE7XG5cdCAgICB9LFxuXHQgICAgXCJvYmplY3RcIjogZnVuY3Rpb24gb2JqZWN0KGEsIGIpIHtcblx0ICAgICAgdmFyIGksXG5cdCAgICAgICAgICBhUHJvcGVydGllcyA9IFtdLFxuXHQgICAgICAgICAgYlByb3BlcnRpZXMgPSBbXTtcblxuXHQgICAgICBpZiAoY29tcGFyZUNvbnN0cnVjdG9ycyhhLCBiKSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH0gLy8gQmUgc3RyaWN0OiBkb24ndCBlbnN1cmUgaGFzT3duUHJvcGVydHkgYW5kIGdvIGRlZXBcblxuXG5cdCAgICAgIGZvciAoaSBpbiBhKSB7XG5cdCAgICAgICAgLy8gQ29sbGVjdCBhJ3MgcHJvcGVydGllc1xuXHQgICAgICAgIGFQcm9wZXJ0aWVzLnB1c2goaSk7IC8vIFNraXAgT09QIG1ldGhvZHMgdGhhdCBsb29rIHRoZSBzYW1lXG5cblx0ICAgICAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIHR5cGVvZiBhLmNvbnN0cnVjdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhW2ldID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGJbaV0gPT09IFwiZnVuY3Rpb25cIiAmJiBhW2ldLnRvU3RyaW5nKCkgPT09IGJbaV0udG9TdHJpbmcoKSkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfSAvLyBDb21wYXJlIG5vbi1jb250YWluZXJzOyBxdWV1ZSBub24tcmVmZXJlbmNlLWVxdWFsIGNvbnRhaW5lcnNcblxuXG5cdCAgICAgICAgaWYgKCFicmVhZHRoRmlyc3RDb21wYXJlQ2hpbGQoYVtpXSwgYltpXSkpIHtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKGkgaW4gYikge1xuXHQgICAgICAgIC8vIENvbGxlY3QgYidzIHByb3BlcnRpZXNcblx0ICAgICAgICBiUHJvcGVydGllcy5wdXNoKGkpO1xuXHQgICAgICB9IC8vIEVuc3VyZXMgaWRlbnRpY2FsIHByb3BlcnRpZXMgbmFtZVxuXG5cblx0ICAgICAgcmV0dXJuIHR5cGVFcXVpdihhUHJvcGVydGllcy5zb3J0KCksIGJQcm9wZXJ0aWVzLnNvcnQoKSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIHR5cGVFcXVpdihhLCBiKSB7XG5cdCAgICB2YXIgdHlwZSA9IG9iamVjdFR5cGUoYSk7IC8vIENhbGxiYWNrcyBmb3IgY29udGFpbmVycyB3aWxsIGFwcGVuZCB0byB0aGUgcGFpcnMgcXVldWUgdG8gYWNoaWV2ZSBicmVhZHRoLWZpcnN0XG5cdCAgICAvLyBzZWFyY2ggb3JkZXIuIFRoZSBwYWlycyBxdWV1ZSBpcyBhbHNvIHVzZWQgdG8gYXZvaWQgcmVwcm9jZXNzaW5nIGFueSBwYWlyIG9mXG5cdCAgICAvLyBjb250YWluZXJzIHRoYXQgYXJlIHJlZmVyZW5jZS1lcXVhbCB0byBhIHByZXZpb3VzbHkgdmlzaXRlZCBwYWlyIChhIHNwZWNpYWwgY2FzZVxuXHQgICAgLy8gdGhpcyBiZWluZyByZWN1cnNpb24gZGV0ZWN0aW9uKS5cblx0ICAgIC8vXG5cdCAgICAvLyBCZWNhdXNlIG9mIHRoaXMgYXBwcm9hY2gsIG9uY2UgdHlwZUVxdWl2IHJldHVybnMgYSBmYWxzZSB2YWx1ZSwgaXQgc2hvdWxkIG5vdCBiZVxuXHQgICAgLy8gY2FsbGVkIGFnYWluIHdpdGhvdXQgY2xlYXJpbmcgdGhlIHBhaXIgcXVldWUgZWxzZSBpdCBtYXkgd3JvbmdseSByZXBvcnQgYSB2aXNpdGVkXG5cdCAgICAvLyBwYWlyIGFzIGJlaW5nIGVxdWl2YWxlbnQuXG5cblx0ICAgIHJldHVybiBvYmplY3RUeXBlKGIpID09PSB0eXBlICYmIGNhbGxiYWNrc1t0eXBlXShhLCBiKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbm5lckVxdWl2KGEsIGIpIHtcblx0ICAgIHZhciBpLCBwYWlyOyAvLyBXZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIG1vcmUgdG8gY29tcGFyZVxuXG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IC8vIENsZWFyIHRoZSBnbG9iYWwgcGFpciBxdWV1ZSBhbmQgYWRkIHRoZSB0b3AtbGV2ZWwgdmFsdWVzIGJlaW5nIGNvbXBhcmVkXG5cblxuXHQgICAgcGFpcnMgPSBbe1xuXHQgICAgICBhOiBhLFxuXHQgICAgICBiOiBiXG5cdCAgICB9XTtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHBhaXIgPSBwYWlyc1tpXTsgLy8gUGVyZm9ybSB0eXBlLXNwZWNpZmljIGNvbXBhcmlzb24gb24gYW55IHBhaXJzIHRoYXQgYXJlIG5vdCBzdHJpY3RseVxuXHQgICAgICAvLyBlcXVhbC4gRm9yIGNvbnRhaW5lciB0eXBlcywgdGhhdCBjb21wYXJpc29uIHdpbGwgcG9zdHBvbmUgY29tcGFyaXNvblxuXHQgICAgICAvLyBvZiBhbnkgc3ViLWNvbnRhaW5lciBwYWlyIHRvIHRoZSBlbmQgb2YgdGhlIHBhaXIgcXVldWUuIFRoaXMgZ2l2ZXNcblx0ICAgICAgLy8gYnJlYWR0aC1maXJzdCBzZWFyY2ggb3JkZXIuIEl0IGFsc28gYXZvaWRzIHRoZSByZXByb2Nlc3Npbmcgb2Zcblx0ICAgICAgLy8gcmVmZXJlbmNlLWVxdWFsIHNpYmxpbmdzLCBjb3VzaW5zIGV0Yywgd2hpY2ggY2FuIGhhdmUgYSBzaWduaWZpY2FudCBzcGVlZFxuXHQgICAgICAvLyBpbXBhY3Qgd2hlbiBjb21wYXJpbmcgYSBjb250YWluZXIgb2Ygc21hbGwgb2JqZWN0cyBlYWNoIG9mIHdoaWNoIGhhcyBhXG5cdCAgICAgIC8vIHJlZmVyZW5jZSB0byB0aGUgc2FtZSAoc2luZ2xldG9uKSBsYXJnZSBvYmplY3QuXG5cblx0ICAgICAgaWYgKHBhaXIuYSAhPT0gcGFpci5iICYmICF0eXBlRXF1aXYocGFpci5hLCBwYWlyLmIpKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIC4uLmFjcm9zcyBhbGwgY29uc2VjdXRpdmUgYXJndW1lbnQgcGFpcnNcblxuXG5cdCAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiB8fCBpbm5lckVxdWl2LmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciByZXN1bHQgPSBpbm5lckVxdWl2LmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTsgLy8gUmVsZWFzZSBhbnkgcmV0YWluZWQgb2JqZWN0c1xuXG5cdCAgICBwYWlycy5sZW5ndGggPSAwO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBDb25maWcgb2JqZWN0OiBNYWludGFpbiBpbnRlcm5hbCBzdGF0ZVxuXHQgKiBMYXRlciBleHBvc2VkIGFzIFFVbml0LmNvbmZpZ1xuXHQgKiBgY29uZmlnYCBpbml0aWFsaXplZCBhdCB0b3Agb2Ygc2NvcGVcblx0ICovXG5cblx0dmFyIGNvbmZpZyA9IHtcblx0ICAvLyBUaGUgcXVldWUgb2YgdGVzdHMgdG8gcnVuXG5cdCAgcXVldWU6IFtdLFxuXHQgIC8vIEJsb2NrIHVudGlsIGRvY3VtZW50IHJlYWR5XG5cdCAgYmxvY2tpbmc6IHRydWUsXG5cdCAgLy8gQnkgZGVmYXVsdCwgcnVuIHByZXZpb3VzbHkgZmFpbGVkIHRlc3RzIGZpcnN0XG5cdCAgLy8gdmVyeSB1c2VmdWwgaW4gY29tYmluYXRpb24gd2l0aCBcIkhpZGUgcGFzc2VkIHRlc3RzXCIgY2hlY2tlZFxuXHQgIHJlb3JkZXI6IHRydWUsXG5cdCAgLy8gQnkgZGVmYXVsdCwgbW9kaWZ5IGRvY3VtZW50LnRpdGxlIHdoZW4gc3VpdGUgaXMgZG9uZVxuXHQgIGFsdGVydGl0bGU6IHRydWUsXG5cdCAgLy8gSFRNTCBSZXBvcnRlcjogY29sbGFwc2UgZXZlcnkgdGVzdCBleGNlcHQgdGhlIGZpcnN0IGZhaWxpbmcgdGVzdFxuXHQgIC8vIElmIGZhbHNlLCBhbGwgZmFpbGluZyB0ZXN0cyB3aWxsIGJlIGV4cGFuZGVkXG5cdCAgY29sbGFwc2U6IHRydWUsXG5cdCAgLy8gQnkgZGVmYXVsdCwgc2Nyb2xsIHRvIHRvcCBvZiB0aGUgcGFnZSB3aGVuIHN1aXRlIGlzIGRvbmVcblx0ICBzY3JvbGx0b3A6IHRydWUsXG5cdCAgLy8gRGVwdGggdXAtdG8gd2hpY2ggb2JqZWN0IHdpbGwgYmUgZHVtcGVkXG5cdCAgbWF4RGVwdGg6IDUsXG5cdCAgLy8gV2hlbiBlbmFibGVkLCBhbGwgdGVzdHMgbXVzdCBjYWxsIGV4cGVjdCgpXG5cdCAgcmVxdWlyZUV4cGVjdHM6IGZhbHNlLFxuXHQgIC8vIFBsYWNlaG9sZGVyIGZvciB1c2VyLWNvbmZpZ3VyYWJsZSBmb3JtLWV4cG9zZWQgVVJMIHBhcmFtZXRlcnNcblx0ICB1cmxDb25maWc6IFtdLFxuXHQgIC8vIFNldCBvZiBhbGwgbW9kdWxlcy5cblx0ICBtb2R1bGVzOiBbXSxcblx0ICAvLyBUaGUgZmlyc3QgdW5uYW1lZCBtb2R1bGVcblx0ICBjdXJyZW50TW9kdWxlOiB7XG5cdCAgICBuYW1lOiBcIlwiLFxuXHQgICAgdGVzdHM6IFtdLFxuXHQgICAgY2hpbGRNb2R1bGVzOiBbXSxcblx0ICAgIHRlc3RzUnVuOiAwLFxuXHQgICAgdW5za2lwcGVkVGVzdHNSdW46IDAsXG5cdCAgICBob29rczoge1xuXHQgICAgICBiZWZvcmU6IFtdLFxuXHQgICAgICBiZWZvcmVFYWNoOiBbXSxcblx0ICAgICAgYWZ0ZXJFYWNoOiBbXSxcblx0ICAgICAgYWZ0ZXI6IFtdXG5cdCAgICB9XG5cdCAgfSxcblx0ICBjYWxsYmFja3M6IHt9LFxuXHQgIC8vIFRoZSBzdG9yYWdlIG1vZHVsZSB0byB1c2UgZm9yIHJlb3JkZXJpbmcgdGVzdHNcblx0ICBzdG9yYWdlOiBsb2NhbFNlc3Npb25TdG9yYWdlXG5cdH07IC8vIHRha2UgYSBwcmVkZWZpbmVkIFFVbml0LmNvbmZpZyBhbmQgZXh0ZW5kIHRoZSBkZWZhdWx0c1xuXG5cdHZhciBnbG9iYWxDb25maWcgPSB3aW5kb3ckMSAmJiB3aW5kb3ckMS5RVW5pdCAmJiB3aW5kb3ckMS5RVW5pdC5jb25maWc7IC8vIG9ubHkgZXh0ZW5kIHRoZSBnbG9iYWwgY29uZmlnIGlmIHRoZXJlIGlzIG5vIFFVbml0IG92ZXJsb2FkXG5cblx0aWYgKHdpbmRvdyQxICYmIHdpbmRvdyQxLlFVbml0ICYmICF3aW5kb3ckMS5RVW5pdC52ZXJzaW9uKSB7XG5cdCAgZXh0ZW5kKGNvbmZpZywgZ2xvYmFsQ29uZmlnKTtcblx0fSAvLyBQdXNoIGEgbG9vc2UgdW5uYW1lZCBtb2R1bGUgdG8gdGhlIG1vZHVsZXMgY29sbGVjdGlvblxuXG5cblx0Y29uZmlnLm1vZHVsZXMucHVzaChjb25maWcuY3VycmVudE1vZHVsZSk7XG5cblx0Ly8gaHR0cHM6Ly9mbGVzbGVyLmJsb2dzcG90LmNvbS8yMDA4LzA1L2pzZHVtcC1wcmV0dHktZHVtcC1vZi1hbnktamF2YXNjcmlwdC5odG1sXG5cblx0dmFyIGR1bXAgPSAoZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIHF1b3RlKHN0cikge1xuXHQgICAgcmV0dXJuIFwiXFxcIlwiICsgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1wiL2csIFwiXFxcXFxcXCJcIikgKyBcIlxcXCJcIjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBsaXRlcmFsKG8pIHtcblx0ICAgIHJldHVybiBvICsgXCJcIjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBqb2luKHByZSwgYXJyLCBwb3N0KSB7XG5cdCAgICB2YXIgcyA9IGR1bXAuc2VwYXJhdG9yKCksXG5cdCAgICAgICAgYmFzZSA9IGR1bXAuaW5kZW50KCksXG5cdCAgICAgICAgaW5uZXIgPSBkdW1wLmluZGVudCgxKTtcblxuXHQgICAgaWYgKGFyci5qb2luKSB7XG5cdCAgICAgIGFyciA9IGFyci5qb2luKFwiLFwiICsgcyArIGlubmVyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFhcnIpIHtcblx0ICAgICAgcmV0dXJuIHByZSArIHBvc3Q7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBbcHJlLCBpbm5lciArIGFyciwgYmFzZSArIHBvc3RdLmpvaW4ocyk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYXJyYXkoYXJyLCBzdGFjaykge1xuXHQgICAgdmFyIGkgPSBhcnIubGVuZ3RoLFxuXHQgICAgICAgIHJldCA9IG5ldyBBcnJheShpKTtcblxuXHQgICAgaWYgKGR1bXAubWF4RGVwdGggJiYgZHVtcC5kZXB0aCA+IGR1bXAubWF4RGVwdGgpIHtcblx0ICAgICAgcmV0dXJuIFwiW29iamVjdCBBcnJheV1cIjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy51cCgpO1xuXG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIHJldFtpXSA9IHRoaXMucGFyc2UoYXJyW2ldLCB1bmRlZmluZWQsIHN0YWNrKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5kb3duKCk7XG5cdCAgICByZXR1cm4gam9pbihcIltcIiwgcmV0LCBcIl1cIik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcblx0ICAgIHJldHVybiAoLy9OYXRpdmUgQXJyYXlzXG5cdCAgICAgIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiIHx8IC8vIE5vZGVMaXN0IG9iamVjdHNcblx0ICAgICAgdHlwZW9mIG9iai5sZW5ndGggPT09IFwibnVtYmVyXCIgJiYgb2JqLml0ZW0gIT09IHVuZGVmaW5lZCAmJiAob2JqLmxlbmd0aCA/IG9iai5pdGVtKDApID09PSBvYmpbMF0gOiBvYmouaXRlbSgwKSA9PT0gbnVsbCAmJiBvYmpbMF0gPT09IHVuZGVmaW5lZClcblx0ICAgICk7XG5cdCAgfVxuXG5cdCAgdmFyIHJlTmFtZSA9IC9eZnVuY3Rpb24gKFxcdyspLyxcblx0ICAgICAgZHVtcCA9IHtcblx0ICAgIC8vIFRoZSBvYmpUeXBlIGlzIHVzZWQgbW9zdGx5IGludGVybmFsbHksIHlvdSBjYW4gZml4IGEgKGN1c3RvbSkgdHlwZSBpbiBhZHZhbmNlXG5cdCAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2Uob2JqLCBvYmpUeXBlLCBzdGFjaykge1xuXHQgICAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuXHQgICAgICB2YXIgcmVzLFxuXHQgICAgICAgICAgcGFyc2VyLFxuXHQgICAgICAgICAgcGFyc2VyVHlwZSxcblx0ICAgICAgICAgIG9iakluZGV4ID0gc3RhY2suaW5kZXhPZihvYmopO1xuXG5cdCAgICAgIGlmIChvYmpJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICByZXR1cm4gXCJyZWN1cnNpb24oXCIuY29uY2F0KG9iakluZGV4IC0gc3RhY2subGVuZ3RoLCBcIilcIik7XG5cdCAgICAgIH1cblxuXHQgICAgICBvYmpUeXBlID0gb2JqVHlwZSB8fCB0aGlzLnR5cGVPZihvYmopO1xuXHQgICAgICBwYXJzZXIgPSB0aGlzLnBhcnNlcnNbb2JqVHlwZV07XG5cdCAgICAgIHBhcnNlclR5cGUgPSBfdHlwZW9mKHBhcnNlcik7XG5cblx0ICAgICAgaWYgKHBhcnNlclR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgIHN0YWNrLnB1c2gob2JqKTtcblx0ICAgICAgICByZXMgPSBwYXJzZXIuY2FsbCh0aGlzLCBvYmosIHN0YWNrKTtcblx0ICAgICAgICBzdGFjay5wb3AoKTtcblx0ICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHBhcnNlclR5cGUgPT09IFwic3RyaW5nXCIgPyBwYXJzZXIgOiB0aGlzLnBhcnNlcnMuZXJyb3I7XG5cdCAgICB9LFxuXHQgICAgdHlwZU9mOiBmdW5jdGlvbiB0eXBlT2Yob2JqKSB7XG5cdCAgICAgIHZhciB0eXBlO1xuXG5cdCAgICAgIGlmIChvYmogPT09IG51bGwpIHtcblx0ICAgICAgICB0eXBlID0gXCJudWxsXCI7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICAgIHR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXHQgICAgICB9IGVsc2UgaWYgKGlzKFwicmVnZXhwXCIsIG9iaikpIHtcblx0ICAgICAgICB0eXBlID0gXCJyZWdleHBcIjtcblx0ICAgICAgfSBlbHNlIGlmIChpcyhcImRhdGVcIiwgb2JqKSkge1xuXHQgICAgICAgIHR5cGUgPSBcImRhdGVcIjtcblx0ICAgICAgfSBlbHNlIGlmIChpcyhcImZ1bmN0aW9uXCIsIG9iaikpIHtcblx0ICAgICAgICB0eXBlID0gXCJmdW5jdGlvblwiO1xuXHQgICAgICB9IGVsc2UgaWYgKG9iai5zZXRJbnRlcnZhbCAhPT0gdW5kZWZpbmVkICYmIG9iai5kb2N1bWVudCAhPT0gdW5kZWZpbmVkICYmIG9iai5ub2RlVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgdHlwZSA9IFwid2luZG93XCI7XG5cdCAgICAgIH0gZWxzZSBpZiAob2JqLm5vZGVUeXBlID09PSA5KSB7XG5cdCAgICAgICAgdHlwZSA9IFwiZG9jdW1lbnRcIjtcblx0ICAgICAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUpIHtcblx0ICAgICAgICB0eXBlID0gXCJub2RlXCI7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7XG5cdCAgICAgICAgdHlwZSA9IFwiYXJyYXlcIjtcblx0ICAgICAgfSBlbHNlIGlmIChvYmouY29uc3RydWN0b3IgPT09IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgIHR5cGUgPSBcImVycm9yXCI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdHlwZSA9IF90eXBlb2Yob2JqKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgfSxcblx0ICAgIHNlcGFyYXRvcjogZnVuY3Rpb24gc2VwYXJhdG9yKCkge1xuXHQgICAgICBpZiAodGhpcy5tdWx0aWxpbmUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5IVE1MID8gXCI8YnIgLz5cIiA6IFwiXFxuXCI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuSFRNTCA/IFwiJiMxNjA7XCIgOiBcIiBcIjtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIC8vIEV4dHJhIGNhbiBiZSBhIG51bWJlciwgc2hvcnRjdXQgZm9yIGluY3JlYXNpbmctY2FsbGluZy1kZWNyZWFzaW5nXG5cdCAgICBpbmRlbnQ6IGZ1bmN0aW9uIGluZGVudChleHRyYSkge1xuXHQgICAgICBpZiAoIXRoaXMubXVsdGlsaW5lKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgY2hyID0gdGhpcy5pbmRlbnRDaGFyO1xuXG5cdCAgICAgIGlmICh0aGlzLkhUTUwpIHtcblx0ICAgICAgICBjaHIgPSBjaHIucmVwbGFjZSgvXFx0L2csIFwiICAgXCIpLnJlcGxhY2UoLyAvZywgXCImIzE2MDtcIik7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gbmV3IEFycmF5KHRoaXMuZGVwdGggKyAoZXh0cmEgfHwgMCkpLmpvaW4oY2hyKTtcblx0ICAgIH0sXG5cdCAgICB1cDogZnVuY3Rpb24gdXAoYSkge1xuXHQgICAgICB0aGlzLmRlcHRoICs9IGEgfHwgMTtcblx0ICAgIH0sXG5cdCAgICBkb3duOiBmdW5jdGlvbiBkb3duKGEpIHtcblx0ICAgICAgdGhpcy5kZXB0aCAtPSBhIHx8IDE7XG5cdCAgICB9LFxuXHQgICAgc2V0UGFyc2VyOiBmdW5jdGlvbiBzZXRQYXJzZXIobmFtZSwgcGFyc2VyKSB7XG5cdCAgICAgIHRoaXMucGFyc2Vyc1tuYW1lXSA9IHBhcnNlcjtcblx0ICAgIH0sXG5cdCAgICAvLyBUaGUgbmV4dCAzIGFyZSBleHBvc2VkIHNvIHlvdSBjYW4gdXNlIHRoZW1cblx0ICAgIHF1b3RlOiBxdW90ZSxcblx0ICAgIGxpdGVyYWw6IGxpdGVyYWwsXG5cdCAgICBqb2luOiBqb2luLFxuXHQgICAgZGVwdGg6IDEsXG5cdCAgICBtYXhEZXB0aDogY29uZmlnLm1heERlcHRoLFxuXHQgICAgLy8gVGhpcyBpcyB0aGUgbGlzdCBvZiBwYXJzZXJzLCB0byBtb2RpZnkgdGhlbSwgdXNlIGR1bXAuc2V0UGFyc2VyXG5cdCAgICBwYXJzZXJzOiB7XG5cdCAgICAgIHdpbmRvdzogXCJbV2luZG93XVwiLFxuXHQgICAgICBkb2N1bWVudDogXCJbRG9jdW1lbnRdXCIsXG5cdCAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gXCJFcnJvcihcXFwiXCIgKyBfZXJyb3IubWVzc2FnZSArIFwiXFxcIilcIjtcblx0ICAgICAgfSxcblx0ICAgICAgdW5rbm93bjogXCJbVW5rbm93bl1cIixcblx0ICAgICAgXCJudWxsXCI6IFwibnVsbFwiLFxuXHQgICAgICBcInVuZGVmaW5lZFwiOiBcInVuZGVmaW5lZFwiLFxuXHQgICAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uIF9mdW5jdGlvbihmbikge1xuXHQgICAgICAgIHZhciByZXQgPSBcImZ1bmN0aW9uXCIsXG5cdCAgICAgICAgICAgIC8vIEZ1bmN0aW9ucyBuZXZlciBoYXZlIG5hbWUgaW4gSUVcblx0ICAgICAgICBuYW1lID0gXCJuYW1lXCIgaW4gZm4gPyBmbi5uYW1lIDogKHJlTmFtZS5leGVjKGZuKSB8fCBbXSlbMV07XG5cblx0ICAgICAgICBpZiAobmFtZSkge1xuXHQgICAgICAgICAgcmV0ICs9IFwiIFwiICsgbmFtZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXQgKz0gXCIoXCI7XG5cdCAgICAgICAgcmV0ID0gW3JldCwgZHVtcC5wYXJzZShmbiwgXCJmdW5jdGlvbkFyZ3NcIiksIFwiKXtcIl0uam9pbihcIlwiKTtcblx0ICAgICAgICByZXR1cm4gam9pbihyZXQsIGR1bXAucGFyc2UoZm4sIFwiZnVuY3Rpb25Db2RlXCIpLCBcIn1cIik7XG5cdCAgICAgIH0sXG5cdCAgICAgIGFycmF5OiBhcnJheSxcblx0ICAgICAgbm9kZWxpc3Q6IGFycmF5LFxuXHQgICAgICBcImFyZ3VtZW50c1wiOiBhcnJheSxcblx0ICAgICAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QobWFwLCBzdGFjaykge1xuXHQgICAgICAgIHZhciBrZXlzLFxuXHQgICAgICAgICAgICBrZXksXG5cdCAgICAgICAgICAgIHZhbCxcblx0ICAgICAgICAgICAgaSxcblx0ICAgICAgICAgICAgbm9uRW51bWVyYWJsZVByb3BlcnRpZXMsXG5cdCAgICAgICAgICAgIHJldCA9IFtdO1xuXG5cdCAgICAgICAgaWYgKGR1bXAubWF4RGVwdGggJiYgZHVtcC5kZXB0aCA+IGR1bXAubWF4RGVwdGgpIHtcblx0ICAgICAgICAgIHJldHVybiBcIltvYmplY3QgT2JqZWN0XVwiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGR1bXAudXAoKTtcblx0ICAgICAgICBrZXlzID0gW107XG5cblx0ICAgICAgICBmb3IgKGtleSBpbiBtYXApIHtcblx0ICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuXHQgICAgICAgIH0gLy8gU29tZSBwcm9wZXJ0aWVzIGFyZSBub3QgYWx3YXlzIGVudW1lcmFibGUgb24gRXJyb3Igb2JqZWN0cy5cblxuXG5cdCAgICAgICAgbm9uRW51bWVyYWJsZVByb3BlcnRpZXMgPSBbXCJtZXNzYWdlXCIsIFwibmFtZVwiXTtcblxuXHQgICAgICAgIGZvciAoaSBpbiBub25FbnVtZXJhYmxlUHJvcGVydGllcykge1xuXHQgICAgICAgICAga2V5ID0gbm9uRW51bWVyYWJsZVByb3BlcnRpZXNbaV07XG5cblx0ICAgICAgICAgIGlmIChrZXkgaW4gbWFwICYmICFpbkFycmF5KGtleSwga2V5cykpIHtcblx0ICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAga2V5cy5zb3J0KCk7XG5cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgICAgIHZhbCA9IG1hcFtrZXldO1xuXHQgICAgICAgICAgcmV0LnB1c2goZHVtcC5wYXJzZShrZXksIFwia2V5XCIpICsgXCI6IFwiICsgZHVtcC5wYXJzZSh2YWwsIHVuZGVmaW5lZCwgc3RhY2spKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkdW1wLmRvd24oKTtcblx0ICAgICAgICByZXR1cm4gam9pbihcIntcIiwgcmV0LCBcIn1cIik7XG5cdCAgICAgIH0sXG5cdCAgICAgIG5vZGU6IGZ1bmN0aW9uIG5vZGUoX25vZGUpIHtcblx0ICAgICAgICB2YXIgbGVuLFxuXHQgICAgICAgICAgICBpLFxuXHQgICAgICAgICAgICB2YWwsXG5cdCAgICAgICAgICAgIG9wZW4gPSBkdW1wLkhUTUwgPyBcIiZsdDtcIiA6IFwiPFwiLFxuXHQgICAgICAgICAgICBjbG9zZSA9IGR1bXAuSFRNTCA/IFwiJmd0O1wiIDogXCI+XCIsXG5cdCAgICAgICAgICAgIHRhZyA9IF9ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdCAgICAgICAgICAgIHJldCA9IG9wZW4gKyB0YWcsXG5cdCAgICAgICAgICAgIGF0dHJzID0gX25vZGUuYXR0cmlidXRlcztcblxuXHQgICAgICAgIGlmIChhdHRycykge1xuXHQgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFsID0gYXR0cnNbaV0ubm9kZVZhbHVlOyAvLyBJRTYgaW5jbHVkZXMgYWxsIGF0dHJpYnV0ZXMgaW4gLmF0dHJpYnV0ZXMsIGV2ZW4gb25lcyBub3QgZXhwbGljaXRseVxuXHQgICAgICAgICAgICAvLyBzZXQuIFRob3NlIGhhdmUgdmFsdWVzIGxpa2UgdW5kZWZpbmVkLCBudWxsLCAwLCBmYWxzZSwgXCJcIiBvclxuXHQgICAgICAgICAgICAvLyBcImluaGVyaXRcIi5cblxuXHQgICAgICAgICAgICBpZiAodmFsICYmIHZhbCAhPT0gXCJpbmhlcml0XCIpIHtcblx0ICAgICAgICAgICAgICByZXQgKz0gXCIgXCIgKyBhdHRyc1tpXS5ub2RlTmFtZSArIFwiPVwiICsgZHVtcC5wYXJzZSh2YWwsIFwiYXR0cmlidXRlXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0ICs9IGNsb3NlOyAvLyBTaG93IGNvbnRlbnQgb2YgVGV4dE5vZGUgb3IgQ0RBVEFTZWN0aW9uXG5cblx0ICAgICAgICBpZiAoX25vZGUubm9kZVR5cGUgPT09IDMgfHwgX25vZGUubm9kZVR5cGUgPT09IDQpIHtcblx0ICAgICAgICAgIHJldCArPSBfbm9kZS5ub2RlVmFsdWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJldCArIG9wZW4gKyBcIi9cIiArIHRhZyArIGNsb3NlO1xuXHQgICAgICB9LFxuXHQgICAgICAvLyBGdW5jdGlvbiBjYWxscyBpdCBpbnRlcm5hbGx5LCBpdCdzIHRoZSBhcmd1bWVudHMgcGFydCBvZiB0aGUgZnVuY3Rpb25cblx0ICAgICAgZnVuY3Rpb25BcmdzOiBmdW5jdGlvbiBmdW5jdGlvbkFyZ3MoZm4pIHtcblx0ICAgICAgICB2YXIgYXJncyxcblx0ICAgICAgICAgICAgbCA9IGZuLmxlbmd0aDtcblxuXHQgICAgICAgIGlmICghbCkge1xuXHQgICAgICAgICAgcmV0dXJuIFwiXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYXJncyA9IG5ldyBBcnJheShsKTtcblxuXHQgICAgICAgIHdoaWxlIChsLS0pIHtcblx0ICAgICAgICAgIC8vIDk3IGlzICdhJ1xuXHQgICAgICAgICAgYXJnc1tsXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gXCIgXCIgKyBhcmdzLmpvaW4oXCIsIFwiKSArIFwiIFwiO1xuXHQgICAgICB9LFxuXHQgICAgICAvLyBPYmplY3QgY2FsbHMgaXQgaW50ZXJuYWxseSwgdGhlIGtleSBwYXJ0IG9mIGFuIGl0ZW0gaW4gYSBtYXBcblx0ICAgICAga2V5OiBxdW90ZSxcblx0ICAgICAgLy8gRnVuY3Rpb24gY2FsbHMgaXQgaW50ZXJuYWxseSwgaXQncyB0aGUgY29udGVudCBvZiB0aGUgZnVuY3Rpb25cblx0ICAgICAgZnVuY3Rpb25Db2RlOiBcIltjb2RlXVwiLFxuXHQgICAgICAvLyBOb2RlIGNhbGxzIGl0IGludGVybmFsbHksIGl0J3MgYSBodG1sIGF0dHJpYnV0ZSB2YWx1ZVxuXHQgICAgICBhdHRyaWJ1dGU6IHF1b3RlLFxuXHQgICAgICBzdHJpbmc6IHF1b3RlLFxuXHQgICAgICBkYXRlOiBxdW90ZSxcblx0ICAgICAgcmVnZXhwOiBsaXRlcmFsLFxuXHQgICAgICBudW1iZXI6IGxpdGVyYWwsXG5cdCAgICAgIFwiYm9vbGVhblwiOiBsaXRlcmFsLFxuXHQgICAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbChzeW0pIHtcblx0ICAgICAgICByZXR1cm4gc3ltLnRvU3RyaW5nKCk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICAvLyBJZiB0cnVlLCBlbnRpdGllcyBhcmUgZXNjYXBlZCAoIDwsID4sIFxcdCwgc3BhY2UgYW5kIFxcbiApXG5cdCAgICBIVE1MOiBmYWxzZSxcblx0ICAgIC8vIEluZGVudGF0aW9uIHVuaXRcblx0ICAgIGluZGVudENoYXI6IFwiICBcIixcblx0ICAgIC8vIElmIHRydWUsIGl0ZW1zIGluIGEgY29sbGVjdGlvbiwgYXJlIHNlcGFyYXRlZCBieSBhIFxcbiwgZWxzZSBqdXN0IGEgc3BhY2UuXG5cdCAgICBtdWx0aWxpbmU6IHRydWVcblx0ICB9O1xuXHQgIHJldHVybiBkdW1wO1xuXHR9KSgpO1xuXG5cdHZhciBTdWl0ZVJlcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gU3VpdGVSZXBvcnQobmFtZSwgcGFyZW50U3VpdGUpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWl0ZVJlcG9ydCk7XG5cblx0ICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICB0aGlzLmZ1bGxOYW1lID0gcGFyZW50U3VpdGUgPyBwYXJlbnRTdWl0ZS5mdWxsTmFtZS5jb25jYXQobmFtZSkgOiBbXTtcblx0ICAgIHRoaXMudGVzdHMgPSBbXTtcblx0ICAgIHRoaXMuY2hpbGRTdWl0ZXMgPSBbXTtcblxuXHQgICAgaWYgKHBhcmVudFN1aXRlKSB7XG5cdCAgICAgIHBhcmVudFN1aXRlLnB1c2hDaGlsZFN1aXRlKHRoaXMpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIF9jcmVhdGVDbGFzcyhTdWl0ZVJlcG9ydCwgW3tcblx0ICAgIGtleTogXCJzdGFydFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KHJlY29yZFRpbWUpIHtcblx0ICAgICAgaWYgKHJlY29yZFRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG5cdCAgICAgICAgaWYgKHBlcmZvcm1hbmNlKSB7XG5cdCAgICAgICAgICB2YXIgc3VpdGVMZXZlbCA9IHRoaXMuZnVsbE5hbWUubGVuZ3RoO1xuXHQgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhcInF1bml0X3N1aXRlX1wiLmNvbmNhdChzdWl0ZUxldmVsLCBcIl9zdGFydFwiKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cdCAgICAgICAgZnVsbE5hbWU6IHRoaXMuZnVsbE5hbWUuc2xpY2UoKSxcblx0ICAgICAgICB0ZXN0czogdGhpcy50ZXN0cy5tYXAoZnVuY3Rpb24gKHRlc3QpIHtcblx0ICAgICAgICAgIHJldHVybiB0ZXN0LnN0YXJ0KCk7XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgY2hpbGRTdWl0ZXM6IHRoaXMuY2hpbGRTdWl0ZXMubWFwKGZ1bmN0aW9uIChzdWl0ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIHN1aXRlLnN0YXJ0KCk7XG5cdCAgICAgICAgfSksXG5cdCAgICAgICAgdGVzdENvdW50czoge1xuXHQgICAgICAgICAgdG90YWw6IHRoaXMuZ2V0VGVzdENvdW50cygpLnRvdGFsXG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJlbmRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQocmVjb3JkVGltZSkge1xuXHQgICAgICBpZiAocmVjb3JkVGltZSkge1xuXHQgICAgICAgIHRoaXMuX2VuZFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG5cdCAgICAgICAgaWYgKHBlcmZvcm1hbmNlKSB7XG5cdCAgICAgICAgICB2YXIgc3VpdGVMZXZlbCA9IHRoaXMuZnVsbE5hbWUubGVuZ3RoO1xuXHQgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhcInF1bml0X3N1aXRlX1wiLmNvbmNhdChzdWl0ZUxldmVsLCBcIl9lbmRcIikpO1xuXHQgICAgICAgICAgdmFyIHN1aXRlTmFtZSA9IHRoaXMuZnVsbE5hbWUuam9pbihcIiDigJMgXCIpO1xuXHQgICAgICAgICAgbWVhc3VyZShzdWl0ZUxldmVsID09PSAwID8gXCJRVW5pdCBUZXN0IFJ1blwiIDogXCJRVW5pdCBUZXN0IFN1aXRlOiBcIi5jb25jYXQoc3VpdGVOYW1lKSwgXCJxdW5pdF9zdWl0ZV9cIi5jb25jYXQoc3VpdGVMZXZlbCwgXCJfc3RhcnRcIiksIFwicXVuaXRfc3VpdGVfXCIuY29uY2F0KHN1aXRlTGV2ZWwsIFwiX2VuZFwiKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cdCAgICAgICAgZnVsbE5hbWU6IHRoaXMuZnVsbE5hbWUuc2xpY2UoKSxcblx0ICAgICAgICB0ZXN0czogdGhpcy50ZXN0cy5tYXAoZnVuY3Rpb24gKHRlc3QpIHtcblx0ICAgICAgICAgIHJldHVybiB0ZXN0LmVuZCgpO1xuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIGNoaWxkU3VpdGVzOiB0aGlzLmNoaWxkU3VpdGVzLm1hcChmdW5jdGlvbiAoc3VpdGUpIHtcblx0ICAgICAgICAgIHJldHVybiBzdWl0ZS5lbmQoKTtcblx0ICAgICAgICB9KSxcblx0ICAgICAgICB0ZXN0Q291bnRzOiB0aGlzLmdldFRlc3RDb3VudHMoKSxcblx0ICAgICAgICBydW50aW1lOiB0aGlzLmdldFJ1bnRpbWUoKSxcblx0ICAgICAgICBzdGF0dXM6IHRoaXMuZ2V0U3RhdHVzKClcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwicHVzaENoaWxkU3VpdGVcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoQ2hpbGRTdWl0ZShzdWl0ZSkge1xuXHQgICAgICB0aGlzLmNoaWxkU3VpdGVzLnB1c2goc3VpdGUpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJwdXNoVGVzdFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hUZXN0KHRlc3QpIHtcblx0ICAgICAgdGhpcy50ZXN0cy5wdXNoKHRlc3QpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJnZXRSdW50aW1lXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVudGltZSgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2VuZFRpbWUgLSB0aGlzLl9zdGFydFRpbWU7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImdldFRlc3RDb3VudHNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXN0Q291bnRzKCkge1xuXHQgICAgICB2YXIgY291bnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7XG5cdCAgICAgICAgcGFzc2VkOiAwLFxuXHQgICAgICAgIGZhaWxlZDogMCxcblx0ICAgICAgICBza2lwcGVkOiAwLFxuXHQgICAgICAgIHRvZG86IDAsXG5cdCAgICAgICAgdG90YWw6IDBcblx0ICAgICAgfTtcblx0ICAgICAgY291bnRzID0gdGhpcy50ZXN0cy5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50cywgdGVzdCkge1xuXHQgICAgICAgIGlmICh0ZXN0LnZhbGlkKSB7XG5cdCAgICAgICAgICBjb3VudHNbdGVzdC5nZXRTdGF0dXMoKV0rKztcblx0ICAgICAgICAgIGNvdW50cy50b3RhbCsrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBjb3VudHM7XG5cdCAgICAgIH0sIGNvdW50cyk7XG5cdCAgICAgIHJldHVybiB0aGlzLmNoaWxkU3VpdGVzLnJlZHVjZShmdW5jdGlvbiAoY291bnRzLCBzdWl0ZSkge1xuXHQgICAgICAgIHJldHVybiBzdWl0ZS5nZXRUZXN0Q291bnRzKGNvdW50cyk7XG5cdCAgICAgIH0sIGNvdW50cyk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImdldFN0YXR1c1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcblx0ICAgICAgdmFyIF90aGlzJGdldFRlc3RDb3VudHMgPSB0aGlzLmdldFRlc3RDb3VudHMoKSxcblx0ICAgICAgICAgIHRvdGFsID0gX3RoaXMkZ2V0VGVzdENvdW50cy50b3RhbCxcblx0ICAgICAgICAgIGZhaWxlZCA9IF90aGlzJGdldFRlc3RDb3VudHMuZmFpbGVkLFxuXHQgICAgICAgICAgc2tpcHBlZCA9IF90aGlzJGdldFRlc3RDb3VudHMuc2tpcHBlZCxcblx0ICAgICAgICAgIHRvZG8gPSBfdGhpcyRnZXRUZXN0Q291bnRzLnRvZG87XG5cblx0ICAgICAgaWYgKGZhaWxlZCkge1xuXHQgICAgICAgIHJldHVybiBcImZhaWxlZFwiO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChza2lwcGVkID09PSB0b3RhbCkge1xuXHQgICAgICAgICAgcmV0dXJuIFwic2tpcHBlZFwiO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodG9kbyA9PT0gdG90YWwpIHtcblx0ICAgICAgICAgIHJldHVybiBcInRvZG9cIjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIFwicGFzc2VkXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIFN1aXRlUmVwb3J0O1xuXHR9KCk7XG5cblx0dmFyIGZvY3VzZWQgPSBmYWxzZTtcblx0dmFyIG1vZHVsZVN0YWNrID0gW107XG5cblx0ZnVuY3Rpb24gaXNQYXJlbnRNb2R1bGVJblF1ZXVlKCkge1xuXHQgIHZhciBtb2R1bGVzSW5RdWV1ZSA9IGNvbmZpZy5tb2R1bGVzLm1hcChmdW5jdGlvbiAobW9kdWxlKSB7XG5cdCAgICByZXR1cm4gbW9kdWxlLm1vZHVsZUlkO1xuXHQgIH0pO1xuXHQgIHJldHVybiBtb2R1bGVTdGFjay5zb21lKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0ICAgIHJldHVybiBtb2R1bGVzSW5RdWV1ZS5pbmNsdWRlcyhtb2R1bGUubW9kdWxlSWQpO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlTW9kdWxlKG5hbWUsIHRlc3RFbnZpcm9ubWVudCwgbW9kaWZpZXJzKSB7XG5cdCAgdmFyIHBhcmVudE1vZHVsZSA9IG1vZHVsZVN0YWNrLmxlbmd0aCA/IG1vZHVsZVN0YWNrLnNsaWNlKC0xKVswXSA6IG51bGw7XG5cdCAgdmFyIG1vZHVsZU5hbWUgPSBwYXJlbnRNb2R1bGUgIT09IG51bGwgPyBbcGFyZW50TW9kdWxlLm5hbWUsIG5hbWVdLmpvaW4oXCIgPiBcIikgOiBuYW1lO1xuXHQgIHZhciBwYXJlbnRTdWl0ZSA9IHBhcmVudE1vZHVsZSA/IHBhcmVudE1vZHVsZS5zdWl0ZVJlcG9ydCA6IGdsb2JhbFN1aXRlO1xuXHQgIHZhciBza2lwID0gcGFyZW50TW9kdWxlICE9PSBudWxsICYmIHBhcmVudE1vZHVsZS5za2lwIHx8IG1vZGlmaWVycy5za2lwO1xuXHQgIHZhciB0b2RvID0gcGFyZW50TW9kdWxlICE9PSBudWxsICYmIHBhcmVudE1vZHVsZS50b2RvIHx8IG1vZGlmaWVycy50b2RvO1xuXHQgIHZhciBtb2R1bGUgPSB7XG5cdCAgICBuYW1lOiBtb2R1bGVOYW1lLFxuXHQgICAgcGFyZW50TW9kdWxlOiBwYXJlbnRNb2R1bGUsXG5cdCAgICB0ZXN0czogW10sXG5cdCAgICBtb2R1bGVJZDogZ2VuZXJhdGVIYXNoKG1vZHVsZU5hbWUpLFxuXHQgICAgdGVzdHNSdW46IDAsXG5cdCAgICB1bnNraXBwZWRUZXN0c1J1bjogMCxcblx0ICAgIGNoaWxkTW9kdWxlczogW10sXG5cdCAgICBzdWl0ZVJlcG9ydDogbmV3IFN1aXRlUmVwb3J0KG5hbWUsIHBhcmVudFN1aXRlKSxcblx0ICAgIC8vIFBhc3MgYWxvbmcgYHNraXBgIGFuZCBgdG9kb2AgcHJvcGVydGllcyBmcm9tIHBhcmVudCBtb2R1bGUsIGluIGNhc2Vcblx0ICAgIC8vIHRoZXJlIGlzIG9uZSwgdG8gY2hpbGRzLiBBbmQgdXNlIG93biBvdGhlcndpc2UuXG5cdCAgICAvLyBUaGlzIHByb3BlcnR5IHdpbGwgYmUgdXNlZCB0byBtYXJrIG93biB0ZXN0cyBhbmQgdGVzdHMgb2YgY2hpbGQgc3VpdGVzXG5cdCAgICAvLyBhcyBlaXRoZXIgYHNraXBwZWRgIG9yIGB0b2RvYC5cblx0ICAgIHNraXA6IHNraXAsXG5cdCAgICB0b2RvOiBza2lwID8gZmFsc2UgOiB0b2RvXG5cdCAgfTtcblx0ICB2YXIgZW52ID0ge307XG5cblx0ICBpZiAocGFyZW50TW9kdWxlKSB7XG5cdCAgICBwYXJlbnRNb2R1bGUuY2hpbGRNb2R1bGVzLnB1c2gobW9kdWxlKTtcblx0ICAgIGV4dGVuZChlbnYsIHBhcmVudE1vZHVsZS50ZXN0RW52aXJvbm1lbnQpO1xuXHQgIH1cblxuXHQgIGV4dGVuZChlbnYsIHRlc3RFbnZpcm9ubWVudCk7XG5cdCAgbW9kdWxlLnRlc3RFbnZpcm9ubWVudCA9IGVudjtcblx0ICBjb25maWcubW9kdWxlcy5wdXNoKG1vZHVsZSk7XG5cdCAgcmV0dXJuIG1vZHVsZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NNb2R1bGUobmFtZSwgb3B0aW9ucywgZXhlY3V0ZU5vdykge1xuXHQgIHZhciBtb2RpZmllcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG5cdCAgaWYgKG9iamVjdFR5cGUob3B0aW9ucykgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgZXhlY3V0ZU5vdyA9IG9wdGlvbnM7XG5cdCAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIHZhciBtb2R1bGUgPSBjcmVhdGVNb2R1bGUobmFtZSwgb3B0aW9ucywgbW9kaWZpZXJzKTsgLy8gTW92ZSBhbnkgaG9va3MgdG8gYSAnaG9va3MnIG9iamVjdFxuXG5cdCAgdmFyIHRlc3RFbnZpcm9ubWVudCA9IG1vZHVsZS50ZXN0RW52aXJvbm1lbnQ7XG5cdCAgdmFyIGhvb2tzID0gbW9kdWxlLmhvb2tzID0ge307XG5cdCAgc2V0SG9va0Zyb21FbnZpcm9ubWVudChob29rcywgdGVzdEVudmlyb25tZW50LCBcImJlZm9yZVwiKTtcblx0ICBzZXRIb29rRnJvbUVudmlyb25tZW50KGhvb2tzLCB0ZXN0RW52aXJvbm1lbnQsIFwiYmVmb3JlRWFjaFwiKTtcblx0ICBzZXRIb29rRnJvbUVudmlyb25tZW50KGhvb2tzLCB0ZXN0RW52aXJvbm1lbnQsIFwiYWZ0ZXJFYWNoXCIpO1xuXHQgIHNldEhvb2tGcm9tRW52aXJvbm1lbnQoaG9va3MsIHRlc3RFbnZpcm9ubWVudCwgXCJhZnRlclwiKTtcblx0ICB2YXIgbW9kdWxlRm5zID0ge1xuXHQgICAgYmVmb3JlOiBzZXRIb29rRnVuY3Rpb24obW9kdWxlLCBcImJlZm9yZVwiKSxcblx0ICAgIGJlZm9yZUVhY2g6IHNldEhvb2tGdW5jdGlvbihtb2R1bGUsIFwiYmVmb3JlRWFjaFwiKSxcblx0ICAgIGFmdGVyRWFjaDogc2V0SG9va0Z1bmN0aW9uKG1vZHVsZSwgXCJhZnRlckVhY2hcIiksXG5cdCAgICBhZnRlcjogc2V0SG9va0Z1bmN0aW9uKG1vZHVsZSwgXCJhZnRlclwiKVxuXHQgIH07XG5cdCAgdmFyIGN1cnJlbnRNb2R1bGUgPSBjb25maWcuY3VycmVudE1vZHVsZTtcblxuXHQgIGlmIChvYmplY3RUeXBlKGV4ZWN1dGVOb3cpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgIG1vZHVsZVN0YWNrLnB1c2gobW9kdWxlKTtcblx0ICAgIGNvbmZpZy5jdXJyZW50TW9kdWxlID0gbW9kdWxlO1xuXHQgICAgZXhlY3V0ZU5vdy5jYWxsKG1vZHVsZS50ZXN0RW52aXJvbm1lbnQsIG1vZHVsZUZucyk7XG5cdCAgICBtb2R1bGVTdGFjay5wb3AoKTtcblx0ICAgIG1vZHVsZSA9IG1vZHVsZS5wYXJlbnRNb2R1bGUgfHwgY3VycmVudE1vZHVsZTtcblx0ICB9XG5cblx0ICBjb25maWcuY3VycmVudE1vZHVsZSA9IG1vZHVsZTtcblxuXHQgIGZ1bmN0aW9uIHNldEhvb2tGcm9tRW52aXJvbm1lbnQoaG9va3MsIGVudmlyb25tZW50LCBuYW1lKSB7XG5cdCAgICB2YXIgcG90ZW50aWFsSG9vayA9IGVudmlyb25tZW50W25hbWVdO1xuXHQgICAgaG9va3NbbmFtZV0gPSB0eXBlb2YgcG90ZW50aWFsSG9vayA9PT0gXCJmdW5jdGlvblwiID8gW3BvdGVudGlhbEhvb2tdIDogW107XG5cdCAgICBkZWxldGUgZW52aXJvbm1lbnRbbmFtZV07XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc2V0SG9va0Z1bmN0aW9uKG1vZHVsZSwgaG9va05hbWUpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiBzZXRIb29rKGNhbGxiYWNrKSB7XG5cdCAgICAgIG1vZHVsZS5ob29rc1tob29rTmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdCAgICB9O1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1vZHVsZSQxKG5hbWUsIG9wdGlvbnMsIGV4ZWN1dGVOb3cpIHtcblx0ICBpZiAoZm9jdXNlZCAmJiAhaXNQYXJlbnRNb2R1bGVJblF1ZXVlKCkpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICBwcm9jZXNzTW9kdWxlKG5hbWUsIG9wdGlvbnMsIGV4ZWN1dGVOb3cpO1xuXHR9XG5cblx0bW9kdWxlJDEub25seSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoIWZvY3VzZWQpIHtcblx0ICAgIGNvbmZpZy5tb2R1bGVzLmxlbmd0aCA9IDA7XG5cdCAgICBjb25maWcucXVldWUubGVuZ3RoID0gMDtcblx0ICB9XG5cblx0ICBwcm9jZXNzTW9kdWxlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcblx0ICBmb2N1c2VkID0gdHJ1ZTtcblx0fTtcblxuXHRtb2R1bGUkMS5za2lwID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMsIGV4ZWN1dGVOb3cpIHtcblx0ICBpZiAoZm9jdXNlZCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHByb2Nlc3NNb2R1bGUobmFtZSwgb3B0aW9ucywgZXhlY3V0ZU5vdywge1xuXHQgICAgc2tpcDogdHJ1ZVxuXHQgIH0pO1xuXHR9O1xuXG5cdG1vZHVsZSQxLnRvZG8gPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucywgZXhlY3V0ZU5vdykge1xuXHQgIGlmIChmb2N1c2VkKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgcHJvY2Vzc01vZHVsZShuYW1lLCBvcHRpb25zLCBleGVjdXRlTm93LCB7XG5cdCAgICB0b2RvOiB0cnVlXG5cdCAgfSk7XG5cdH07XG5cblx0dmFyIExJU1RFTkVSUyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdHZhciBTVVBQT1JURURfRVZFTlRTID0gW1wicnVuU3RhcnRcIiwgXCJzdWl0ZVN0YXJ0XCIsIFwidGVzdFN0YXJ0XCIsIFwiYXNzZXJ0aW9uXCIsIFwidGVzdEVuZFwiLCBcInN1aXRlRW5kXCIsIFwicnVuRW5kXCJdO1xuXHQvKipcblx0ICogRW1pdHMgYW4gZXZlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgdG8gYWxsIGN1cnJlbnRseSByZWdpc3RlcmVkIGxpc3RlbmVycy5cblx0ICogQ2FsbGJhY2tzIHdpbGwgZmlyZSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmUgcmVnaXN0ZXJlZCAoRklGTykuIFRoaXNcblx0ICogZnVuY3Rpb24gaXMgbm90IGV4cG9zZWQgcHVibGljbHk7IGl0IGlzIHVzZWQgYnkgUVVuaXQgaW50ZXJuYWxzIHRvIGVtaXRcblx0ICogbG9nZ2luZyBldmVudHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBtZXRob2QgZW1pdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lLCBkYXRhKSB7XG5cdCAgaWYgKG9iamVjdFR5cGUoZXZlbnROYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV2ZW50TmFtZSBtdXN0IGJlIGEgc3RyaW5nIHdoZW4gZW1pdHRpbmcgYW4gZXZlbnRcIik7XG5cdCAgfSAvLyBDbG9uZSB0aGUgY2FsbGJhY2tzIGluIGNhc2Ugb25lIG9mIHRoZW0gcmVnaXN0ZXJzIGEgbmV3IGNhbGxiYWNrXG5cblxuXHQgIHZhciBvcmlnaW5hbENhbGxiYWNrcyA9IExJU1RFTkVSU1tldmVudE5hbWVdO1xuXHQgIHZhciBjYWxsYmFja3MgPSBvcmlnaW5hbENhbGxiYWNrcyA/IF90b0NvbnN1bWFibGVBcnJheShvcmlnaW5hbENhbGxiYWNrcykgOiBbXTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBjYWxsYmFja3NbaV0oZGF0YSk7XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBhcyBhIGxpc3RlbmVyIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICogQG1ldGhvZCBvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcblx0ICBpZiAob2JqZWN0VHlwZShldmVudE5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXZlbnROYW1lIG11c3QgYmUgYSBzdHJpbmcgd2hlbiByZWdpc3RlcmluZyBhIGxpc3RlbmVyXCIpO1xuXHQgIH0gZWxzZSBpZiAoIWluQXJyYXkoZXZlbnROYW1lLCBTVVBQT1JURURfRVZFTlRTKSkge1xuXHQgICAgdmFyIGV2ZW50cyA9IFNVUFBPUlRFRF9FVkVOVFMuam9pbihcIiwgXCIpO1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiLmNvbmNhdChldmVudE5hbWUsIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBldmVudDsgbXVzdCBiZSBvbmUgb2Y6IFwiKS5jb25jYXQoZXZlbnRzLCBcIi5cIikpO1xuXHQgIH0gZWxzZSBpZiAob2JqZWN0VHlwZShjYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbiB3aGVuIHJlZ2lzdGVyaW5nIGEgbGlzdGVuZXJcIik7XG5cdCAgfVxuXG5cdCAgaWYgKCFMSVNURU5FUlNbZXZlbnROYW1lXSkge1xuXHQgICAgTElTVEVORVJTW2V2ZW50TmFtZV0gPSBbXTtcblx0ICB9IC8vIERvbid0IHJlZ2lzdGVyIHRoZSBzYW1lIGNhbGxiYWNrIG1vcmUgdGhhbiBvbmNlXG5cblxuXHQgIGlmICghaW5BcnJheShjYWxsYmFjaywgTElTVEVORVJTW2V2ZW50TmFtZV0pKSB7XG5cdCAgICBMSVNURU5FUlNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgYmFzZWRpciwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHQgIHBhdGg6IGJhc2VkaXIsXG5cdFx0ICBleHBvcnRzOiB7fSxcblx0XHQgIHJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7XG5cdCAgICAgIHJldHVybiBjb21tb25qc1JlcXVpcmUocGF0aCwgKGJhc2UgPT09IHVuZGVmaW5lZCB8fCBiYXNlID09PSBudWxsKSA/IG1vZHVsZS5wYXRoIDogYmFzZSk7XG5cdCAgICB9XG5cdFx0fSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzJyk7XG5cdH1cblxuXHR2YXIgZXM2UHJvbWlzZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKiFcblx0ICAgKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG5cdCAgICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcblx0ICAgKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG5cdCAgICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuXHQgICAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG5cdCAgICovXG5cdCAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0ICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA7XG5cdCAgfSkoY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uICgpIHtcblxuXHQgICAgZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG5cdCAgICAgIHZhciB0eXBlID0gdHlwZW9mIHg7XG5cdCAgICAgIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG5cdCAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblx0ICAgIH1cblxuXHQgICAgdmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuXG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheSkge1xuXHQgICAgICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblx0ICAgIHZhciBsZW4gPSAwO1xuXHQgICAgdmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcblx0ICAgIHZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxuXHQgICAgdmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcblx0ICAgICAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuXHQgICAgICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcblx0ICAgICAgbGVuICs9IDI7XG5cblx0ICAgICAgaWYgKGxlbiA9PT0gMikge1xuXHQgICAgICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cblx0ICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuXHQgICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cblx0ICAgICAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcblx0ICAgICAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcblx0ICAgICAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuXHQgICAgICBhc2FwID0gYXNhcEZuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuXHQgICAgdmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xuXHQgICAgdmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblx0ICAgIHZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJzsgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcblxuXHQgICAgdmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJzsgLy8gbm9kZVxuXG5cdCAgICBmdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcblx0ICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG5cdCAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcblx0ICAgICAgfTtcblx0ICAgIH0gLy8gdmVydHhcblxuXG5cdCAgICBmdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuXHQgICAgICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdmVydHhOZXh0KGZsdXNoKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcblx0ICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXHQgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXHQgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblx0ICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7XG5cdCAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcblx0ICAgICAgfTtcblx0ICAgIH0gLy8gd2ViIHdvcmtlclxuXG5cblx0ICAgIGZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuXHQgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuXHQgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuXHQgICAgICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcblx0ICAgICAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG5cdCAgICAgIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcblxuXHQgICAgZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcblx0ICAgICAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcblx0ICAgICAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXHQgICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cdCAgICAgICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cblx0ICAgICAgbGVuID0gMDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcblxuXHQgICAgICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG5cdCAgICAgICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7IC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5cblx0ICAgIGlmIChpc05vZGUpIHtcblx0ICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG5cdCAgICB9IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG5cdCAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG5cdCAgICB9IGVsc2UgaWYgKGlzV29ya2VyKSB7XG5cdCAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuXHQgICAgfSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNvbW1vbmpzUmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG5cdCAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuXHQgICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuXHQgICAgICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cdCAgICAgIGlmIChfc3RhdGUpIHtcblx0ICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG5cdCAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcblx0ICAgICAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblx0ICAgIFxuXHQgICAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblx0ICAgICAgICByZXNvbHZlKDEpO1xuXHQgICAgICB9KTtcblx0ICAgIFxuXHQgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuXHQgICAgICAgIC8vIHZhbHVlID09PSAxXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cdCAgICBcblx0ICAgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblx0ICAgIFxuXHQgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuXHQgICAgICAgIC8vIHZhbHVlID09PSAxXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBAbWV0aG9kIHJlc29sdmVcblx0ICAgICAgQHN0YXRpY1xuXHQgICAgICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcblx0ICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuXHQgICAgICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cblx0ICAgICAgYHZhbHVlYFxuXHQgICAgKi9cblxuXG5cdCAgICBmdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG5cdCAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdCAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0ICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXHQgICAgICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG5cdCAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuXHQgICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0ICAgIHZhciBQRU5ESU5HID0gdm9pZCAwO1xuXHQgICAgdmFyIEZVTEZJTExFRCA9IDE7XG5cdCAgICB2YXIgUkVKRUNURUQgPSAyO1xuXG5cdCAgICBmdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG5cdCAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuXHQgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB0cnlUaGVuKHRoZW4kJDEsIHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB0aGVuJCQxLmNhbGwodmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICByZXR1cm4gZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4kJDEpIHtcblx0ICAgICAgYXNhcChmdW5jdGlvbiAocHJvbWlzZSkge1xuXHQgICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0cnlUaGVuKHRoZW4kJDEsIHRoZW5hYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChzZWFsZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG5cdCAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgICAgaWYgKHNlYWxlZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cdCAgICAgICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcblx0ICAgICAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG5cdCAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcblx0ICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cdCAgICAgICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgcHJvbWlzZSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG5cdCAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuXHQgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG5cdCAgICAgIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuXHQgICAgICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuXHQgICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG5cdCAgICAgICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcblx0ICAgICAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuXHQgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcblx0ICAgICAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuXHQgICAgICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG5cdCAgICAgICAgdmFyIHRoZW4kJDEgPSB2b2lkIDA7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgdGhlbiQkMSA9IHZhbHVlLnRoZW47XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG5cdCAgICAgIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG5cdCAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHVibGlzaChwcm9taXNlKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuXHQgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcblx0ICAgICAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cblx0ICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuXHQgICAgICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuXHQgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuXHQgICAgICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cdCAgICAgIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuXHQgICAgICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcblx0ICAgICAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cdCAgICAgIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cdCAgICAgIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG5cdCAgICAgIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcblx0ICAgICAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG5cdCAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuXHQgICAgICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcblx0ICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG5cdCAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cblx0ICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBjaGlsZCA9IHZvaWQgMCxcblx0ICAgICAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuXHQgICAgICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcblx0ICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuXHQgICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG5cdCAgICAgICAgaWYgKGNoaWxkKSB7XG5cdCAgICAgICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuXHQgICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcblx0ICAgICAgICAgIHZhbHVlID0gdm9pZCAwLFxuXHQgICAgICAgICAgZXJyb3IgPSB2b2lkIDAsXG5cdCAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG5cdCAgICAgICAgICBlcnJvciA9IGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG5cdCAgICAgICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YWx1ZSA9IGRldGFpbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykgOyBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcblx0ICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcblx0ICAgICAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcblx0ICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcblx0ICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcblx0ICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuXHQgICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuXHQgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcblx0ICAgICAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmVqZWN0KHByb21pc2UsIGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBpZCA9IDA7XG5cblx0ICAgIGZ1bmN0aW9uIG5leHRJZCgpIHtcblx0ICAgICAgcmV0dXJuIGlkKys7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcblx0ICAgICAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG5cdCAgICAgIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuXHQgICAgICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdCAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuXHQgICAgICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cblx0ICAgICAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuXHQgICAgICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcblx0ICAgICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHQgICAgICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXHQgICAgICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuXHQgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXG5cdCAgICAgIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG5cdCAgICAgICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cdCAgICAgICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuXHQgICAgICAgICAgdmFyIF90aGVuID0gdm9pZCAwO1xuXG5cdCAgICAgICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG5cdCAgICAgICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcblxuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG5cdCAgICAgICAgICAgIGVycm9yID0gZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG5cblx0ICAgICAgICAgICAgaWYgKGRpZEVycm9yKSB7XG5cdCAgICAgICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24gKHJlc29sdmUkJDEpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSQkMShlbnRyeSk7XG5cdCAgICAgICAgICAgIH0pLCBpKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHJlc29sdmUkJDEoZW50cnkpLCBpKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cblx0ICAgICAgRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uIF9zZXR0bGVkQXQoc3RhdGUsIGksIHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cblx0ICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcblx0ICAgICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG5cdCAgICAgICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG5cdCAgICAgICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG5cdCAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXG5cdCAgICAgIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcblx0ICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cdCAgICAgICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuXHQgICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgcmV0dXJuIEVudW1lcmF0b3I7XG5cdCAgICB9KCk7XG5cdCAgICAvKipcblx0ICAgICAgYFByb21pc2UuYWxsYCBhY2NlcHRzIGFuIGFycmF5IG9mIHByb21pc2VzLCBhbmQgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoXG5cdCAgICAgIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlcyBmb3IgdGhlIHBhc3NlZCBwcm9taXNlcywgb3Jcblx0ICAgICAgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIG9mIHRoZSBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBiZSByZWplY3RlZC4gSXQgY2FzdHMgYWxsXG5cdCAgICAgIGVsZW1lbnRzIG9mIHRoZSBwYXNzZWQgaXRlcmFibGUgdG8gcHJvbWlzZXMgYXMgaXQgcnVucyB0aGlzIGFsZ29yaXRobS5cblx0ICAgIFxuXHQgICAgICBFeGFtcGxlOlxuXHQgICAgXG5cdCAgICAgIGBgYGphdmFzY3JpcHRcblx0ICAgICAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcblx0ICAgICAgbGV0IHByb21pc2UyID0gcmVzb2x2ZSgyKTtcblx0ICAgICAgbGV0IHByb21pc2UzID0gcmVzb2x2ZSgzKTtcblx0ICAgICAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cdCAgICBcblx0ICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuXHQgICAgICAgIC8vIFRoZSBhcnJheSBoZXJlIHdvdWxkIGJlIFsgMSwgMiwgMyBdO1xuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICBcblx0ICAgICAgSWYgYW55IG9mIHRoZSBgcHJvbWlzZXNgIGdpdmVuIHRvIGBhbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2Vcblx0ICAgICAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG5cdCAgICAgIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblx0ICAgIFxuXHQgICAgICBFeGFtcGxlOlxuXHQgICAgXG5cdCAgICAgIGBgYGphdmFzY3JpcHRcblx0ICAgICAgbGV0IHByb21pc2UxID0gcmVzb2x2ZSgxKTtcblx0ICAgICAgbGV0IHByb21pc2UyID0gcmVqZWN0KG5ldyBFcnJvcihcIjJcIikpO1xuXHQgICAgICBsZXQgcHJvbWlzZTMgPSByZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG5cdCAgICAgIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXHQgICAgXG5cdCAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcblx0ICAgICAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcblx0ICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICBcblx0ICAgICAgQG1ldGhvZCBhbGxcblx0ICAgICAgQHN0YXRpY1xuXHQgICAgICBAcGFyYW0ge0FycmF5fSBlbnRyaWVzIGFycmF5IG9mIHByb21pc2VzXG5cdCAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuXHQgICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG5cdCAgICAgIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgYHByb21pc2VzYCBoYXZlIGJlZW5cblx0ICAgICAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuXG5cdCAgICAgIEBzdGF0aWNcblx0ICAgICovXG5cblxuXHQgICAgZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuXHQgICAgICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cdCAgICBcblx0ICAgICAgRXhhbXBsZTpcblx0ICAgIFxuXHQgICAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICAgIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG5cdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG5cdCAgICAgICAgfSwgMjAwKTtcblx0ICAgICAgfSk7XG5cdCAgICBcblx0ICAgICAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcblx0ICAgICAgICB9LCAxMDApO1xuXHQgICAgICB9KTtcblx0ICAgIFxuXHQgICAgICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcblx0ICAgICAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuXHQgICAgICAgIC8vIHdhcyByZXNvbHZlZC5cblx0ICAgICAgfSk7XG5cdCAgICAgIGBgYFxuXHQgICAgXG5cdCAgICAgIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3Rcblx0ICAgICAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuXHQgICAgICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG5cdCAgICAgIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuXHQgICAgICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXHQgICAgXG5cdCAgICAgIGBgYGphdmFzY3JpcHRcblx0ICAgICAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcblx0ICAgICAgICB9LCAyMDApO1xuXHQgICAgICB9KTtcblx0ICAgIFxuXHQgICAgICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuXHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0ICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcblx0ICAgICAgICB9LCAxMDApO1xuXHQgICAgICB9KTtcblx0ICAgIFxuXHQgICAgICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcblx0ICAgICAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuXHQgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG5cdCAgICAgICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcblx0ICAgICAgfSk7XG5cdCAgICAgIGBgYFxuXHQgICAgXG5cdCAgICAgIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cdCAgICBcblx0ICAgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBAbWV0aG9kIHJhY2Vcblx0ICAgICAgQHN0YXRpY1xuXHQgICAgICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG5cdCAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgICAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcblx0ICAgICAgcHJvbWlzZSB0byBzZXR0bGUuXG5cdCAgICAqL1xuXG5cblx0ICAgIGZ1bmN0aW9uIHJhY2UoZW50cmllcykge1xuXHQgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXHQgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG5cdCAgICAgIGlmICghaXNBcnJheShlbnRyaWVzKSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKF8sIHJlamVjdCkge1xuXHQgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAgYFByb21pc2UucmVqZWN0YCByZXR1cm5zIGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWQgYHJlYXNvbmAuXG5cdCAgICAgIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblx0ICAgIFxuXHQgICAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcblx0ICAgICAgICByZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cdCAgICAgIH0pO1xuXHQgICAgXG5cdCAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG5cdCAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG5cdCAgICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cdCAgICBcblx0ICAgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuXHQgICAgXG5cdCAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgICAgLy8gQ29kZSBoZXJlIGRvZXNuJ3QgcnVuIGJlY2F1c2UgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQhXG5cdCAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG5cdCAgICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdXSE9PUFMnXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBAbWV0aG9kIHJlamVjdFxuXHQgICAgICBAc3RhdGljXG5cdCAgICAgIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG5cdCAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgICAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGByZWFzb25gLlxuXHQgICAgKi9cblxuXG5cdCAgICBmdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcblx0ICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0ICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblx0ICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cdCAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuXHQgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBuZWVkc05ldygpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG5cdCAgICAgIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG5cdCAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuXHQgICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblx0ICAgIFxuXHQgICAgICBUZXJtaW5vbG9neVxuXHQgICAgICAtLS0tLS0tLS0tLVxuXHQgICAgXG5cdCAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG5cdCAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cblx0ICAgICAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuXHQgICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cblx0ICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuXHQgICAgICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblx0ICAgIFxuXHQgICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cdCAgICBcblx0ICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcblx0ICAgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuXHQgICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblx0ICAgIFxuXHQgICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcblx0ICAgICAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuXHQgICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcblx0ICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuXHQgICAgICBpdHNlbGYgZnVsZmlsbC5cblx0ICAgIFxuXHQgICAgXG5cdCAgICAgIEJhc2ljIFVzYWdlOlxuXHQgICAgICAtLS0tLS0tLS0tLS1cblx0ICAgIFxuXHQgICAgICBgYGBqc1xuXHQgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIC8vIG9uIHN1Y2Nlc3Ncblx0ICAgICAgICByZXNvbHZlKHZhbHVlKTtcblx0ICAgIFxuXHQgICAgICAgIC8vIG9uIGZhaWx1cmVcblx0ICAgICAgICByZWplY3QocmVhc29uKTtcblx0ICAgICAgfSk7XG5cdCAgICBcblx0ICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcblx0ICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG5cdCAgICAgICAgLy8gb24gcmVqZWN0aW9uXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgIFxuXHQgICAgICBBZHZhbmNlZCBVc2FnZTpcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cdCAgICBcblx0ICAgICAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuXHQgICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblx0ICAgIFxuXHQgICAgICBgYGBqc1xuXHQgICAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuXHQgICAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHQgICAgXG5cdCAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcblx0ICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuXHQgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHQgICAgICAgICAgeGhyLnNlbmQoKTtcblx0ICAgIFxuXHQgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG5cdCAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICBcblx0ICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcblx0ICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuXHQgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcblx0ICAgICAgICAvLyBvbiByZWplY3Rpb25cblx0ICAgICAgfSk7XG5cdCAgICAgIGBgYFxuXHQgICAgXG5cdCAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cdCAgICBcblx0ICAgICAgYGBganNcblx0ICAgICAgUHJvbWlzZS5hbGwoW1xuXHQgICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuXHQgICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG5cdCAgICAgIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcblx0ICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG5cdCAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXHQgICAgXG5cdCAgICAgICAgcmV0dXJuIHZhbHVlcztcblx0ICAgICAgfSk7XG5cdCAgICAgIGBgYFxuXHQgICAgXG5cdCAgICAgIEBjbGFzcyBQcm9taXNlXG5cdCAgICAgIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG5cdCAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgICAgQGNvbnN0cnVjdG9yXG5cdCAgICAqL1xuXG5cblx0ICAgIHZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcblx0ICAgICAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG5cdCAgICAgICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuXHQgICAgICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuXHQgICAgICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcblx0ICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLyoqXG5cdCAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuXHQgICAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuXHQgICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cdCAgICAgICBgYGBqc1xuXHQgICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG5cdCAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcblx0ICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcblx0ICAgICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICAgICBDaGFpbmluZ1xuXHQgICAgICAtLS0tLS0tLVxuXHQgICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcblx0ICAgICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuXHQgICAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblx0ICAgICAgIGBgYGpzXG5cdCAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuXHQgICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG5cdCAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICAgICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG5cdCAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG5cdCAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuXHQgICAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuXHQgICAgICB9KTtcblx0ICAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuXHQgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG5cdCAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG5cdCAgICAgICBgYGBqc1xuXHQgICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG5cdCAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuXHQgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcblx0ICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHQgICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgICAgIEFzc2ltaWxhdGlvblxuXHQgICAgICAtLS0tLS0tLS0tLS1cblx0ICAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG5cdCAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcblx0ICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcblx0ICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cdCAgICAgICBgYGBqc1xuXHQgICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcblx0ICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG5cdCAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG5cdCAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblx0ICAgICAgIGBgYGpzXG5cdCAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuXHQgICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcblx0ICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcblx0ICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG5cdCAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcblx0ICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgICAgIFNpbXBsZSBFeGFtcGxlXG5cdCAgICAgIC0tLS0tLS0tLS0tLS0tXG5cdCAgICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cdCAgICAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICAgIGxldCByZXN1bHQ7XG5cdCAgICAgICB0cnkge1xuXHQgICAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcblx0ICAgICAgICAvLyBzdWNjZXNzXG5cdCAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG5cdCAgICAgICAgLy8gZmFpbHVyZVxuXHQgICAgICB9XG5cdCAgICAgIGBgYFxuXHQgICAgICAgRXJyYmFjayBFeGFtcGxlXG5cdCAgICAgICBgYGBqc1xuXHQgICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAvLyBmYWlsdXJlXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIHN1Y2Nlc3Ncblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgICAgIFByb21pc2UgRXhhbXBsZTtcblx0ICAgICAgIGBgYGphdmFzY3JpcHRcblx0ICAgICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcblx0ICAgICAgICAvLyBzdWNjZXNzXG5cdCAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG5cdCAgICAgICAgLy8gZmFpbHVyZVxuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICAgICBBZHZhbmNlZCBFeGFtcGxlXG5cdCAgICAgIC0tLS0tLS0tLS0tLS0tXG5cdCAgICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cdCAgICAgICBgYGBqYXZhc2NyaXB0XG5cdCAgICAgIGxldCBhdXRob3IsIGJvb2tzO1xuXHQgICAgICAgdHJ5IHtcblx0ICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG5cdCAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcblx0ICAgICAgICAvLyBzdWNjZXNzXG5cdCAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG5cdCAgICAgICAgLy8gZmFpbHVyZVxuXHQgICAgICB9XG5cdCAgICAgIGBgYFxuXHQgICAgICAgRXJyYmFjayBFeGFtcGxlXG5cdCAgICAgICBgYGBqc1xuXHQgICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXHQgICAgICAgfVxuXHQgICAgICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcblx0ICAgICAgIH1cblx0ICAgICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuXHQgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgIGZhaWx1cmUoZXJyKTtcblx0ICAgICAgICAgIC8vIGZhaWx1cmVcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuXHQgICAgICAgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuXHQgICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcblx0ICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgLy8gc3VjY2Vzc1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIGBgYFxuXHQgICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXHQgICAgICAgYGBgamF2YXNjcmlwdFxuXHQgICAgICBmaW5kQXV0aG9yKCkuXG5cdCAgICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG5cdCAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG5cdCAgICAgICAgICAvLyBmb3VuZCBib29rc1xuXHQgICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG5cdCAgICAgIH0pO1xuXHQgICAgICBgYGBcblx0ICAgICAgIEBtZXRob2QgdGhlblxuXHQgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuXHQgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG5cdCAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cblx0ICAgICAgQHJldHVybiB7UHJvbWlzZX1cblx0ICAgICAgKi9cblxuXHQgICAgICAvKipcblx0ICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuXHQgICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXHQgICAgICBgYGBqc1xuXHQgICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHN5bmNocm9ub3VzXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgIGZpbmRBdXRob3IoKTtcblx0ICAgICAgfSBjYXRjaChyZWFzb24pIHtcblx0ICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3Jvbmdcblx0ICAgICAgfVxuXHQgICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG5cdCAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuXHQgICAgICB9KTtcblx0ICAgICAgYGBgXG5cdCAgICAgIEBtZXRob2QgY2F0Y2hcblx0ICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cblx0ICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuXHQgICAgICBAcmV0dXJuIHtQcm9taXNlfVxuXHQgICAgICAqL1xuXG5cblx0ICAgICAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcblx0ICAgICAgfTtcblx0ICAgICAgLyoqXG5cdCAgICAgICAgYGZpbmFsbHlgIHdpbGwgYmUgaW52b2tlZCByZWdhcmRsZXNzIG9mIHRoZSBwcm9taXNlJ3MgZmF0ZSBqdXN0IGFzIG5hdGl2ZVxuXHQgICAgICAgIHRyeS9jYXRjaC9maW5hbGx5IGJlaGF2ZXNcblx0ICAgICAgXG5cdCAgICAgICAgU3luY2hyb25vdXMgZXhhbXBsZTpcblx0ICAgICAgXG5cdCAgICAgICAgYGBganNcblx0ICAgICAgICBmaW5kQXV0aG9yKCkge1xuXHQgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXR1cm4gbmV3IEF1dGhvcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHJldHVybiBmaW5kQXV0aG9yKCk7IC8vIHN1Y2NlZWQgb3IgZmFpbFxuXHQgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcblx0ICAgICAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcblx0ICAgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgICAgLy8gYWx3YXlzIHJ1bnNcblx0ICAgICAgICAgIC8vIGRvZXNuJ3QgYWZmZWN0IHRoZSByZXR1cm4gdmFsdWVcblx0ICAgICAgICB9XG5cdCAgICAgICAgYGBgXG5cdCAgICAgIFxuXHQgICAgICAgIEFzeW5jaHJvbm91cyBleGFtcGxlOlxuXHQgICAgICBcblx0ICAgICAgICBgYGBqc1xuXHQgICAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuXHQgICAgICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuXHQgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKXtcblx0ICAgICAgICAgIC8vIGF1dGhvciB3YXMgZWl0aGVyIGZvdW5kLCBvciBub3Rcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBgYGBcblx0ICAgICAgXG5cdCAgICAgICAgQG1ldGhvZCBmaW5hbGx5XG5cdCAgICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICAgICAgICBAcmV0dXJuIHtQcm9taXNlfVxuXHQgICAgICAqL1xuXG5cblx0ICAgICAgUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzO1xuXHQgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb21pc2UuY29uc3RydWN0b3I7XG5cblx0ICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0ICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgIHRocm93IHJlYXNvbjtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgcmV0dXJuIFByb21pc2U7XG5cdCAgICB9KCk7XG5cblx0ICAgIFByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5cdCAgICBQcm9taXNlJDEuYWxsID0gYWxsO1xuXHQgICAgUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuXHQgICAgUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5cdCAgICBQcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5cdCAgICBQcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblx0ICAgIFByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5cdCAgICBQcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXHQgICAgLypnbG9iYWwgc2VsZiovXG5cblx0ICAgIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuXHQgICAgICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cblx0ICAgICAgaWYgKHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICBsb2NhbCA9IGNvbW1vbmpzR2xvYmFsO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIGxvY2FsID0gc2VsZjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG5cdCAgICAgIGlmIChQKSB7XG5cdCAgICAgICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7Ly8gc2lsZW50bHkgaWdub3JlZFxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcblx0ICAgIH0gLy8gU3RyYW5nZSBjb21wYXQuLlxuXG5cblx0ICAgIFByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuXHQgICAgUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cdCAgICByZXR1cm4gUHJvbWlzZSQxO1xuXHQgIH0pO1xuXHR9KTtcblxuXHR2YXIgUHJvbWlzZSQxID0gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgPyBQcm9taXNlIDogZXM2UHJvbWlzZTtcblxuXHRmdW5jdGlvbiByZWdpc3RlckxvZ2dpbmdDYWxsYmFja3Mob2JqKSB7XG5cdCAgdmFyIGksXG5cdCAgICAgIGwsXG5cdCAgICAgIGtleSxcblx0ICAgICAgY2FsbGJhY2tOYW1lcyA9IFtcImJlZ2luXCIsIFwiZG9uZVwiLCBcImxvZ1wiLCBcInRlc3RTdGFydFwiLCBcInRlc3REb25lXCIsIFwibW9kdWxlU3RhcnRcIiwgXCJtb2R1bGVEb25lXCJdO1xuXG5cdCAgZnVuY3Rpb24gcmVnaXN0ZXJMb2dnaW5nQ2FsbGJhY2soa2V5KSB7XG5cdCAgICB2YXIgbG9nZ2luZ0NhbGxiYWNrID0gZnVuY3Rpb24gbG9nZ2luZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG5cdCAgICAgIGlmIChvYmplY3RUeXBlKGNhbGxiYWNrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUVVuaXQgbG9nZ2luZyBtZXRob2RzIHJlcXVpcmUgYSBjYWxsYmFjayBmdW5jdGlvbiBhcyB0aGVpciBmaXJzdCBwYXJhbWV0ZXJzLlwiKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbmZpZy5jYWxsYmFja3Nba2V5XS5wdXNoKGNhbGxiYWNrKTtcblx0ICAgIH07XG5cblx0ICAgIHJldHVybiBsb2dnaW5nQ2FsbGJhY2s7XG5cdCAgfVxuXG5cdCAgZm9yIChpID0gMCwgbCA9IGNhbGxiYWNrTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBrZXkgPSBjYWxsYmFja05hbWVzW2ldOyAvLyBJbml0aWFsaXplIGtleSBjb2xsZWN0aW9uIG9mIGxvZ2dpbmcgY2FsbGJhY2tcblxuXHQgICAgaWYgKG9iamVjdFR5cGUoY29uZmlnLmNhbGxiYWNrc1trZXldKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICBjb25maWcuY2FsbGJhY2tzW2tleV0gPSBbXTtcblx0ICAgIH1cblxuXHQgICAgb2JqW2tleV0gPSByZWdpc3RlckxvZ2dpbmdDYWxsYmFjayhrZXkpO1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBydW5Mb2dnaW5nQ2FsbGJhY2tzKGtleSwgYXJncykge1xuXHQgIHZhciBjYWxsYmFja3MgPSBjb25maWcuY2FsbGJhY2tzW2tleV07IC8vIEhhbmRsaW5nICdsb2cnIGNhbGxiYWNrcyBzZXBhcmF0ZWx5LiBVbmxpa2UgdGhlIG90aGVyIGNhbGxiYWNrcyxcblx0ICAvLyB0aGUgbG9nIGNhbGxiYWNrIGlzIG5vdCBjb250cm9sbGVkIGJ5IHRoZSBwcm9jZXNzaW5nIHF1ZXVlLFxuXHQgIC8vIGJ1dCByYXRoZXIgdXNlZCBieSBhc3NlcnRzLiBIZW5jZSB0byBwcm9taXNmeSB0aGUgJ2xvZycgY2FsbGJhY2tcblx0ICAvLyB3b3VsZCBtZWFuIHByb21pc2Z5aW5nIGVhY2ggc3RlcCBvZiBhIHRlc3RcblxuXHQgIGlmIChrZXkgPT09IFwibG9nXCIpIHtcblx0ICAgIGNhbGxiYWNrcy5tYXAoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgIHJldHVybiBjYWxsYmFjayhhcmdzKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gLy8gZW5zdXJlIHRoYXQgZWFjaCBjYWxsYmFjayBpcyBleGVjdXRlZCBzZXJpYWxseVxuXG5cblx0ICByZXR1cm4gY2FsbGJhY2tzLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZUNoYWluLCBjYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIHByb21pc2VDaGFpbi50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKGNhbGxiYWNrKGFyZ3MpKTtcblx0ICAgIH0pO1xuXHQgIH0sIFByb21pc2UkMS5yZXNvbHZlKFtdKSk7XG5cdH1cblxuXHQvLyBEb2Vzbid0IHN1cHBvcnQgSUU5LCBpdCB3aWxsIHJldHVybiB1bmRlZmluZWQgb24gdGhlc2UgYnJvd3NlcnNcblx0Ly8gU2VlIGFsc28gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IvU3RhY2tcblx0dmFyIGZpbGVOYW1lID0gKHNvdXJjZUZyb21TdGFja3RyYWNlKDApIHx8IFwiXCIpLnJlcGxhY2UoLyg6XFxkKykrXFwpPy8sIFwiXCIpLnJlcGxhY2UoLy4rXFwvLywgXCJcIik7XG5cdGZ1bmN0aW9uIGV4dHJhY3RTdGFja3RyYWNlKGUsIG9mZnNldCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA9PT0gdW5kZWZpbmVkID8gNCA6IG9mZnNldDtcblx0ICB2YXIgc3RhY2ssIGluY2x1ZGUsIGk7XG5cblx0ICBpZiAoZSAmJiBlLnN0YWNrKSB7XG5cdCAgICBzdGFjayA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG5cblx0ICAgIGlmICgvXmVycm9yJC9pLnRlc3Qoc3RhY2tbMF0pKSB7XG5cdCAgICAgIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmaWxlTmFtZSkge1xuXHQgICAgICBpbmNsdWRlID0gW107XG5cblx0ICAgICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoc3RhY2tbaV0uaW5kZXhPZihmaWxlTmFtZSkgIT09IC0xKSB7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpbmNsdWRlLnB1c2goc3RhY2tbaV0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGluY2x1ZGUubGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIGluY2x1ZGUuam9pbihcIlxcblwiKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc3RhY2tbb2Zmc2V0XTtcblx0ICB9XG5cdH1cblx0ZnVuY3Rpb24gc291cmNlRnJvbVN0YWNrdHJhY2Uob2Zmc2V0KSB7XG5cdCAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7IC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgb25seSwgSUUgPD0xMCAtIDExIG9ubHlcblx0ICAvLyBOb3QgYWxsIGJyb3dzZXJzIGdlbmVyYXRlIHRoZSBgc3RhY2tgIHByb3BlcnR5IGZvciBgbmV3IEVycm9yKClgLCBzZWUgYWxzbyAjNjM2XG5cblx0ICBpZiAoIWVycm9yLnN0YWNrKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICBlcnJvciA9IGVycjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZXh0cmFjdFN0YWNrdHJhY2UoZXJyb3IsIG9mZnNldCk7XG5cdH1cblxuXHR2YXIgcHJpb3JpdHlDb3VudCA9IDA7XG5cdHZhciB1bml0U2FtcGxlcjsgLy8gVGhpcyBpcyBhIHF1ZXVlIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0YXNrcyB3aXRoaW4gYSBzaW5nbGUgdGVzdC5cblx0Ly8gQWZ0ZXIgdGVzdHMgYXJlIGRlcXVldWVkIGZyb20gY29uZmlnLnF1ZXVlIHRoZXkgYXJlIGV4cGFuZGVkIGludG9cblx0Ly8gYSBzZXQgb2YgdGFza3MgaW4gdGhpcyBxdWV1ZS5cblxuXHR2YXIgdGFza1F1ZXVlID0gW107XG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgdGFza1F1ZXVlIHRvIHRoZSBuZXh0IHRhc2suIElmIHRoZSB0YXNrUXVldWUgaXMgZW1wdHksXG5cdCAqIHByb2Nlc3MgdGhlIHRlc3RRdWV1ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBhZHZhbmNlKCkge1xuXHQgIGFkdmFuY2VUYXNrUXVldWUoKTtcblxuXHQgIGlmICghdGFza1F1ZXVlLmxlbmd0aCAmJiAhY29uZmlnLmJsb2NraW5nICYmICFjb25maWcuY3VycmVudCkge1xuXHQgICAgYWR2YW5jZVRlc3RRdWV1ZSgpO1xuXHQgIH1cblx0fVxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHRhc2tRdWV1ZSB3aXRoIGFuIGluY3JlYXNlZCBkZXB0aFxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGFkdmFuY2VUYXNrUXVldWUoKSB7XG5cdCAgdmFyIHN0YXJ0ID0gbm93KCk7XG5cdCAgY29uZmlnLmRlcHRoID0gKGNvbmZpZy5kZXB0aCB8fCAwKSArIDE7XG5cdCAgcHJvY2Vzc1Rhc2tRdWV1ZShzdGFydCk7XG5cdCAgY29uZmlnLmRlcHRoLS07XG5cdH1cblx0LyoqXG5cdCAqIFByb2Nlc3MgdGhlIGZpcnN0IHRhc2sgb24gdGhlIHRhc2tRdWV1ZSBhcyBhIHByb21pc2UuXG5cdCAqIEVhY2ggdGFzayBpcyBhIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9xdW5pdGpzL3F1bml0L2Jsb2IvbWFzdGVyL3NyYy90ZXN0LmpzI0wzODFcblx0ICovXG5cblxuXHRmdW5jdGlvbiBwcm9jZXNzVGFza1F1ZXVlKHN0YXJ0KSB7XG5cdCAgaWYgKHRhc2tRdWV1ZS5sZW5ndGggJiYgIWNvbmZpZy5ibG9ja2luZykge1xuXHQgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBzdGFydDtcblxuXHQgICAgaWYgKCFkZWZpbmVkLnNldFRpbWVvdXQgfHwgY29uZmlnLnVwZGF0ZVJhdGUgPD0gMCB8fCBlbGFwc2VkVGltZSA8IGNvbmZpZy51cGRhdGVSYXRlKSB7XG5cdCAgICAgIHZhciB0YXNrID0gdGFza1F1ZXVlLnNoaWZ0KCk7XG5cdCAgICAgIFByb21pc2UkMS5yZXNvbHZlKHRhc2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCF0YXNrUXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgICBhZHZhbmNlKCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHByb2Nlc3NUYXNrUXVldWUoc3RhcnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzZXRUaW1lb3V0JDEoYWR2YW5jZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBBZHZhbmNlIHRoZSB0ZXN0UXVldWUgdG8gdGhlIG5leHQgdGVzdCB0byBwcm9jZXNzLiBDYWxsIGRvbmUoKSBpZiB0ZXN0UXVldWUgY29tcGxldGVzLlxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGFkdmFuY2VUZXN0UXVldWUoKSB7XG5cdCAgaWYgKCFjb25maWcuYmxvY2tpbmcgJiYgIWNvbmZpZy5xdWV1ZS5sZW5ndGggJiYgY29uZmlnLmRlcHRoID09PSAwKSB7XG5cdCAgICBkb25lKCk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIHRlc3RUYXNrcyA9IGNvbmZpZy5xdWV1ZS5zaGlmdCgpO1xuXHQgIGFkZFRvVGFza1F1ZXVlKHRlc3RUYXNrcygpKTtcblxuXHQgIGlmIChwcmlvcml0eUNvdW50ID4gMCkge1xuXHQgICAgcHJpb3JpdHlDb3VudC0tO1xuXHQgIH1cblxuXHQgIGFkdmFuY2UoKTtcblx0fVxuXHQvKipcblx0ICogRW5xdWV1ZSB0aGUgdGFza3MgZm9yIGEgdGVzdCBpbnRvIHRoZSB0YXNrIHF1ZXVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXNrc0FycmF5XG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gYWRkVG9UYXNrUXVldWUodGFza3NBcnJheSkge1xuXHQgIHRhc2tRdWV1ZS5wdXNoLmFwcGx5KHRhc2tRdWV1ZSwgX3RvQ29uc3VtYWJsZUFycmF5KHRhc2tzQXJyYXkpKTtcblx0fVxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBudW1iZXIgb2YgdGFza3MgcmVtYWluaW5nIGluIHRoZSB0YXNrIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZC5cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIHRhc2tRdWV1ZUxlbmd0aCgpIHtcblx0ICByZXR1cm4gdGFza1F1ZXVlLmxlbmd0aDtcblx0fVxuXHQvKipcblx0ICogQWRkcyBhIHRlc3QgdG8gdGhlIFRlc3RRdWV1ZSBmb3IgZXhlY3V0aW9uLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0VGFza3NGdW5jXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJpb3JpdGl6ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc2VlZFxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGFkZFRvVGVzdFF1ZXVlKHRlc3RUYXNrc0Z1bmMsIHByaW9yaXRpemUsIHNlZWQpIHtcblx0ICBpZiAocHJpb3JpdGl6ZSkge1xuXHQgICAgY29uZmlnLnF1ZXVlLnNwbGljZShwcmlvcml0eUNvdW50KyssIDAsIHRlc3RUYXNrc0Z1bmMpO1xuXHQgIH0gZWxzZSBpZiAoc2VlZCkge1xuXHQgICAgaWYgKCF1bml0U2FtcGxlcikge1xuXHQgICAgICB1bml0U2FtcGxlciA9IHVuaXRTYW1wbGVyR2VuZXJhdG9yKHNlZWQpO1xuXHQgICAgfSAvLyBJbnNlcnQgaW50byBhIHJhbmRvbSBwb3NpdGlvbiBhZnRlciBhbGwgcHJpb3JpdGl6ZWQgaXRlbXNcblxuXG5cdCAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKHVuaXRTYW1wbGVyKCkgKiAoY29uZmlnLnF1ZXVlLmxlbmd0aCAtIHByaW9yaXR5Q291bnQgKyAxKSk7XG5cdCAgICBjb25maWcucXVldWUuc3BsaWNlKHByaW9yaXR5Q291bnQgKyBpbmRleCwgMCwgdGVzdFRhc2tzRnVuYyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGNvbmZpZy5xdWV1ZS5wdXNoKHRlc3RUYXNrc0Z1bmMpO1xuXHQgIH1cblx0fVxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHNlZWRlZCBcInNhbXBsZVwiIGdlbmVyYXRvciB3aGljaCBpcyB1c2VkIGZvciByYW5kb21pemluZyB0ZXN0cy5cblx0ICovXG5cblxuXHRmdW5jdGlvbiB1bml0U2FtcGxlckdlbmVyYXRvcihzZWVkKSB7XG5cdCAgLy8gMzItYml0IHhvcnNoaWZ0LCByZXF1aXJlcyBvbmx5IGEgbm9uemVybyBzZWVkXG5cdCAgLy8gaHR0cHM6Ly9leGNhbWVyYS5jb20vc3BoaW54L2FydGljbGUteG9yc2hpZnQuaHRtbFxuXHQgIHZhciBzYW1wbGUgPSBwYXJzZUludChnZW5lcmF0ZUhhc2goc2VlZCksIDE2KSB8fCAtMTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgc2FtcGxlIF49IHNhbXBsZSA8PCAxMztcblx0ICAgIHNhbXBsZSBePSBzYW1wbGUgPj4+IDE3O1xuXHQgICAgc2FtcGxlIF49IHNhbXBsZSA8PCA1OyAvLyBFQ01BU2NyaXB0IGhhcyBubyB1bnNpZ25lZCBudW1iZXIgdHlwZVxuXG5cdCAgICBpZiAoc2FtcGxlIDwgMCkge1xuXHQgICAgICBzYW1wbGUgKz0gMHgxMDAwMDAwMDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzYW1wbGUgLyAweDEwMDAwMDAwMDtcblx0ICB9O1xuXHR9XG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBQcm9jZXNzaW5nUXVldWUgaXMgZG9uZSBwcm9jZXNzaW5nIGFsbFxuXHQgKiBpdGVtcy4gSXQgaGFuZGxlcyBlbWl0dGluZyB0aGUgZmluYWwgcnVuIGV2ZW50cy5cblx0ICovXG5cblxuXHRmdW5jdGlvbiBkb25lKCkge1xuXHQgIHZhciBzdG9yYWdlID0gY29uZmlnLnN0b3JhZ2U7XG5cdCAgUHJvY2Vzc2luZ1F1ZXVlLmZpbmlzaGVkID0gdHJ1ZTtcblx0ICB2YXIgcnVudGltZSA9IG5vdygpIC0gY29uZmlnLnN0YXJ0ZWQ7XG5cdCAgdmFyIHBhc3NlZCA9IGNvbmZpZy5zdGF0cy5hbGwgLSBjb25maWcuc3RhdHMuYmFkO1xuXG5cdCAgaWYgKGNvbmZpZy5zdGF0cy50ZXN0Q291bnQgPT09IDApIHtcblx0ICAgIGlmIChjb25maWcuZmlsdGVyICYmIGNvbmZpZy5maWx0ZXIubGVuZ3RoKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRlc3RzIG1hdGNoZWQgdGhlIGZpbHRlciBcXFwiXCIuY29uY2F0KGNvbmZpZy5maWx0ZXIsIFwiXFxcIi5cIikpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29uZmlnLm1vZHVsZSAmJiBjb25maWcubW9kdWxlLmxlbmd0aCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0ZXN0cyBtYXRjaGVkIHRoZSBtb2R1bGUgXFxcIlwiLmNvbmNhdChjb25maWcubW9kdWxlLCBcIlxcXCIuXCIpKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbmZpZy5tb2R1bGVJZCAmJiBjb25maWcubW9kdWxlSWQubGVuZ3RoKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRlc3RzIG1hdGNoZWQgdGhlIG1vZHVsZUlkIFxcXCJcIi5jb25jYXQoY29uZmlnLm1vZHVsZUlkLCBcIlxcXCIuXCIpKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbmZpZy50ZXN0SWQgJiYgY29uZmlnLnRlc3RJZC5sZW5ndGgpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGVzdHMgbWF0Y2hlZCB0aGUgdGVzdElkIFxcXCJcIi5jb25jYXQoY29uZmlnLnRlc3RJZCwgXCJcXFwiLlwiKSk7XG5cdCAgICB9XG5cblx0ICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRlc3RzIHdlcmUgcnVuLlwiKTtcblx0ICB9XG5cblx0ICBlbWl0KFwicnVuRW5kXCIsIGdsb2JhbFN1aXRlLmVuZCh0cnVlKSk7XG5cdCAgcnVuTG9nZ2luZ0NhbGxiYWNrcyhcImRvbmVcIiwge1xuXHQgICAgcGFzc2VkOiBwYXNzZWQsXG5cdCAgICBmYWlsZWQ6IGNvbmZpZy5zdGF0cy5iYWQsXG5cdCAgICB0b3RhbDogY29uZmlnLnN0YXRzLmFsbCxcblx0ICAgIHJ1bnRpbWU6IHJ1bnRpbWVcblx0ICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENsZWFyIG93biBzdG9yYWdlIGl0ZW1zIGlmIGFsbCB0ZXN0cyBwYXNzZWRcblx0ICAgIGlmIChzdG9yYWdlICYmIGNvbmZpZy5zdGF0cy5iYWQgPT09IDApIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IHN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICB2YXIga2V5ID0gc3RvcmFnZS5rZXkoaSk7XG5cblx0ICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCJxdW5pdC10ZXN0LVwiKSA9PT0gMCkge1xuXHQgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdH1cblxuXHR2YXIgUHJvY2Vzc2luZ1F1ZXVlID0ge1xuXHQgIGZpbmlzaGVkOiBmYWxzZSxcblx0ICBhZGQ6IGFkZFRvVGVzdFF1ZXVlLFxuXHQgIGFkdmFuY2U6IGFkdmFuY2UsXG5cdCAgdGFza0NvdW50OiB0YXNrUXVldWVMZW5ndGhcblx0fTtcblxuXHR2YXIgVGVzdFJlcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gVGVzdFJlcG9ydChuYW1lLCBzdWl0ZSwgb3B0aW9ucykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRlc3RSZXBvcnQpO1xuXG5cdCAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgdGhpcy5zdWl0ZU5hbWUgPSBzdWl0ZS5uYW1lO1xuXHQgICAgdGhpcy5mdWxsTmFtZSA9IHN1aXRlLmZ1bGxOYW1lLmNvbmNhdChuYW1lKTtcblx0ICAgIHRoaXMucnVudGltZSA9IDA7XG5cdCAgICB0aGlzLmFzc2VydGlvbnMgPSBbXTtcblx0ICAgIHRoaXMuc2tpcHBlZCA9ICEhb3B0aW9ucy5za2lwO1xuXHQgICAgdGhpcy50b2RvID0gISFvcHRpb25zLnRvZG87XG5cdCAgICB0aGlzLnZhbGlkID0gb3B0aW9ucy52YWxpZDtcblx0ICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG5cdCAgICB0aGlzLl9lbmRUaW1lID0gMDtcblx0ICAgIHN1aXRlLnB1c2hUZXN0KHRoaXMpO1xuXHQgIH1cblxuXHQgIF9jcmVhdGVDbGFzcyhUZXN0UmVwb3J0LCBbe1xuXHQgICAga2V5OiBcInN0YXJ0XCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQocmVjb3JkVGltZSkge1xuXHQgICAgICBpZiAocmVjb3JkVGltZSkge1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cblx0ICAgICAgICBpZiAocGVyZm9ybWFuY2UpIHtcblx0ICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJxdW5pdF90ZXN0X3N0YXJ0XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuXHQgICAgICAgIHN1aXRlTmFtZTogdGhpcy5zdWl0ZU5hbWUsXG5cdCAgICAgICAgZnVsbE5hbWU6IHRoaXMuZnVsbE5hbWUuc2xpY2UoKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJlbmRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQocmVjb3JkVGltZSkge1xuXHQgICAgICBpZiAocmVjb3JkVGltZSkge1xuXHQgICAgICAgIHRoaXMuX2VuZFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG5cdCAgICAgICAgaWYgKHBlcmZvcm1hbmNlKSB7XG5cdCAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKFwicXVuaXRfdGVzdF9lbmRcIik7XG5cdCAgICAgICAgICB2YXIgdGVzdE5hbWUgPSB0aGlzLmZ1bGxOYW1lLmpvaW4oXCIg4oCTIFwiKTtcblx0ICAgICAgICAgIG1lYXN1cmUoXCJRVW5pdCBUZXN0OiBcIi5jb25jYXQodGVzdE5hbWUpLCBcInF1bml0X3Rlc3Rfc3RhcnRcIiwgXCJxdW5pdF90ZXN0X2VuZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuc3RhcnQoKSwge1xuXHQgICAgICAgIHJ1bnRpbWU6IHRoaXMuZ2V0UnVudGltZSgpLFxuXHQgICAgICAgIHN0YXR1czogdGhpcy5nZXRTdGF0dXMoKSxcblx0ICAgICAgICBlcnJvcnM6IHRoaXMuZ2V0RmFpbGVkQXNzZXJ0aW9ucygpLFxuXHQgICAgICAgIGFzc2VydGlvbnM6IHRoaXMuZ2V0QXNzZXJ0aW9ucygpXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJwdXNoQXNzZXJ0aW9uXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaEFzc2VydGlvbihhc3NlcnRpb24pIHtcblx0ICAgICAgdGhpcy5hc3NlcnRpb25zLnB1c2goYXNzZXJ0aW9uKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZ2V0UnVudGltZVwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bnRpbWUoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9lbmRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJnZXRTdGF0dXNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG5cdCAgICAgIGlmICh0aGlzLnNraXBwZWQpIHtcblx0ICAgICAgICByZXR1cm4gXCJza2lwcGVkXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdGVzdFBhc3NlZCA9IHRoaXMuZ2V0RmFpbGVkQXNzZXJ0aW9ucygpLmxlbmd0aCA+IDAgPyB0aGlzLnRvZG8gOiAhdGhpcy50b2RvO1xuXG5cdCAgICAgIGlmICghdGVzdFBhc3NlZCkge1xuXHQgICAgICAgIHJldHVybiBcImZhaWxlZFwiO1xuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMudG9kbykge1xuXHQgICAgICAgIHJldHVybiBcInRvZG9cIjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gXCJwYXNzZWRcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJnZXRGYWlsZWRBc3NlcnRpb25zXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmFpbGVkQXNzZXJ0aW9ucygpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFzc2VydGlvbikge1xuXHQgICAgICAgIHJldHVybiAhYXNzZXJ0aW9uLnBhc3NlZDtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImdldEFzc2VydGlvbnNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBc3NlcnRpb25zKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5hc3NlcnRpb25zLnNsaWNlKCk7XG5cdCAgICB9IC8vIFJlbW92ZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyBmcm9tIGFzc2VydGlvbnMuIFRoaXMgaXMgdG8gcHJldmVudFxuXHQgICAgLy8gbGVha2luZyBtZW1vcnkgdGhyb3VnaG91dCBhIHRlc3Qgc3VpdGUuXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwic2xpbUFzc2VydGlvbnNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzbGltQXNzZXJ0aW9ucygpIHtcblx0ICAgICAgdGhpcy5hc3NlcnRpb25zID0gdGhpcy5hc3NlcnRpb25zLm1hcChmdW5jdGlvbiAoYXNzZXJ0aW9uKSB7XG5cdCAgICAgICAgZGVsZXRlIGFzc2VydGlvbi5hY3R1YWw7XG5cdCAgICAgICAgZGVsZXRlIGFzc2VydGlvbi5leHBlY3RlZDtcblx0ICAgICAgICByZXR1cm4gYXNzZXJ0aW9uO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gVGVzdFJlcG9ydDtcblx0fSgpO1xuXG5cdHZhciBmb2N1c2VkJDEgPSBmYWxzZTtcblx0ZnVuY3Rpb24gVGVzdChzZXR0aW5ncykge1xuXHQgIHZhciBpLCBsO1xuXHQgICsrVGVzdC5jb3VudDtcblx0ICB0aGlzLmV4cGVjdGVkID0gbnVsbDtcblx0ICB0aGlzLmFzc2VydGlvbnMgPSBbXTtcblx0ICB0aGlzLnNlbWFwaG9yZSA9IDA7XG5cdCAgdGhpcy5tb2R1bGUgPSBjb25maWcuY3VycmVudE1vZHVsZTtcblx0ICB0aGlzLnN0ZXBzID0gW107XG5cdCAgdGhpcy50aW1lb3V0ID0gdW5kZWZpbmVkO1xuXHQgIHRoaXMuZXJyb3JGb3JTdGFjayA9IG5ldyBFcnJvcigpOyAvLyBJZiBhIG1vZHVsZSBpcyBza2lwcGVkLCBhbGwgaXRzIHRlc3RzIGFuZCB0aGUgdGVzdHMgb2YgdGhlIGNoaWxkIHN1aXRlc1xuXHQgIC8vIHNob3VsZCBiZSB0cmVhdGVkIGFzIHNraXBwZWQgZXZlbiBpZiB0aGV5IGFyZSBkZWZpbmVkIGFzIGBvbmx5YCBvciBgdG9kb2AuXG5cdCAgLy8gQXMgZm9yIGB0b2RvYCBtb2R1bGUsIGFsbCBpdHMgdGVzdHMgd2lsbCBiZSB0cmVhdGVkIGFzIGB0b2RvYCBleGNlcHQgZm9yXG5cdCAgLy8gdGVzdHMgZGVmaW5lZCBhcyBgc2tpcGAgd2hpY2ggd2lsbCBiZSBsZWZ0IGludGFjdC5cblx0ICAvL1xuXHQgIC8vIFNvLCBpZiBhIHRlc3QgaXMgZGVmaW5lZCBhcyBgdG9kb2AgYW5kIGlzIGluc2lkZSBhIHNraXBwZWQgbW9kdWxlLCB3ZSBzaG91bGRcblx0ICAvLyB0aGVuIHRyZWF0IHRoYXQgdGVzdCBhcyBpZiB3YXMgZGVmaW5lZCBhcyBgc2tpcGAuXG5cblx0ICBpZiAodGhpcy5tb2R1bGUuc2tpcCkge1xuXHQgICAgc2V0dGluZ3Muc2tpcCA9IHRydWU7XG5cdCAgICBzZXR0aW5ncy50b2RvID0gZmFsc2U7IC8vIFNraXBwZWQgdGVzdHMgc2hvdWxkIGJlIGxlZnQgaW50YWN0XG5cdCAgfSBlbHNlIGlmICh0aGlzLm1vZHVsZS50b2RvICYmICFzZXR0aW5ncy5za2lwKSB7XG5cdCAgICBzZXR0aW5ncy50b2RvID0gdHJ1ZTtcblx0ICB9XG5cblx0ICBleHRlbmQodGhpcywgc2V0dGluZ3MpO1xuXHQgIHRoaXMudGVzdFJlcG9ydCA9IG5ldyBUZXN0UmVwb3J0KHNldHRpbmdzLnRlc3ROYW1lLCB0aGlzLm1vZHVsZS5zdWl0ZVJlcG9ydCwge1xuXHQgICAgdG9kbzogc2V0dGluZ3MudG9kbyxcblx0ICAgIHNraXA6IHNldHRpbmdzLnNraXAsXG5cdCAgICB2YWxpZDogdGhpcy52YWxpZCgpXG5cdCAgfSk7IC8vIFJlZ2lzdGVyIHVuaXF1ZSBzdHJpbmdzXG5cblx0ICBmb3IgKGkgPSAwLCBsID0gdGhpcy5tb2R1bGUudGVzdHM7IGkgPCBsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAodGhpcy5tb2R1bGUudGVzdHNbaV0ubmFtZSA9PT0gdGhpcy50ZXN0TmFtZSkge1xuXHQgICAgICB0aGlzLnRlc3ROYW1lICs9IFwiIFwiO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHRoaXMudGVzdElkID0gZ2VuZXJhdGVIYXNoKHRoaXMubW9kdWxlLm5hbWUsIHRoaXMudGVzdE5hbWUpO1xuXHQgIHRoaXMubW9kdWxlLnRlc3RzLnB1c2goe1xuXHQgICAgbmFtZTogdGhpcy50ZXN0TmFtZSxcblx0ICAgIHRlc3RJZDogdGhpcy50ZXN0SWQsXG5cdCAgICBza2lwOiAhIXNldHRpbmdzLnNraXBcblx0ICB9KTtcblxuXHQgIGlmIChzZXR0aW5ncy5za2lwKSB7XG5cdCAgICAvLyBTa2lwcGVkIHRlc3RzIHdpbGwgZnVsbHkgaWdub3JlIGFueSBzZW50IGNhbGxiYWNrXG5cdCAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cblx0ICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcblx0ICAgIHRoaXMuZXhwZWN0ZWQgPSAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAodHlwZW9mIHRoaXMuY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB2YXIgbWV0aG9kID0gdGhpcy50b2RvID8gXCJ0b2RvXCIgOiBcInRlc3RcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblxuXHQgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uIGFzIGEgdGVzdCBjYWxsYmFjayB0byBRVW5pdC5cIi5jb25jYXQobWV0aG9kLCBcIihcXFwiXCIpLmNvbmNhdChzZXR0aW5ncy50ZXN0TmFtZSwgXCJcXFwiKVwiKSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYXNzZXJ0ID0gbmV3IEFzc2VydCh0aGlzKTtcblx0ICB9XG5cdH1cblx0VGVzdC5jb3VudCA9IDA7XG5cblx0ZnVuY3Rpb24gZ2V0Tm90U3RhcnRlZE1vZHVsZXMoc3RhcnRNb2R1bGUpIHtcblx0ICB2YXIgbW9kdWxlID0gc3RhcnRNb2R1bGUsXG5cdCAgICAgIG1vZHVsZXMgPSBbXTtcblxuXHQgIHdoaWxlIChtb2R1bGUgJiYgbW9kdWxlLnRlc3RzUnVuID09PSAwKSB7XG5cdCAgICBtb2R1bGVzLnB1c2gobW9kdWxlKTtcblx0ICAgIG1vZHVsZSA9IG1vZHVsZS5wYXJlbnRNb2R1bGU7XG5cdCAgfSAvLyBUaGUgYWJvdmUgcHVzaCBtb2R1bGVzIGZyb20gdGhlIGNoaWxkIHRvIHRoZSBwYXJlbnRcblx0ICAvLyByZXR1cm4gYSByZXZlcnNlZCBvcmRlciB3aXRoIHRoZSB0b3AgYmVpbmcgdGhlIHRvcCBtb3N0IHBhcmVudCBtb2R1bGVcblxuXG5cdCAgcmV0dXJuIG1vZHVsZXMucmV2ZXJzZSgpO1xuXHR9XG5cblx0VGVzdC5wcm90b3R5cGUgPSB7XG5cdCAgLy8gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlIGNhbiBiZSBleHBlbnNpdmUsIHNvIHVzaW5nIGEgZ2V0dGVyIGRlZmVycyB0aGlzIHVudGlsIHdlIG5lZWQgaXRcblx0ICBnZXQgc3RhY2soKSB7XG5cdCAgICByZXR1cm4gZXh0cmFjdFN0YWNrdHJhY2UodGhpcy5lcnJvckZvclN0YWNrLCAyKTtcblx0ICB9LFxuXG5cdCAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICB2YXIgbW9kdWxlID0gdGhpcy5tb2R1bGUsXG5cdCAgICAgICAgbm90U3RhcnRlZE1vZHVsZXMgPSBnZXROb3RTdGFydGVkTW9kdWxlcyhtb2R1bGUpOyAvLyBlbnN1cmUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWQgc2VyaWFsbHkgZm9yIGVhY2ggbW9kdWxlXG5cblx0ICAgIHZhciBjYWxsYmFja1Byb21pc2VzID0gbm90U3RhcnRlZE1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChwcm9taXNlQ2hhaW4sIHN0YXJ0TW9kdWxlKSB7XG5cdCAgICAgIHJldHVybiBwcm9taXNlQ2hhaW4udGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc3RhcnRNb2R1bGUuc3RhdHMgPSB7XG5cdCAgICAgICAgICBhbGw6IDAsXG5cdCAgICAgICAgICBiYWQ6IDAsXG5cdCAgICAgICAgICBzdGFydGVkOiBub3coKVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgZW1pdChcInN1aXRlU3RhcnRcIiwgc3RhcnRNb2R1bGUuc3VpdGVSZXBvcnQuc3RhcnQodHJ1ZSkpO1xuXHQgICAgICAgIHJldHVybiBydW5Mb2dnaW5nQ2FsbGJhY2tzKFwibW9kdWxlU3RhcnRcIiwge1xuXHQgICAgICAgICAgbmFtZTogc3RhcnRNb2R1bGUubmFtZSxcblx0ICAgICAgICAgIHRlc3RzOiBzdGFydE1vZHVsZS50ZXN0c1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgIH0sIFByb21pc2UkMS5yZXNvbHZlKFtdKSk7XG5cdCAgICByZXR1cm4gY2FsbGJhY2tQcm9taXNlcy50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgY29uZmlnLmN1cnJlbnQgPSBfdGhpcztcblx0ICAgICAgX3RoaXMudGVzdEVudmlyb25tZW50ID0gZXh0ZW5kKHt9LCBtb2R1bGUudGVzdEVudmlyb25tZW50KTtcblx0ICAgICAgX3RoaXMuc3RhcnRlZCA9IG5vdygpO1xuXHQgICAgICBlbWl0KFwidGVzdFN0YXJ0XCIsIF90aGlzLnRlc3RSZXBvcnQuc3RhcnQodHJ1ZSkpO1xuXHQgICAgICByZXR1cm4gcnVuTG9nZ2luZ0NhbGxiYWNrcyhcInRlc3RTdGFydFwiLCB7XG5cdCAgICAgICAgbmFtZTogX3RoaXMudGVzdE5hbWUsXG5cdCAgICAgICAgbW9kdWxlOiBtb2R1bGUubmFtZSxcblx0ICAgICAgICB0ZXN0SWQ6IF90aGlzLnRlc3RJZCxcblx0ICAgICAgICBwcmV2aW91c0ZhaWx1cmU6IF90aGlzLnByZXZpb3VzRmFpbHVyZVxuXHQgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIWNvbmZpZy5wb2xsdXRpb24pIHtcblx0ICAgICAgICAgIHNhdmVHbG9iYWwoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBydW46IGZ1bmN0aW9uIHJ1bigpIHtcblx0ICAgIHZhciBwcm9taXNlO1xuXHQgICAgY29uZmlnLmN1cnJlbnQgPSB0aGlzO1xuXHQgICAgdGhpcy5jYWxsYmFja1N0YXJ0ZWQgPSBub3coKTtcblxuXHQgICAgaWYgKGNvbmZpZy5ub3RyeWNhdGNoKSB7XG5cdCAgICAgIHJ1blRlc3QodGhpcyk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdHJ5IHtcblx0ICAgICAgcnVuVGVzdCh0aGlzKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgdGhpcy5wdXNoRmFpbHVyZShcIkRpZWQgb24gdGVzdCAjXCIgKyAodGhpcy5hc3NlcnRpb25zLmxlbmd0aCArIDEpICsgXCIgXCIgKyB0aGlzLnN0YWNrICsgXCI6IFwiICsgKGUubWVzc2FnZSB8fCBlKSwgZXh0cmFjdFN0YWNrdHJhY2UoZSwgMCkpOyAvLyBFbHNlIG5leHQgdGVzdCB3aWxsIGNhcnJ5IHRoZSByZXNwb25zaWJpbGl0eVxuXG5cdCAgICAgIHNhdmVHbG9iYWwoKTsgLy8gUmVzdGFydCB0aGUgdGVzdHMgaWYgdGhleSdyZSBibG9ja2luZ1xuXG5cdCAgICAgIGlmIChjb25maWcuYmxvY2tpbmcpIHtcblx0ICAgICAgICBpbnRlcm5hbFJlY292ZXIodGhpcyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcnVuVGVzdCh0ZXN0KSB7XG5cdCAgICAgIHByb21pc2UgPSB0ZXN0LmNhbGxiYWNrLmNhbGwodGVzdC50ZXN0RW52aXJvbm1lbnQsIHRlc3QuYXNzZXJ0KTtcblx0ICAgICAgdGVzdC5yZXNvbHZlUHJvbWlzZShwcm9taXNlKTsgLy8gSWYgdGhlIHRlc3QgaGFzIGEgXCJsb2NrXCIgb24gaXQsIGJ1dCB0aGUgdGltZW91dCBpcyAwLCB0aGVuIHdlIHB1c2ggYVxuXHQgICAgICAvLyBmYWlsdXJlIGFzIHRoZSB0ZXN0IHNob3VsZCBiZSBzeW5jaHJvbm91cy5cblxuXHQgICAgICBpZiAodGVzdC50aW1lb3V0ID09PSAwICYmIHRlc3Quc2VtYXBob3JlICE9PSAwKSB7XG5cdCAgICAgICAgcHVzaEZhaWx1cmUoXCJUZXN0IGRpZCBub3QgZmluaXNoIHN5bmNocm9ub3VzbHkgZXZlbiB0aG91Z2ggYXNzZXJ0LnRpbWVvdXQoIDAgKSB3YXMgdXNlZC5cIiwgc291cmNlRnJvbVN0YWNrdHJhY2UoMikpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoKSB7XG5cdCAgICBjaGVja1BvbGx1dGlvbigpO1xuXHQgIH0sXG5cdCAgcXVldWVIb29rOiBmdW5jdGlvbiBxdWV1ZUhvb2soaG9vaywgaG9va05hbWUsIGhvb2tPd25lcikge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHZhciBjYWxsSG9vayA9IGZ1bmN0aW9uIGNhbGxIb29rKCkge1xuXHQgICAgICB2YXIgcHJvbWlzZSA9IGhvb2suY2FsbChfdGhpczIudGVzdEVudmlyb25tZW50LCBfdGhpczIuYXNzZXJ0KTtcblxuXHQgICAgICBfdGhpczIucmVzb2x2ZVByb21pc2UocHJvbWlzZSwgaG9va05hbWUpO1xuXHQgICAgfTtcblxuXHQgICAgdmFyIHJ1bkhvb2sgPSBmdW5jdGlvbiBydW5Ib29rKCkge1xuXHQgICAgICBpZiAoaG9va05hbWUgPT09IFwiYmVmb3JlXCIpIHtcblx0ICAgICAgICBpZiAoaG9va093bmVyLnVuc2tpcHBlZFRlc3RzUnVuICE9PSAwKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgX3RoaXMyLnByZXNlcnZlRW52aXJvbm1lbnQgPSB0cnVlO1xuXHQgICAgICB9IC8vIFRoZSAnYWZ0ZXInIGhvb2sgc2hvdWxkIG9ubHkgZXhlY3V0ZSB3aGVuIHRoZXJlIGFyZSBub3QgdGVzdHMgbGVmdCBhbmRcblx0ICAgICAgLy8gd2hlbiB0aGUgJ2FmdGVyJyBhbmQgJ2ZpbmlzaCcgdGFza3MgYXJlIHRoZSBvbmx5IHRhc2tzIGxlZnQgdG8gcHJvY2Vzc1xuXG5cblx0ICAgICAgaWYgKGhvb2tOYW1lID09PSBcImFmdGVyXCIgJiYgaG9va093bmVyLnVuc2tpcHBlZFRlc3RzUnVuICE9PSBudW1iZXJPZlVuc2tpcHBlZFRlc3RzKGhvb2tPd25lcikgLSAxICYmIChjb25maWcucXVldWUubGVuZ3RoID4gMCB8fCBQcm9jZXNzaW5nUXVldWUudGFza0NvdW50KCkgPiAyKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbmZpZy5jdXJyZW50ID0gX3RoaXMyO1xuXG5cdCAgICAgIGlmIChjb25maWcubm90cnljYXRjaCkge1xuXHQgICAgICAgIGNhbGxIb29rKCk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBjYWxsSG9vaygpO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIF90aGlzMi5wdXNoRmFpbHVyZShob29rTmFtZSArIFwiIGZhaWxlZCBvbiBcIiArIF90aGlzMi50ZXN0TmFtZSArIFwiOiBcIiArIChlcnJvci5tZXNzYWdlIHx8IGVycm9yKSwgZXh0cmFjdFN0YWNrdHJhY2UoZXJyb3IsIDApKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIHJ1bkhvb2s7XG5cdCAgfSxcblx0ICAvLyBDdXJyZW50bHkgb25seSB1c2VkIGZvciBtb2R1bGUgbGV2ZWwgaG9va3MsIGNhbiBiZSB1c2VkIHRvIGFkZCBnbG9iYWwgbGV2ZWwgb25lc1xuXHQgIGhvb2tzOiBmdW5jdGlvbiBob29rcyhoYW5kbGVyKSB7XG5cdCAgICB2YXIgaG9va3MgPSBbXTtcblxuXHQgICAgZnVuY3Rpb24gcHJvY2Vzc0hvb2tzKHRlc3QsIG1vZHVsZSkge1xuXHQgICAgICBpZiAobW9kdWxlLnBhcmVudE1vZHVsZSkge1xuXHQgICAgICAgIHByb2Nlc3NIb29rcyh0ZXN0LCBtb2R1bGUucGFyZW50TW9kdWxlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtb2R1bGUuaG9va3NbaGFuZGxlcl0ubGVuZ3RoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUuaG9va3NbaGFuZGxlcl0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGhvb2tzLnB1c2godGVzdC5xdWV1ZUhvb2sobW9kdWxlLmhvb2tzW2hhbmRsZXJdW2ldLCBoYW5kbGVyLCBtb2R1bGUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gSG9va3MgYXJlIGlnbm9yZWQgb24gc2tpcHBlZCB0ZXN0c1xuXG5cblx0ICAgIGlmICghdGhpcy5za2lwKSB7XG5cdCAgICAgIHByb2Nlc3NIb29rcyh0aGlzLCB0aGlzLm1vZHVsZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBob29rcztcblx0ICB9LFxuXHQgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKCkge1xuXHQgICAgY29uZmlnLmN1cnJlbnQgPSB0aGlzOyAvLyBSZWxlYXNlIHRoZSB0ZXN0IGNhbGxiYWNrIHRvIGVuc3VyZSB0aGF0IGFueXRoaW5nIHJlZmVyZW5jZWQgaGFzIGJlZW5cblx0ICAgIC8vIHJlbGVhc2VkIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG5cdCAgICB0aGlzLmNhbGxiYWNrID0gdW5kZWZpbmVkO1xuXG5cdCAgICBpZiAodGhpcy5zdGVwcy5sZW5ndGgpIHtcblx0ICAgICAgdmFyIHN0ZXBzTGlzdCA9IHRoaXMuc3RlcHMuam9pbihcIiwgXCIpO1xuXHQgICAgICB0aGlzLnB1c2hGYWlsdXJlKFwiRXhwZWN0ZWQgYXNzZXJ0LnZlcmlmeVN0ZXBzKCkgdG8gYmUgY2FsbGVkIGJlZm9yZSBlbmQgb2YgdGVzdCBcIiArIFwiYWZ0ZXIgdXNpbmcgYXNzZXJ0LnN0ZXAoKS4gVW52ZXJpZmllZCBzdGVwczogXCIuY29uY2F0KHN0ZXBzTGlzdCksIHRoaXMuc3RhY2spO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29uZmlnLnJlcXVpcmVFeHBlY3RzICYmIHRoaXMuZXhwZWN0ZWQgPT09IG51bGwpIHtcblx0ICAgICAgdGhpcy5wdXNoRmFpbHVyZShcIkV4cGVjdGVkIG51bWJlciBvZiBhc3NlcnRpb25zIHRvIGJlIGRlZmluZWQsIGJ1dCBleHBlY3QoKSB3YXMgXCIgKyBcIm5vdCBjYWxsZWQuXCIsIHRoaXMuc3RhY2spO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmV4cGVjdGVkICE9PSBudWxsICYmIHRoaXMuZXhwZWN0ZWQgIT09IHRoaXMuYXNzZXJ0aW9ucy5sZW5ndGgpIHtcblx0ICAgICAgdGhpcy5wdXNoRmFpbHVyZShcIkV4cGVjdGVkIFwiICsgdGhpcy5leHBlY3RlZCArIFwiIGFzc2VydGlvbnMsIGJ1dCBcIiArIHRoaXMuYXNzZXJ0aW9ucy5sZW5ndGggKyBcIiB3ZXJlIHJ1blwiLCB0aGlzLnN0YWNrKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5leHBlY3RlZCA9PT0gbnVsbCAmJiAhdGhpcy5hc3NlcnRpb25zLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLnB1c2hGYWlsdXJlKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFzc2VydGlvbiwgYnV0IG5vbmUgd2VyZSBydW4gLSBjYWxsIFwiICsgXCJleHBlY3QoMCkgdG8gYWNjZXB0IHplcm8gYXNzZXJ0aW9ucy5cIiwgdGhpcy5zdGFjayk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBpLFxuXHQgICAgICAgIG1vZHVsZSA9IHRoaXMubW9kdWxlLFxuXHQgICAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGUubmFtZSxcblx0ICAgICAgICB0ZXN0TmFtZSA9IHRoaXMudGVzdE5hbWUsXG5cdCAgICAgICAgc2tpcHBlZCA9ICEhdGhpcy5za2lwLFxuXHQgICAgICAgIHRvZG8gPSAhIXRoaXMudG9kbyxcblx0ICAgICAgICBiYWQgPSAwLFxuXHQgICAgICAgIHN0b3JhZ2UgPSBjb25maWcuc3RvcmFnZTtcblx0ICAgIHRoaXMucnVudGltZSA9IG5vdygpIC0gdGhpcy5zdGFydGVkO1xuXHQgICAgY29uZmlnLnN0YXRzLmFsbCArPSB0aGlzLmFzc2VydGlvbnMubGVuZ3RoO1xuXHQgICAgY29uZmlnLnN0YXRzLnRlc3RDb3VudCArPSAxO1xuXHQgICAgbW9kdWxlLnN0YXRzLmFsbCArPSB0aGlzLmFzc2VydGlvbnMubGVuZ3RoO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5hc3NlcnRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICghdGhpcy5hc3NlcnRpb25zW2ldLnJlc3VsdCkge1xuXHQgICAgICAgIGJhZCsrO1xuXHQgICAgICAgIGNvbmZpZy5zdGF0cy5iYWQrKztcblx0ICAgICAgICBtb2R1bGUuc3RhdHMuYmFkKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbm90aWZ5VGVzdHNSYW4obW9kdWxlLCBza2lwcGVkKTsgLy8gU3RvcmUgcmVzdWx0IHdoZW4gcG9zc2libGVcblxuXHQgICAgaWYgKHN0b3JhZ2UpIHtcblx0ICAgICAgaWYgKGJhZCkge1xuXHQgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShcInF1bml0LXRlc3QtXCIgKyBtb2R1bGVOYW1lICsgXCItXCIgKyB0ZXN0TmFtZSwgYmFkKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oXCJxdW5pdC10ZXN0LVwiICsgbW9kdWxlTmFtZSArIFwiLVwiICsgdGVzdE5hbWUpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIEFmdGVyIGVtaXR0aW5nIHRoZSBqcy1yZXBvcnRlcnMgZXZlbnQgd2UgY2xlYW51cCB0aGUgYXNzZXJ0aW9uIGRhdGEgdG9cblx0ICAgIC8vIGF2b2lkIGxlYWtpbmcgaXQuIEl0IGlzIG5vdCB1c2VkIGJ5IHRoZSBsZWdhY3kgdGVzdERvbmUgY2FsbGJhY2tzLlxuXG5cblx0ICAgIGVtaXQoXCJ0ZXN0RW5kXCIsIHRoaXMudGVzdFJlcG9ydC5lbmQodHJ1ZSkpO1xuXHQgICAgdGhpcy50ZXN0UmVwb3J0LnNsaW1Bc3NlcnRpb25zKCk7XG5cdCAgICB2YXIgdGVzdCA9IHRoaXM7XG5cdCAgICByZXR1cm4gcnVuTG9nZ2luZ0NhbGxiYWNrcyhcInRlc3REb25lXCIsIHtcblx0ICAgICAgbmFtZTogdGVzdE5hbWUsXG5cdCAgICAgIG1vZHVsZTogbW9kdWxlTmFtZSxcblx0ICAgICAgc2tpcHBlZDogc2tpcHBlZCxcblx0ICAgICAgdG9kbzogdG9kbyxcblx0ICAgICAgZmFpbGVkOiBiYWQsXG5cdCAgICAgIHBhc3NlZDogdGhpcy5hc3NlcnRpb25zLmxlbmd0aCAtIGJhZCxcblx0ICAgICAgdG90YWw6IHRoaXMuYXNzZXJ0aW9ucy5sZW5ndGgsXG5cdCAgICAgIHJ1bnRpbWU6IHNraXBwZWQgPyAwIDogdGhpcy5ydW50aW1lLFxuXHQgICAgICAvLyBIVE1MIFJlcG9ydGVyIHVzZVxuXHQgICAgICBhc3NlcnRpb25zOiB0aGlzLmFzc2VydGlvbnMsXG5cdCAgICAgIHRlc3RJZDogdGhpcy50ZXN0SWQsXG5cblx0ICAgICAgLy8gU291cmNlIG9mIFRlc3Rcblx0ICAgICAgLy8gZ2VuZXJhdGluZyBzdGFjayB0cmFjZSBpcyBleHBlbnNpdmUsIHNvIHVzaW5nIGEgZ2V0dGVyIHdpbGwgaGVscCBkZWZlciB0aGlzIHVudGlsIHdlIG5lZWQgaXRcblx0ICAgICAgZ2V0IHNvdXJjZSgpIHtcblx0ICAgICAgICByZXR1cm4gdGVzdC5zdGFjaztcblx0ICAgICAgfVxuXG5cdCAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKG1vZHVsZS50ZXN0c1J1biA9PT0gbnVtYmVyT2ZUZXN0cyhtb2R1bGUpKSB7XG5cdCAgICAgICAgdmFyIGNvbXBsZXRlZE1vZHVsZXMgPSBbbW9kdWxlXTsgLy8gQ2hlY2sgaWYgdGhlIHBhcmVudCBtb2R1bGVzLCBpdGVyYXRpdmVseSwgYXJlIGRvbmUuIElmIHRoYXQgdGhlIGNhc2UsXG5cdCAgICAgICAgLy8gd2UgZW1pdCB0aGUgYHN1aXRlRW5kYCBldmVudCBhbmQgdHJpZ2dlciBgbW9kdWxlRG9uZWAgY2FsbGJhY2suXG5cblx0ICAgICAgICB2YXIgcGFyZW50ID0gbW9kdWxlLnBhcmVudE1vZHVsZTtcblxuXHQgICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnRlc3RzUnVuID09PSBudW1iZXJPZlRlc3RzKHBhcmVudCkpIHtcblx0ICAgICAgICAgIGNvbXBsZXRlZE1vZHVsZXMucHVzaChwYXJlbnQpO1xuXHQgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE1vZHVsZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gY29tcGxldGVkTW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByb21pc2VDaGFpbiwgY29tcGxldGVkTW9kdWxlKSB7XG5cdCAgICAgICAgICByZXR1cm4gcHJvbWlzZUNoYWluLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbG9nU3VpdGVFbmQoY29tcGxldGVkTW9kdWxlKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sIFByb21pc2UkMS5yZXNvbHZlKFtdKSk7XG5cdCAgICAgIH1cblx0ICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICBjb25maWcuY3VycmVudCA9IHVuZGVmaW5lZDtcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBsb2dTdWl0ZUVuZChtb2R1bGUpIHtcblx0ICAgICAgLy8gUmVzZXQgYG1vZHVsZS5ob29rc2AgdG8gZW5zdXJlIHRoYXQgYW55dGhpbmcgcmVmZXJlbmNlZCBpbiB0aGVzZSBob29rc1xuXHQgICAgICAvLyBoYXMgYmVlbiByZWxlYXNlZCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cblx0ICAgICAgbW9kdWxlLmhvb2tzID0ge307XG5cdCAgICAgIGVtaXQoXCJzdWl0ZUVuZFwiLCBtb2R1bGUuc3VpdGVSZXBvcnQuZW5kKHRydWUpKTtcblx0ICAgICAgcmV0dXJuIHJ1bkxvZ2dpbmdDYWxsYmFja3MoXCJtb2R1bGVEb25lXCIsIHtcblx0ICAgICAgICBuYW1lOiBtb2R1bGUubmFtZSxcblx0ICAgICAgICB0ZXN0czogbW9kdWxlLnRlc3RzLFxuXHQgICAgICAgIGZhaWxlZDogbW9kdWxlLnN0YXRzLmJhZCxcblx0ICAgICAgICBwYXNzZWQ6IG1vZHVsZS5zdGF0cy5hbGwgLSBtb2R1bGUuc3RhdHMuYmFkLFxuXHQgICAgICAgIHRvdGFsOiBtb2R1bGUuc3RhdHMuYWxsLFxuXHQgICAgICAgIHJ1bnRpbWU6IG5vdygpIC0gbW9kdWxlLnN0YXRzLnN0YXJ0ZWRcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBwcmVzZXJ2ZVRlc3RFbnZpcm9ubWVudDogZnVuY3Rpb24gcHJlc2VydmVUZXN0RW52aXJvbm1lbnQoKSB7XG5cdCAgICBpZiAodGhpcy5wcmVzZXJ2ZUVudmlyb25tZW50KSB7XG5cdCAgICAgIHRoaXMubW9kdWxlLnRlc3RFbnZpcm9ubWVudCA9IHRoaXMudGVzdEVudmlyb25tZW50O1xuXHQgICAgICB0aGlzLnRlc3RFbnZpcm9ubWVudCA9IGV4dGVuZCh7fSwgdGhpcy5tb2R1bGUudGVzdEVudmlyb25tZW50KTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZSgpIHtcblx0ICAgIHZhciB0ZXN0ID0gdGhpcztcblxuXHQgICAgaWYgKCF0aGlzLnZhbGlkKCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBydW5UZXN0KCkge1xuXHQgICAgICByZXR1cm4gW2Z1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGVzdC5iZWZvcmUoKTtcblx0ICAgICAgfV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0ZXN0Lmhvb2tzKFwiYmVmb3JlXCIpKSwgW2Z1bmN0aW9uICgpIHtcblx0ICAgICAgICB0ZXN0LnByZXNlcnZlVGVzdEVudmlyb25tZW50KCk7XG5cdCAgICAgIH1dLCBfdG9Db25zdW1hYmxlQXJyYXkodGVzdC5ob29rcyhcImJlZm9yZUVhY2hcIikpLCBbZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRlc3QucnVuKCk7XG5cdCAgICAgIH1dLCBfdG9Db25zdW1hYmxlQXJyYXkodGVzdC5ob29rcyhcImFmdGVyRWFjaFwiKS5yZXZlcnNlKCkpLCBfdG9Db25zdW1hYmxlQXJyYXkodGVzdC5ob29rcyhcImFmdGVyXCIpLnJldmVyc2UoKSksIFtmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGVzdC5hZnRlcigpO1xuXHQgICAgICB9LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRlc3QuZmluaXNoKCk7XG5cdCAgICAgIH1dKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByZXZpb3VzRmFpbENvdW50ID0gY29uZmlnLnN0b3JhZ2UgJiYgK2NvbmZpZy5zdG9yYWdlLmdldEl0ZW0oXCJxdW5pdC10ZXN0LVwiICsgdGhpcy5tb2R1bGUubmFtZSArIFwiLVwiICsgdGhpcy50ZXN0TmFtZSk7IC8vIFByaW9yaXRpemUgcHJldmlvdXNseSBmYWlsZWQgdGVzdHMsIGRldGVjdGVkIGZyb20gc3RvcmFnZVxuXG5cdCAgICB2YXIgcHJpb3JpdGl6ZSA9IGNvbmZpZy5yZW9yZGVyICYmICEhcHJldmlvdXNGYWlsQ291bnQ7XG5cdCAgICB0aGlzLnByZXZpb3VzRmFpbHVyZSA9ICEhcHJldmlvdXNGYWlsQ291bnQ7XG5cdCAgICBQcm9jZXNzaW5nUXVldWUuYWRkKHJ1blRlc3QsIHByaW9yaXRpemUsIGNvbmZpZy5zZWVkKTsgLy8gSWYgdGhlIHF1ZXVlIGhhcyBhbHJlYWR5IGZpbmlzaGVkLCB3ZSBtYW51YWxseSBwcm9jZXNzIHRoZSBuZXcgdGVzdFxuXG5cdCAgICBpZiAoUHJvY2Vzc2luZ1F1ZXVlLmZpbmlzaGVkKSB7XG5cdCAgICAgIFByb2Nlc3NpbmdRdWV1ZS5hZHZhbmNlKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBwdXNoUmVzdWx0OiBmdW5jdGlvbiBwdXNoUmVzdWx0KHJlc3VsdEluZm8pIHtcblx0ICAgIGlmICh0aGlzICE9PSBjb25maWcuY3VycmVudCkge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gb2NjdXJyZWQgYWZ0ZXIgdGVzdCBoYWQgZmluaXNoZWQuXCIpO1xuXHQgICAgfSAvLyBEZXN0cnVjdHVyZSBvZiByZXN1bHRJbmZvID0geyByZXN1bHQsIGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG5lZ2F0aXZlIH1cblxuXG5cdCAgICB2YXIgc291cmNlLFxuXHQgICAgICAgIGRldGFpbHMgPSB7XG5cdCAgICAgIG1vZHVsZTogdGhpcy5tb2R1bGUubmFtZSxcblx0ICAgICAgbmFtZTogdGhpcy50ZXN0TmFtZSxcblx0ICAgICAgcmVzdWx0OiByZXN1bHRJbmZvLnJlc3VsdCxcblx0ICAgICAgbWVzc2FnZTogcmVzdWx0SW5mby5tZXNzYWdlLFxuXHQgICAgICBhY3R1YWw6IHJlc3VsdEluZm8uYWN0dWFsLFxuXHQgICAgICB0ZXN0SWQ6IHRoaXMudGVzdElkLFxuXHQgICAgICBuZWdhdGl2ZTogcmVzdWx0SW5mby5uZWdhdGl2ZSB8fCBmYWxzZSxcblx0ICAgICAgcnVudGltZTogbm93KCkgLSB0aGlzLnN0YXJ0ZWQsXG5cdCAgICAgIHRvZG86ICEhdGhpcy50b2RvXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoaGFzT3duLmNhbGwocmVzdWx0SW5mbywgXCJleHBlY3RlZFwiKSkge1xuXHQgICAgICBkZXRhaWxzLmV4cGVjdGVkID0gcmVzdWx0SW5mby5leHBlY3RlZDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFyZXN1bHRJbmZvLnJlc3VsdCkge1xuXHQgICAgICBzb3VyY2UgPSByZXN1bHRJbmZvLnNvdXJjZSB8fCBzb3VyY2VGcm9tU3RhY2t0cmFjZSgpO1xuXG5cdCAgICAgIGlmIChzb3VyY2UpIHtcblx0ICAgICAgICBkZXRhaWxzLnNvdXJjZSA9IHNvdXJjZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxvZ0Fzc2VydGlvbihkZXRhaWxzKTtcblx0ICAgIHRoaXMuYXNzZXJ0aW9ucy5wdXNoKHtcblx0ICAgICAgcmVzdWx0OiAhIXJlc3VsdEluZm8ucmVzdWx0LFxuXHQgICAgICBtZXNzYWdlOiByZXN1bHRJbmZvLm1lc3NhZ2Vcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgcHVzaEZhaWx1cmU6IGZ1bmN0aW9uIHB1c2hGYWlsdXJlKG1lc3NhZ2UsIHNvdXJjZSwgYWN0dWFsKSB7XG5cdCAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGVzdCkpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVzaEZhaWx1cmUoKSBhc3NlcnRpb24gb3V0c2lkZSB0ZXN0IGNvbnRleHQsIHdhcyBcIiArIHNvdXJjZUZyb21TdGFja3RyYWNlKDIpKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5wdXNoUmVzdWx0KHtcblx0ICAgICAgcmVzdWx0OiBmYWxzZSxcblx0ICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBcImVycm9yXCIsXG5cdCAgICAgIGFjdHVhbDogYWN0dWFsIHx8IG51bGwsXG5cdCAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICB9KTtcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgICogTG9nIGFzc2VydGlvbiBkZXRhaWxzIHVzaW5nIGJvdGggdGhlIG9sZCBRVW5pdC5sb2cgaW50ZXJmYWNlIGFuZFxuXHQgICAqIFFVbml0Lm9uKCBcImFzc2VydGlvblwiICkgaW50ZXJmYWNlLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblx0ICBsb2dBc3NlcnRpb246IGZ1bmN0aW9uIGxvZ0Fzc2VydGlvbihkZXRhaWxzKSB7XG5cdCAgICBydW5Mb2dnaW5nQ2FsbGJhY2tzKFwibG9nXCIsIGRldGFpbHMpO1xuXHQgICAgdmFyIGFzc2VydGlvbiA9IHtcblx0ICAgICAgcGFzc2VkOiBkZXRhaWxzLnJlc3VsdCxcblx0ICAgICAgYWN0dWFsOiBkZXRhaWxzLmFjdHVhbCxcblx0ICAgICAgZXhwZWN0ZWQ6IGRldGFpbHMuZXhwZWN0ZWQsXG5cdCAgICAgIG1lc3NhZ2U6IGRldGFpbHMubWVzc2FnZSxcblx0ICAgICAgc3RhY2s6IGRldGFpbHMuc291cmNlLFxuXHQgICAgICB0b2RvOiBkZXRhaWxzLnRvZG9cblx0ICAgIH07XG5cdCAgICB0aGlzLnRlc3RSZXBvcnQucHVzaEFzc2VydGlvbihhc3NlcnRpb24pO1xuXHQgICAgZW1pdChcImFzc2VydGlvblwiLCBhc3NlcnRpb24pO1xuXHQgIH0sXG5cdCAgcmVzb2x2ZVByb21pc2U6IGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHBoYXNlKSB7XG5cdCAgICB2YXIgdGhlbixcblx0ICAgICAgICByZXN1bWUsXG5cdCAgICAgICAgbWVzc2FnZSxcblx0ICAgICAgICB0ZXN0ID0gdGhpcztcblxuXHQgICAgaWYgKHByb21pc2UgIT0gbnVsbCkge1xuXHQgICAgICB0aGVuID0gcHJvbWlzZS50aGVuO1xuXG5cdCAgICAgIGlmIChvYmplY3RUeXBlKHRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICByZXN1bWUgPSBpbnRlcm5hbFN0b3AodGVzdCk7XG5cblx0ICAgICAgICBpZiAoY29uZmlnLm5vdHJ5Y2F0Y2gpIHtcblx0ICAgICAgICAgIHRoZW4uY2FsbChwcm9taXNlLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJlc3VtZSgpO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRoZW4uY2FsbChwcm9taXNlLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJlc3VtZSgpO1xuXHQgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlByb21pc2UgcmVqZWN0ZWQgXCIgKyAoIXBoYXNlID8gXCJkdXJpbmdcIiA6IHBoYXNlLnJlcGxhY2UoL0VhY2gkLywgXCJcIikpICsgXCIgXFxcIlwiICsgdGVzdC50ZXN0TmFtZSArIFwiXFxcIjogXCIgKyAoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSB8fCBlcnJvcik7XG5cdCAgICAgICAgICAgIHRlc3QucHVzaEZhaWx1cmUobWVzc2FnZSwgZXh0cmFjdFN0YWNrdHJhY2UoZXJyb3IsIDApKTsgLy8gRWxzZSBuZXh0IHRlc3Qgd2lsbCBjYXJyeSB0aGUgcmVzcG9uc2liaWxpdHlcblxuXHQgICAgICAgICAgICBzYXZlR2xvYmFsKCk7IC8vIFVuYmxvY2tcblxuXHQgICAgICAgICAgICBpbnRlcm5hbFJlY292ZXIodGVzdCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIHZhbGlkOiBmdW5jdGlvbiB2YWxpZCgpIHtcblx0ICAgIHZhciBmaWx0ZXIgPSBjb25maWcuZmlsdGVyLFxuXHQgICAgICAgIHJlZ2V4RmlsdGVyID0gL14oIT8pXFwvKFtcXHdcXFddKilcXC8oaT8kKS8uZXhlYyhmaWx0ZXIpLFxuXHQgICAgICAgIG1vZHVsZSA9IGNvbmZpZy5tb2R1bGUgJiYgY29uZmlnLm1vZHVsZS50b0xvd2VyQ2FzZSgpLFxuXHQgICAgICAgIGZ1bGxOYW1lID0gdGhpcy5tb2R1bGUubmFtZSArIFwiOiBcIiArIHRoaXMudGVzdE5hbWU7XG5cblx0ICAgIGZ1bmN0aW9uIG1vZHVsZUNoYWluTmFtZU1hdGNoKHRlc3RNb2R1bGUpIHtcblx0ICAgICAgdmFyIHRlc3RNb2R1bGVOYW1lID0gdGVzdE1vZHVsZS5uYW1lID8gdGVzdE1vZHVsZS5uYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuXG5cdCAgICAgIGlmICh0ZXN0TW9kdWxlTmFtZSA9PT0gbW9kdWxlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH0gZWxzZSBpZiAodGVzdE1vZHVsZS5wYXJlbnRNb2R1bGUpIHtcblx0ICAgICAgICByZXR1cm4gbW9kdWxlQ2hhaW5OYW1lTWF0Y2godGVzdE1vZHVsZS5wYXJlbnRNb2R1bGUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBtb2R1bGVDaGFpbklkTWF0Y2godGVzdE1vZHVsZSkge1xuXHQgICAgICByZXR1cm4gaW5BcnJheSh0ZXN0TW9kdWxlLm1vZHVsZUlkLCBjb25maWcubW9kdWxlSWQpIHx8IHRlc3RNb2R1bGUucGFyZW50TW9kdWxlICYmIG1vZHVsZUNoYWluSWRNYXRjaCh0ZXN0TW9kdWxlLnBhcmVudE1vZHVsZSk7XG5cdCAgICB9IC8vIEludGVybmFsbHktZ2VuZXJhdGVkIHRlc3RzIGFyZSBhbHdheXMgdmFsaWRcblxuXG5cdCAgICBpZiAodGhpcy5jYWxsYmFjayAmJiB0aGlzLmNhbGxiYWNrLnZhbGlkVGVzdCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbmZpZy5tb2R1bGVJZCAmJiBjb25maWcubW9kdWxlSWQubGVuZ3RoID4gMCAmJiAhbW9kdWxlQ2hhaW5JZE1hdGNoKHRoaXMubW9kdWxlKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb25maWcudGVzdElkICYmIGNvbmZpZy50ZXN0SWQubGVuZ3RoID4gMCAmJiAhaW5BcnJheSh0aGlzLnRlc3RJZCwgY29uZmlnLnRlc3RJZCkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kdWxlICYmICFtb2R1bGVDaGFpbk5hbWVNYXRjaCh0aGlzLm1vZHVsZSkpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWZpbHRlcikge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlZ2V4RmlsdGVyID8gdGhpcy5yZWdleEZpbHRlcighIXJlZ2V4RmlsdGVyWzFdLCByZWdleEZpbHRlclsyXSwgcmVnZXhGaWx0ZXJbM10sIGZ1bGxOYW1lKSA6IHRoaXMuc3RyaW5nRmlsdGVyKGZpbHRlciwgZnVsbE5hbWUpO1xuXHQgIH0sXG5cdCAgcmVnZXhGaWx0ZXI6IGZ1bmN0aW9uIHJlZ2V4RmlsdGVyKGV4Y2x1ZGUsIHBhdHRlcm4sIGZsYWdzLCBmdWxsTmFtZSkge1xuXHQgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG5cdCAgICB2YXIgbWF0Y2ggPSByZWdleC50ZXN0KGZ1bGxOYW1lKTtcblx0ICAgIHJldHVybiBtYXRjaCAhPT0gZXhjbHVkZTtcblx0ICB9LFxuXHQgIHN0cmluZ0ZpbHRlcjogZnVuY3Rpb24gc3RyaW5nRmlsdGVyKGZpbHRlciwgZnVsbE5hbWUpIHtcblx0ICAgIGZpbHRlciA9IGZpbHRlci50b0xvd2VyQ2FzZSgpO1xuXHQgICAgZnVsbE5hbWUgPSBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgdmFyIGluY2x1ZGUgPSBmaWx0ZXIuY2hhckF0KDApICE9PSBcIiFcIjtcblxuXHQgICAgaWYgKCFpbmNsdWRlKSB7XG5cdCAgICAgIGZpbHRlciA9IGZpbHRlci5zbGljZSgxKTtcblx0ICAgIH0gLy8gSWYgdGhlIGZpbHRlciBtYXRjaGVzLCB3ZSBuZWVkIHRvIGhvbm91ciBpbmNsdWRlXG5cblxuXHQgICAgaWYgKGZ1bGxOYW1lLmluZGV4T2YoZmlsdGVyKSAhPT0gLTEpIHtcblx0ICAgICAgcmV0dXJuIGluY2x1ZGU7XG5cdCAgICB9IC8vIE90aGVyd2lzZSwgZG8gdGhlIG9wcG9zaXRlXG5cblxuXHQgICAgcmV0dXJuICFpbmNsdWRlO1xuXHQgIH1cblx0fTtcblx0ZnVuY3Rpb24gcHVzaEZhaWx1cmUoKSB7XG5cdCAgaWYgKCFjb25maWcuY3VycmVudCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwicHVzaEZhaWx1cmUoKSBhc3NlcnRpb24gb3V0c2lkZSB0ZXN0IGNvbnRleHQsIGluIFwiICsgc291cmNlRnJvbVN0YWNrdHJhY2UoMikpO1xuXHQgIH0gLy8gR2V0cyBjdXJyZW50IHRlc3Qgb2JqXG5cblxuXHQgIHZhciBjdXJyZW50VGVzdCA9IGNvbmZpZy5jdXJyZW50O1xuXHQgIHJldHVybiBjdXJyZW50VGVzdC5wdXNoRmFpbHVyZS5hcHBseShjdXJyZW50VGVzdCwgYXJndW1lbnRzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNhdmVHbG9iYWwoKSB7XG5cdCAgY29uZmlnLnBvbGx1dGlvbiA9IFtdO1xuXG5cdCAgaWYgKGNvbmZpZy5ub2dsb2JhbHMpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBnbG9iYWxfX2RlZmF1bHRbJ2RlZmF1bHQnXSkge1xuXHQgICAgICBpZiAoaGFzT3duLmNhbGwoZ2xvYmFsX19kZWZhdWx0WydkZWZhdWx0J10sIGtleSkpIHtcblx0ICAgICAgICAvLyBJbiBPcGVyYSBzb21ldGltZXMgRE9NIGVsZW1lbnQgaWRzIHNob3cgdXAgaGVyZSwgaWdub3JlIHRoZW1cblx0ICAgICAgICBpZiAoL15xdW5pdC10ZXN0LW91dHB1dC8udGVzdChrZXkpKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjb25maWcucG9sbHV0aW9uLnB1c2goa2V5KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrUG9sbHV0aW9uKCkge1xuXHQgIHZhciBuZXdHbG9iYWxzLFxuXHQgICAgICBkZWxldGVkR2xvYmFscyxcblx0ICAgICAgb2xkID0gY29uZmlnLnBvbGx1dGlvbjtcblx0ICBzYXZlR2xvYmFsKCk7XG5cdCAgbmV3R2xvYmFscyA9IGRpZmYoY29uZmlnLnBvbGx1dGlvbiwgb2xkKTtcblxuXHQgIGlmIChuZXdHbG9iYWxzLmxlbmd0aCA+IDApIHtcblx0ICAgIHB1c2hGYWlsdXJlKFwiSW50cm9kdWNlZCBnbG9iYWwgdmFyaWFibGUocyk6IFwiICsgbmV3R2xvYmFscy5qb2luKFwiLCBcIikpO1xuXHQgIH1cblxuXHQgIGRlbGV0ZWRHbG9iYWxzID0gZGlmZihvbGQsIGNvbmZpZy5wb2xsdXRpb24pO1xuXG5cdCAgaWYgKGRlbGV0ZWRHbG9iYWxzLmxlbmd0aCA+IDApIHtcblx0ICAgIHB1c2hGYWlsdXJlKFwiRGVsZXRlZCBnbG9iYWwgdmFyaWFibGUocyk6IFwiICsgZGVsZXRlZEdsb2JhbHMuam9pbihcIiwgXCIpKTtcblx0ICB9XG5cdH0gLy8gV2lsbCBiZSBleHBvc2VkIGFzIFFVbml0LnRlc3RcblxuXG5cdGZ1bmN0aW9uIHRlc3QodGVzdE5hbWUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKGZvY3VzZWQkMSkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHZhciBuZXdUZXN0ID0gbmV3IFRlc3Qoe1xuXHQgICAgdGVzdE5hbWU6IHRlc3ROYW1lLFxuXHQgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG5cdCAgfSk7XG5cdCAgbmV3VGVzdC5xdWV1ZSgpO1xuXHR9XG5cdGZ1bmN0aW9uIHRvZG8odGVzdE5hbWUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKGZvY3VzZWQkMSkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHZhciBuZXdUZXN0ID0gbmV3IFRlc3Qoe1xuXHQgICAgdGVzdE5hbWU6IHRlc3ROYW1lLFxuXHQgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuXHQgICAgdG9kbzogdHJ1ZVxuXHQgIH0pO1xuXHQgIG5ld1Rlc3QucXVldWUoKTtcblx0fSAvLyBXaWxsIGJlIGV4cG9zZWQgYXMgUVVuaXQuc2tpcFxuXG5cdGZ1bmN0aW9uIHNraXAodGVzdE5hbWUpIHtcblx0ICBpZiAoZm9jdXNlZCQxKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIHRlc3QgPSBuZXcgVGVzdCh7XG5cdCAgICB0ZXN0TmFtZTogdGVzdE5hbWUsXG5cdCAgICBza2lwOiB0cnVlXG5cdCAgfSk7XG5cdCAgdGVzdC5xdWV1ZSgpO1xuXHR9IC8vIFdpbGwgYmUgZXhwb3NlZCBhcyBRVW5pdC5vbmx5XG5cblx0ZnVuY3Rpb24gb25seSh0ZXN0TmFtZSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIWZvY3VzZWQkMSkge1xuXHQgICAgY29uZmlnLnF1ZXVlLmxlbmd0aCA9IDA7XG5cdCAgICBmb2N1c2VkJDEgPSB0cnVlO1xuXHQgIH1cblxuXHQgIHZhciBuZXdUZXN0ID0gbmV3IFRlc3Qoe1xuXHQgICAgdGVzdE5hbWU6IHRlc3ROYW1lLFxuXHQgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG5cdCAgfSk7XG5cdCAgbmV3VGVzdC5xdWV1ZSgpO1xuXHR9IC8vIFJlc2V0cyBjb25maWcudGltZW91dCB3aXRoIGEgbmV3IHRpbWVvdXQgZHVyYXRpb24uXG5cblx0ZnVuY3Rpb24gcmVzZXRUZXN0VGltZW91dCh0aW1lb3V0RHVyYXRpb24pIHtcblx0ICBjbGVhclRpbWVvdXQoY29uZmlnLnRpbWVvdXQpO1xuXHQgIGNvbmZpZy50aW1lb3V0ID0gc2V0VGltZW91dCQxKGNvbmZpZy50aW1lb3V0SGFuZGxlcih0aW1lb3V0RHVyYXRpb24pLCB0aW1lb3V0RHVyYXRpb24pO1xuXHR9IC8vIFB1dCBhIGhvbGQgb24gcHJvY2Vzc2luZyBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbGVhc2UgaXQuXG5cblx0ZnVuY3Rpb24gaW50ZXJuYWxTdG9wKHRlc3QpIHtcblx0ICB2YXIgcmVsZWFzZWQgPSBmYWxzZTtcblx0ICB0ZXN0LnNlbWFwaG9yZSArPSAxO1xuXHQgIGNvbmZpZy5ibG9ja2luZyA9IHRydWU7IC8vIFNldCBhIHJlY292ZXJ5IHRpbWVvdXQsIGlmIHNvIGNvbmZpZ3VyZWQuXG5cblx0ICBpZiAoZGVmaW5lZC5zZXRUaW1lb3V0KSB7XG5cdCAgICB2YXIgdGltZW91dER1cmF0aW9uO1xuXG5cdCAgICBpZiAodHlwZW9mIHRlc3QudGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICB0aW1lb3V0RHVyYXRpb24gPSB0ZXN0LnRpbWVvdXQ7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcudGVzdFRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgdGltZW91dER1cmF0aW9uID0gY29uZmlnLnRlc3RUaW1lb3V0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIHRpbWVvdXREdXJhdGlvbiA9PT0gXCJudW1iZXJcIiAmJiB0aW1lb3V0RHVyYXRpb24gPiAwKSB7XG5cdCAgICAgIGNsZWFyVGltZW91dChjb25maWcudGltZW91dCk7XG5cblx0ICAgICAgY29uZmlnLnRpbWVvdXRIYW5kbGVyID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcHVzaEZhaWx1cmUoXCJUZXN0IHRvb2sgbG9uZ2VyIHRoYW4gXCIuY29uY2F0KHRpbWVvdXQsIFwibXM7IHRlc3QgdGltZWQgb3V0LlwiKSwgc291cmNlRnJvbVN0YWNrdHJhY2UoMikpO1xuXHQgICAgICAgICAgcmVsZWFzZWQgPSB0cnVlO1xuXHQgICAgICAgICAgaW50ZXJuYWxSZWNvdmVyKHRlc3QpO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH07XG5cblx0ICAgICAgY29uZmlnLnRpbWVvdXQgPSBzZXRUaW1lb3V0JDEoY29uZmlnLnRpbWVvdXRIYW5kbGVyKHRpbWVvdXREdXJhdGlvbiksIHRpbWVvdXREdXJhdGlvbik7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHJlc3VtZSgpIHtcblx0ICAgIGlmIChyZWxlYXNlZCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHJlbGVhc2VkID0gdHJ1ZTtcblx0ICAgIHRlc3Quc2VtYXBob3JlIC09IDE7XG5cdCAgICBpbnRlcm5hbFN0YXJ0KHRlc3QpO1xuXHQgIH07XG5cdH0gLy8gRm9yY2VmdWxseSByZWxlYXNlIGFsbCBwcm9jZXNzaW5nIGhvbGRzLlxuXG5cdGZ1bmN0aW9uIGludGVybmFsUmVjb3Zlcih0ZXN0KSB7XG5cdCAgdGVzdC5zZW1hcGhvcmUgPSAwO1xuXHQgIGludGVybmFsU3RhcnQodGVzdCk7XG5cdH0gLy8gUmVsZWFzZSBhIHByb2Nlc3NpbmcgaG9sZCwgc2NoZWR1bGluZyBhIHJlc3VtcHRpb24gYXR0ZW1wdCBpZiBubyBob2xkcyByZW1haW4uXG5cblxuXHRmdW5jdGlvbiBpbnRlcm5hbFN0YXJ0KHRlc3QpIHtcblx0ICAvLyBJZiBzZW1hcGhvcmUgaXMgbm9uLW51bWVyaWMsIHRocm93IGVycm9yXG5cdCAgaWYgKGlzTmFOKHRlc3Quc2VtYXBob3JlKSkge1xuXHQgICAgdGVzdC5zZW1hcGhvcmUgPSAwO1xuXHQgICAgcHVzaEZhaWx1cmUoXCJJbnZhbGlkIHZhbHVlIG9uIHRlc3Quc2VtYXBob3JlXCIsIHNvdXJjZUZyb21TdGFja3RyYWNlKDIpKTtcblx0ICAgIHJldHVybjtcblx0ICB9IC8vIERvbid0IHN0YXJ0IHVudGlsIGVxdWFsIG51bWJlciBvZiBzdG9wLWNhbGxzXG5cblxuXHQgIGlmICh0ZXN0LnNlbWFwaG9yZSA+IDApIHtcblx0ICAgIHJldHVybjtcblx0ICB9IC8vIFRocm93IGFuIEVycm9yIGlmIHN0YXJ0IGlzIGNhbGxlZCBtb3JlIG9mdGVuIHRoYW4gc3RvcFxuXG5cblx0ICBpZiAodGVzdC5zZW1hcGhvcmUgPCAwKSB7XG5cdCAgICB0ZXN0LnNlbWFwaG9yZSA9IDA7XG5cdCAgICBwdXNoRmFpbHVyZShcIlRyaWVkIHRvIHJlc3RhcnQgdGVzdCB3aGlsZSBhbHJlYWR5IHN0YXJ0ZWQgKHRlc3QncyBzZW1hcGhvcmUgd2FzIDAgYWxyZWFkeSlcIiwgc291cmNlRnJvbVN0YWNrdHJhY2UoMikpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gLy8gQWRkIGEgc2xpZ2h0IGRlbGF5IHRvIGFsbG93IG1vcmUgYXNzZXJ0aW9ucyBldGMuXG5cblxuXHQgIGlmIChkZWZpbmVkLnNldFRpbWVvdXQpIHtcblx0ICAgIGlmIChjb25maWcudGltZW91dCkge1xuXHQgICAgICBjbGVhclRpbWVvdXQoY29uZmlnLnRpbWVvdXQpO1xuXHQgICAgfVxuXG5cdCAgICBjb25maWcudGltZW91dCA9IHNldFRpbWVvdXQkMShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0ZXN0LnNlbWFwaG9yZSA+IDApIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcblx0ICAgICAgICBjbGVhclRpbWVvdXQoY29uZmlnLnRpbWVvdXQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgYmVnaW4oKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBiZWdpbigpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbGxlY3RUZXN0cyhtb2R1bGUpIHtcblx0ICB2YXIgdGVzdHMgPSBbXS5jb25jYXQobW9kdWxlLnRlc3RzKTtcblxuXHQgIHZhciBtb2R1bGVzID0gX3RvQ29uc3VtYWJsZUFycmF5KG1vZHVsZS5jaGlsZE1vZHVsZXMpOyAvLyBEbyBhIGJyZWFkdGgtZmlyc3QgdHJhdmVyc2FsIG9mIHRoZSBjaGlsZCBtb2R1bGVzXG5cblxuXHQgIHdoaWxlIChtb2R1bGVzLmxlbmd0aCkge1xuXHQgICAgdmFyIG5leHRNb2R1bGUgPSBtb2R1bGVzLnNoaWZ0KCk7XG5cdCAgICB0ZXN0cy5wdXNoLmFwcGx5KHRlc3RzLCBuZXh0TW9kdWxlLnRlc3RzKTtcblx0ICAgIG1vZHVsZXMucHVzaC5hcHBseShtb2R1bGVzLCBfdG9Db25zdW1hYmxlQXJyYXkobmV4dE1vZHVsZS5jaGlsZE1vZHVsZXMpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGVzdHM7XG5cdH1cblxuXHRmdW5jdGlvbiBudW1iZXJPZlRlc3RzKG1vZHVsZSkge1xuXHQgIHJldHVybiBjb2xsZWN0VGVzdHMobW9kdWxlKS5sZW5ndGg7XG5cdH1cblxuXHRmdW5jdGlvbiBudW1iZXJPZlVuc2tpcHBlZFRlc3RzKG1vZHVsZSkge1xuXHQgIHJldHVybiBjb2xsZWN0VGVzdHMobW9kdWxlKS5maWx0ZXIoZnVuY3Rpb24gKHRlc3QpIHtcblx0ICAgIHJldHVybiAhdGVzdC5za2lwO1xuXHQgIH0pLmxlbmd0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIG5vdGlmeVRlc3RzUmFuKG1vZHVsZSwgc2tpcHBlZCkge1xuXHQgIG1vZHVsZS50ZXN0c1J1bisrO1xuXG5cdCAgaWYgKCFza2lwcGVkKSB7XG5cdCAgICBtb2R1bGUudW5za2lwcGVkVGVzdHNSdW4rKztcblx0ICB9XG5cblx0ICB3aGlsZSAobW9kdWxlID0gbW9kdWxlLnBhcmVudE1vZHVsZSkge1xuXHQgICAgbW9kdWxlLnRlc3RzUnVuKys7XG5cblx0ICAgIGlmICghc2tpcHBlZCkge1xuXHQgICAgICBtb2R1bGUudW5za2lwcGVkVGVzdHNSdW4rKztcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHR2YXIgQXNzZXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBBc3NlcnQodGVzdENvbnRleHQpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnQpO1xuXG5cdCAgICB0aGlzLnRlc3QgPSB0ZXN0Q29udGV4dDtcblx0ICB9IC8vIEFzc2VydCBoZWxwZXJzXG5cblxuXHQgIF9jcmVhdGVDbGFzcyhBc3NlcnQsIFt7XG5cdCAgICBrZXk6IFwidGltZW91dFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcblx0ICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBudW1iZXIgYXMgdGhlIGR1cmF0aW9uIHRvIGFzc2VydC50aW1lb3V0XCIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy50ZXN0LnRpbWVvdXQgPSBkdXJhdGlvbjsgLy8gSWYgYSB0aW1lb3V0IGhhcyBiZWVuIHNldCwgY2xlYXIgaXQgYW5kIHJlc2V0IHdpdGggdGhlIG5ldyBkdXJhdGlvblxuXG5cdCAgICAgIGlmIChjb25maWcudGltZW91dCkge1xuXHQgICAgICAgIGNsZWFyVGltZW91dChjb25maWcudGltZW91dCk7XG5cblx0ICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXRIYW5kbGVyICYmIHRoaXMudGVzdC50aW1lb3V0ID4gMCkge1xuXHQgICAgICAgICAgcmVzZXRUZXN0VGltZW91dCh0aGlzLnRlc3QudGltZW91dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IC8vIERvY3VtZW50cyBhIFwic3RlcFwiLCB3aGljaCBpcyBhIHN0cmluZyB2YWx1ZSwgaW4gYSB0ZXN0IGFzIGEgcGFzc2luZyBhc3NlcnRpb25cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJzdGVwXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcChtZXNzYWdlKSB7XG5cdCAgICAgIHZhciBhc3NlcnRpb25NZXNzYWdlID0gbWVzc2FnZTtcblx0ICAgICAgdmFyIHJlc3VsdCA9ICEhbWVzc2FnZTtcblx0ICAgICAgdGhpcy50ZXN0LnN0ZXBzLnB1c2gobWVzc2FnZSk7XG5cblx0ICAgICAgaWYgKG9iamVjdFR5cGUobWVzc2FnZSkgPT09IFwidW5kZWZpbmVkXCIgfHwgbWVzc2FnZSA9PT0gXCJcIikge1xuXHQgICAgICAgIGFzc2VydGlvbk1lc3NhZ2UgPSBcIllvdSBtdXN0IHByb3ZpZGUgYSBtZXNzYWdlIHRvIGFzc2VydC5zdGVwXCI7XG5cdCAgICAgIH0gZWxzZSBpZiAob2JqZWN0VHlwZShtZXNzYWdlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGFzc2VydGlvbk1lc3NhZ2UgPSBcIllvdSBtdXN0IHByb3ZpZGUgYSBzdHJpbmcgdmFsdWUgdG8gYXNzZXJ0LnN0ZXBcIjtcblx0ICAgICAgICByZXN1bHQgPSBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgbWVzc2FnZTogYXNzZXJ0aW9uTWVzc2FnZVxuXHQgICAgICB9KTtcblx0ICAgIH0gLy8gVmVyaWZpZXMgdGhlIHN0ZXBzIGluIGEgdGVzdCBtYXRjaCBhIGdpdmVuIGFycmF5IG9mIHN0cmluZyB2YWx1ZXNcblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ2ZXJpZnlTdGVwc1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeVN0ZXBzKHN0ZXBzLCBtZXNzYWdlKSB7XG5cdCAgICAgIC8vIFNpbmNlIHRoZSBzdGVwcyBhcnJheSBpcyBqdXN0IHN0cmluZyB2YWx1ZXMsIHdlIGNhbiBjbG9uZSB3aXRoIHNsaWNlXG5cdCAgICAgIHZhciBhY3R1YWxTdGVwc0Nsb25lID0gdGhpcy50ZXN0LnN0ZXBzLnNsaWNlKCk7XG5cdCAgICAgIHRoaXMuZGVlcEVxdWFsKGFjdHVhbFN0ZXBzQ2xvbmUsIHN0ZXBzLCBtZXNzYWdlKTtcblx0ICAgICAgdGhpcy50ZXN0LnN0ZXBzLmxlbmd0aCA9IDA7XG5cdCAgICB9IC8vIFNwZWNpZnkgdGhlIG51bWJlciBvZiBleHBlY3RlZCBhc3NlcnRpb25zIHRvIGd1YXJhbnRlZSB0aGF0IGZhaWxlZCB0ZXN0XG5cdCAgICAvLyAobm8gYXNzZXJ0aW9ucyBhcmUgcnVuIGF0IGFsbCkgZG9uJ3Qgc2xpcCB0aHJvdWdoLlxuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcImV4cGVjdFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGVjdChhc3NlcnRzKSB7XG5cdCAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgdGhpcy50ZXN0LmV4cGVjdGVkID0gYXNzZXJ0cztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy50ZXN0LmV4cGVjdGVkO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIFB1dCBhIGhvbGQgb24gcHJvY2Vzc2luZyBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbGVhc2UgaXQgYSBtYXhpbXVtIG9mIG9uY2UuXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiYXN5bmNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBhc3luYyhjb3VudCkge1xuXHQgICAgICB2YXIgdGVzdCA9IHRoaXMudGVzdDtcblx0ICAgICAgdmFyIHBvcHBlZCA9IGZhbHNlLFxuXHQgICAgICAgICAgYWNjZXB0Q2FsbENvdW50ID0gY291bnQ7XG5cblx0ICAgICAgaWYgKHR5cGVvZiBhY2NlcHRDYWxsQ291bnQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgICBhY2NlcHRDYWxsQ291bnQgPSAxO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHJlc3VtZSA9IGludGVybmFsU3RvcCh0ZXN0KTtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRvbmUoKSB7XG5cdCAgICAgICAgaWYgKGNvbmZpZy5jdXJyZW50ICE9PSB0ZXN0KSB7XG5cdCAgICAgICAgICB0aHJvdyBFcnJvcihcImFzc2VydC5hc3luYyBjYWxsYmFjayBjYWxsZWQgYWZ0ZXIgdGVzdCBmaW5pc2hlZC5cIik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHBvcHBlZCkge1xuXHQgICAgICAgICAgdGVzdC5wdXNoRmFpbHVyZShcIlRvbyBtYW55IGNhbGxzIHRvIHRoZSBgYXNzZXJ0LmFzeW5jYCBjYWxsYmFja1wiLCBzb3VyY2VGcm9tU3RhY2t0cmFjZSgyKSk7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYWNjZXB0Q2FsbENvdW50IC09IDE7XG5cblx0ICAgICAgICBpZiAoYWNjZXB0Q2FsbENvdW50ID4gMCkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBvcHBlZCA9IHRydWU7XG5cdCAgICAgICAgcmVzdW1lKCk7XG5cdCAgICAgIH07XG5cdCAgICB9IC8vIEV4cG9ydHMgdGVzdC5wdXNoKCkgdG8gdGhlIHVzZXIgQVBJXG5cdCAgICAvLyBBbGlhcyBvZiBwdXNoUmVzdWx0LlxuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInB1c2hcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHJlc3VsdCwgYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgbmVnYXRpdmUpIHtcblx0ICAgICAgTG9nZ2VyLndhcm4oXCJhc3NlcnQucHVzaCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUVVuaXQgMy4wLlwiICsgXCIgUGxlYXNlIHVzZSBhc3NlcnQucHVzaFJlc3VsdCBpbnN0ZWFkIChodHRwczovL2FwaS5xdW5pdGpzLmNvbS9hc3NlcnQvcHVzaFJlc3VsdCkuXCIpO1xuXHQgICAgICB2YXIgY3VycmVudEFzc2VydCA9IHRoaXMgaW5zdGFuY2VvZiBBc3NlcnQgPyB0aGlzIDogY29uZmlnLmN1cnJlbnQuYXNzZXJ0O1xuXHQgICAgICByZXR1cm4gY3VycmVudEFzc2VydC5wdXNoUmVzdWx0KHtcblx0ICAgICAgICByZXN1bHQ6IHJlc3VsdCxcblx0ICAgICAgICBhY3R1YWw6IGFjdHVhbCxcblx0ICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG5cdCAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcblx0ICAgICAgICBuZWdhdGl2ZTogbmVnYXRpdmVcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInB1c2hSZXN1bHRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoUmVzdWx0KHJlc3VsdEluZm8pIHtcblx0ICAgICAgLy8gRGVzdHJ1Y3R1cmUgb2YgcmVzdWx0SW5mbyA9IHsgcmVzdWx0LCBhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBuZWdhdGl2ZSB9XG5cdCAgICAgIHZhciBhc3NlcnQgPSB0aGlzO1xuXHQgICAgICB2YXIgY3VycmVudFRlc3QgPSBhc3NlcnQgaW5zdGFuY2VvZiBBc3NlcnQgJiYgYXNzZXJ0LnRlc3QgfHwgY29uZmlnLmN1cnJlbnQ7IC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZpeC5cblx0ICAgICAgLy8gQWxsb3dzIHRoZSBkaXJlY3QgdXNlIG9mIGdsb2JhbCBleHBvcnRlZCBhc3NlcnRpb25zIGFuZCBRVW5pdC5hc3NlcnQuKlxuXHQgICAgICAvLyBBbHRob3VnaCwgaXQncyB1c2UgaXMgbm90IHJlY29tbWVuZGVkIGFzIGl0IGNhbiBsZWFrIGFzc2VydGlvbnNcblx0ICAgICAgLy8gdG8gb3RoZXIgdGVzdHMgZnJvbSBhc3luYyB0ZXN0cywgYmVjYXVzZSB3ZSBvbmx5IGdldCBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB0ZXN0LFxuXHQgICAgICAvLyBub3QgZXhhY3RseSB0aGUgdGVzdCB3aGVyZSBhc3NlcnRpb24gd2VyZSBpbnRlbmRlZCB0byBiZSBjYWxsZWQuXG5cblx0ICAgICAgaWYgKCFjdXJyZW50VGVzdCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzc2VydGlvbiBvdXRzaWRlIHRlc3QgY29udGV4dCwgaW4gXCIgKyBzb3VyY2VGcm9tU3RhY2t0cmFjZSgyKSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIShhc3NlcnQgaW5zdGFuY2VvZiBBc3NlcnQpKSB7XG5cdCAgICAgICAgYXNzZXJ0ID0gY3VycmVudFRlc3QuYXNzZXJ0O1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGFzc2VydC50ZXN0LnB1c2hSZXN1bHQocmVzdWx0SW5mbyk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcIm9rXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gb2socmVzdWx0LCBtZXNzYWdlKSB7XG5cdCAgICAgIGlmICghbWVzc2FnZSkge1xuXHQgICAgICAgIG1lc3NhZ2UgPSByZXN1bHQgPyBcIm9rYXlcIiA6IFwiZmFpbGVkLCBleHBlY3RlZCBhcmd1bWVudCB0byBiZSB0cnV0aHksIHdhczogXCIuY29uY2F0KGR1bXAucGFyc2UocmVzdWx0KSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLnB1c2hSZXN1bHQoe1xuXHQgICAgICAgIHJlc3VsdDogISFyZXN1bHQsXG5cdCAgICAgICAgYWN0dWFsOiByZXN1bHQsXG5cdCAgICAgICAgZXhwZWN0ZWQ6IHRydWUsXG5cdCAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibm90T2tcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBub3RPayhyZXN1bHQsIG1lc3NhZ2UpIHtcblx0ICAgICAgaWYgKCFtZXNzYWdlKSB7XG5cdCAgICAgICAgbWVzc2FnZSA9ICFyZXN1bHQgPyBcIm9rYXlcIiA6IFwiZmFpbGVkLCBleHBlY3RlZCBhcmd1bWVudCB0byBiZSBmYWxzeSwgd2FzOiBcIi5jb25jYXQoZHVtcC5wYXJzZShyZXN1bHQpKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiAhcmVzdWx0LFxuXHQgICAgICAgIGFjdHVhbDogcmVzdWx0LFxuXHQgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcblx0ICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0cnVlXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3RydWUocmVzdWx0LCBtZXNzYWdlKSB7XG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiByZXN1bHQgPT09IHRydWUsXG5cdCAgICAgICAgYWN0dWFsOiByZXN1bHQsXG5cdCAgICAgICAgZXhwZWN0ZWQ6IHRydWUsXG5cdCAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZmFsc2VcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZmFsc2UocmVzdWx0LCBtZXNzYWdlKSB7XG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiByZXN1bHQgPT09IGZhbHNlLFxuXHQgICAgICAgIGFjdHVhbDogcmVzdWx0LFxuXHQgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcblx0ICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJlcXVhbFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHQgICAgICB2YXIgcmVzdWx0ID0gZXhwZWN0ZWQgPT0gYWN0dWFsO1xuXHQgICAgICB0aGlzLnB1c2hSZXN1bHQoe1xuXHQgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuXHQgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuXHQgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcblx0ICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJub3RFcXVhbFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHQgICAgICB2YXIgcmVzdWx0ID0gZXhwZWN0ZWQgIT0gYWN0dWFsO1xuXHQgICAgICB0aGlzLnB1c2hSZXN1bHQoe1xuXHQgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuXHQgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuXHQgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcblx0ICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuXHQgICAgICAgIG5lZ2F0aXZlOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJwcm9wRXF1YWxcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuXHQgICAgICBhY3R1YWwgPSBvYmplY3RWYWx1ZXMoYWN0dWFsKTtcblx0ICAgICAgZXhwZWN0ZWQgPSBvYmplY3RWYWx1ZXMoZXhwZWN0ZWQpO1xuXHQgICAgICB0aGlzLnB1c2hSZXN1bHQoe1xuXHQgICAgICAgIHJlc3VsdDogZXF1aXYoYWN0dWFsLCBleHBlY3RlZCksXG5cdCAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG5cdCAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHQgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2Vcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcIm5vdFByb3BFcXVhbFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIG5vdFByb3BFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgICAgIGFjdHVhbCA9IG9iamVjdFZhbHVlcyhhY3R1YWwpO1xuXHQgICAgICBleHBlY3RlZCA9IG9iamVjdFZhbHVlcyhleHBlY3RlZCk7XG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiAhZXF1aXYoYWN0dWFsLCBleHBlY3RlZCksXG5cdCAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG5cdCAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHQgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdCAgICAgICAgbmVnYXRpdmU6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImRlZXBFcXVhbFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiBlcXVpdihhY3R1YWwsIGV4cGVjdGVkKSxcblx0ICAgICAgICBhY3R1YWw6IGFjdHVhbCxcblx0ICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG5cdCAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibm90RGVlcEVxdWFsXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICAgICAgdGhpcy5wdXNoUmVzdWx0KHtcblx0ICAgICAgICByZXN1bHQ6ICFlcXVpdihhY3R1YWwsIGV4cGVjdGVkKSxcblx0ICAgICAgICBhY3R1YWw6IGFjdHVhbCxcblx0ICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG5cdCAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcblx0ICAgICAgICBuZWdhdGl2ZTogdHJ1ZVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwic3RyaWN0RXF1YWxcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgICAgIHRoaXMucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiBleHBlY3RlZCA9PT0gYWN0dWFsLFxuXHQgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuXHQgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcblx0ICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJub3RTdHJpY3RFcXVhbFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICAgICAgdGhpcy5wdXNoUmVzdWx0KHtcblx0ICAgICAgICByZXN1bHQ6IGV4cGVjdGVkICE9PSBhY3R1YWwsXG5cdCAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG5cdCAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHQgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdCAgICAgICAgbmVnYXRpdmU6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRocm93c1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRocm93cyhibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcblx0ICAgICAgdmFyIGFjdHVhbCxcblx0ICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICB2YXIgY3VycmVudFRlc3QgPSB0aGlzIGluc3RhbmNlb2YgQXNzZXJ0ICYmIHRoaXMudGVzdCB8fCBjb25maWcuY3VycmVudDsgLy8gJ2V4cGVjdGVkJyBpcyBvcHRpb25hbCB1bmxlc3MgZG9pbmcgc3RyaW5nIGNvbXBhcmlzb25cblxuXHQgICAgICBpZiAob2JqZWN0VHlwZShleHBlY3RlZCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG5cdCAgICAgICAgICBleHBlY3RlZCA9IG51bGw7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRocm93cy9yYWlzZXMgZG9lcyBub3QgYWNjZXB0IGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgZXhwZWN0ZWQgYXJndW1lbnQuXFxuXCIgKyBcIlVzZSBhIG5vbi1zdHJpbmcgb2JqZWN0IHZhbHVlIChlLmcuIHJlZ0V4cCkgaW5zdGVhZCBpZiBpdCdzIG5lY2Vzc2FyeS5cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgY3VycmVudFRlc3QuaWdub3JlR2xvYmFsRXJyb3JzID0gdHJ1ZTtcblxuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGJsb2NrLmNhbGwoY3VycmVudFRlc3QudGVzdEVudmlyb25tZW50KTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGFjdHVhbCA9IGU7XG5cdCAgICAgIH1cblxuXHQgICAgICBjdXJyZW50VGVzdC5pZ25vcmVHbG9iYWxFcnJvcnMgPSBmYWxzZTtcblxuXHQgICAgICBpZiAoYWN0dWFsKSB7XG5cdCAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IG9iamVjdFR5cGUoZXhwZWN0ZWQpOyAvLyBXZSBkb24ndCB3YW50IHRvIHZhbGlkYXRlIHRocm93biBlcnJvclxuXG5cdCAgICAgICAgaWYgKCFleHBlY3RlZCkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTsgLy8gRXhwZWN0ZWQgaXMgYSByZWdleHBcblx0ICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJyZWdleHBcIikge1xuXHQgICAgICAgICAgcmVzdWx0ID0gZXhwZWN0ZWQudGVzdChlcnJvclN0cmluZyhhY3R1YWwpKTsgLy8gTG9nIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgcmVnZXhwXG5cblx0ICAgICAgICAgIGV4cGVjdGVkID0gU3RyaW5nKGV4cGVjdGVkKTsgLy8gRXhwZWN0ZWQgaXMgYSBjb25zdHJ1Y3RvciwgbWF5YmUgYW4gRXJyb3IgY29uc3RydWN0b3Jcblx0ICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSB0cnVlOyAvLyBFeHBlY3RlZCBpcyBhbiBFcnJvciBvYmplY3Rcblx0ICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgcmVzdWx0ID0gYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQuY29uc3RydWN0b3IgJiYgYWN0dWFsLm5hbWUgPT09IGV4cGVjdGVkLm5hbWUgJiYgYWN0dWFsLm1lc3NhZ2UgPT09IGV4cGVjdGVkLm1lc3NhZ2U7IC8vIExvZyB0aGUgc3RyaW5nIGZvcm0gb2YgdGhlIEVycm9yIG9iamVjdFxuXG5cdCAgICAgICAgICBleHBlY3RlZCA9IGVycm9yU3RyaW5nKGV4cGVjdGVkKTsgLy8gRXhwZWN0ZWQgaXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdHJ1ZSBpZiB2YWxpZGF0aW9uIHBhc3NlZFxuXHQgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcImZ1bmN0aW9uXCIgJiYgZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgZXhwZWN0ZWQgPSBudWxsO1xuXHQgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBjdXJyZW50VGVzdC5hc3NlcnQucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgLy8gdW5kZWZpbmVkIGlmIGl0IGRpZG4ndCB0aHJvd1xuXHQgICAgICAgIGFjdHVhbDogYWN0dWFsICYmIGVycm9yU3RyaW5nKGFjdHVhbCksXG5cdCAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHQgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2Vcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInJlamVjdHNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZWplY3RzKHByb21pc2UsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblx0ICAgICAgdmFyIGN1cnJlbnRUZXN0ID0gdGhpcyBpbnN0YW5jZW9mIEFzc2VydCAmJiB0aGlzLnRlc3QgfHwgY29uZmlnLmN1cnJlbnQ7IC8vICdleHBlY3RlZCcgaXMgb3B0aW9uYWwgdW5sZXNzIGRvaW5nIHN0cmluZyBjb21wYXJpc29uXG5cblx0ICAgICAgaWYgKG9iamVjdFR5cGUoZXhwZWN0ZWQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuXHQgICAgICAgICAgZXhwZWN0ZWQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG1lc3NhZ2UgPSBcImFzc2VydC5yZWplY3RzIGRvZXMgbm90IGFjY2VwdCBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGV4cGVjdGVkIFwiICsgXCJhcmd1bWVudC5cXG5Vc2UgYSBub24tc3RyaW5nIG9iamVjdCB2YWx1ZSAoZS5nLiB2YWxpZGF0b3IgZnVuY3Rpb24pIGluc3RlYWQgXCIgKyBcImlmIG5lY2Vzc2FyeS5cIjtcblx0ICAgICAgICAgIGN1cnJlbnRUZXN0LmFzc2VydC5wdXNoUmVzdWx0KHtcblx0ICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcblx0ICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHRoZW4gPSBwcm9taXNlICYmIHByb21pc2UudGhlbjtcblxuXHQgICAgICBpZiAob2JqZWN0VHlwZSh0aGVuKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgdmFyIF9tZXNzYWdlID0gXCJUaGUgdmFsdWUgcHJvdmlkZWQgdG8gYGFzc2VydC5yZWplY3RzYCBpbiBcIiArIFwiXFxcIlwiICsgY3VycmVudFRlc3QudGVzdE5hbWUgKyBcIlxcXCIgd2FzIG5vdCBhIHByb21pc2UuXCI7XG5cblx0ICAgICAgICBjdXJyZW50VGVzdC5hc3NlcnQucHVzaFJlc3VsdCh7XG5cdCAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuXHQgICAgICAgICAgbWVzc2FnZTogX21lc3NhZ2UsXG5cdCAgICAgICAgICBhY3R1YWw6IHByb21pc2Vcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgZG9uZSA9IHRoaXMuYXN5bmMoKTtcblx0ICAgICAgcmV0dXJuIHRoZW4uY2FsbChwcm9taXNlLCBmdW5jdGlvbiBoYW5kbGVGdWxmaWxsbWVudCgpIHtcblx0ICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGBhc3NlcnQucmVqZWN0c2AgY2FsbGJhY2sgaW4gXCIgKyBcIlxcXCJcIiArIGN1cnJlbnRUZXN0LnRlc3ROYW1lICsgXCJcXFwiIGRpZCBub3QgcmVqZWN0LlwiO1xuXHQgICAgICAgIGN1cnJlbnRUZXN0LmFzc2VydC5wdXNoUmVzdWx0KHtcblx0ICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG5cdCAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuXHQgICAgICAgICAgYWN0dWFsOiBwcm9taXNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgZG9uZSgpO1xuXHQgICAgICB9LCBmdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24oYWN0dWFsKSB7XG5cdCAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IG9iamVjdFR5cGUoZXhwZWN0ZWQpOyAvLyBXZSBkb24ndCB3YW50IHRvIHZhbGlkYXRlXG5cblx0ICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTsgLy8gRXhwZWN0ZWQgaXMgYSByZWdleHBcblx0ICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJyZWdleHBcIikge1xuXHQgICAgICAgICAgcmVzdWx0ID0gZXhwZWN0ZWQudGVzdChlcnJvclN0cmluZyhhY3R1YWwpKTsgLy8gTG9nIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgcmVnZXhwXG5cblx0ICAgICAgICAgIGV4cGVjdGVkID0gU3RyaW5nKGV4cGVjdGVkKTsgLy8gRXhwZWN0ZWQgaXMgYSBjb25zdHJ1Y3RvciwgbWF5YmUgYW4gRXJyb3IgY29uc3RydWN0b3Jcblx0ICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSB0cnVlOyAvLyBFeHBlY3RlZCBpcyBhbiBFcnJvciBvYmplY3Rcblx0ICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgcmVzdWx0ID0gYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQuY29uc3RydWN0b3IgJiYgYWN0dWFsLm5hbWUgPT09IGV4cGVjdGVkLm5hbWUgJiYgYWN0dWFsLm1lc3NhZ2UgPT09IGV4cGVjdGVkLm1lc3NhZ2U7IC8vIExvZyB0aGUgc3RyaW5nIGZvcm0gb2YgdGhlIEVycm9yIG9iamVjdFxuXG5cdCAgICAgICAgICBleHBlY3RlZCA9IGVycm9yU3RyaW5nKGV4cGVjdGVkKTsgLy8gRXhwZWN0ZWQgaXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdHJ1ZSBpZiB2YWxpZGF0aW9uIHBhc3NlZFxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcblx0ICAgICAgICAgICAgZXhwZWN0ZWQgPSBudWxsOyAvLyBFeHBlY3RlZCBpcyBzb21lIG90aGVyIGludmFsaWQgdHlwZVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBcImludmFsaWQgZXhwZWN0ZWQgdmFsdWUgcHJvdmlkZWQgdG8gYGFzc2VydC5yZWplY3RzYCBcIiArIFwiY2FsbGJhY2sgaW4gXFxcIlwiICsgY3VycmVudFRlc3QudGVzdE5hbWUgKyBcIlxcXCI6IFwiICsgZXhwZWN0ZWRUeXBlICsgXCIuXCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3VycmVudFRlc3QuYXNzZXJ0LnB1c2hSZXN1bHQoe1xuXHQgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgICAvLyBsZWF2ZSByZWplY3Rpb24gdmFsdWUgb2YgdW5kZWZpbmVkIGFzLWlzXG5cdCAgICAgICAgICBhY3R1YWw6IGFjdHVhbCAmJiBlcnJvclN0cmluZyhhY3R1YWwpLFxuXHQgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuXHQgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGRvbmUoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIEFzc2VydDtcblx0fSgpOyAvLyBQcm92aWRlIGFuIGFsdGVybmF0aXZlIHRvIGFzc2VydC50aHJvd3MoKSwgZm9yIGVudmlyb25tZW50cyB0aGF0IGNvbnNpZGVyIHRocm93cyBhIHJlc2VydmVkIHdvcmRcblx0Ly8gS25vd24gdG8gdXMgYXJlOiBDbG9zdXJlIENvbXBpbGVyLCBOYXJ3aGFsXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkb3Qtbm90YXRpb25cblxuXG5cdEFzc2VydC5wcm90b3R5cGUucmFpc2VzID0gQXNzZXJ0LnByb3RvdHlwZVtcInRocm93c1wiXTtcblx0LyoqXG5cdCAqIENvbnZlcnRzIGFuIGVycm9yIGludG8gYSBzaW1wbGUgc3RyaW5nIGZvciBjb21wYXJpc29ucy5cblx0ICpcblx0ICogQHBhcmFtIHtFcnJvcnxPYmplY3R9IGVycm9yXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cblx0ZnVuY3Rpb24gZXJyb3JTdHJpbmcoZXJyb3IpIHtcblx0ICB2YXIgcmVzdWx0RXJyb3JTdHJpbmcgPSBlcnJvci50b1N0cmluZygpOyAvLyBJZiB0aGUgZXJyb3Igd2Fzbid0IGEgc3ViY2xhc3Mgb2YgRXJyb3IgYnV0IHNvbWV0aGluZyBsaWtlXG5cdCAgLy8gYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBuYW1lIGFuZCBtZXNzYWdlIHByb3BlcnRpZXMuLi5cblxuXHQgIGlmIChyZXN1bHRFcnJvclN0cmluZy5zdWJzdHJpbmcoMCwgNykgPT09IFwiW29iamVjdFwiKSB7XG5cdCAgICB2YXIgbmFtZSA9IGVycm9yLm5hbWUgPyBlcnJvci5uYW1lLnRvU3RyaW5nKCkgOiBcIkVycm9yXCI7XG5cdCAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgPyBlcnJvci5tZXNzYWdlLnRvU3RyaW5nKCkgOiBcIlwiO1xuXG5cdCAgICBpZiAobmFtZSAmJiBtZXNzYWdlKSB7XG5cdCAgICAgIHJldHVybiBcIlwiLmNvbmNhdChuYW1lLCBcIjogXCIpLmNvbmNhdChtZXNzYWdlKTtcblx0ICAgIH0gZWxzZSBpZiAobmFtZSkge1xuXHQgICAgICByZXR1cm4gbmFtZTtcblx0ICAgIH0gZWxzZSBpZiAobWVzc2FnZSkge1xuXHQgICAgICByZXR1cm4gbWVzc2FnZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBcIkVycm9yXCI7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiByZXN1bHRFcnJvclN0cmluZztcblx0ICB9XG5cdH1cblxuXHQvKiBnbG9iYWwgbW9kdWxlLCBleHBvcnRzLCBkZWZpbmUgKi9cblx0ZnVuY3Rpb24gZXhwb3J0UVVuaXQoUVVuaXQpIHtcblx0ICBpZiAoZGVmaW5lZC5kb2N1bWVudCkge1xuXHQgICAgLy8gUVVuaXQgbWF5IGJlIGRlZmluZWQgd2hlbiBpdCBpcyBwcmVjb25maWd1cmVkIGJ1dCB0aGVuIG9ubHkgUVVuaXQgYW5kIFFVbml0LmNvbmZpZyBtYXkgYmUgZGVmaW5lZC5cblx0ICAgIGlmICh3aW5kb3ckMS5RVW5pdCAmJiB3aW5kb3ckMS5RVW5pdC52ZXJzaW9uKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIlFVbml0IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5cIik7XG5cdCAgICB9XG5cblx0ICAgIHdpbmRvdyQxLlFVbml0ID0gUVVuaXQ7XG5cdCAgfSAvLyBGb3Igbm9kZWpzXG5cblxuXHQgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBRVW5pdDsgLy8gRm9yIGNvbnNpc3RlbmN5IHdpdGggQ29tbW9uSlMgZW52aXJvbm1lbnRzJyBleHBvcnRzXG5cblx0ICAgIG1vZHVsZS5leHBvcnRzLlFVbml0ID0gUVVuaXQ7XG5cdCAgfSAvLyBGb3IgQ29tbW9uSlMgd2l0aCBleHBvcnRzLCBidXQgd2l0aG91dCBtb2R1bGUuZXhwb3J0cywgbGlrZSBSaGlub1xuXG5cblx0ICBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgZXhwb3J0cykge1xuXHQgICAgZXhwb3J0cy5RVW5pdCA9IFFVbml0O1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHQgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFFVbml0O1xuXHQgICAgfSk7XG5cdCAgICBRVW5pdC5jb25maWcuYXV0b3N0YXJ0ID0gZmFsc2U7XG5cdCAgfSAvLyBGb3IgV2ViL1NlcnZpY2UgV29ya2Vyc1xuXG5cblx0ICBpZiAoc2VsZiQxICYmIHNlbGYkMS5Xb3JrZXJHbG9iYWxTY29wZSAmJiBzZWxmJDEgaW5zdGFuY2VvZiBzZWxmJDEuV29ya2VyR2xvYmFsU2NvcGUpIHtcblx0ICAgIHNlbGYkMS5RVW5pdCA9IFFVbml0O1xuXHQgIH1cblx0fVxuXG5cdC8vIGVycm9yIGhhbmRsaW5nIHNob3VsZCBiZSBzdXBwcmVzc2VkIGFuZCBmYWxzZSBvdGhlcndpc2UuXG5cdC8vIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBvbmx5IHN1cHByZXNzIGZ1cnRoZXIgZXJyb3IgaGFuZGxpbmcgaWYgdGhlXG5cdC8vIFwiaWdub3JlR2xvYmFsRXJyb3JzXCIgY29uZmlndXJhdGlvbiBvcHRpb24gaXMgZW5hYmxlZC5cblxuXHRmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG5cdCAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgfVxuXG5cdCAgaWYgKGNvbmZpZy5jdXJyZW50KSB7XG5cdCAgICBpZiAoY29uZmlnLmN1cnJlbnQuaWdub3JlR2xvYmFsRXJyb3JzKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBwdXNoRmFpbHVyZS5hcHBseSh2b2lkIDAsIFtlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFja3RyYWNlIHx8IGVycm9yLmZpbGVOYW1lICsgXCI6XCIgKyBlcnJvci5saW5lTnVtYmVyXS5jb25jYXQoYXJncykpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0ZXN0KFwiZ2xvYmFsIGZhaWx1cmVcIiwgZXh0ZW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcHVzaEZhaWx1cmUuYXBwbHkodm9pZCAwLCBbZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2t0cmFjZSB8fCBlcnJvci5maWxlTmFtZSArIFwiOlwiICsgZXJyb3IubGluZU51bWJlcl0uY29uY2F0KGFyZ3MpKTtcblx0ICAgIH0sIHtcblx0ICAgICAgdmFsaWRUZXN0OiB0cnVlXG5cdCAgICB9KSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gb25VbmhhbmRsZWRSZWplY3Rpb24ocmVhc29uKSB7XG5cdCAgdmFyIHJlc3VsdEluZm8gPSB7XG5cdCAgICByZXN1bHQ6IGZhbHNlLFxuXHQgICAgbWVzc2FnZTogcmVhc29uLm1lc3NhZ2UgfHwgXCJlcnJvclwiLFxuXHQgICAgYWN0dWFsOiByZWFzb24sXG5cdCAgICBzb3VyY2U6IHJlYXNvbi5zdGFjayB8fCBzb3VyY2VGcm9tU3RhY2t0cmFjZSgzKVxuXHQgIH07XG5cdCAgdmFyIGN1cnJlbnRUZXN0ID0gY29uZmlnLmN1cnJlbnQ7XG5cblx0ICBpZiAoY3VycmVudFRlc3QpIHtcblx0ICAgIGN1cnJlbnRUZXN0LmFzc2VydC5wdXNoUmVzdWx0KHJlc3VsdEluZm8pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0ZXN0KFwiZ2xvYmFsIGZhaWx1cmVcIiwgZXh0ZW5kKGZ1bmN0aW9uIChhc3NlcnQpIHtcblx0ICAgICAgYXNzZXJ0LnB1c2hSZXN1bHQocmVzdWx0SW5mbyk7XG5cdCAgICB9LCB7XG5cdCAgICAgIHZhbGlkVGVzdDogdHJ1ZVxuXHQgICAgfSkpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBRVW5pdCA9IHt9O1xuXHR2YXIgZ2xvYmFsU3VpdGUgPSBuZXcgU3VpdGVSZXBvcnQoKTsgLy8gVGhlIGluaXRpYWwgXCJjdXJyZW50TW9kdWxlXCIgcmVwcmVzZW50cyB0aGUgZ2xvYmFsIChvciB0b3AtbGV2ZWwpIG1vZHVsZSB0aGF0XG5cdC8vIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgYnkgdGhlIHVzZXIsIHRoZXJlZm9yZSB3ZSBhZGQgdGhlIFwiZ2xvYmFsU3VpdGVcIiB0b1xuXHQvLyBpdCBzaW5jZSBlYWNoIG1vZHVsZSBoYXMgYSBzdWl0ZVJlcG9ydCBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblx0Y29uZmlnLmN1cnJlbnRNb2R1bGUuc3VpdGVSZXBvcnQgPSBnbG9iYWxTdWl0ZTtcblx0dmFyIGdsb2JhbFN0YXJ0Q2FsbGVkID0gZmFsc2U7XG5cdHZhciBydW5TdGFydGVkID0gZmFsc2U7IC8vIEZpZ3VyZSBvdXQgaWYgd2UncmUgcnVubmluZyB0aGUgdGVzdHMgZnJvbSBhIHNlcnZlciBvciBub3RcblxuXHRRVW5pdC5pc0xvY2FsID0gIShkZWZpbmVkLmRvY3VtZW50ICYmIHdpbmRvdyQxLmxvY2F0aW9uLnByb3RvY29sICE9PSBcImZpbGU6XCIpOyAvLyBFeHBvc2UgdGhlIGN1cnJlbnQgUVVuaXQgdmVyc2lvblxuXG5cdFFVbml0LnZlcnNpb24gPSBcIjIuMTEuM1wiO1xuXHRleHRlbmQoUVVuaXQsIHtcblx0ICBvbjogb24sXG5cdCAgbW9kdWxlOiBtb2R1bGUkMSxcblx0ICB0ZXN0OiB0ZXN0LFxuXHQgIHRvZG86IHRvZG8sXG5cdCAgc2tpcDogc2tpcCxcblx0ICBvbmx5OiBvbmx5LFxuXHQgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChjb3VudCkge1xuXHQgICAgdmFyIGdsb2JhbFN0YXJ0QWxyZWFkeUNhbGxlZCA9IGdsb2JhbFN0YXJ0Q2FsbGVkO1xuXG5cdCAgICBpZiAoIWNvbmZpZy5jdXJyZW50KSB7XG5cdCAgICAgIGdsb2JhbFN0YXJ0Q2FsbGVkID0gdHJ1ZTtcblxuXHQgICAgICBpZiAocnVuU3RhcnRlZCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBzdGFydCgpIHdoaWxlIHRlc3QgYWxyZWFkeSBzdGFydGVkIHJ1bm5pbmdcIik7XG5cdCAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsU3RhcnRBbHJlYWR5Q2FsbGVkIHx8IGNvdW50ID4gMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBzdGFydCgpIG91dHNpZGUgb2YgYSB0ZXN0IGNvbnRleHQgdG9vIG1hbnkgdGltZXNcIik7XG5cdCAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmF1dG9zdGFydCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBzdGFydCgpIG91dHNpZGUgb2YgYSB0ZXN0IGNvbnRleHQgd2hlbiBcIiArIFwiUVVuaXQuY29uZmlnLmF1dG9zdGFydCB3YXMgdHJ1ZVwiKTtcblx0ICAgICAgfSBlbHNlIGlmICghY29uZmlnLnBhZ2VMb2FkZWQpIHtcblx0ICAgICAgICAvLyBUaGUgcGFnZSBpc24ndCBjb21wbGV0ZWx5IGxvYWRlZCB5ZXQsIHNvIHdlIHNldCBhdXRvc3RhcnQgYW5kIHRoZW5cblx0ICAgICAgICAvLyBsb2FkIGlmIHdlJ3JlIGluIE5vZGUgb3Igd2FpdCBmb3IgdGhlIGJyb3dzZXIncyBsb2FkIGV2ZW50LlxuXHQgICAgICAgIGNvbmZpZy5hdXRvc3RhcnQgPSB0cnVlOyAvLyBTdGFydHMgZnJvbSBOb2RlIGV2ZW4gaWYgLmxvYWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhbGxlZC4gV2Ugc3RpbGwgcmV0dXJuXG5cdCAgICAgICAgLy8gZWFybHkgb3RoZXJ3aXNlIHdlJ2xsIHdpbmQgdXAgXCJiZWdpbm5pbmdcIiB0d2ljZS5cblxuXHQgICAgICAgIGlmICghZGVmaW5lZC5kb2N1bWVudCkge1xuXHQgICAgICAgICAgUVVuaXQubG9hZCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUVVuaXQuc3RhcnQgY2Fubm90IGJlIGNhbGxlZCBpbnNpZGUgYSB0ZXN0IGNvbnRleHQuXCIpO1xuXHQgICAgfVxuXG5cdCAgICBzY2hlZHVsZUJlZ2luKCk7XG5cdCAgfSxcblx0ICBjb25maWc6IGNvbmZpZyxcblx0ICBpczogaXMsXG5cdCAgb2JqZWN0VHlwZTogb2JqZWN0VHlwZSxcblx0ICBleHRlbmQ6IGV4dGVuZCxcblx0ICBsb2FkOiBmdW5jdGlvbiBsb2FkKCkge1xuXHQgICAgY29uZmlnLnBhZ2VMb2FkZWQgPSB0cnVlOyAvLyBJbml0aWFsaXplIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcblxuXHQgICAgZXh0ZW5kKGNvbmZpZywge1xuXHQgICAgICBzdGF0czoge1xuXHQgICAgICAgIGFsbDogMCxcblx0ICAgICAgICBiYWQ6IDAsXG5cdCAgICAgICAgdGVzdENvdW50OiAwXG5cdCAgICAgIH0sXG5cdCAgICAgIHN0YXJ0ZWQ6IDAsXG5cdCAgICAgIHVwZGF0ZVJhdGU6IDEwMDAsXG5cdCAgICAgIGF1dG9zdGFydDogdHJ1ZSxcblx0ICAgICAgZmlsdGVyOiBcIlwiXG5cdCAgICB9LCB0cnVlKTtcblxuXHQgICAgaWYgKCFydW5TdGFydGVkKSB7XG5cdCAgICAgIGNvbmZpZy5ibG9ja2luZyA9IGZhbHNlO1xuXG5cdCAgICAgIGlmIChjb25maWcuYXV0b3N0YXJ0KSB7XG5cdCAgICAgICAgc2NoZWR1bGVCZWdpbigpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBzdGFjazogZnVuY3Rpb24gc3RhY2sob2Zmc2V0KSB7XG5cdCAgICBvZmZzZXQgPSAob2Zmc2V0IHx8IDApICsgMjtcblx0ICAgIHJldHVybiBzb3VyY2VGcm9tU3RhY2t0cmFjZShvZmZzZXQpO1xuXHQgIH0sXG5cdCAgb25FcnJvcjogb25FcnJvcixcblx0ICBvblVuaGFuZGxlZFJlamVjdGlvbjogb25VbmhhbmRsZWRSZWplY3Rpb25cblx0fSk7XG5cdFFVbml0LnB1c2hGYWlsdXJlID0gcHVzaEZhaWx1cmU7XG5cdFFVbml0LmFzc2VydCA9IEFzc2VydC5wcm90b3R5cGU7XG5cdFFVbml0LmVxdWl2ID0gZXF1aXY7XG5cdFFVbml0LmR1bXAgPSBkdW1wO1xuXHRyZWdpc3RlckxvZ2dpbmdDYWxsYmFja3MoUVVuaXQpO1xuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlQmVnaW4oKSB7XG5cdCAgcnVuU3RhcnRlZCA9IHRydWU7IC8vIEFkZCBhIHNsaWdodCBkZWxheSB0byBhbGxvdyBkZWZpbml0aW9uIG9mIG1vcmUgbW9kdWxlcyBhbmQgdGVzdHMuXG5cblx0ICBpZiAoZGVmaW5lZC5zZXRUaW1lb3V0KSB7XG5cdCAgICBzZXRUaW1lb3V0JDEoZnVuY3Rpb24gKCkge1xuXHQgICAgICBiZWdpbigpO1xuXHQgICAgfSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJlZ2luKCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdW5ibG9ja0FuZEFkdmFuY2VRdWV1ZSgpIHtcblx0ICBjb25maWcuYmxvY2tpbmcgPSBmYWxzZTtcblx0ICBQcm9jZXNzaW5nUXVldWUuYWR2YW5jZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmVnaW4oKSB7XG5cdCAgdmFyIGksXG5cdCAgICAgIGwsXG5cdCAgICAgIG1vZHVsZXNMb2cgPSBbXTsgLy8gSWYgdGhlIHRlc3QgcnVuIGhhc24ndCBvZmZpY2lhbGx5IGJlZ3VuIHlldFxuXG5cdCAgaWYgKCFjb25maWcuc3RhcnRlZCkge1xuXHQgICAgLy8gUmVjb3JkIHRoZSB0aW1lIG9mIHRoZSB0ZXN0IHJ1bidzIGJlZ2lubmluZ1xuXHQgICAgY29uZmlnLnN0YXJ0ZWQgPSBub3coKTsgLy8gRGVsZXRlIHRoZSBsb29zZSB1bm5hbWVkIG1vZHVsZSBpZiB1bnVzZWQuXG5cblx0ICAgIGlmIChjb25maWcubW9kdWxlc1swXS5uYW1lID09PSBcIlwiICYmIGNvbmZpZy5tb2R1bGVzWzBdLnRlc3RzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICBjb25maWcubW9kdWxlcy5zaGlmdCgpO1xuXHQgICAgfSAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBieSBub3QgbG9nZ2luZyBtb2R1bGVzJyB0ZXN0IGVudmlyb25tZW50c1xuXG5cblx0ICAgIGZvciAoaSA9IDAsIGwgPSBjb25maWcubW9kdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgbW9kdWxlc0xvZy5wdXNoKHtcblx0ICAgICAgICBuYW1lOiBjb25maWcubW9kdWxlc1tpXS5uYW1lLFxuXHQgICAgICAgIHRlc3RzOiBjb25maWcubW9kdWxlc1tpXS50ZXN0c1xuXHQgICAgICB9KTtcblx0ICAgIH0gLy8gVGhlIHRlc3QgcnVuIGlzIG9mZmljaWFsbHkgYmVnaW5uaW5nIG5vd1xuXG5cblx0ICAgIGVtaXQoXCJydW5TdGFydFwiLCBnbG9iYWxTdWl0ZS5zdGFydCh0cnVlKSk7XG5cdCAgICBydW5Mb2dnaW5nQ2FsbGJhY2tzKFwiYmVnaW5cIiwge1xuXHQgICAgICB0b3RhbFRlc3RzOiBUZXN0LmNvdW50LFxuXHQgICAgICBtb2R1bGVzOiBtb2R1bGVzTG9nXG5cdCAgICB9KS50aGVuKHVuYmxvY2tBbmRBZHZhbmNlUXVldWUpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB1bmJsb2NrQW5kQWR2YW5jZVF1ZXVlKCk7XG5cdCAgfVxuXHR9XG5cdGV4cG9ydFFVbml0KFFVbml0KTtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0eXBlb2Ygd2luZG93JDEgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGRvY3VtZW50JDEgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgY29uZmlnID0gUVVuaXQuY29uZmlnLFxuXHQgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5OyAvLyBTdG9yZXMgZml4dHVyZSBIVE1MIGZvciByZXNldHRpbmcgbGF0ZXJcblxuXHQgIGZ1bmN0aW9uIHN0b3JlRml4dHVyZSgpIHtcblx0ICAgIC8vIEF2b2lkIG92ZXJ3cml0aW5nIHVzZXItZGVmaW5lZCB2YWx1ZXNcblx0ICAgIGlmIChoYXNPd24uY2FsbChjb25maWcsIFwiZml4dHVyZVwiKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBmaXh0dXJlID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50QnlJZChcInF1bml0LWZpeHR1cmVcIik7XG5cblx0ICAgIGlmIChmaXh0dXJlKSB7XG5cdCAgICAgIGNvbmZpZy5maXh0dXJlID0gZml4dHVyZS5jbG9uZU5vZGUodHJ1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgUVVuaXQuYmVnaW4oc3RvcmVGaXh0dXJlKTsgLy8gUmVzZXRzIHRoZSBmaXh0dXJlIERPTSBlbGVtZW50IGlmIGF2YWlsYWJsZS5cblxuXHQgIGZ1bmN0aW9uIHJlc2V0Rml4dHVyZSgpIHtcblx0ICAgIGlmIChjb25maWcuZml4dHVyZSA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIGZpeHR1cmUgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRCeUlkKFwicXVuaXQtZml4dHVyZVwiKTtcblxuXHQgICAgdmFyIHJlc2V0Rml4dHVyZVR5cGUgPSBfdHlwZW9mKGNvbmZpZy5maXh0dXJlKTtcblxuXHQgICAgaWYgKHJlc2V0Rml4dHVyZVR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgLy8gc3VwcG9ydCB1c2VyIGRlZmluZWQgdmFsdWVzIGZvciBgY29uZmlnLmZpeHR1cmVgXG5cdCAgICAgIHZhciBuZXdGaXh0dXJlID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHQgICAgICBuZXdGaXh0dXJlLnNldEF0dHJpYnV0ZShcImlkXCIsIFwicXVuaXQtZml4dHVyZVwiKTtcblx0ICAgICAgbmV3Rml4dHVyZS5pbm5lckhUTUwgPSBjb25maWcuZml4dHVyZTtcblx0ICAgICAgZml4dHVyZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdGaXh0dXJlLCBmaXh0dXJlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBjbG9uZWRGaXh0dXJlID0gY29uZmlnLmZpeHR1cmUuY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICBmaXh0dXJlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNsb25lZEZpeHR1cmUsIGZpeHR1cmUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIFFVbml0LnRlc3RTdGFydChyZXNldEZpeHR1cmUpO1xuXHR9KSgpO1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgLy8gT25seSBpbnRlcmFjdCB3aXRoIFVSTHMgdmlhIHdpbmRvdy5sb2NhdGlvblxuXHQgIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3ckMSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3ckMS5sb2NhdGlvbjtcblxuXHQgIGlmICghbG9jYXRpb24pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgdXJsUGFyYW1zID0gZ2V0VXJsUGFyYW1zKCk7XG5cdCAgUVVuaXQudXJsUGFyYW1zID0gdXJsUGFyYW1zOyAvLyBNYXRjaCBtb2R1bGUvdGVzdCBieSBpbmNsdXNpb24gaW4gYW4gYXJyYXlcblxuXHQgIFFVbml0LmNvbmZpZy5tb2R1bGVJZCA9IFtdLmNvbmNhdCh1cmxQYXJhbXMubW9kdWxlSWQgfHwgW10pO1xuXHQgIFFVbml0LmNvbmZpZy50ZXN0SWQgPSBbXS5jb25jYXQodXJsUGFyYW1zLnRlc3RJZCB8fCBbXSk7IC8vIEV4YWN0IGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggb2YgdGhlIG1vZHVsZSBuYW1lXG5cblx0ICBRVW5pdC5jb25maWcubW9kdWxlID0gdXJsUGFyYW1zLm1vZHVsZTsgLy8gUmVndWxhciBleHByZXNzaW9uIG9yIGNhc2UtaW5zZW5zdGl2ZSBzdWJzdHJpbmcgbWF0Y2ggYWdhaW5zdCBcIm1vZHVsZU5hbWU6IHRlc3ROYW1lXCJcblxuXHQgIFFVbml0LmNvbmZpZy5maWx0ZXIgPSB1cmxQYXJhbXMuZmlsdGVyOyAvLyBUZXN0IG9yZGVyIHJhbmRvbWl6YXRpb25cblxuXHQgIGlmICh1cmxQYXJhbXMuc2VlZCA9PT0gdHJ1ZSkge1xuXHQgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gc2VlZCBpZiB0aGUgb3B0aW9uIGlzIHNwZWNpZmllZCB3aXRob3V0IGEgdmFsdWVcblx0ICAgIFFVbml0LmNvbmZpZy5zZWVkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cdCAgfSBlbHNlIGlmICh1cmxQYXJhbXMuc2VlZCkge1xuXHQgICAgUVVuaXQuY29uZmlnLnNlZWQgPSB1cmxQYXJhbXMuc2VlZDtcblx0ICB9IC8vIEFkZCBVUkwtcGFyYW1ldGVyLW1hcHBlZCBjb25maWcgdmFsdWVzIHdpdGggVUkgZm9ybSByZW5kZXJpbmcgZGF0YVxuXG5cblx0ICBRVW5pdC5jb25maWcudXJsQ29uZmlnLnB1c2goe1xuXHQgICAgaWQ6IFwiaGlkZXBhc3NlZFwiLFxuXHQgICAgbGFiZWw6IFwiSGlkZSBwYXNzZWQgdGVzdHNcIixcblx0ICAgIHRvb2x0aXA6IFwiT25seSBzaG93IHRlc3RzIGFuZCBhc3NlcnRpb25zIHRoYXQgZmFpbC4gU3RvcmVkIGFzIHF1ZXJ5LXN0cmluZ3MuXCJcblx0ICB9LCB7XG5cdCAgICBpZDogXCJub2dsb2JhbHNcIixcblx0ICAgIGxhYmVsOiBcIkNoZWNrIGZvciBHbG9iYWxzXCIsXG5cdCAgICB0b29sdGlwOiBcIkVuYWJsaW5nIHRoaXMgd2lsbCB0ZXN0IGlmIGFueSB0ZXN0IGludHJvZHVjZXMgbmV3IHByb3BlcnRpZXMgb24gdGhlIFwiICsgXCJnbG9iYWwgb2JqZWN0IChgd2luZG93YCBpbiBCcm93c2VycykuIFN0b3JlZCBhcyBxdWVyeS1zdHJpbmdzLlwiXG5cdCAgfSwge1xuXHQgICAgaWQ6IFwibm90cnljYXRjaFwiLFxuXHQgICAgbGFiZWw6IFwiTm8gdHJ5LWNhdGNoXCIsXG5cdCAgICB0b29sdGlwOiBcIkVuYWJsaW5nIHRoaXMgd2lsbCBydW4gdGVzdHMgb3V0c2lkZSBvZiBhIHRyeS1jYXRjaCBibG9jay4gTWFrZXMgZGVidWdnaW5nIFwiICsgXCJleGNlcHRpb25zIGluIElFIHJlYXNvbmFibGUuIFN0b3JlZCBhcyBxdWVyeS1zdHJpbmdzLlwiXG5cdCAgfSk7XG5cdCAgUVVuaXQuYmVnaW4oZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGksXG5cdCAgICAgICAgb3B0aW9uLFxuXHQgICAgICAgIHVybENvbmZpZyA9IFFVbml0LmNvbmZpZy51cmxDb25maWc7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCB1cmxDb25maWcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gT3B0aW9ucyBjYW4gYmUgZWl0aGVyIHN0cmluZ3Mgb3Igb2JqZWN0cyB3aXRoIG5vbmVtcHR5IFwiaWRcIiBwcm9wZXJ0aWVzXG5cdCAgICAgIG9wdGlvbiA9IFFVbml0LmNvbmZpZy51cmxDb25maWdbaV07XG5cblx0ICAgICAgaWYgKHR5cGVvZiBvcHRpb24gIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBvcHRpb24gPSBvcHRpb24uaWQ7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoUVVuaXQuY29uZmlnW29wdGlvbl0gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIFFVbml0LmNvbmZpZ1tvcHRpb25dID0gdXJsUGFyYW1zW29wdGlvbl07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIGZ1bmN0aW9uIGdldFVybFBhcmFtcygpIHtcblx0ICAgIHZhciBpLCBwYXJhbSwgbmFtZSwgdmFsdWU7XG5cdCAgICB2YXIgdXJsUGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkuc3BsaXQoXCImXCIpO1xuXHQgICAgdmFyIGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAocGFyYW1zW2ldKSB7XG5cdCAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV0uc3BsaXQoXCI9XCIpO1xuXHQgICAgICAgIG5hbWUgPSBkZWNvZGVRdWVyeVBhcmFtKHBhcmFtWzBdKTsgLy8gQWxsb3cganVzdCBhIGtleSB0byB0dXJuIG9uIGEgZmxhZywgZS5nLiwgdGVzdC5odG1sP25vZ2xvYmFsc1xuXG5cdCAgICAgICAgdmFsdWUgPSBwYXJhbS5sZW5ndGggPT09IDEgfHwgZGVjb2RlUXVlcnlQYXJhbShwYXJhbS5zbGljZSgxKS5qb2luKFwiPVwiKSk7XG5cblx0ICAgICAgICBpZiAobmFtZSBpbiB1cmxQYXJhbXMpIHtcblx0ICAgICAgICAgIHVybFBhcmFtc1tuYW1lXSA9IFtdLmNvbmNhdCh1cmxQYXJhbXNbbmFtZV0sIHZhbHVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdXJsUGFyYW1zW25hbWVdID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1cmxQYXJhbXM7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZGVjb2RlUXVlcnlQYXJhbShwYXJhbSkge1xuXHQgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbS5yZXBsYWNlKC9cXCsvZywgXCIlMjBcIikpO1xuXHQgIH1cblx0fSkoKTtcblxuXHR2YXIgZnV6enlzb3J0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG5cdCAgKGZ1bmN0aW9uIChyb290LCBVTUQpIHtcblx0ICAgIGlmICggbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gVU1EKCk7ZWxzZSByb290LmZ1enp5c29ydCA9IFVNRCgpO1xuXHQgIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiBVTUQoKSB7XG5cdCAgICBmdW5jdGlvbiBmdXp6eXNvcnROZXcoaW5zdGFuY2VPcHRpb25zKSB7XG5cdCAgICAgIHZhciBmdXp6eXNvcnQgPSB7XG5cdCAgICAgICAgc2luZ2xlOiBmdW5jdGlvbiAoc2VhcmNoLCB0YXJnZXQsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgIGlmICghc2VhcmNoKSByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgIGlmICghaXNPYmooc2VhcmNoKSkgc2VhcmNoID0gZnV6enlzb3J0LmdldFByZXBhcmVkU2VhcmNoKHNlYXJjaCk7XG5cdCAgICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICBpZiAoIWlzT2JqKHRhcmdldCkpIHRhcmdldCA9IGZ1enp5c29ydC5nZXRQcmVwYXJlZCh0YXJnZXQpO1xuXHQgICAgICAgICAgdmFyIGFsbG93VHlwbyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd1R5cG8gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWxsb3dUeXBvIDogaW5zdGFuY2VPcHRpb25zICYmIGluc3RhbmNlT3B0aW9ucy5hbGxvd1R5cG8gIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlT3B0aW9ucy5hbGxvd1R5cG8gOiB0cnVlO1xuXHQgICAgICAgICAgdmFyIGFsZ29yaXRobSA9IGFsbG93VHlwbyA/IGZ1enp5c29ydC5hbGdvcml0aG0gOiBmdXp6eXNvcnQuYWxnb3JpdGhtTm9UeXBvO1xuXHQgICAgICAgICAgcmV0dXJuIGFsZ29yaXRobShzZWFyY2gsIHRhcmdldCwgc2VhcmNoWzBdKTsgLy8gdmFyIHRocmVzaG9sZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aHJlc2hvbGQgfHwgaW5zdGFuY2VPcHRpb25zICYmIGluc3RhbmNlT3B0aW9ucy50aHJlc2hvbGQgfHwgLTkwMDcxOTkyNTQ3NDA5OTFcblx0ICAgICAgICAgIC8vIHZhciByZXN1bHQgPSBhbGdvcml0aG0oc2VhcmNoLCB0YXJnZXQsIHNlYXJjaFswXSlcblx0ICAgICAgICAgIC8vIGlmKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIG51bGxcblx0ICAgICAgICAgIC8vIGlmKHJlc3VsdC5zY29yZSA8IHRocmVzaG9sZCkgcmV0dXJuIG51bGxcblx0ICAgICAgICAgIC8vIHJldHVybiByZXN1bHRcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdvOiBmdW5jdGlvbiAoc2VhcmNoLCB0YXJnZXRzLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICBpZiAoIXNlYXJjaCkgcmV0dXJuIG5vUmVzdWx0cztcblx0ICAgICAgICAgIHNlYXJjaCA9IGZ1enp5c29ydC5wcmVwYXJlU2VhcmNoKHNlYXJjaCk7XG5cdCAgICAgICAgICB2YXIgc2VhcmNoTG93ZXJDb2RlID0gc2VhcmNoWzBdO1xuXHQgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aHJlc2hvbGQgfHwgaW5zdGFuY2VPcHRpb25zICYmIGluc3RhbmNlT3B0aW9ucy50aHJlc2hvbGQgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7XG5cdCAgICAgICAgICB2YXIgbGltaXQgPSBvcHRpb25zICYmIG9wdGlvbnMubGltaXQgfHwgaW5zdGFuY2VPcHRpb25zICYmIGluc3RhbmNlT3B0aW9ucy5saW1pdCB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXHQgICAgICAgICAgdmFyIGFsbG93VHlwbyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd1R5cG8gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWxsb3dUeXBvIDogaW5zdGFuY2VPcHRpb25zICYmIGluc3RhbmNlT3B0aW9ucy5hbGxvd1R5cG8gIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlT3B0aW9ucy5hbGxvd1R5cG8gOiB0cnVlO1xuXHQgICAgICAgICAgdmFyIGFsZ29yaXRobSA9IGFsbG93VHlwbyA/IGZ1enp5c29ydC5hbGdvcml0aG0gOiBmdXp6eXNvcnQuYWxnb3JpdGhtTm9UeXBvO1xuXHQgICAgICAgICAgdmFyIHJlc3VsdHNMZW4gPSAwO1xuXHQgICAgICAgICAgdmFyIGxpbWl0ZWRDb3VudCA9IDA7XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0c0xlbiA9IHRhcmdldHMubGVuZ3RoOyAvLyBUaGlzIGNvZGUgaXMgY29weS9wYXN0ZWQgMyB0aW1lcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBbb3B0aW9ucy5rZXlzLCBvcHRpb25zLmtleSwgbm8ga2V5c11cblx0ICAgICAgICAgIC8vIG9wdGlvbnMua2V5c1xuXG5cdCAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmtleXMpIHtcblx0ICAgICAgICAgICAgdmFyIHNjb3JlRm4gPSBvcHRpb25zLnNjb3JlRm4gfHwgZGVmYXVsdFNjb3JlRm47XG5cdCAgICAgICAgICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuXHQgICAgICAgICAgICB2YXIga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0YXJnZXRzTGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0ICAgICAgICAgICAgICB2YXIgb2JqID0gdGFyZ2V0c1tpXTtcblx0ICAgICAgICAgICAgICB2YXIgb2JqUmVzdWx0cyA9IG5ldyBBcnJheShrZXlzTGVuKTtcblxuXHQgICAgICAgICAgICAgIGZvciAodmFyIGtleUkgPSBrZXlzTGVuIC0gMTsga2V5SSA+PSAwOyAtLWtleUkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2tleUldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldFZhbHVlKG9iaiwga2V5KTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgb2JqUmVzdWx0c1trZXlJXSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWlzT2JqKHRhcmdldCkpIHRhcmdldCA9IGZ1enp5c29ydC5nZXRQcmVwYXJlZCh0YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgb2JqUmVzdWx0c1trZXlJXSA9IGFsZ29yaXRobShzZWFyY2gsIHRhcmdldCwgc2VhcmNoTG93ZXJDb2RlKTtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBvYmpSZXN1bHRzLm9iaiA9IG9iajsgLy8gYmVmb3JlIHNjb3JlRm4gc28gc2NvcmVGbiBjYW4gdXNlIGl0XG5cblx0ICAgICAgICAgICAgICB2YXIgc2NvcmUgPSBzY29yZUZuKG9ialJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgIGlmIChzY29yZSA9PT0gbnVsbCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgdGhyZXNob2xkKSBjb250aW51ZTtcblx0ICAgICAgICAgICAgICBvYmpSZXN1bHRzLnNjb3JlID0gc2NvcmU7XG5cblx0ICAgICAgICAgICAgICBpZiAocmVzdWx0c0xlbiA8IGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICBxLmFkZChvYmpSZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgICsrcmVzdWx0c0xlbjtcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgKytsaW1pdGVkQ291bnQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBxLnBlZWsoKS5zY29yZSkgcS5yZXBsYWNlVG9wKG9ialJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSAvLyBvcHRpb25zLmtleVxuXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5rZXkpIHtcblx0ICAgICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0YXJnZXRzTGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0ICAgICAgICAgICAgICB2YXIgb2JqID0gdGFyZ2V0c1tpXTtcblx0ICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VmFsdWUob2JqLCBrZXkpO1xuXHQgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSBjb250aW51ZTtcblx0ICAgICAgICAgICAgICBpZiAoIWlzT2JqKHRhcmdldCkpIHRhcmdldCA9IGZ1enp5c29ydC5nZXRQcmVwYXJlZCh0YXJnZXQpO1xuXHQgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbGdvcml0aG0oc2VhcmNoLCB0YXJnZXQsIHNlYXJjaExvd2VyQ29kZSk7XG5cdCAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zY29yZSA8IHRocmVzaG9sZCkgY29udGludWU7IC8vIGhhdmUgdG8gY2xvbmUgcmVzdWx0IHNvIGR1cGxpY2F0ZSB0YXJnZXRzIGZyb20gZGlmZmVyZW50IG9iaiBjYW4gZWFjaCByZWZlcmVuY2UgdGhlIGNvcnJlY3Qgb2JqXG5cblx0ICAgICAgICAgICAgICByZXN1bHQgPSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlc3VsdC50YXJnZXQsXG5cdCAgICAgICAgICAgICAgICBfdGFyZ2V0TG93ZXJDb2RlczogbnVsbCxcblx0ICAgICAgICAgICAgICAgIF9uZXh0QmVnaW5uaW5nSW5kZXhlczogbnVsbCxcblx0ICAgICAgICAgICAgICAgIHNjb3JlOiByZXN1bHQuc2NvcmUsXG5cdCAgICAgICAgICAgICAgICBpbmRleGVzOiByZXN1bHQuaW5kZXhlcyxcblx0ICAgICAgICAgICAgICAgIG9iajogb2JqXG5cdCAgICAgICAgICAgICAgfTsgLy8gaGlkZGVuXG5cblx0ICAgICAgICAgICAgICBpZiAocmVzdWx0c0xlbiA8IGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICBxLmFkZChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgKytyZXN1bHRzTGVuO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICArK2xpbWl0ZWRDb3VudDtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2NvcmUgPiBxLnBlZWsoKS5zY29yZSkgcS5yZXBsYWNlVG9wKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IC8vIG5vIGtleXNcblxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRhcmdldHNMZW4gLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuXHQgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSBjb250aW51ZTtcblx0ICAgICAgICAgICAgICBpZiAoIWlzT2JqKHRhcmdldCkpIHRhcmdldCA9IGZ1enp5c29ydC5nZXRQcmVwYXJlZCh0YXJnZXQpO1xuXHQgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbGdvcml0aG0oc2VhcmNoLCB0YXJnZXQsIHNlYXJjaExvd2VyQ29kZSk7XG5cdCAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zY29yZSA8IHRocmVzaG9sZCkgY29udGludWU7XG5cblx0ICAgICAgICAgICAgICBpZiAocmVzdWx0c0xlbiA8IGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICBxLmFkZChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgKytyZXN1bHRzTGVuO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICArK2xpbWl0ZWRDb3VudDtcblx0ICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2NvcmUgPiBxLnBlZWsoKS5zY29yZSkgcS5yZXBsYWNlVG9wKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChyZXN1bHRzTGVuID09PSAwKSByZXR1cm4gbm9SZXN1bHRzO1xuXHQgICAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocmVzdWx0c0xlbik7XG5cblx0ICAgICAgICAgIGZvciAodmFyIGkgPSByZXN1bHRzTGVuIC0gMTsgaSA+PSAwOyAtLWkpIHJlc3VsdHNbaV0gPSBxLnBvbGwoKTtcblxuXHQgICAgICAgICAgcmVzdWx0cy50b3RhbCA9IHJlc3VsdHNMZW4gKyBsaW1pdGVkQ291bnQ7XG5cdCAgICAgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdvQXN5bmM6IGZ1bmN0aW9uIChzZWFyY2gsIHRhcmdldHMsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgIGlmICghc2VhcmNoKSByZXR1cm4gcmVzb2x2ZShub1Jlc3VsdHMpO1xuXHQgICAgICAgICAgICBzZWFyY2ggPSBmdXp6eXNvcnQucHJlcGFyZVNlYXJjaChzZWFyY2gpO1xuXHQgICAgICAgICAgICB2YXIgc2VhcmNoTG93ZXJDb2RlID0gc2VhcmNoWzBdO1xuXHQgICAgICAgICAgICB2YXIgcSA9IGZhc3Rwcmlvcml0eXF1ZXVlKCk7XG5cdCAgICAgICAgICAgIHZhciBpQ3VycmVudCA9IHRhcmdldHMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aHJlc2hvbGQgfHwgaW5zdGFuY2VPcHRpb25zICYmIGluc3RhbmNlT3B0aW9ucy50aHJlc2hvbGQgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7XG5cdCAgICAgICAgICAgIHZhciBsaW1pdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5saW1pdCB8fCBpbnN0YW5jZU9wdGlvbnMgJiYgaW5zdGFuY2VPcHRpb25zLmxpbWl0IHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cdCAgICAgICAgICAgIHZhciBhbGxvd1R5cG8gPSBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dUeXBvICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFsbG93VHlwbyA6IGluc3RhbmNlT3B0aW9ucyAmJiBpbnN0YW5jZU9wdGlvbnMuYWxsb3dUeXBvICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZU9wdGlvbnMuYWxsb3dUeXBvIDogdHJ1ZTtcblx0ICAgICAgICAgICAgdmFyIGFsZ29yaXRobSA9IGFsbG93VHlwbyA/IGZ1enp5c29ydC5hbGdvcml0aG0gOiBmdXp6eXNvcnQuYWxnb3JpdGhtTm9UeXBvO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0c0xlbiA9IDA7XG5cdCAgICAgICAgICAgIHZhciBsaW1pdGVkQ291bnQgPSAwO1xuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNhbmNlbGVkKSByZXR1cm4gcmVqZWN0KCdjYW5jZWxlZCcpO1xuXHQgICAgICAgICAgICAgIHZhciBzdGFydE1zID0gRGF0ZS5ub3coKTsgLy8gVGhpcyBjb2RlIGlzIGNvcHkvcGFzdGVkIDMgdGltZXMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgW29wdGlvbnMua2V5cywgb3B0aW9ucy5rZXksIG5vIGtleXNdXG5cdCAgICAgICAgICAgICAgLy8gb3B0aW9ucy5rZXlzXG5cblx0ICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmtleXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzY29yZUZuID0gb3B0aW9ucy5zY29yZUZuIHx8IGRlZmF1bHRTY29yZUZuO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKDsgaUN1cnJlbnQgPj0gMDsgLS1pQ3VycmVudCkge1xuXHQgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGFyZ2V0c1tpQ3VycmVudF07XG5cdCAgICAgICAgICAgICAgICAgIHZhciBvYmpSZXN1bHRzID0gbmV3IEFycmF5KGtleXNMZW4pO1xuXG5cdCAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleUkgPSBrZXlzTGVuIC0gMTsga2V5SSA+PSAwOyAtLWtleUkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1trZXlJXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VmFsdWUob2JqLCBrZXkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgIG9ialJlc3VsdHNba2V5SV0gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iaih0YXJnZXQpKSB0YXJnZXQgPSBmdXp6eXNvcnQuZ2V0UHJlcGFyZWQodGFyZ2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICBvYmpSZXN1bHRzW2tleUldID0gYWxnb3JpdGhtKHNlYXJjaCwgdGFyZ2V0LCBzZWFyY2hMb3dlckNvZGUpO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgb2JqUmVzdWx0cy5vYmogPSBvYmo7IC8vIGJlZm9yZSBzY29yZUZuIHNvIHNjb3JlRm4gY2FuIHVzZSBpdFxuXG5cdCAgICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IHNjb3JlRm4ob2JqUmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChzY29yZSA9PT0gbnVsbCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChzY29yZSA8IHRocmVzaG9sZCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgIG9ialJlc3VsdHMuc2NvcmUgPSBzY29yZTtcblxuXHQgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c0xlbiA8IGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcS5hZGQob2JqUmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgKytyZXN1bHRzTGVuO1xuXHQgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICsrbGltaXRlZENvdW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IHEucGVlaygpLnNjb3JlKSBxLnJlcGxhY2VUb3Aob2JqUmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICBpZiAoaUN1cnJlbnQgJSAxMDAwXG5cdCAgICAgICAgICAgICAgICAgIC8qaXRlbXNQZXJDaGVjayovXG5cdCAgICAgICAgICAgICAgICAgID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydE1zID49IDEwXG5cdCAgICAgICAgICAgICAgICAgICAgLyphc3luY0ludGVydmFsKi9cblx0ICAgICAgICAgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXNOb2RlID8gc2V0SW1tZWRpYXRlKHN0ZXApIDogc2V0VGltZW91dChzdGVwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IC8vIG9wdGlvbnMua2V5XG5cblx0ICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuXHQgICAgICAgICAgICAgICAgZm9yICg7IGlDdXJyZW50ID49IDA7IC0taUN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRhcmdldHNbaUN1cnJlbnRdO1xuXHQgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0VmFsdWUob2JqLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgIGlmICghaXNPYmoodGFyZ2V0KSkgdGFyZ2V0ID0gZnV6enlzb3J0LmdldFByZXBhcmVkKHRhcmdldCk7XG5cdCAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbGdvcml0aG0oc2VhcmNoLCB0YXJnZXQsIHNlYXJjaExvd2VyQ29kZSk7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNjb3JlIDwgdGhyZXNob2xkKSBjb250aW51ZTsgLy8gaGF2ZSB0byBjbG9uZSByZXN1bHQgc28gZHVwbGljYXRlIHRhcmdldHMgZnJvbSBkaWZmZXJlbnQgb2JqIGNhbiBlYWNoIHJlZmVyZW5jZSB0aGUgY29ycmVjdCBvYmpcblxuXHQgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiByZXN1bHQudGFyZ2V0LFxuXHQgICAgICAgICAgICAgICAgICAgIF90YXJnZXRMb3dlckNvZGVzOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgICAgIF9uZXh0QmVnaW5uaW5nSW5kZXhlczogbnVsbCxcblx0ICAgICAgICAgICAgICAgICAgICBzY29yZTogcmVzdWx0LnNjb3JlLFxuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHJlc3VsdC5pbmRleGVzLFxuXHQgICAgICAgICAgICAgICAgICAgIG9iajogb2JqXG5cdCAgICAgICAgICAgICAgICAgIH07IC8vIGhpZGRlblxuXG5cdCAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzTGVuIDwgbGltaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBxLmFkZChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICsrcmVzdWx0c0xlbjtcblx0ICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICArK2xpbWl0ZWRDb3VudDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNjb3JlID4gcS5wZWVrKCkuc2NvcmUpIHEucmVwbGFjZVRvcChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgaWYgKGlDdXJyZW50ICUgMTAwMFxuXHQgICAgICAgICAgICAgICAgICAvKml0ZW1zUGVyQ2hlY2sqL1xuXHQgICAgICAgICAgICAgICAgICA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnRNcyA+PSAxMFxuXHQgICAgICAgICAgICAgICAgICAgIC8qYXN5bmNJbnRlcnZhbCovXG5cdCAgICAgICAgICAgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzTm9kZSA/IHNldEltbWVkaWF0ZShzdGVwKSA6IHNldFRpbWVvdXQoc3RlcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSAvLyBubyBrZXlzXG5cblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZm9yICg7IGlDdXJyZW50ID49IDA7IC0taUN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaUN1cnJlbnRdO1xuXHQgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgIGlmICghaXNPYmoodGFyZ2V0KSkgdGFyZ2V0ID0gZnV6enlzb3J0LmdldFByZXBhcmVkKHRhcmdldCk7XG5cdCAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhbGdvcml0aG0oc2VhcmNoLCB0YXJnZXQsIHNlYXJjaExvd2VyQ29kZSk7XG5cdCAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnNjb3JlIDwgdGhyZXNob2xkKSBjb250aW51ZTtcblxuXHQgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c0xlbiA8IGxpbWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcS5hZGQocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICArK3Jlc3VsdHNMZW47XG5cdCAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKytsaW1pdGVkQ291bnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zY29yZSA+IHEucGVlaygpLnNjb3JlKSBxLnJlcGxhY2VUb3AocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgIGlmIChpQ3VycmVudCAlIDEwMDBcblx0ICAgICAgICAgICAgICAgICAgLyppdGVtc1BlckNoZWNrKi9cblx0ICAgICAgICAgICAgICAgICAgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0TXMgPj0gMTBcblx0ICAgICAgICAgICAgICAgICAgICAvKmFzeW5jSW50ZXJ2YWwqL1xuXHQgICAgICAgICAgICAgICAgICAgICkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpc05vZGUgPyBzZXRJbW1lZGlhdGUoc3RlcCkgOiBzZXRUaW1lb3V0KHN0ZXApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBpZiAocmVzdWx0c0xlbiA9PT0gMCkgcmV0dXJuIHJlc29sdmUobm9SZXN1bHRzKTtcblx0ICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShyZXN1bHRzTGVuKTtcblxuXHQgICAgICAgICAgICAgIGZvciAodmFyIGkgPSByZXN1bHRzTGVuIC0gMTsgaSA+PSAwOyAtLWkpIHJlc3VsdHNbaV0gPSBxLnBvbGwoKTtcblxuXHQgICAgICAgICAgICAgIHJlc3VsdHMudG90YWwgPSByZXN1bHRzTGVuICsgbGltaXRlZENvdW50O1xuXHQgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpc05vZGUgPyBzZXRJbW1lZGlhdGUoc3RlcCkgOiBzdGVwKCk7XG5cdCAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgcC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcblx0ICAgICAgICAgIH07XG5cblx0ICAgICAgICAgIHJldHVybiBwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAocmVzdWx0LCBoT3BlbiwgaENsb3NlKSB7XG5cdCAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgIGlmIChoT3BlbiA9PT0gdW5kZWZpbmVkKSBoT3BlbiA9ICc8Yj4nO1xuXHQgICAgICAgICAgaWYgKGhDbG9zZSA9PT0gdW5kZWZpbmVkKSBoQ2xvc2UgPSAnPC9iPic7XG5cdCAgICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSAnJztcblx0ICAgICAgICAgIHZhciBtYXRjaGVzSW5kZXggPSAwO1xuXHQgICAgICAgICAgdmFyIG9wZW5lZCA9IGZhbHNlO1xuXHQgICAgICAgICAgdmFyIHRhcmdldCA9IHJlc3VsdC50YXJnZXQ7XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0TGVuID0gdGFyZ2V0Lmxlbmd0aDtcblx0ICAgICAgICAgIHZhciBtYXRjaGVzQmVzdCA9IHJlc3VsdC5pbmRleGVzO1xuXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldExlbjsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFyID0gdGFyZ2V0W2ldO1xuXG5cdCAgICAgICAgICAgIGlmIChtYXRjaGVzQmVzdFttYXRjaGVzSW5kZXhdID09PSBpKSB7XG5cdCAgICAgICAgICAgICAgKyttYXRjaGVzSW5kZXg7XG5cblx0ICAgICAgICAgICAgICBpZiAoIW9wZW5lZCkge1xuXHQgICAgICAgICAgICAgICAgb3BlbmVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkICs9IGhPcGVuO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIGlmIChtYXRjaGVzSW5kZXggPT09IG1hdGNoZXNCZXN0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWQgKz0gY2hhciArIGhDbG9zZSArIHRhcmdldC5zdWJzdHIoaSArIDEpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIGlmIChvcGVuZWQpIHtcblx0ICAgICAgICAgICAgICAgIG9wZW5lZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWQgKz0gaENsb3NlO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGhpZ2hsaWdodGVkICs9IGNoYXI7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiBoaWdobGlnaHRlZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHByZXBhcmU6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcblx0ICAgICAgICAgICAgX3RhcmdldExvd2VyQ29kZXM6IGZ1enp5c29ydC5wcmVwYXJlTG93ZXJDb2Rlcyh0YXJnZXQpLFxuXHQgICAgICAgICAgICBfbmV4dEJlZ2lubmluZ0luZGV4ZXM6IG51bGwsXG5cdCAgICAgICAgICAgIHNjb3JlOiBudWxsLFxuXHQgICAgICAgICAgICBpbmRleGVzOiBudWxsLFxuXHQgICAgICAgICAgICBvYmo6IG51bGxcblx0ICAgICAgICAgIH07IC8vIGhpZGRlblxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcHJlcGFyZVNsb3c6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcblx0ICAgICAgICAgICAgX3RhcmdldExvd2VyQ29kZXM6IGZ1enp5c29ydC5wcmVwYXJlTG93ZXJDb2Rlcyh0YXJnZXQpLFxuXHQgICAgICAgICAgICBfbmV4dEJlZ2lubmluZ0luZGV4ZXM6IGZ1enp5c29ydC5wcmVwYXJlTmV4dEJlZ2lubmluZ0luZGV4ZXModGFyZ2V0KSxcblx0ICAgICAgICAgICAgc2NvcmU6IG51bGwsXG5cdCAgICAgICAgICAgIGluZGV4ZXM6IG51bGwsXG5cdCAgICAgICAgICAgIG9iajogbnVsbFxuXHQgICAgICAgICAgfTsgLy8gaGlkZGVuXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwcmVwYXJlU2VhcmNoOiBmdW5jdGlvbiAoc2VhcmNoKSB7XG5cdCAgICAgICAgICBpZiAoIXNlYXJjaCkgcmV0dXJuO1xuXHQgICAgICAgICAgcmV0dXJuIGZ1enp5c29ydC5wcmVwYXJlTG93ZXJDb2RlcyhzZWFyY2gpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy8gQmVsb3cgdGhpcyBwb2ludCBpcyBvbmx5IGludGVybmFsIGNvZGVcblx0ICAgICAgICAvLyBCZWxvdyB0aGlzIHBvaW50IGlzIG9ubHkgaW50ZXJuYWwgY29kZVxuXHQgICAgICAgIC8vIEJlbG93IHRoaXMgcG9pbnQgaXMgb25seSBpbnRlcm5hbCBjb2RlXG5cdCAgICAgICAgLy8gQmVsb3cgdGhpcyBwb2ludCBpcyBvbmx5IGludGVybmFsIGNvZGVcblx0ICAgICAgICBnZXRQcmVwYXJlZDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiA5OTkpIHJldHVybiBmdXp6eXNvcnQucHJlcGFyZSh0YXJnZXQpOyAvLyBkb24ndCBjYWNoZSBodWdlIHRhcmdldHNcblxuXHQgICAgICAgICAgdmFyIHRhcmdldFByZXBhcmVkID0gcHJlcGFyZWRDYWNoZS5nZXQodGFyZ2V0KTtcblx0ICAgICAgICAgIGlmICh0YXJnZXRQcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGFyZ2V0UHJlcGFyZWQ7XG5cdCAgICAgICAgICB0YXJnZXRQcmVwYXJlZCA9IGZ1enp5c29ydC5wcmVwYXJlKHRhcmdldCk7XG5cdCAgICAgICAgICBwcmVwYXJlZENhY2hlLnNldCh0YXJnZXQsIHRhcmdldFByZXBhcmVkKTtcblx0ICAgICAgICAgIHJldHVybiB0YXJnZXRQcmVwYXJlZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldFByZXBhcmVkU2VhcmNoOiBmdW5jdGlvbiAoc2VhcmNoKSB7XG5cdCAgICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA+IDk5OSkgcmV0dXJuIGZ1enp5c29ydC5wcmVwYXJlU2VhcmNoKHNlYXJjaCk7IC8vIGRvbid0IGNhY2hlIGh1Z2Ugc2VhcmNoZXNcblxuXHQgICAgICAgICAgdmFyIHNlYXJjaFByZXBhcmVkID0gcHJlcGFyZWRTZWFyY2hDYWNoZS5nZXQoc2VhcmNoKTtcblx0ICAgICAgICAgIGlmIChzZWFyY2hQcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gc2VhcmNoUHJlcGFyZWQ7XG5cdCAgICAgICAgICBzZWFyY2hQcmVwYXJlZCA9IGZ1enp5c29ydC5wcmVwYXJlU2VhcmNoKHNlYXJjaCk7XG5cdCAgICAgICAgICBwcmVwYXJlZFNlYXJjaENhY2hlLnNldChzZWFyY2gsIHNlYXJjaFByZXBhcmVkKTtcblx0ICAgICAgICAgIHJldHVybiBzZWFyY2hQcmVwYXJlZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGFsZ29yaXRobTogZnVuY3Rpb24gKHNlYXJjaExvd2VyQ29kZXMsIHByZXBhcmVkLCBzZWFyY2hMb3dlckNvZGUpIHtcblx0ICAgICAgICAgIHZhciB0YXJnZXRMb3dlckNvZGVzID0gcHJlcGFyZWQuX3RhcmdldExvd2VyQ29kZXM7XG5cdCAgICAgICAgICB2YXIgc2VhcmNoTGVuID0gc2VhcmNoTG93ZXJDb2Rlcy5sZW5ndGg7XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0TGVuID0gdGFyZ2V0TG93ZXJDb2Rlcy5sZW5ndGg7XG5cdCAgICAgICAgICB2YXIgc2VhcmNoSSA9IDA7IC8vIHdoZXJlIHdlIGF0XG5cblx0ICAgICAgICAgIHZhciB0YXJnZXRJID0gMDsgLy8gd2hlcmUgeW91IGF0XG5cblx0ICAgICAgICAgIHZhciB0eXBvU2ltcGxlSSA9IDA7XG5cdCAgICAgICAgICB2YXIgbWF0Y2hlc1NpbXBsZUxlbiA9IDA7IC8vIHZlcnkgYmFzaWMgZnV6enkgbWF0Y2g7IHRvIHJlbW92ZSBub24tbWF0Y2hpbmcgdGFyZ2V0cyBBU0FQIVxuXHQgICAgICAgICAgLy8gd2FsayB0aHJvdWdoIHRhcmdldC4gZmluZCBzZXF1ZW50aWFsIG1hdGNoZXMuXG5cdCAgICAgICAgICAvLyBpZiBhbGwgY2hhcnMgYXJlbid0IGZvdW5kIHRoZW4gZXhpdFxuXG5cdCAgICAgICAgICBmb3IgKDs7KSB7XG5cdCAgICAgICAgICAgIHZhciBpc01hdGNoID0gc2VhcmNoTG93ZXJDb2RlID09PSB0YXJnZXRMb3dlckNvZGVzW3RhcmdldEldO1xuXG5cdCAgICAgICAgICAgIGlmIChpc01hdGNoKSB7XG5cdCAgICAgICAgICAgICAgbWF0Y2hlc1NpbXBsZVttYXRjaGVzU2ltcGxlTGVuKytdID0gdGFyZ2V0STtcblx0ICAgICAgICAgICAgICArK3NlYXJjaEk7XG5cdCAgICAgICAgICAgICAgaWYgKHNlYXJjaEkgPT09IHNlYXJjaExlbikgYnJlYWs7XG5cdCAgICAgICAgICAgICAgc2VhcmNoTG93ZXJDb2RlID0gc2VhcmNoTG93ZXJDb2Rlc1t0eXBvU2ltcGxlSSA9PT0gMCA/IHNlYXJjaEkgOiB0eXBvU2ltcGxlSSA9PT0gc2VhcmNoSSA/IHNlYXJjaEkgKyAxIDogdHlwb1NpbXBsZUkgPT09IHNlYXJjaEkgLSAxID8gc2VhcmNoSSAtIDEgOiBzZWFyY2hJXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICsrdGFyZ2V0STtcblxuXHQgICAgICAgICAgICBpZiAodGFyZ2V0SSA+PSB0YXJnZXRMZW4pIHtcblx0ICAgICAgICAgICAgICAvLyBGYWlsZWQgdG8gZmluZCBzZWFyY2hJXG5cdCAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHR5cG8gb3IgZXhpdFxuXHQgICAgICAgICAgICAgIC8vIHdlIGdvIGFzIGZhciBhcyBwb3NzaWJsZSBiZWZvcmUgdHJ5aW5nIHRvIHRyYW5zcG9zZVxuXHQgICAgICAgICAgICAgIC8vIHRoZW4gd2UgdHJhbnNwb3NlIGJhY2t3YXJkcyB1bnRpbCB3ZSByZWFjaCB0aGUgYmVnaW5uaW5nXG5cdCAgICAgICAgICAgICAgZm9yICg7Oykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHNlYXJjaEkgPD0gMSkgcmV0dXJuIG51bGw7IC8vIG5vdCBhbGxvd2VkIHRvIHRyYW5zcG9zZSBmaXJzdCBjaGFyXG5cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBvU2ltcGxlSSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlbid0IHRyaWVkIHRvIHRyYW5zcG9zZSB5ZXRcblx0ICAgICAgICAgICAgICAgICAgLS1zZWFyY2hJO1xuXHQgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoTG93ZXJDb2RlTmV3ID0gc2VhcmNoTG93ZXJDb2Rlc1tzZWFyY2hJXTtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaExvd2VyQ29kZSA9PT0gc2VhcmNoTG93ZXJDb2RlTmV3KSBjb250aW51ZTsgLy8gZG9lc24ndCBtYWtlIHNlbnNlIHRvIHRyYW5zcG9zZSBhIHJlcGVhdCBjaGFyXG5cblx0ICAgICAgICAgICAgICAgICAgdHlwb1NpbXBsZUkgPSBzZWFyY2hJO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHR5cG9TaW1wbGVJID09PSAxKSByZXR1cm4gbnVsbDsgLy8gcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBsaW5lIGZvciB0cmFuc3Bvc2luZ1xuXG5cdCAgICAgICAgICAgICAgICAgIC0tdHlwb1NpbXBsZUk7XG5cdCAgICAgICAgICAgICAgICAgIHNlYXJjaEkgPSB0eXBvU2ltcGxlSTtcblx0ICAgICAgICAgICAgICAgICAgc2VhcmNoTG93ZXJDb2RlID0gc2VhcmNoTG93ZXJDb2Rlc1tzZWFyY2hJICsgMV07XG5cdCAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hMb3dlckNvZGVOZXcgPSBzZWFyY2hMb3dlckNvZGVzW3NlYXJjaEldO1xuXHQgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoTG93ZXJDb2RlID09PSBzZWFyY2hMb3dlckNvZGVOZXcpIGNvbnRpbnVlOyAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gdHJhbnNwb3NlIGEgcmVwZWF0IGNoYXJcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgbWF0Y2hlc1NpbXBsZUxlbiA9IHNlYXJjaEk7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXRJID0gbWF0Y2hlc1NpbXBsZVttYXRjaGVzU2ltcGxlTGVuIC0gMV0gKyAxO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHZhciBzZWFyY2hJID0gMDtcblx0ICAgICAgICAgIHZhciB0eXBvU3RyaWN0SSA9IDA7XG5cdCAgICAgICAgICB2YXIgc3VjY2Vzc1N0cmljdCA9IGZhbHNlO1xuXHQgICAgICAgICAgdmFyIG1hdGNoZXNTdHJpY3RMZW4gPSAwO1xuXHQgICAgICAgICAgdmFyIG5leHRCZWdpbm5pbmdJbmRleGVzID0gcHJlcGFyZWQuX25leHRCZWdpbm5pbmdJbmRleGVzO1xuXHQgICAgICAgICAgaWYgKG5leHRCZWdpbm5pbmdJbmRleGVzID09PSBudWxsKSBuZXh0QmVnaW5uaW5nSW5kZXhlcyA9IHByZXBhcmVkLl9uZXh0QmVnaW5uaW5nSW5kZXhlcyA9IGZ1enp5c29ydC5wcmVwYXJlTmV4dEJlZ2lubmluZ0luZGV4ZXMocHJlcGFyZWQudGFyZ2V0KTtcblx0ICAgICAgICAgIHZhciBmaXJzdFBvc3NpYmxlSSA9IHRhcmdldEkgPSBtYXRjaGVzU2ltcGxlWzBdID09PSAwID8gMCA6IG5leHRCZWdpbm5pbmdJbmRleGVzW21hdGNoZXNTaW1wbGVbMF0gLSAxXTsgLy8gT3VyIHRhcmdldCBzdHJpbmcgc3VjY2Vzc2Z1bGx5IG1hdGNoZWQgYWxsIGNoYXJhY3RlcnMgaW4gc2VxdWVuY2UhXG5cdCAgICAgICAgICAvLyBMZXQncyB0cnkgYSBtb3JlIGFkdmFuY2VkIGFuZCBzdHJpY3QgdGVzdCB0byBpbXByb3ZlIHRoZSBzY29yZVxuXHQgICAgICAgICAgLy8gb25seSBjb3VudCBpdCBhcyBhIG1hdGNoIGlmIGl0J3MgY29uc2VjdXRpdmUgb3IgYSBiZWdpbm5pbmcgY2hhcmFjdGVyIVxuXG5cdCAgICAgICAgICBpZiAodGFyZ2V0SSAhPT0gdGFyZ2V0TGVuKSBmb3IgKDs7KSB7XG5cdCAgICAgICAgICAgIGlmICh0YXJnZXRJID49IHRhcmdldExlbikge1xuXHQgICAgICAgICAgICAgIC8vIFdlIGZhaWxlZCB0byBmaW5kIGEgZ29vZCBzcG90IGZvciB0aGlzIHNlYXJjaCBjaGFyLCBnbyBiYWNrIHRvIHRoZSBwcmV2aW91cyBzZWFyY2ggY2hhciBhbmQgZm9yY2UgaXQgZm9yd2FyZFxuXHQgICAgICAgICAgICAgIGlmIChzZWFyY2hJIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgIC8vIFdlIGZhaWxlZCB0byBwdXNoIGNoYXJzIGZvcndhcmQgZm9yIGEgYmV0dGVyIG1hdGNoXG5cdCAgICAgICAgICAgICAgICAvLyB0cmFuc3Bvc2UsIHN0YXJ0aW5nIGZyb20gdGhlIGJlZ2lubmluZ1xuXHQgICAgICAgICAgICAgICAgKyt0eXBvU3RyaWN0STtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBvU3RyaWN0SSA+IHNlYXJjaExlbiAtIDIpIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNlYXJjaExvd2VyQ29kZXNbdHlwb1N0cmljdEldID09PSBzZWFyY2hMb3dlckNvZGVzW3R5cG9TdHJpY3RJICsgMV0pIGNvbnRpbnVlOyAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gdHJhbnNwb3NlIGEgcmVwZWF0IGNoYXJcblxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0SSA9IGZpcnN0UG9zc2libGVJO1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgLS1zZWFyY2hJO1xuXHQgICAgICAgICAgICAgIHZhciBsYXN0TWF0Y2ggPSBtYXRjaGVzU3RyaWN0Wy0tbWF0Y2hlc1N0cmljdExlbl07XG5cdCAgICAgICAgICAgICAgdGFyZ2V0SSA9IG5leHRCZWdpbm5pbmdJbmRleGVzW2xhc3RNYXRjaF07XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgdmFyIGlzTWF0Y2ggPSBzZWFyY2hMb3dlckNvZGVzW3R5cG9TdHJpY3RJID09PSAwID8gc2VhcmNoSSA6IHR5cG9TdHJpY3RJID09PSBzZWFyY2hJID8gc2VhcmNoSSArIDEgOiB0eXBvU3RyaWN0SSA9PT0gc2VhcmNoSSAtIDEgPyBzZWFyY2hJIC0gMSA6IHNlYXJjaEldID09PSB0YXJnZXRMb3dlckNvZGVzW3RhcmdldEldO1xuXG5cdCAgICAgICAgICAgICAgaWYgKGlzTWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIG1hdGNoZXNTdHJpY3RbbWF0Y2hlc1N0cmljdExlbisrXSA9IHRhcmdldEk7XG5cdCAgICAgICAgICAgICAgICArK3NlYXJjaEk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChzZWFyY2hJID09PSBzZWFyY2hMZW4pIHtcblx0ICAgICAgICAgICAgICAgICAgc3VjY2Vzc1N0cmljdCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICArK3RhcmdldEk7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldEkgPSBuZXh0QmVnaW5uaW5nSW5kZXhlc1t0YXJnZXRJXTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHtcblx0ICAgICAgICAgICAgLy8gdGFsbHkgdXAgdGhlIHNjb3JlICYga2VlcCB0cmFjayBvZiBtYXRjaGVzIGZvciBoaWdobGlnaHRpbmcgbGF0ZXJcblx0ICAgICAgICAgICAgaWYgKHN1Y2Nlc3NTdHJpY3QpIHtcblx0ICAgICAgICAgICAgICB2YXIgbWF0Y2hlc0Jlc3QgPSBtYXRjaGVzU3RyaWN0O1xuXHQgICAgICAgICAgICAgIHZhciBtYXRjaGVzQmVzdExlbiA9IG1hdGNoZXNTdHJpY3RMZW47XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgdmFyIG1hdGNoZXNCZXN0ID0gbWF0Y2hlc1NpbXBsZTtcblx0ICAgICAgICAgICAgICB2YXIgbWF0Y2hlc0Jlc3RMZW4gPSBtYXRjaGVzU2ltcGxlTGVuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHNjb3JlID0gMDtcblx0ICAgICAgICAgICAgdmFyIGxhc3RUYXJnZXRJID0gLTE7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWFyY2hMZW47ICsraSkge1xuXHQgICAgICAgICAgICAgIHZhciB0YXJnZXRJID0gbWF0Y2hlc0Jlc3RbaV07IC8vIHNjb3JlIG9ubHkgZ29lcyBkb3duIGlmIHRoZXkncmUgbm90IGNvbnNlY3V0aXZlXG5cblx0ICAgICAgICAgICAgICBpZiAobGFzdFRhcmdldEkgIT09IHRhcmdldEkgLSAxKSBzY29yZSAtPSB0YXJnZXRJO1xuXHQgICAgICAgICAgICAgIGxhc3RUYXJnZXRJID0gdGFyZ2V0STtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghc3VjY2Vzc1N0cmljdCkge1xuXHQgICAgICAgICAgICAgIHNjb3JlICo9IDEwMDA7XG5cdCAgICAgICAgICAgICAgaWYgKHR5cG9TaW1wbGVJICE9PSAwKSBzY29yZSArPSAtMjA7XG5cdCAgICAgICAgICAgICAgLyp0eXBvUGVuYWx0eSovXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgaWYgKHR5cG9TdHJpY3RJICE9PSAwKSBzY29yZSArPSAtMjA7XG5cdCAgICAgICAgICAgICAgLyp0eXBvUGVuYWx0eSovXG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBzY29yZSAtPSB0YXJnZXRMZW4gLSBzZWFyY2hMZW47XG5cdCAgICAgICAgICAgIHByZXBhcmVkLnNjb3JlID0gc2NvcmU7XG5cdCAgICAgICAgICAgIHByZXBhcmVkLmluZGV4ZXMgPSBuZXcgQXJyYXkobWF0Y2hlc0Jlc3RMZW4pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaGVzQmVzdExlbiAtIDE7IGkgPj0gMDsgLS1pKSBwcmVwYXJlZC5pbmRleGVzW2ldID0gbWF0Y2hlc0Jlc3RbaV07XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVkO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgYWxnb3JpdGhtTm9UeXBvOiBmdW5jdGlvbiAoc2VhcmNoTG93ZXJDb2RlcywgcHJlcGFyZWQsIHNlYXJjaExvd2VyQ29kZSkge1xuXHQgICAgICAgICAgdmFyIHRhcmdldExvd2VyQ29kZXMgPSBwcmVwYXJlZC5fdGFyZ2V0TG93ZXJDb2Rlcztcblx0ICAgICAgICAgIHZhciBzZWFyY2hMZW4gPSBzZWFyY2hMb3dlckNvZGVzLmxlbmd0aDtcblx0ICAgICAgICAgIHZhciB0YXJnZXRMZW4gPSB0YXJnZXRMb3dlckNvZGVzLmxlbmd0aDtcblx0ICAgICAgICAgIHZhciBzZWFyY2hJID0gMDsgLy8gd2hlcmUgd2UgYXRcblxuXHQgICAgICAgICAgdmFyIHRhcmdldEkgPSAwOyAvLyB3aGVyZSB5b3UgYXRcblxuXHQgICAgICAgICAgdmFyIG1hdGNoZXNTaW1wbGVMZW4gPSAwOyAvLyB2ZXJ5IGJhc2ljIGZ1enp5IG1hdGNoOyB0byByZW1vdmUgbm9uLW1hdGNoaW5nIHRhcmdldHMgQVNBUCFcblx0ICAgICAgICAgIC8vIHdhbGsgdGhyb3VnaCB0YXJnZXQuIGZpbmQgc2VxdWVudGlhbCBtYXRjaGVzLlxuXHQgICAgICAgICAgLy8gaWYgYWxsIGNoYXJzIGFyZW4ndCBmb3VuZCB0aGVuIGV4aXRcblxuXHQgICAgICAgICAgZm9yICg7Oykge1xuXHQgICAgICAgICAgICB2YXIgaXNNYXRjaCA9IHNlYXJjaExvd2VyQ29kZSA9PT0gdGFyZ2V0TG93ZXJDb2Rlc1t0YXJnZXRJXTtcblxuXHQgICAgICAgICAgICBpZiAoaXNNYXRjaCkge1xuXHQgICAgICAgICAgICAgIG1hdGNoZXNTaW1wbGVbbWF0Y2hlc1NpbXBsZUxlbisrXSA9IHRhcmdldEk7XG5cdCAgICAgICAgICAgICAgKytzZWFyY2hJO1xuXHQgICAgICAgICAgICAgIGlmIChzZWFyY2hJID09PSBzZWFyY2hMZW4pIGJyZWFrO1xuXHQgICAgICAgICAgICAgIHNlYXJjaExvd2VyQ29kZSA9IHNlYXJjaExvd2VyQ29kZXNbc2VhcmNoSV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICArK3RhcmdldEk7XG5cdCAgICAgICAgICAgIGlmICh0YXJnZXRJID49IHRhcmdldExlbikgcmV0dXJuIG51bGw7IC8vIEZhaWxlZCB0byBmaW5kIHNlYXJjaElcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdmFyIHNlYXJjaEkgPSAwO1xuXHQgICAgICAgICAgdmFyIHN1Y2Nlc3NTdHJpY3QgPSBmYWxzZTtcblx0ICAgICAgICAgIHZhciBtYXRjaGVzU3RyaWN0TGVuID0gMDtcblx0ICAgICAgICAgIHZhciBuZXh0QmVnaW5uaW5nSW5kZXhlcyA9IHByZXBhcmVkLl9uZXh0QmVnaW5uaW5nSW5kZXhlcztcblx0ICAgICAgICAgIGlmIChuZXh0QmVnaW5uaW5nSW5kZXhlcyA9PT0gbnVsbCkgbmV4dEJlZ2lubmluZ0luZGV4ZXMgPSBwcmVwYXJlZC5fbmV4dEJlZ2lubmluZ0luZGV4ZXMgPSBmdXp6eXNvcnQucHJlcGFyZU5leHRCZWdpbm5pbmdJbmRleGVzKHByZXBhcmVkLnRhcmdldCk7XG5cdCAgICAgICAgICB2YXIgZmlyc3RQb3NzaWJsZUkgPSB0YXJnZXRJID0gbWF0Y2hlc1NpbXBsZVswXSA9PT0gMCA/IDAgOiBuZXh0QmVnaW5uaW5nSW5kZXhlc1ttYXRjaGVzU2ltcGxlWzBdIC0gMV07IC8vIE91ciB0YXJnZXQgc3RyaW5nIHN1Y2Nlc3NmdWxseSBtYXRjaGVkIGFsbCBjaGFyYWN0ZXJzIGluIHNlcXVlbmNlIVxuXHQgICAgICAgICAgLy8gTGV0J3MgdHJ5IGEgbW9yZSBhZHZhbmNlZCBhbmQgc3RyaWN0IHRlc3QgdG8gaW1wcm92ZSB0aGUgc2NvcmVcblx0ICAgICAgICAgIC8vIG9ubHkgY291bnQgaXQgYXMgYSBtYXRjaCBpZiBpdCdzIGNvbnNlY3V0aXZlIG9yIGEgYmVnaW5uaW5nIGNoYXJhY3RlciFcblxuXHQgICAgICAgICAgaWYgKHRhcmdldEkgIT09IHRhcmdldExlbikgZm9yICg7Oykge1xuXHQgICAgICAgICAgICBpZiAodGFyZ2V0SSA+PSB0YXJnZXRMZW4pIHtcblx0ICAgICAgICAgICAgICAvLyBXZSBmYWlsZWQgdG8gZmluZCBhIGdvb2Qgc3BvdCBmb3IgdGhpcyBzZWFyY2ggY2hhciwgZ28gYmFjayB0byB0aGUgcHJldmlvdXMgc2VhcmNoIGNoYXIgYW5kIGZvcmNlIGl0IGZvcndhcmRcblx0ICAgICAgICAgICAgICBpZiAoc2VhcmNoSSA8PSAwKSBicmVhazsgLy8gV2UgZmFpbGVkIHRvIHB1c2ggY2hhcnMgZm9yd2FyZCBmb3IgYSBiZXR0ZXIgbWF0Y2hcblxuXHQgICAgICAgICAgICAgIC0tc2VhcmNoSTtcblx0ICAgICAgICAgICAgICB2YXIgbGFzdE1hdGNoID0gbWF0Y2hlc1N0cmljdFstLW1hdGNoZXNTdHJpY3RMZW5dO1xuXHQgICAgICAgICAgICAgIHRhcmdldEkgPSBuZXh0QmVnaW5uaW5nSW5kZXhlc1tsYXN0TWF0Y2hdO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHZhciBpc01hdGNoID0gc2VhcmNoTG93ZXJDb2Rlc1tzZWFyY2hJXSA9PT0gdGFyZ2V0TG93ZXJDb2Rlc1t0YXJnZXRJXTtcblxuXHQgICAgICAgICAgICAgIGlmIChpc01hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICBtYXRjaGVzU3RyaWN0W21hdGNoZXNTdHJpY3RMZW4rK10gPSB0YXJnZXRJO1xuXHQgICAgICAgICAgICAgICAgKytzZWFyY2hJO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoc2VhcmNoSSA9PT0gc2VhcmNoTGVuKSB7XG5cdCAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NTdHJpY3QgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgKyt0YXJnZXRJO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXRJID0gbmV4dEJlZ2lubmluZ0luZGV4ZXNbdGFyZ2V0SV07XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIC8vIHRhbGx5IHVwIHRoZSBzY29yZSAmIGtlZXAgdHJhY2sgb2YgbWF0Y2hlcyBmb3IgaGlnaGxpZ2h0aW5nIGxhdGVyXG5cdCAgICAgICAgICAgIGlmIChzdWNjZXNzU3RyaWN0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIG1hdGNoZXNCZXN0ID0gbWF0Y2hlc1N0cmljdDtcblx0ICAgICAgICAgICAgICB2YXIgbWF0Y2hlc0Jlc3RMZW4gPSBtYXRjaGVzU3RyaWN0TGVuO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIHZhciBtYXRjaGVzQmVzdCA9IG1hdGNoZXNTaW1wbGU7XG5cdCAgICAgICAgICAgICAgdmFyIG1hdGNoZXNCZXN0TGVuID0gbWF0Y2hlc1NpbXBsZUxlbjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBzY29yZSA9IDA7XG5cdCAgICAgICAgICAgIHZhciBsYXN0VGFyZ2V0SSA9IC0xO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoTGVuOyArK2kpIHtcblx0ICAgICAgICAgICAgICB2YXIgdGFyZ2V0SSA9IG1hdGNoZXNCZXN0W2ldOyAvLyBzY29yZSBvbmx5IGdvZXMgZG93biBpZiB0aGV5J3JlIG5vdCBjb25zZWN1dGl2ZVxuXG5cdCAgICAgICAgICAgICAgaWYgKGxhc3RUYXJnZXRJICE9PSB0YXJnZXRJIC0gMSkgc2NvcmUgLT0gdGFyZ2V0STtcblx0ICAgICAgICAgICAgICBsYXN0VGFyZ2V0SSA9IHRhcmdldEk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXN1Y2Nlc3NTdHJpY3QpIHNjb3JlICo9IDEwMDA7XG5cdCAgICAgICAgICAgIHNjb3JlIC09IHRhcmdldExlbiAtIHNlYXJjaExlbjtcblx0ICAgICAgICAgICAgcHJlcGFyZWQuc2NvcmUgPSBzY29yZTtcblx0ICAgICAgICAgICAgcHJlcGFyZWQuaW5kZXhlcyA9IG5ldyBBcnJheShtYXRjaGVzQmVzdExlbik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoZXNCZXN0TGVuIC0gMTsgaSA+PSAwOyAtLWkpIHByZXBhcmVkLmluZGV4ZXNbaV0gPSBtYXRjaGVzQmVzdFtpXTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcHJlcGFyZWQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwcmVwYXJlTG93ZXJDb2RlczogZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgICAgdmFyIHN0ckxlbiA9IHN0ci5sZW5ndGg7XG5cdCAgICAgICAgICB2YXIgbG93ZXJDb2RlcyA9IFtdOyAvLyBuZXcgQXJyYXkoc3RyTGVuKSAgICBzcGFyc2UgYXJyYXkgaXMgdG9vIHNsb3dcblxuXHQgICAgICAgICAgdmFyIGxvd2VyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyTGVuOyArK2kpIGxvd2VyQ29kZXNbaV0gPSBsb3dlci5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAgICAgICByZXR1cm4gbG93ZXJDb2Rlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHByZXBhcmVCZWdpbm5pbmdJbmRleGVzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0TGVuID0gdGFyZ2V0Lmxlbmd0aDtcblx0ICAgICAgICAgIHZhciBiZWdpbm5pbmdJbmRleGVzID0gW107XG5cdCAgICAgICAgICB2YXIgYmVnaW5uaW5nSW5kZXhlc0xlbiA9IDA7XG5cdCAgICAgICAgICB2YXIgd2FzVXBwZXIgPSBmYWxzZTtcblx0ICAgICAgICAgIHZhciB3YXNBbHBoYW51bSA9IGZhbHNlO1xuXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldExlbjsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciB0YXJnZXRDb2RlID0gdGFyZ2V0LmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgICAgIHZhciBpc1VwcGVyID0gdGFyZ2V0Q29kZSA+PSA2NSAmJiB0YXJnZXRDb2RlIDw9IDkwO1xuXHQgICAgICAgICAgICB2YXIgaXNBbHBoYW51bSA9IGlzVXBwZXIgfHwgdGFyZ2V0Q29kZSA+PSA5NyAmJiB0YXJnZXRDb2RlIDw9IDEyMiB8fCB0YXJnZXRDb2RlID49IDQ4ICYmIHRhcmdldENvZGUgPD0gNTc7XG5cdCAgICAgICAgICAgIHZhciBpc0JlZ2lubmluZyA9IGlzVXBwZXIgJiYgIXdhc1VwcGVyIHx8ICF3YXNBbHBoYW51bSB8fCAhaXNBbHBoYW51bTtcblx0ICAgICAgICAgICAgd2FzVXBwZXIgPSBpc1VwcGVyO1xuXHQgICAgICAgICAgICB3YXNBbHBoYW51bSA9IGlzQWxwaGFudW07XG5cdCAgICAgICAgICAgIGlmIChpc0JlZ2lubmluZykgYmVnaW5uaW5nSW5kZXhlc1tiZWdpbm5pbmdJbmRleGVzTGVuKytdID0gaTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIGJlZ2lubmluZ0luZGV4ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBwcmVwYXJlTmV4dEJlZ2lubmluZ0luZGV4ZXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgICAgICAgIHZhciB0YXJnZXRMZW4gPSB0YXJnZXQubGVuZ3RoO1xuXHQgICAgICAgICAgdmFyIGJlZ2lubmluZ0luZGV4ZXMgPSBmdXp6eXNvcnQucHJlcGFyZUJlZ2lubmluZ0luZGV4ZXModGFyZ2V0KTtcblx0ICAgICAgICAgIHZhciBuZXh0QmVnaW5uaW5nSW5kZXhlcyA9IFtdOyAvLyBuZXcgQXJyYXkodGFyZ2V0TGVuKSAgICAgc3BhcnNlIGFycmF5IGlzIHRvbyBzbG93XG5cblx0ICAgICAgICAgIHZhciBsYXN0SXNCZWdpbm5pbmcgPSBiZWdpbm5pbmdJbmRleGVzWzBdO1xuXHQgICAgICAgICAgdmFyIGxhc3RJc0JlZ2lubmluZ0kgPSAwO1xuXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldExlbjsgKytpKSB7XG5cdCAgICAgICAgICAgIGlmIChsYXN0SXNCZWdpbm5pbmcgPiBpKSB7XG5cdCAgICAgICAgICAgICAgbmV4dEJlZ2lubmluZ0luZGV4ZXNbaV0gPSBsYXN0SXNCZWdpbm5pbmc7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgbGFzdElzQmVnaW5uaW5nID0gYmVnaW5uaW5nSW5kZXhlc1srK2xhc3RJc0JlZ2lubmluZ0ldO1xuXHQgICAgICAgICAgICAgIG5leHRCZWdpbm5pbmdJbmRleGVzW2ldID0gbGFzdElzQmVnaW5uaW5nID09PSB1bmRlZmluZWQgPyB0YXJnZXRMZW4gOiBsYXN0SXNCZWdpbm5pbmc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIG5leHRCZWdpbm5pbmdJbmRleGVzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgY2xlYW51cDogY2xlYW51cCxcblx0ICAgICAgICBuZXc6IGZ1enp5c29ydE5ld1xuXHQgICAgICB9O1xuXHQgICAgICByZXR1cm4gZnV6enlzb3J0O1xuXHQgICAgfSAvLyBmdXp6eXNvcnROZXdcblx0ICAgIC8vIFRoaXMgc3R1ZmYgaXMgb3V0c2lkZSBmdXp6eXNvcnROZXcsIGJlY2F1c2UgaXQncyBzaGFyZWQgd2l0aCBpbnN0YW5jZXMgb2YgZnV6enlzb3J0Lm5ldygpXG5cblxuXHQgICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBjb21tb25qc1JlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnOyAvLyB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5cdCAgICAvLyB2YXIgTUlOX0lOVCA9IE51bWJlci5NSU5fVkFMVUVcblxuXHQgICAgdmFyIHByZXBhcmVkQ2FjaGUgPSBuZXcgTWFwKCk7XG5cdCAgICB2YXIgcHJlcGFyZWRTZWFyY2hDYWNoZSA9IG5ldyBNYXAoKTtcblx0ICAgIHZhciBub1Jlc3VsdHMgPSBbXTtcblx0ICAgIG5vUmVzdWx0cy50b3RhbCA9IDA7XG5cdCAgICB2YXIgbWF0Y2hlc1NpbXBsZSA9IFtdO1xuXHQgICAgdmFyIG1hdGNoZXNTdHJpY3QgPSBbXTtcblxuXHQgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0ICAgICAgcHJlcGFyZWRDYWNoZS5jbGVhcigpO1xuXHQgICAgICBwcmVwYXJlZFNlYXJjaENhY2hlLmNsZWFyKCk7XG5cdCAgICAgIG1hdGNoZXNTaW1wbGUgPSBbXTtcblx0ICAgICAgbWF0Y2hlc1N0cmljdCA9IFtdO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBkZWZhdWx0U2NvcmVGbihhKSB7XG5cdCAgICAgIHZhciBtYXggPSAtOTAwNzE5OTI1NDc0MDk5MTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBhW2ldO1xuXHQgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGNvbnRpbnVlO1xuXHQgICAgICAgIHZhciBzY29yZSA9IHJlc3VsdC5zY29yZTtcblx0ICAgICAgICBpZiAoc2NvcmUgPiBtYXgpIG1heCA9IHNjb3JlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1heCA9PT0gLTkwMDcxOTkyNTQ3NDA5OTEpIHJldHVybiBudWxsO1xuXHQgICAgICByZXR1cm4gbWF4O1xuXHQgICAgfSAvLyBwcm9wID0gJ2tleScgICAgICAgICAgICAgIDIuNW1zIG9wdGltaXplZCBmb3IgdGhpcyBjYXNlLCBzZWVtcyB0byBiZSBhYm91dCBhcyBmYXN0IGFzIGRpcmVjdCBvYmpbcHJvcF1cblx0ICAgIC8vIHByb3AgPSAna2V5MS5rZXkyJyAgICAgICAgMTBtc1xuXHQgICAgLy8gcHJvcCA9IFsna2V5MScsICdrZXkyJ10gICAyN21zXG5cblxuXHQgICAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqLCBwcm9wKSB7XG5cdCAgICAgIHZhciB0bXAgPSBvYmpbcHJvcF07XG5cdCAgICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRtcDtcblx0ICAgICAgdmFyIHNlZ3MgPSBwcm9wO1xuXHQgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcCkpIHNlZ3MgPSBwcm9wLnNwbGl0KCcuJyk7XG5cdCAgICAgIHZhciBsZW4gPSBzZWdzLmxlbmd0aDtcblx0ICAgICAgdmFyIGkgPSAtMTtcblxuXHQgICAgICB3aGlsZSAob2JqICYmICsraSA8IGxlbikgb2JqID0gb2JqW3NlZ3NbaV1dO1xuXG5cdCAgICAgIHJldHVybiBvYmo7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGlzT2JqKHgpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcblx0ICAgIH0gLy8gZmFzdGVyIGFzIGEgZnVuY3Rpb25cblx0ICAgIC8vIEhhY2tlZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9sZW1pcmUvRmFzdFByaW9yaXR5UXVldWUuanNcblxuXG5cdCAgICB2YXIgZmFzdHByaW9yaXR5cXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciByID0gW10sXG5cdCAgICAgICAgICBvID0gMCxcblx0ICAgICAgICAgIGUgPSB7fTtcblxuXHQgICAgICBmdW5jdGlvbiBuKCkge1xuXHQgICAgICAgIGZvciAodmFyIGUgPSAwLCBuID0gcltlXSwgYyA9IDE7IGMgPCBvOykge1xuXHQgICAgICAgICAgdmFyIGYgPSBjICsgMTtcblx0ICAgICAgICAgIGUgPSBjLCBmIDwgbyAmJiByW2ZdLnNjb3JlIDwgcltjXS5zY29yZSAmJiAoZSA9IGYpLCByW2UgLSAxID4+IDFdID0gcltlXSwgYyA9IDEgKyAoZSA8PCAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKHZhciBhID0gZSAtIDEgPj4gMTsgZSA+IDAgJiYgbi5zY29yZSA8IHJbYV0uc2NvcmU7IGEgPSAoZSA9IGEpIC0gMSA+PiAxKSByW2VdID0gclthXTtcblxuXHQgICAgICAgIHJbZV0gPSBuO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGUuYWRkID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgbiA9IG87XG5cdCAgICAgICAgcltvKytdID0gZTtcblxuXHQgICAgICAgIGZvciAodmFyIGMgPSBuIC0gMSA+PiAxOyBuID4gMCAmJiBlLnNjb3JlIDwgcltjXS5zY29yZTsgYyA9IChuID0gYykgLSAxID4+IDEpIHJbbl0gPSByW2NdO1xuXG5cdCAgICAgICAgcltuXSA9IGU7XG5cdCAgICAgIH0sIGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoMCAhPT0gbykge1xuXHQgICAgICAgICAgdmFyIGUgPSByWzBdO1xuXHQgICAgICAgICAgcmV0dXJuIHJbMF0gPSByWy0tb10sIG4oKSwgZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sIGUucGVlayA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKDAgIT09IG8pIHJldHVybiByWzBdO1xuXHQgICAgICB9LCBlLnJlcGxhY2VUb3AgPSBmdW5jdGlvbiAobykge1xuXHQgICAgICAgIHJbMF0gPSBvLCBuKCk7XG5cdCAgICAgIH0sIGU7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgcSA9IGZhc3Rwcmlvcml0eXF1ZXVlKCk7IC8vIHJldXNlIHRoaXMsIGV4Y2VwdCBmb3IgYXN5bmMsIGl0IG5lZWRzIHRvIG1ha2UgaXRzIG93blxuXG5cdCAgICByZXR1cm4gZnV6enlzb3J0TmV3KCk7XG5cdCAgfSk7IC8vIFVNRFxuXHQgIC8vIFRPRE86IChwZXJmb3JtYW5jZSkgd2FzbSB2ZXJzaW9uIT9cblx0ICAvLyBUT0RPOiAocGVyZm9ybWFuY2UpIGxheW91dCBtZW1vcnkgaW4gYW4gb3B0aW1hbCB3YXkgdG8gZ28gZmFzdCBieSBhdm9pZGluZyBjYWNoZSBtaXNzZXNcblx0ICAvLyBUT0RPOiAocGVyZm9ybWFuY2UpIHByZXBhcmVkQ2FjaGUgaXMgYSBtZW1vcnkgbGVha1xuXHQgIC8vIFRPRE86IChsaWtlIHN1YmxpbWUpIGJhY2tzbGFzaCA9PT0gZm9yd2FyZHNsYXNoXG5cdCAgLy8gVE9ETzogKHBlcmZvcm1hbmNlKSBpIGhhdmUgbm8gaWRlYSBob3cgd2VsbCBvcHRpem1pZWQgdGhlIGFsbG93aW5nIHR5cG9zIGFsZ29yaXRobSBpc1xuXG5cdH0pO1xuXG5cdHZhciBzdGF0cyA9IHtcblx0ICBwYXNzZWRUZXN0czogMCxcblx0ICBmYWlsZWRUZXN0czogMCxcblx0ICBza2lwcGVkVGVzdHM6IDAsXG5cdCAgdG9kb1Rlc3RzOiAwXG5cdH07IC8vIEVzY2FwZSB0ZXh0IGZvciBhdHRyaWJ1dGUgb3IgdGV4dCBjb250ZW50LlxuXG5cdGZ1bmN0aW9uIGVzY2FwZVRleHQocykge1xuXHQgIGlmICghcykge1xuXHQgICAgcmV0dXJuIFwiXCI7XG5cdCAgfVxuXG5cdCAgcyA9IHMgKyBcIlwiOyAvLyBCb3RoIHNpbmdsZSBxdW90ZXMgYW5kIGRvdWJsZSBxdW90ZXMgKGZvciBhdHRyaWJ1dGVzKVxuXG5cdCAgcmV0dXJuIHMucmVwbGFjZSgvWydcIjw+Jl0vZywgZnVuY3Rpb24gKHMpIHtcblx0ICAgIHN3aXRjaCAocykge1xuXHQgICAgICBjYXNlIFwiJ1wiOlxuXHQgICAgICAgIHJldHVybiBcIiYjMDM5O1wiO1xuXG5cdCAgICAgIGNhc2UgXCJcXFwiXCI6XG5cdCAgICAgICAgcmV0dXJuIFwiJnF1b3Q7XCI7XG5cblx0ICAgICAgY2FzZSBcIjxcIjpcblx0ICAgICAgICByZXR1cm4gXCImbHQ7XCI7XG5cblx0ICAgICAgY2FzZSBcIj5cIjpcblx0ICAgICAgICByZXR1cm4gXCImZ3Q7XCI7XG5cblx0ICAgICAgY2FzZSBcIiZcIjpcblx0ICAgICAgICByZXR1cm4gXCImYW1wO1wiO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAvLyBEb24ndCBsb2FkIHRoZSBIVE1MIFJlcG9ydGVyIG9uIG5vbi1icm93c2VyIGVudmlyb25tZW50c1xuXHQgIGlmICh0eXBlb2Ygd2luZG93JDEgPT09IFwidW5kZWZpbmVkXCIgfHwgIXdpbmRvdyQxLmRvY3VtZW50KSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIGNvbmZpZyA9IFFVbml0LmNvbmZpZyxcblx0ICAgICAgaGlkZGVuVGVzdHMgPSBbXSxcblx0ICAgICAgZG9jdW1lbnQgPSB3aW5kb3ckMS5kb2N1bWVudCxcblx0ICAgICAgY29sbGFwc2VOZXh0ID0gZmFsc2UsXG5cdCAgICAgIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG5cdCAgICAgIHVuZmlsdGVyZWRVcmwgPSBzZXRVcmwoe1xuXHQgICAgZmlsdGVyOiB1bmRlZmluZWQsXG5cdCAgICBtb2R1bGU6IHVuZGVmaW5lZCxcblx0ICAgIG1vZHVsZUlkOiB1bmRlZmluZWQsXG5cdCAgICB0ZXN0SWQ6IHVuZGVmaW5lZFxuXHQgIH0pLFxuXHQgICAgICBtb2R1bGVzTGlzdCA9IFtdO1xuXG5cdCAgZnVuY3Rpb24gYWRkRXZlbnQoZWxlbSwgdHlwZSwgZm4pIHtcblx0ICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgZmFsc2UpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGZuKSB7XG5cdCAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhZGRFdmVudHMoZWxlbXMsIHR5cGUsIGZuKSB7XG5cdCAgICB2YXIgaSA9IGVsZW1zLmxlbmd0aDtcblxuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICBhZGRFdmVudChlbGVtc1tpXSwgdHlwZSwgZm4pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIG5hbWUpIHtcblx0ICAgIHJldHVybiAoXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiKS5pbmRleE9mKFwiIFwiICsgbmFtZSArIFwiIFwiKSA+PSAwO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW0sIG5hbWUpIHtcblx0ICAgIGlmICghaGFzQ2xhc3MoZWxlbSwgbmFtZSkpIHtcblx0ICAgICAgZWxlbS5jbGFzc05hbWUgKz0gKGVsZW0uY2xhc3NOYW1lID8gXCIgXCIgOiBcIlwiKSArIG5hbWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgbmFtZSwgZm9yY2UpIHtcblx0ICAgIGlmIChmb3JjZSB8fCB0eXBlb2YgZm9yY2UgPT09IFwidW5kZWZpbmVkXCIgJiYgIWhhc0NsYXNzKGVsZW0sIG5hbWUpKSB7XG5cdCAgICAgIGFkZENsYXNzKGVsZW0sIG5hbWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVtb3ZlQ2xhc3MoZWxlbSwgbmFtZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbSwgbmFtZSkge1xuXHQgICAgdmFyIHNldCA9IFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIjsgLy8gQ2xhc3MgbmFtZSBtYXkgYXBwZWFyIG11bHRpcGxlIHRpbWVzXG5cblx0ICAgIHdoaWxlIChzZXQuaW5kZXhPZihcIiBcIiArIG5hbWUgKyBcIiBcIikgPj0gMCkge1xuXHQgICAgICBzZXQgPSBzZXQucmVwbGFjZShcIiBcIiArIG5hbWUgKyBcIiBcIiwgXCIgXCIpO1xuXHQgICAgfSAvLyBUcmltIGZvciBwcmV0dGluZXNzXG5cblxuXHQgICAgZWxlbS5jbGFzc05hbWUgPSB0eXBlb2Ygc2V0LnRyaW0gPT09IFwiZnVuY3Rpb25cIiA/IHNldC50cmltKCkgOiBzZXQucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gaWQobmFtZSkge1xuXHQgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5hbWUpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGFib3J0VGVzdHMoKSB7XG5cdCAgICB2YXIgYWJvcnRCdXR0b24gPSBpZChcInF1bml0LWFib3J0LXRlc3RzLWJ1dHRvblwiKTtcblxuXHQgICAgaWYgKGFib3J0QnV0dG9uKSB7XG5cdCAgICAgIGFib3J0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcblx0ICAgICAgYWJvcnRCdXR0b24uaW5uZXJIVE1MID0gXCJBYm9ydGluZy4uLlwiO1xuXHQgICAgfVxuXG5cdCAgICBRVW5pdC5jb25maWcucXVldWUubGVuZ3RoID0gMDtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbnRlcmNlcHROYXZpZ2F0aW9uKGV2KSB7XG5cdCAgICBhcHBseVVybFBhcmFtcygpO1xuXG5cdCAgICBpZiAoZXYgJiYgZXYucHJldmVudERlZmF1bHQpIHtcblx0ICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldFVybENvbmZpZ0h0bWwoKSB7XG5cdCAgICB2YXIgaSxcblx0ICAgICAgICBqLFxuXHQgICAgICAgIHZhbCxcblx0ICAgICAgICBlc2NhcGVkLFxuXHQgICAgICAgIGVzY2FwZWRUb29sdGlwLFxuXHQgICAgICAgIHNlbGVjdGlvbiA9IGZhbHNlLFxuXHQgICAgICAgIHVybENvbmZpZyA9IGNvbmZpZy51cmxDb25maWcsXG5cdCAgICAgICAgdXJsQ29uZmlnSHRtbCA9IFwiXCI7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCB1cmxDb25maWcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gT3B0aW9ucyBjYW4gYmUgZWl0aGVyIHN0cmluZ3Mgb3Igb2JqZWN0cyB3aXRoIG5vbmVtcHR5IFwiaWRcIiBwcm9wZXJ0aWVzXG5cdCAgICAgIHZhbCA9IGNvbmZpZy51cmxDb25maWdbaV07XG5cblx0ICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YWwgPSB7XG5cdCAgICAgICAgICBpZDogdmFsLFxuXHQgICAgICAgICAgbGFiZWw6IHZhbFxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICBlc2NhcGVkID0gZXNjYXBlVGV4dCh2YWwuaWQpO1xuXHQgICAgICBlc2NhcGVkVG9vbHRpcCA9IGVzY2FwZVRleHQodmFsLnRvb2x0aXApO1xuXG5cdCAgICAgIGlmICghdmFsLnZhbHVlIHx8IHR5cGVvZiB2YWwudmFsdWUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB1cmxDb25maWdIdG1sICs9IFwiPGxhYmVsIGZvcj0ncXVuaXQtdXJsY29uZmlnLVwiICsgZXNjYXBlZCArIFwiJyB0aXRsZT0nXCIgKyBlc2NhcGVkVG9vbHRpcCArIFwiJz48aW5wdXQgaWQ9J3F1bml0LXVybGNvbmZpZy1cIiArIGVzY2FwZWQgKyBcIicgbmFtZT0nXCIgKyBlc2NhcGVkICsgXCInIHR5cGU9J2NoZWNrYm94J1wiICsgKHZhbC52YWx1ZSA/IFwiIHZhbHVlPSdcIiArIGVzY2FwZVRleHQodmFsLnZhbHVlKSArIFwiJ1wiIDogXCJcIikgKyAoY29uZmlnW3ZhbC5pZF0gPyBcIiBjaGVja2VkPSdjaGVja2VkJ1wiIDogXCJcIikgKyBcIiB0aXRsZT0nXCIgKyBlc2NhcGVkVG9vbHRpcCArIFwiJyAvPlwiICsgZXNjYXBlVGV4dCh2YWwubGFiZWwpICsgXCI8L2xhYmVsPlwiO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVybENvbmZpZ0h0bWwgKz0gXCI8bGFiZWwgZm9yPSdxdW5pdC11cmxjb25maWctXCIgKyBlc2NhcGVkICsgXCInIHRpdGxlPSdcIiArIGVzY2FwZWRUb29sdGlwICsgXCInPlwiICsgdmFsLmxhYmVsICsgXCI6IDwvbGFiZWw+PHNlbGVjdCBpZD0ncXVuaXQtdXJsY29uZmlnLVwiICsgZXNjYXBlZCArIFwiJyBuYW1lPSdcIiArIGVzY2FwZWQgKyBcIicgdGl0bGU9J1wiICsgZXNjYXBlZFRvb2x0aXAgKyBcIic+PG9wdGlvbj48L29wdGlvbj5cIjtcblxuXHQgICAgICAgIGlmIChRVW5pdC5pcyhcImFycmF5XCIsIHZhbC52YWx1ZSkpIHtcblx0ICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2YWwudmFsdWUubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgZXNjYXBlZCA9IGVzY2FwZVRleHQodmFsLnZhbHVlW2pdKTtcblx0ICAgICAgICAgICAgdXJsQ29uZmlnSHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgZXNjYXBlZCArIFwiJ1wiICsgKGNvbmZpZ1t2YWwuaWRdID09PSB2YWwudmFsdWVbal0gPyAoc2VsZWN0aW9uID0gdHJ1ZSkgJiYgXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIikgKyBcIj5cIiArIGVzY2FwZWQgKyBcIjwvb3B0aW9uPlwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBmb3IgKGogaW4gdmFsLnZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbCh2YWwudmFsdWUsIGopKSB7XG5cdCAgICAgICAgICAgICAgdXJsQ29uZmlnSHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgZXNjYXBlVGV4dChqKSArIFwiJ1wiICsgKGNvbmZpZ1t2YWwuaWRdID09PSBqID8gKHNlbGVjdGlvbiA9IHRydWUpICYmIFwiIHNlbGVjdGVkPSdzZWxlY3RlZCdcIiA6IFwiXCIpICsgXCI+XCIgKyBlc2NhcGVUZXh0KHZhbC52YWx1ZVtqXSkgKyBcIjwvb3B0aW9uPlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGNvbmZpZ1t2YWwuaWRdICYmICFzZWxlY3Rpb24pIHtcblx0ICAgICAgICAgIGVzY2FwZWQgPSBlc2NhcGVUZXh0KGNvbmZpZ1t2YWwuaWRdKTtcblx0ICAgICAgICAgIHVybENvbmZpZ0h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIGVzY2FwZWQgKyBcIicgc2VsZWN0ZWQ9J3NlbGVjdGVkJyBkaXNhYmxlZD0nZGlzYWJsZWQnPlwiICsgZXNjYXBlZCArIFwiPC9vcHRpb24+XCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdXJsQ29uZmlnSHRtbCArPSBcIjwvc2VsZWN0PlwiO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1cmxDb25maWdIdG1sO1xuXHQgIH0gLy8gSGFuZGxlIFwiY2xpY2tcIiBldmVudHMgb24gdG9vbGJhciBjaGVja2JveGVzIGFuZCBcImNoYW5nZVwiIGZvciBzZWxlY3QgbWVudXMuXG5cdCAgLy8gVXBkYXRlcyB0aGUgVVJMIHdpdGggdGhlIG5ldyBzdGF0ZSBvZiBgY29uZmlnLnVybENvbmZpZ2AgdmFsdWVzLlxuXG5cblx0ICBmdW5jdGlvbiB0b29sYmFyQ2hhbmdlZCgpIHtcblx0ICAgIHZhciB1cGRhdGVkVXJsLFxuXHQgICAgICAgIHZhbHVlLFxuXHQgICAgICAgIHRlc3RzLFxuXHQgICAgICAgIGZpZWxkID0gdGhpcyxcblx0ICAgICAgICBwYXJhbXMgPSB7fTsgLy8gRGV0ZWN0IGlmIGZpZWxkIGlzIGEgc2VsZWN0IG1lbnUgb3IgYSBjaGVja2JveFxuXG5cdCAgICBpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gZmllbGQpIHtcblx0ICAgICAgdmFsdWUgPSBmaWVsZC5vcHRpb25zW2ZpZWxkLnNlbGVjdGVkSW5kZXhdLnZhbHVlIHx8IHVuZGVmaW5lZDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhbHVlID0gZmllbGQuY2hlY2tlZCA/IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCB0cnVlIDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICBwYXJhbXNbZmllbGQubmFtZV0gPSB2YWx1ZTtcblx0ICAgIHVwZGF0ZWRVcmwgPSBzZXRVcmwocGFyYW1zKTsgLy8gQ2hlY2sgaWYgd2UgY2FuIGFwcGx5IHRoZSBjaGFuZ2Ugd2l0aG91dCBhIHBhZ2UgcmVmcmVzaFxuXG5cdCAgICBpZiAoXCJoaWRlcGFzc2VkXCIgPT09IGZpZWxkLm5hbWUgJiYgXCJyZXBsYWNlU3RhdGVcIiBpbiB3aW5kb3ckMS5oaXN0b3J5KSB7XG5cdCAgICAgIFFVbml0LnVybFBhcmFtc1tmaWVsZC5uYW1lXSA9IHZhbHVlO1xuXHQgICAgICBjb25maWdbZmllbGQubmFtZV0gPSB2YWx1ZSB8fCBmYWxzZTtcblx0ICAgICAgdGVzdHMgPSBpZChcInF1bml0LXRlc3RzXCIpO1xuXG5cdCAgICAgIGlmICh0ZXN0cykge1xuXHQgICAgICAgIHZhciBsZW5ndGggPSB0ZXN0cy5jaGlsZHJlbi5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gdGVzdHMuY2hpbGRyZW47XG5cblx0ICAgICAgICBpZiAoZmllbGQuY2hlY2tlZCkge1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdGVzdCA9IGNoaWxkcmVuW2ldO1xuXHQgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGVzdCA/IHRlc3QuY2xhc3NOYW1lIDogXCJcIjtcblx0ICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUhhc1Bhc3MgPSBjbGFzc05hbWUuaW5kZXhPZihcInBhc3NcIikgPiAtMTtcblx0ICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUhhc1NraXBwZWQgPSBjbGFzc05hbWUuaW5kZXhPZihcInNraXBwZWRcIikgPiAtMTtcblxuXHQgICAgICAgICAgICBpZiAoY2xhc3NOYW1lSGFzUGFzcyB8fCBjbGFzc05hbWVIYXNTa2lwcGVkKSB7XG5cdCAgICAgICAgICAgICAgaGlkZGVuVGVzdHMucHVzaCh0ZXN0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaGlkZGVuVGVzdHMpLFxuXHQgICAgICAgICAgICAgIF9zdGVwO1xuXG5cdCAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuXHQgICAgICAgICAgICAgIHZhciBoaWRkZW5UZXN0ID0gX3N0ZXAudmFsdWU7XG5cdCAgICAgICAgICAgICAgdGVzdHMucmVtb3ZlQ2hpbGQoaGlkZGVuVGVzdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuXHQgICAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgd2hpbGUgKCh0ZXN0ID0gaGlkZGVuVGVzdHMucG9wKCkpICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdGVzdHMuYXBwZW5kQ2hpbGQodGVzdCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgd2luZG93JDEuaGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCwgXCJcIiwgdXBkYXRlZFVybCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB3aW5kb3ckMS5sb2NhdGlvbiA9IHVwZGF0ZWRVcmw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc2V0VXJsKHBhcmFtcykge1xuXHQgICAgdmFyIGtleSxcblx0ICAgICAgICBhcnJWYWx1ZSxcblx0ICAgICAgICBpLFxuXHQgICAgICAgIHF1ZXJ5c3RyaW5nID0gXCI/XCIsXG5cdCAgICAgICAgbG9jYXRpb24gPSB3aW5kb3ckMS5sb2NhdGlvbjtcblx0ICAgIHBhcmFtcyA9IFFVbml0LmV4dGVuZChRVW5pdC5leHRlbmQoe30sIFFVbml0LnVybFBhcmFtcyksIHBhcmFtcyk7XG5cblx0ICAgIGZvciAoa2V5IGluIHBhcmFtcykge1xuXHQgICAgICAvLyBTa2lwIGluaGVyaXRlZCBvciB1bmRlZmluZWQgcHJvcGVydGllc1xuXHQgICAgICBpZiAoaGFzT3duLmNhbGwocGFyYW1zLCBrZXkpICYmIHBhcmFtc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAvLyBPdXRwdXQgYSBwYXJhbWV0ZXIgZm9yIGVhY2ggdmFsdWUgb2YgdGhpcyBrZXlcblx0ICAgICAgICAvLyAoYnV0IHVzdWFsbHkganVzdCBvbmUpXG5cdCAgICAgICAgYXJyVmFsdWUgPSBbXS5jb25jYXQocGFyYW1zW2tleV0pO1xuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyclZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBxdWVyeXN0cmluZyArPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHQgICAgICAgICAgaWYgKGFyclZhbHVlW2ldICE9PSB0cnVlKSB7XG5cdCAgICAgICAgICAgIHF1ZXJ5c3RyaW5nICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyclZhbHVlW2ldKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcXVlcnlzdHJpbmcgKz0gXCImXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIHF1ZXJ5c3RyaW5nLnNsaWNlKDAsIC0xKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhcHBseVVybFBhcmFtcygpIHtcblx0ICAgIHZhciBpLFxuXHQgICAgICAgIHNlbGVjdGVkTW9kdWxlcyA9IFtdLFxuXHQgICAgICAgIG1vZHVsZXNMaXN0ID0gaWQoXCJxdW5pdC1tb2R1bGVmaWx0ZXItZHJvcGRvd24tbGlzdFwiKS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLFxuXHQgICAgICAgIGZpbHRlciA9IGlkKFwicXVuaXQtZmlsdGVyLWlucHV0XCIpLnZhbHVlO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbW9kdWxlc0xpc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKG1vZHVsZXNMaXN0W2ldLmNoZWNrZWQpIHtcblx0ICAgICAgICBzZWxlY3RlZE1vZHVsZXMucHVzaChtb2R1bGVzTGlzdFtpXS52YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgd2luZG93JDEubG9jYXRpb24gPSBzZXRVcmwoe1xuXHQgICAgICBmaWx0ZXI6IGZpbHRlciA9PT0gXCJcIiA/IHVuZGVmaW5lZCA6IGZpbHRlcixcblx0ICAgICAgbW9kdWxlSWQ6IHNlbGVjdGVkTW9kdWxlcy5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBzZWxlY3RlZE1vZHVsZXMsXG5cdCAgICAgIC8vIFJlbW92ZSBtb2R1bGUgYW5kIHRlc3RJZCBmaWx0ZXJcblx0ICAgICAgbW9kdWxlOiB1bmRlZmluZWQsXG5cdCAgICAgIHRlc3RJZDogdW5kZWZpbmVkXG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0b29sYmFyVXJsQ29uZmlnQ29udGFpbmVyKCkge1xuXHQgICAgdmFyIHVybENvbmZpZ0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXHQgICAgdXJsQ29uZmlnQ29udGFpbmVyLmlubmVySFRNTCA9IGdldFVybENvbmZpZ0h0bWwoKTtcblx0ICAgIGFkZENsYXNzKHVybENvbmZpZ0NvbnRhaW5lciwgXCJxdW5pdC11cmwtY29uZmlnXCIpO1xuXHQgICAgYWRkRXZlbnRzKHVybENvbmZpZ0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLCBcImNoYW5nZVwiLCB0b29sYmFyQ2hhbmdlZCk7XG5cdCAgICBhZGRFdmVudHModXJsQ29uZmlnQ29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpLCBcImNoYW5nZVwiLCB0b29sYmFyQ2hhbmdlZCk7XG5cdCAgICByZXR1cm4gdXJsQ29uZmlnQ29udGFpbmVyO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGFib3J0VGVzdHNCdXR0b24oKSB7XG5cdCAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblx0ICAgIGJ1dHRvbi5pZCA9IFwicXVuaXQtYWJvcnQtdGVzdHMtYnV0dG9uXCI7XG5cdCAgICBidXR0b24uaW5uZXJIVE1MID0gXCJBYm9ydFwiO1xuXHQgICAgYWRkRXZlbnQoYnV0dG9uLCBcImNsaWNrXCIsIGFib3J0VGVzdHMpO1xuXHQgICAgcmV0dXJuIGJ1dHRvbjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0b29sYmFyTG9vc2VGaWx0ZXIoKSB7XG5cdCAgICB2YXIgZmlsdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG5cdCAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiksXG5cdCAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG5cdCAgICAgICAgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblx0ICAgIGFkZENsYXNzKGZpbHRlciwgXCJxdW5pdC1maWx0ZXJcIik7XG5cdCAgICBsYWJlbC5pbm5lckhUTUwgPSBcIkZpbHRlcjogXCI7XG5cdCAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG5cdCAgICBpbnB1dC52YWx1ZSA9IGNvbmZpZy5maWx0ZXIgfHwgXCJcIjtcblx0ICAgIGlucHV0Lm5hbWUgPSBcImZpbHRlclwiO1xuXHQgICAgaW5wdXQuaWQgPSBcInF1bml0LWZpbHRlci1pbnB1dFwiO1xuXHQgICAgYnV0dG9uLmlubmVySFRNTCA9IFwiR29cIjtcblx0ICAgIGxhYmVsLmFwcGVuZENoaWxkKGlucHV0KTtcblx0ICAgIGZpbHRlci5hcHBlbmRDaGlsZChsYWJlbCk7XG5cdCAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpKTtcblx0ICAgIGZpbHRlci5hcHBlbmRDaGlsZChidXR0b24pO1xuXHQgICAgYWRkRXZlbnQoZmlsdGVyLCBcInN1Ym1pdFwiLCBpbnRlcmNlcHROYXZpZ2F0aW9uKTtcblx0ICAgIHJldHVybiBmaWx0ZXI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbW9kdWxlTGlzdEh0bWwobW9kdWxlcykge1xuXHQgICAgdmFyIGksXG5cdCAgICAgICAgY2hlY2tlZCxcblx0ICAgICAgICBodG1sID0gXCJcIjtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKG1vZHVsZXNbaV0ubmFtZSAhPT0gXCJcIikge1xuXHQgICAgICAgIGNoZWNrZWQgPSBjb25maWcubW9kdWxlSWQuaW5kZXhPZihtb2R1bGVzW2ldLm1vZHVsZUlkKSA+IC0xO1xuXHQgICAgICAgIGh0bWwgKz0gXCI8bGk+PGxhYmVsIGNsYXNzPSdjbGlja2FibGVcIiArIChjaGVja2VkID8gXCIgY2hlY2tlZFwiIDogXCJcIikgKyBcIic+PGlucHV0IHR5cGU9J2NoZWNrYm94JyBcIiArIFwidmFsdWU9J1wiICsgbW9kdWxlc1tpXS5tb2R1bGVJZCArIFwiJ1wiICsgKGNoZWNrZWQgPyBcIiBjaGVja2VkPSdjaGVja2VkJ1wiIDogXCJcIikgKyBcIiAvPlwiICsgZXNjYXBlVGV4dChtb2R1bGVzW2ldLm5hbWUpICsgXCI8L2xhYmVsPjwvbGk+XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdG9vbGJhck1vZHVsZUZpbHRlcigpIHtcblx0ICAgIHZhciBjb21taXQsXG5cdCAgICAgICAgcmVzZXQsXG5cdCAgICAgICAgbW9kdWxlRmlsdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG5cdCAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiksXG5cdCAgICAgICAgbW9kdWxlU2VhcmNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuXHQgICAgICAgIGRyb3BEb3duID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0ICAgICAgICBhY3Rpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksXG5cdCAgICAgICAgYXBwbHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLFxuXHQgICAgICAgIHJlc2V0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSxcblx0ICAgICAgICBhbGxNb2R1bGVzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiksXG5cdCAgICAgICAgYWxsQ2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG5cdCAgICAgICAgZHJvcERvd25MaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpLFxuXHQgICAgICAgIGRpcnR5ID0gZmFsc2U7XG5cdCAgICBtb2R1bGVTZWFyY2guaWQgPSBcInF1bml0LW1vZHVsZWZpbHRlci1zZWFyY2hcIjtcblx0ICAgIG1vZHVsZVNlYXJjaC5hdXRvY29tcGxldGUgPSBcIm9mZlwiO1xuXHQgICAgYWRkRXZlbnQobW9kdWxlU2VhcmNoLCBcImlucHV0XCIsIHNlYXJjaElucHV0KTtcblx0ICAgIGFkZEV2ZW50KG1vZHVsZVNlYXJjaCwgXCJpbnB1dFwiLCBzZWFyY2hGb2N1cyk7XG5cdCAgICBhZGRFdmVudChtb2R1bGVTZWFyY2gsIFwiZm9jdXNcIiwgc2VhcmNoRm9jdXMpO1xuXHQgICAgYWRkRXZlbnQobW9kdWxlU2VhcmNoLCBcImNsaWNrXCIsIHNlYXJjaEZvY3VzKTtcblx0ICAgIGNvbmZpZy5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQgICAgICByZXR1cm4gbW9kdWxlLm5hbWVQcmVwYXJlZCA9IGZ1enp5c29ydC5wcmVwYXJlKG1vZHVsZS5uYW1lKTtcblx0ICAgIH0pO1xuXHQgICAgbGFiZWwuaWQgPSBcInF1bml0LW1vZHVsZWZpbHRlci1zZWFyY2gtY29udGFpbmVyXCI7XG5cdCAgICBsYWJlbC5pbm5lckhUTUwgPSBcIk1vZHVsZTogXCI7XG5cdCAgICBsYWJlbC5hcHBlbmRDaGlsZChtb2R1bGVTZWFyY2gpO1xuXHQgICAgYXBwbHlCdXR0b24udGV4dENvbnRlbnQgPSBcIkFwcGx5XCI7XG5cdCAgICBhcHBseUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICByZXNldEJ1dHRvbi50ZXh0Q29udGVudCA9IFwiUmVzZXRcIjtcblx0ICAgIHJlc2V0QnV0dG9uLnR5cGUgPSBcInJlc2V0XCI7XG5cdCAgICByZXNldEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICBhbGxDaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuXHQgICAgYWxsQ2hlY2tib3guY2hlY2tlZCA9IGNvbmZpZy5tb2R1bGVJZC5sZW5ndGggPT09IDA7XG5cdCAgICBhbGxNb2R1bGVzTGFiZWwuY2xhc3NOYW1lID0gXCJjbGlja2FibGVcIjtcblxuXHQgICAgaWYgKGNvbmZpZy5tb2R1bGVJZC5sZW5ndGgpIHtcblx0ICAgICAgYWxsTW9kdWxlc0xhYmVsLmNsYXNzTmFtZSA9IFwiY2hlY2tlZFwiO1xuXHQgICAgfVxuXG5cdCAgICBhbGxNb2R1bGVzTGFiZWwuYXBwZW5kQ2hpbGQoYWxsQ2hlY2tib3gpO1xuXHQgICAgYWxsTW9kdWxlc0xhYmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQWxsIG1vZHVsZXNcIikpO1xuXHQgICAgYWN0aW9ucy5pZCA9IFwicXVuaXQtbW9kdWxlZmlsdGVyLWFjdGlvbnNcIjtcblx0ICAgIGFjdGlvbnMuYXBwZW5kQ2hpbGQoYXBwbHlCdXR0b24pO1xuXHQgICAgYWN0aW9ucy5hcHBlbmRDaGlsZChyZXNldEJ1dHRvbik7XG5cdCAgICBhY3Rpb25zLmFwcGVuZENoaWxkKGFsbE1vZHVsZXNMYWJlbCk7XG5cdCAgICBjb21taXQgPSBhY3Rpb25zLmZpcnN0Q2hpbGQ7XG5cdCAgICByZXNldCA9IGNvbW1pdC5uZXh0U2libGluZztcblx0ICAgIGFkZEV2ZW50KGNvbW1pdCwgXCJjbGlja1wiLCBhcHBseVVybFBhcmFtcyk7XG5cdCAgICBkcm9wRG93bkxpc3QuaWQgPSBcInF1bml0LW1vZHVsZWZpbHRlci1kcm9wZG93bi1saXN0XCI7XG5cdCAgICBkcm9wRG93bkxpc3QuaW5uZXJIVE1MID0gbW9kdWxlTGlzdEh0bWwoY29uZmlnLm1vZHVsZXMpO1xuXHQgICAgZHJvcERvd24uaWQgPSBcInF1bml0LW1vZHVsZWZpbHRlci1kcm9wZG93blwiO1xuXHQgICAgZHJvcERvd24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgZHJvcERvd24uYXBwZW5kQ2hpbGQoYWN0aW9ucyk7XG5cdCAgICBkcm9wRG93bi5hcHBlbmRDaGlsZChkcm9wRG93bkxpc3QpO1xuXHQgICAgYWRkRXZlbnQoZHJvcERvd24sIFwiY2hhbmdlXCIsIHNlbGVjdGlvbkNoYW5nZSk7XG5cdCAgICBzZWxlY3Rpb25DaGFuZ2UoKTtcblx0ICAgIG1vZHVsZUZpbHRlci5pZCA9IFwicXVuaXQtbW9kdWxlZmlsdGVyXCI7XG5cdCAgICBtb2R1bGVGaWx0ZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXHQgICAgbW9kdWxlRmlsdGVyLmFwcGVuZENoaWxkKGRyb3BEb3duKTtcblx0ICAgIGFkZEV2ZW50KG1vZHVsZUZpbHRlciwgXCJzdWJtaXRcIiwgaW50ZXJjZXB0TmF2aWdhdGlvbik7XG5cdCAgICBhZGRFdmVudChtb2R1bGVGaWx0ZXIsIFwicmVzZXRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBMZXQgdGhlIHJlc2V0IGhhcHBlbiwgdGhlbiB1cGRhdGUgc3R5bGVzXG5cdCAgICAgIHdpbmRvdyQxLnNldFRpbWVvdXQoc2VsZWN0aW9uQ2hhbmdlKTtcblx0ICAgIH0pOyAvLyBFbmFibGVzIHNob3cvaGlkZSBmb3IgdGhlIGRyb3Bkb3duXG5cblx0ICAgIGZ1bmN0aW9uIHNlYXJjaEZvY3VzKCkge1xuXHQgICAgICBpZiAoZHJvcERvd24uc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBkcm9wRG93bi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHQgICAgICBhZGRFdmVudChkb2N1bWVudCwgXCJjbGlja1wiLCBoaWRlSGFuZGxlcik7XG5cdCAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCBcImtleWRvd25cIiwgaGlkZUhhbmRsZXIpOyAvLyBIaWRlIG9uIEVzY2FwZSBrZXlkb3duIG9yIG91dHNpZGUtY29udGFpbmVyIGNsaWNrXG5cblx0ICAgICAgZnVuY3Rpb24gaGlkZUhhbmRsZXIoZSkge1xuXHQgICAgICAgIHZhciBpbkNvbnRhaW5lciA9IG1vZHVsZUZpbHRlci5jb250YWlucyhlLnRhcmdldCk7XG5cblx0ICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNyB8fCAhaW5Db250YWluZXIpIHtcblx0ICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3ICYmIGluQ29udGFpbmVyKSB7XG5cdCAgICAgICAgICAgIG1vZHVsZVNlYXJjaC5mb2N1cygpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBkcm9wRG93bi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICAgICAgICByZW1vdmVFdmVudChkb2N1bWVudCwgXCJjbGlja1wiLCBoaWRlSGFuZGxlcik7XG5cdCAgICAgICAgICByZW1vdmVFdmVudChkb2N1bWVudCwgXCJrZXlkb3duXCIsIGhpZGVIYW5kbGVyKTtcblx0ICAgICAgICAgIG1vZHVsZVNlYXJjaC52YWx1ZSA9IFwiXCI7XG5cdCAgICAgICAgICBzZWFyY2hJbnB1dCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmaWx0ZXJNb2R1bGVzKHNlYXJjaFRleHQpIHtcblx0ICAgICAgaWYgKHNlYXJjaFRleHQgPT09IFwiXCIpIHtcblx0ICAgICAgICByZXR1cm4gY29uZmlnLm1vZHVsZXM7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZnV6enlzb3J0LmdvKHNlYXJjaFRleHQsIGNvbmZpZy5tb2R1bGVzLCB7XG5cdCAgICAgICAga2V5OiBcIm5hbWVQcmVwYXJlZFwiLFxuXHQgICAgICAgIHRocmVzaG9sZDogLTEwMDAwXG5cdCAgICAgIH0pLm1hcChmdW5jdGlvbiAobW9kdWxlKSB7XG5cdCAgICAgICAgcmV0dXJuIG1vZHVsZS5vYmo7XG5cdCAgICAgIH0pO1xuXHQgICAgfSAvLyBQcm9jZXNzZXMgbW9kdWxlIHNlYXJjaCBib3ggaW5wdXRcblxuXG5cdCAgICB2YXIgc2VhcmNoSW5wdXRUaW1lb3V0O1xuXG5cdCAgICBmdW5jdGlvbiBzZWFyY2hJbnB1dCgpIHtcblx0ICAgICAgd2luZG93JDEuY2xlYXJUaW1lb3V0KHNlYXJjaElucHV0VGltZW91dCk7XG5cdCAgICAgIHNlYXJjaElucHV0VGltZW91dCA9IHdpbmRvdyQxLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBzZWFyY2hUZXh0ID0gbW9kdWxlU2VhcmNoLnZhbHVlLnRvTG93ZXJDYXNlKCksXG5cdCAgICAgICAgICAgIGZpbHRlcmVkTW9kdWxlcyA9IGZpbHRlck1vZHVsZXMoc2VhcmNoVGV4dCk7XG5cdCAgICAgICAgZHJvcERvd25MaXN0LmlubmVySFRNTCA9IG1vZHVsZUxpc3RIdG1sKGZpbHRlcmVkTW9kdWxlcyk7XG5cdCAgICAgIH0sIDIwMCk7XG5cdCAgICB9IC8vIFByb2Nlc3NlcyBzZWxlY3Rpb24gY2hhbmdlc1xuXG5cblx0ICAgIGZ1bmN0aW9uIHNlbGVjdGlvbkNoYW5nZShldnQpIHtcblx0ICAgICAgdmFyIGksXG5cdCAgICAgICAgICBpdGVtLFxuXHQgICAgICAgICAgY2hlY2tib3ggPSBldnQgJiYgZXZ0LnRhcmdldCB8fCBhbGxDaGVja2JveCxcblx0ICAgICAgICAgIG1vZHVsZXNMaXN0ID0gZHJvcERvd25MaXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIiksXG5cdCAgICAgICAgICBzZWxlY3RlZE5hbWVzID0gW107XG5cdCAgICAgIHRvZ2dsZUNsYXNzKGNoZWNrYm94LnBhcmVudE5vZGUsIFwiY2hlY2tlZFwiLCBjaGVja2JveC5jaGVja2VkKTtcblx0ICAgICAgZGlydHkgPSBmYWxzZTtcblxuXHQgICAgICBpZiAoY2hlY2tib3guY2hlY2tlZCAmJiBjaGVja2JveCAhPT0gYWxsQ2hlY2tib3gpIHtcblx0ICAgICAgICBhbGxDaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG5cdCAgICAgICAgcmVtb3ZlQ2xhc3MoYWxsQ2hlY2tib3gucGFyZW50Tm9kZSwgXCJjaGVja2VkXCIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IG1vZHVsZXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaXRlbSA9IG1vZHVsZXNMaXN0W2ldO1xuXG5cdCAgICAgICAgaWYgKCFldnQpIHtcblx0ICAgICAgICAgIHRvZ2dsZUNsYXNzKGl0ZW0ucGFyZW50Tm9kZSwgXCJjaGVja2VkXCIsIGl0ZW0uY2hlY2tlZCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjaGVja2JveCA9PT0gYWxsQ2hlY2tib3ggJiYgY2hlY2tib3guY2hlY2tlZCkge1xuXHQgICAgICAgICAgaXRlbS5jaGVja2VkID0gZmFsc2U7XG5cdCAgICAgICAgICByZW1vdmVDbGFzcyhpdGVtLnBhcmVudE5vZGUsIFwiY2hlY2tlZFwiKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkaXJ0eSA9IGRpcnR5IHx8IGl0ZW0uY2hlY2tlZCAhPT0gaXRlbS5kZWZhdWx0Q2hlY2tlZDtcblxuXHQgICAgICAgIGlmIChpdGVtLmNoZWNrZWQpIHtcblx0ICAgICAgICAgIHNlbGVjdGVkTmFtZXMucHVzaChpdGVtLnBhcmVudE5vZGUudGV4dENvbnRlbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbW1pdC5zdHlsZS5kaXNwbGF5ID0gcmVzZXQuc3R5bGUuZGlzcGxheSA9IGRpcnR5ID8gXCJcIiA6IFwibm9uZVwiO1xuXHQgICAgICBtb2R1bGVTZWFyY2gucGxhY2Vob2xkZXIgPSBzZWxlY3RlZE5hbWVzLmpvaW4oXCIsIFwiKSB8fCBhbGxDaGVja2JveC5wYXJlbnROb2RlLnRleHRDb250ZW50O1xuXHQgICAgICBtb2R1bGVTZWFyY2gudGl0bGUgPSBcIlR5cGUgdG8gZmlsdGVyIGxpc3QuIEN1cnJlbnQgc2VsZWN0aW9uOlxcblwiICsgKHNlbGVjdGVkTmFtZXMuam9pbihcIlxcblwiKSB8fCBhbGxDaGVja2JveC5wYXJlbnROb2RlLnRleHRDb250ZW50KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG1vZHVsZUZpbHRlcjtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0b29sYmFyRmlsdGVycygpIHtcblx0ICAgIHZhciB0b29sYmFyRmlsdGVycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXHQgICAgdG9vbGJhckZpbHRlcnMuaWQgPSBcInF1bml0LXRvb2xiYXItZmlsdGVyc1wiO1xuXHQgICAgdG9vbGJhckZpbHRlcnMuYXBwZW5kQ2hpbGQodG9vbGJhckxvb3NlRmlsdGVyKCkpO1xuXHQgICAgdG9vbGJhckZpbHRlcnMuYXBwZW5kQ2hpbGQodG9vbGJhck1vZHVsZUZpbHRlcigpKTtcblx0ICAgIHJldHVybiB0b29sYmFyRmlsdGVycztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhcHBlbmRUb29sYmFyKCkge1xuXHQgICAgdmFyIHRvb2xiYXIgPSBpZChcInF1bml0LXRlc3RydW5uZXItdG9vbGJhclwiKTtcblxuXHQgICAgaWYgKHRvb2xiYXIpIHtcblx0ICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZCh0b29sYmFyVXJsQ29uZmlnQ29udGFpbmVyKCkpO1xuXHQgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKHRvb2xiYXJGaWx0ZXJzKCkpO1xuXHQgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmNsYXNzTmFtZSA9IFwiY2xlYXJmaXhcIjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhcHBlbmRIZWFkZXIoKSB7XG5cdCAgICB2YXIgaGVhZGVyID0gaWQoXCJxdW5pdC1oZWFkZXJcIik7XG5cblx0ICAgIGlmIChoZWFkZXIpIHtcblx0ICAgICAgaGVhZGVyLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nXCIgKyBlc2NhcGVUZXh0KHVuZmlsdGVyZWRVcmwpICsgXCInPlwiICsgaGVhZGVyLmlubmVySFRNTCArIFwiPC9hPiBcIjtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhcHBlbmRCYW5uZXIoKSB7XG5cdCAgICB2YXIgYmFubmVyID0gaWQoXCJxdW5pdC1iYW5uZXJcIik7XG5cblx0ICAgIGlmIChiYW5uZXIpIHtcblx0ICAgICAgYmFubmVyLmNsYXNzTmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYXBwZW5kVGVzdFJlc3VsdHMoKSB7XG5cdCAgICB2YXIgdGVzdHMgPSBpZChcInF1bml0LXRlc3RzXCIpLFxuXHQgICAgICAgIHJlc3VsdCA9IGlkKFwicXVuaXQtdGVzdHJlc3VsdFwiKSxcblx0ICAgICAgICBjb250cm9scztcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICByZXN1bHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXN1bHQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGVzdHMpIHtcblx0ICAgICAgdGVzdHMuaW5uZXJIVE1MID0gXCJcIjtcblx0ICAgICAgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG5cdCAgICAgIHJlc3VsdC5pZCA9IFwicXVuaXQtdGVzdHJlc3VsdFwiO1xuXHQgICAgICByZXN1bHQuY2xhc3NOYW1lID0gXCJyZXN1bHRcIjtcblx0ICAgICAgdGVzdHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocmVzdWx0LCB0ZXN0cyk7XG5cdCAgICAgIHJlc3VsdC5pbm5lckhUTUwgPSBcIjxkaXYgaWQ9XFxcInF1bml0LXRlc3RyZXN1bHQtZGlzcGxheVxcXCI+UnVubmluZy4uLjxiciAvPiYjMTYwOzwvZGl2PlwiICsgXCI8ZGl2IGlkPVxcXCJxdW5pdC10ZXN0cmVzdWx0LWNvbnRyb2xzXFxcIj48L2Rpdj5cIiArIFwiPGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlwiO1xuXHQgICAgICBjb250cm9scyA9IGlkKFwicXVuaXQtdGVzdHJlc3VsdC1jb250cm9sc1wiKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbnRyb2xzKSB7XG5cdCAgICAgIGNvbnRyb2xzLmFwcGVuZENoaWxkKGFib3J0VGVzdHNCdXR0b24oKSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYXBwZW5kRmlsdGVyZWRUZXN0KCkge1xuXHQgICAgdmFyIHRlc3RJZCA9IFFVbml0LmNvbmZpZy50ZXN0SWQ7XG5cblx0ICAgIGlmICghdGVzdElkIHx8IHRlc3RJZC5sZW5ndGggPD0gMCkge1xuXHQgICAgICByZXR1cm4gXCJcIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFwiPGRpdiBpZD0ncXVuaXQtZmlsdGVyZWRUZXN0Jz5SZXJ1bm5pbmcgc2VsZWN0ZWQgdGVzdHM6IFwiICsgZXNjYXBlVGV4dCh0ZXN0SWQuam9pbihcIiwgXCIpKSArIFwiIDxhIGlkPSdxdW5pdC1jbGVhckZpbHRlcicgaHJlZj0nXCIgKyBlc2NhcGVUZXh0KHVuZmlsdGVyZWRVcmwpICsgXCInPlJ1biBhbGwgdGVzdHM8L2E+PC9kaXY+XCI7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYXBwZW5kVXNlckFnZW50KCkge1xuXHQgICAgdmFyIHVzZXJBZ2VudCA9IGlkKFwicXVuaXQtdXNlckFnZW50XCIpO1xuXG5cdCAgICBpZiAodXNlckFnZW50KSB7XG5cdCAgICAgIHVzZXJBZ2VudC5pbm5lckhUTUwgPSBcIlwiO1xuXHQgICAgICB1c2VyQWdlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJRVW5pdCBcIiArIFFVbml0LnZlcnNpb24gKyBcIjsgXCIgKyBuYXZpZ2F0b3IudXNlckFnZW50KSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gYXBwZW5kSW50ZXJmYWNlKCkge1xuXHQgICAgdmFyIHF1bml0ID0gaWQoXCJxdW5pdFwiKTsgLy8gRm9yIGNvbXBhdCB3aXRoIFFVbml0IDEuMiwgYW5kIHRvIHN1cHBvcnQgZnVsbHkgY3VzdG9tIHRoZW1lIEhUTUwsXG5cdCAgICAvLyB3ZSB3aWxsIHVzZSBhbnkgZXhpc3RpbmcgZWxlbWVudHMgaWYgbm8gaWQ9XCJxdW5pdFwiIGVsZW1lbnQgZXhpc3RzLlxuXHQgICAgLy9cblx0ICAgIC8vIE5vdGUgdGhhdCB3ZSBkb24ndCBmYWlsIG9yIGZhbGxiYWNrIHRvIGNyZWF0aW5nIGl0IG91cnNlbHZlcyxcblx0ICAgIC8vIGJlY2F1c2Ugbm90IGhhdmluZyBpZD1cInF1bml0XCIgKGFuZCBub3QgaGF2aW5nIHRoZSBiZWxvdyBlbGVtZW50cylcblx0ICAgIC8vIHNpbXBseSBtZWFucyBRVW5pdCBhY3RzIGhlYWRsZXNzLCBhbGxvd2luZyB1c2VycyB0byB1c2UgdGhlaXIgb3duXG5cdCAgICAvLyByZXBvcnRlcnMsIG9yIGZvciBhIHRlc3QgcnVubmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIGRpcmVjdGx5IHdpdGhvdXRcblx0ICAgIC8vIGhhdmluZyB0aGUgSFRNTCByZXBvcnRlciBhY3RpdmVseSByZW5kZXIgYW55dGhpbmcuXG5cblx0ICAgIGlmIChxdW5pdCkge1xuXHQgICAgICAvLyBTaW5jZSBRVW5pdCAxLjMsIHRoZXNlIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgaWYgdGhlIHBhZ2Vcblx0ICAgICAgLy8gY29udGFpbnMgaWQ9XCJxdW5pdFwiLlxuXHQgICAgICBxdW5pdC5pbm5lckhUTUwgPSBcIjxoMSBpZD0ncXVuaXQtaGVhZGVyJz5cIiArIGVzY2FwZVRleHQoZG9jdW1lbnQudGl0bGUpICsgXCI8L2gxPlwiICsgXCI8aDIgaWQ9J3F1bml0LWJhbm5lcic+PC9oMj5cIiArIFwiPGRpdiBpZD0ncXVuaXQtdGVzdHJ1bm5lci10b29sYmFyJz48L2Rpdj5cIiArIGFwcGVuZEZpbHRlcmVkVGVzdCgpICsgXCI8aDIgaWQ9J3F1bml0LXVzZXJBZ2VudCc+PC9oMj5cIiArIFwiPG9sIGlkPSdxdW5pdC10ZXN0cyc+PC9vbD5cIjtcblx0ICAgIH1cblxuXHQgICAgYXBwZW5kSGVhZGVyKCk7XG5cdCAgICBhcHBlbmRCYW5uZXIoKTtcblx0ICAgIGFwcGVuZFRlc3RSZXN1bHRzKCk7XG5cdCAgICBhcHBlbmRVc2VyQWdlbnQoKTtcblx0ICAgIGFwcGVuZFRvb2xiYXIoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBhcHBlbmRUZXN0KG5hbWUsIHRlc3RJZCwgbW9kdWxlTmFtZSkge1xuXHQgICAgdmFyIHRpdGxlLFxuXHQgICAgICAgIHJlcnVuVHJpZ2dlcixcblx0ICAgICAgICB0ZXN0QmxvY2ssXG5cdCAgICAgICAgYXNzZXJ0TGlzdCxcblx0ICAgICAgICB0ZXN0cyA9IGlkKFwicXVuaXQtdGVzdHNcIik7XG5cblx0ICAgIGlmICghdGVzdHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHJvbmdcIik7XG5cdCAgICB0aXRsZS5pbm5lckhUTUwgPSBnZXROYW1lSHRtbChuYW1lLCBtb2R1bGVOYW1lKTtcblx0ICAgIHJlcnVuVHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHQgICAgcmVydW5UcmlnZ2VyLmlubmVySFRNTCA9IFwiUmVydW5cIjtcblx0ICAgIHJlcnVuVHJpZ2dlci5ocmVmID0gc2V0VXJsKHtcblx0ICAgICAgdGVzdElkOiB0ZXN0SWRcblx0ICAgIH0pO1xuXHQgICAgdGVzdEJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuXHQgICAgdGVzdEJsb2NrLmFwcGVuZENoaWxkKHRpdGxlKTtcblx0ICAgIHRlc3RCbG9jay5hcHBlbmRDaGlsZChyZXJ1blRyaWdnZXIpO1xuXHQgICAgdGVzdEJsb2NrLmlkID0gXCJxdW5pdC10ZXN0LW91dHB1dC1cIiArIHRlc3RJZDtcblx0ICAgIGFzc2VydExpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2xcIik7XG5cdCAgICBhc3NlcnRMaXN0LmNsYXNzTmFtZSA9IFwicXVuaXQtYXNzZXJ0LWxpc3RcIjtcblx0ICAgIHRlc3RCbG9jay5hcHBlbmRDaGlsZChhc3NlcnRMaXN0KTtcblx0ICAgIHRlc3RzLmFwcGVuZENoaWxkKHRlc3RCbG9jayk7XG5cdCAgfSAvLyBIVE1MIFJlcG9ydGVyIGluaXRpYWxpemF0aW9uIGFuZCBsb2FkXG5cblxuXHQgIFFVbml0LmJlZ2luKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG5cdCAgICB2YXIgaSwgbW9kdWxlT2JqOyAvLyBTb3J0IG1vZHVsZXMgYnkgbmFtZSBmb3IgdGhlIHBpY2tlclxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgZGV0YWlscy5tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG1vZHVsZU9iaiA9IGRldGFpbHMubW9kdWxlc1tpXTtcblxuXHQgICAgICBpZiAobW9kdWxlT2JqLm5hbWUpIHtcblx0ICAgICAgICBtb2R1bGVzTGlzdC5wdXNoKG1vZHVsZU9iai5uYW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBtb2R1bGVzTGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG5cdCAgICB9KTsgLy8gSW5pdGlhbGl6ZSBRVW5pdCBlbGVtZW50c1xuXG5cdCAgICBhcHBlbmRJbnRlcmZhY2UoKTtcblx0ICB9KTtcblx0ICBRVW5pdC5kb25lKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG5cdCAgICB2YXIgYmFubmVyID0gaWQoXCJxdW5pdC1iYW5uZXJcIiksXG5cdCAgICAgICAgdGVzdHMgPSBpZChcInF1bml0LXRlc3RzXCIpLFxuXHQgICAgICAgIGFib3J0QnV0dG9uID0gaWQoXCJxdW5pdC1hYm9ydC10ZXN0cy1idXR0b25cIiksXG5cdCAgICAgICAgdG90YWxUZXN0cyA9IHN0YXRzLnBhc3NlZFRlc3RzICsgc3RhdHMuc2tpcHBlZFRlc3RzICsgc3RhdHMudG9kb1Rlc3RzICsgc3RhdHMuZmFpbGVkVGVzdHMsXG5cdCAgICAgICAgaHRtbCA9IFt0b3RhbFRlc3RzLCBcIiB0ZXN0cyBjb21wbGV0ZWQgaW4gXCIsIGRldGFpbHMucnVudGltZSwgXCIgbWlsbGlzZWNvbmRzLCB3aXRoIFwiLCBzdGF0cy5mYWlsZWRUZXN0cywgXCIgZmFpbGVkLCBcIiwgc3RhdHMuc2tpcHBlZFRlc3RzLCBcIiBza2lwcGVkLCBhbmQgXCIsIHN0YXRzLnRvZG9UZXN0cywgXCIgdG9kby48YnIgLz5cIiwgXCI8c3BhbiBjbGFzcz0ncGFzc2VkJz5cIiwgZGV0YWlscy5wYXNzZWQsIFwiPC9zcGFuPiBhc3NlcnRpb25zIG9mIDxzcGFuIGNsYXNzPSd0b3RhbCc+XCIsIGRldGFpbHMudG90YWwsIFwiPC9zcGFuPiBwYXNzZWQsIDxzcGFuIGNsYXNzPSdmYWlsZWQnPlwiLCBkZXRhaWxzLmZhaWxlZCwgXCI8L3NwYW4+IGZhaWxlZC5cIl0uam9pbihcIlwiKSxcblx0ICAgICAgICB0ZXN0LFxuXHQgICAgICAgIGFzc2VydExpLFxuXHQgICAgICAgIGFzc2VydExpc3Q7IC8vIFVwZGF0ZSByZW1haW5pbmcgdGVzdHMgdG8gYWJvcnRlZFxuXG5cdCAgICBpZiAoYWJvcnRCdXR0b24gJiYgYWJvcnRCdXR0b24uZGlzYWJsZWQpIHtcblx0ICAgICAgaHRtbCA9IFwiVGVzdHMgYWJvcnRlZCBhZnRlciBcIiArIGRldGFpbHMucnVudGltZSArIFwiIG1pbGxpc2Vjb25kcy5cIjtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlc3RzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGVzdCA9IHRlc3RzLmNoaWxkcmVuW2ldO1xuXG5cdCAgICAgICAgaWYgKHRlc3QuY2xhc3NOYW1lID09PSBcIlwiIHx8IHRlc3QuY2xhc3NOYW1lID09PSBcInJ1bm5pbmdcIikge1xuXHQgICAgICAgICAgdGVzdC5jbGFzc05hbWUgPSBcImFib3J0ZWRcIjtcblx0ICAgICAgICAgIGFzc2VydExpc3QgPSB0ZXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwib2xcIilbMF07XG5cdCAgICAgICAgICBhc3NlcnRMaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcblx0ICAgICAgICAgIGFzc2VydExpLmNsYXNzTmFtZSA9IFwiZmFpbFwiO1xuXHQgICAgICAgICAgYXNzZXJ0TGkuaW5uZXJIVE1MID0gXCJUZXN0IGFib3J0ZWQuXCI7XG5cdCAgICAgICAgICBhc3NlcnRMaXN0LmFwcGVuZENoaWxkKGFzc2VydExpKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGJhbm5lciAmJiAoIWFib3J0QnV0dG9uIHx8IGFib3J0QnV0dG9uLmRpc2FibGVkID09PSBmYWxzZSkpIHtcblx0ICAgICAgYmFubmVyLmNsYXNzTmFtZSA9IHN0YXRzLmZhaWxlZFRlc3RzID8gXCJxdW5pdC1mYWlsXCIgOiBcInF1bml0LXBhc3NcIjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGFib3J0QnV0dG9uKSB7XG5cdCAgICAgIGFib3J0QnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYWJvcnRCdXR0b24pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGVzdHMpIHtcblx0ICAgICAgaWQoXCJxdW5pdC10ZXN0cmVzdWx0LWRpc3BsYXlcIikuaW5uZXJIVE1MID0gaHRtbDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbmZpZy5hbHRlcnRpdGxlICYmIGRvY3VtZW50LnRpdGxlKSB7XG5cdCAgICAgIC8vIFNob3cg4pyWIGZvciBnb29kLCDinJQgZm9yIGJhZCBzdWl0ZSByZXN1bHQgaW4gdGl0bGVcblx0ICAgICAgLy8gdXNlIGVzY2FwZSBzZXF1ZW5jZXMgaW4gY2FzZSBmaWxlIGdldHMgbG9hZGVkIHdpdGggbm9uLXV0Zi04XG5cdCAgICAgIC8vIGNoYXJzZXRcblx0ICAgICAgZG9jdW1lbnQudGl0bGUgPSBbc3RhdHMuZmFpbGVkVGVzdHMgPyBcIlxcdTI3MTZcIiA6IFwiXFx1MjcxNFwiLCBkb2N1bWVudC50aXRsZS5yZXBsYWNlKC9eW1xcdTI3MTRcXHUyNzE2XSAvaSwgXCJcIildLmpvaW4oXCIgXCIpO1xuXHQgICAgfSAvLyBTY3JvbGwgYmFjayB0byB0b3AgdG8gc2hvdyByZXN1bHRzXG5cblxuXHQgICAgaWYgKGNvbmZpZy5zY3JvbGx0b3AgJiYgd2luZG93JDEuc2Nyb2xsVG8pIHtcblx0ICAgICAgd2luZG93JDEuc2Nyb2xsVG8oMCwgMCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBmdW5jdGlvbiBnZXROYW1lSHRtbChuYW1lLCBtb2R1bGUpIHtcblx0ICAgIHZhciBuYW1lSHRtbCA9IFwiXCI7XG5cblx0ICAgIGlmIChtb2R1bGUpIHtcblx0ICAgICAgbmFtZUh0bWwgPSBcIjxzcGFuIGNsYXNzPSdtb2R1bGUtbmFtZSc+XCIgKyBlc2NhcGVUZXh0KG1vZHVsZSkgKyBcIjwvc3Bhbj46IFwiO1xuXHQgICAgfVxuXG5cdCAgICBuYW1lSHRtbCArPSBcIjxzcGFuIGNsYXNzPSd0ZXN0LW5hbWUnPlwiICsgZXNjYXBlVGV4dChuYW1lKSArIFwiPC9zcGFuPlwiO1xuXHQgICAgcmV0dXJuIG5hbWVIdG1sO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGdldFByb2dyZXNzSHRtbChydW50aW1lLCBzdGF0cywgdG90YWwpIHtcblx0ICAgIHZhciBjb21wbGV0ZWQgPSBzdGF0cy5wYXNzZWRUZXN0cyArIHN0YXRzLnNraXBwZWRUZXN0cyArIHN0YXRzLnRvZG9UZXN0cyArIHN0YXRzLmZhaWxlZFRlc3RzO1xuXHQgICAgcmV0dXJuIFtcIjxiciAvPlwiLCBjb21wbGV0ZWQsIFwiIC8gXCIsIHRvdGFsLCBcIiB0ZXN0cyBjb21wbGV0ZWQgaW4gXCIsIHJ1bnRpbWUsIFwiIG1pbGxpc2Vjb25kcywgd2l0aCBcIiwgc3RhdHMuZmFpbGVkVGVzdHMsIFwiIGZhaWxlZCwgXCIsIHN0YXRzLnNraXBwZWRUZXN0cywgXCIgc2tpcHBlZCwgYW5kIFwiLCBzdGF0cy50b2RvVGVzdHMsIFwiIHRvZG8uXCJdLmpvaW4oXCJcIik7XG5cdCAgfVxuXG5cdCAgUVVuaXQudGVzdFN0YXJ0KGZ1bmN0aW9uIChkZXRhaWxzKSB7XG5cdCAgICB2YXIgcnVubmluZywgYmFkO1xuXHQgICAgYXBwZW5kVGVzdChkZXRhaWxzLm5hbWUsIGRldGFpbHMudGVzdElkLCBkZXRhaWxzLm1vZHVsZSk7XG5cdCAgICBydW5uaW5nID0gaWQoXCJxdW5pdC10ZXN0cmVzdWx0LWRpc3BsYXlcIik7XG5cblx0ICAgIGlmIChydW5uaW5nKSB7XG5cdCAgICAgIGFkZENsYXNzKHJ1bm5pbmcsIFwicnVubmluZ1wiKTtcblx0ICAgICAgYmFkID0gUVVuaXQuY29uZmlnLnJlb3JkZXIgJiYgZGV0YWlscy5wcmV2aW91c0ZhaWx1cmU7XG5cdCAgICAgIHJ1bm5pbmcuaW5uZXJIVE1MID0gW2JhZCA/IFwiUmVydW5uaW5nIHByZXZpb3VzbHkgZmFpbGVkIHRlc3Q6IDxiciAvPlwiIDogXCJSdW5uaW5nOiA8YnIgLz5cIiwgZ2V0TmFtZUh0bWwoZGV0YWlscy5uYW1lLCBkZXRhaWxzLm1vZHVsZSksIGdldFByb2dyZXNzSHRtbChub3coKSAtIGNvbmZpZy5zdGFydGVkLCBzdGF0cywgVGVzdC5jb3VudCldLmpvaW4oXCJcIik7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ICBmdW5jdGlvbiBzdHJpcEh0bWwoc3RyaW5nKSB7XG5cdCAgICAvLyBTdHJpcCB0YWdzLCBodG1sIGVudGl0eSBhbmQgd2hpdGVzcGFjZXNcblx0ICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvPFxcLz9bXj5dKyg+fCQpL2csIFwiXCIpLnJlcGxhY2UoLyZxdW90Oy9nLCBcIlwiKS5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuXHQgIH1cblxuXHQgIFFVbml0LmxvZyhmdW5jdGlvbiAoZGV0YWlscykge1xuXHQgICAgdmFyIGFzc2VydExpc3QsXG5cdCAgICAgICAgYXNzZXJ0TGksXG5cdCAgICAgICAgbWVzc2FnZSxcblx0ICAgICAgICBleHBlY3RlZCxcblx0ICAgICAgICBhY3R1YWwsXG5cdCAgICAgICAgZGlmZixcblx0ICAgICAgICBzaG93RGlmZiA9IGZhbHNlLFxuXHQgICAgICAgIHRlc3RJdGVtID0gaWQoXCJxdW5pdC10ZXN0LW91dHB1dC1cIiArIGRldGFpbHMudGVzdElkKTtcblxuXHQgICAgaWYgKCF0ZXN0SXRlbSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG1lc3NhZ2UgPSBlc2NhcGVUZXh0KGRldGFpbHMubWVzc2FnZSkgfHwgKGRldGFpbHMucmVzdWx0ID8gXCJva2F5XCIgOiBcImZhaWxlZFwiKTtcblx0ICAgIG1lc3NhZ2UgPSBcIjxzcGFuIGNsYXNzPSd0ZXN0LW1lc3NhZ2UnPlwiICsgbWVzc2FnZSArIFwiPC9zcGFuPlwiO1xuXHQgICAgbWVzc2FnZSArPSBcIjxzcGFuIGNsYXNzPSdydW50aW1lJz5AIFwiICsgZGV0YWlscy5ydW50aW1lICsgXCIgbXM8L3NwYW4+XCI7IC8vIFRoZSBwdXNoRmFpbHVyZSBkb2Vzbid0IHByb3ZpZGUgZGV0YWlscy5leHBlY3RlZFxuXHQgICAgLy8gd2hlbiBpdCBjYWxscywgaXQncyBpbXBsaWNpdCB0byBhbHNvIG5vdCBzaG93IGV4cGVjdGVkIGFuZCBkaWZmIHN0dWZmXG5cdCAgICAvLyBBbHNvLCB3ZSBuZWVkIHRvIGNoZWNrIGRldGFpbHMuZXhwZWN0ZWQgZXhpc3RlbmNlLCBhcyBpdCBjYW4gZXhpc3QgYW5kIGJlIHVuZGVmaW5lZFxuXG5cdCAgICBpZiAoIWRldGFpbHMucmVzdWx0ICYmIGhhc093bi5jYWxsKGRldGFpbHMsIFwiZXhwZWN0ZWRcIikpIHtcblx0ICAgICAgaWYgKGRldGFpbHMubmVnYXRpdmUpIHtcblx0ICAgICAgICBleHBlY3RlZCA9IFwiTk9UIFwiICsgUVVuaXQuZHVtcC5wYXJzZShkZXRhaWxzLmV4cGVjdGVkKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBleHBlY3RlZCA9IFFVbml0LmR1bXAucGFyc2UoZGV0YWlscy5leHBlY3RlZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBhY3R1YWwgPSBRVW5pdC5kdW1wLnBhcnNlKGRldGFpbHMuYWN0dWFsKTtcblx0ICAgICAgbWVzc2FnZSArPSBcIjx0YWJsZT48dHIgY2xhc3M9J3Rlc3QtZXhwZWN0ZWQnPjx0aD5FeHBlY3RlZDogPC90aD48dGQ+PHByZT5cIiArIGVzY2FwZVRleHQoZXhwZWN0ZWQpICsgXCI8L3ByZT48L3RkPjwvdHI+XCI7XG5cblx0ICAgICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcblx0ICAgICAgICBtZXNzYWdlICs9IFwiPHRyIGNsYXNzPSd0ZXN0LWFjdHVhbCc+PHRoPlJlc3VsdDogPC90aD48dGQ+PHByZT5cIiArIGVzY2FwZVRleHQoYWN0dWFsKSArIFwiPC9wcmU+PC90ZD48L3RyPlwiO1xuXG5cdCAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWxzLmFjdHVhbCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZGV0YWlscy5leHBlY3RlZCA9PT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgaWYgKCFpc05hTihkZXRhaWxzLmFjdHVhbCkgJiYgIWlzTmFOKGRldGFpbHMuZXhwZWN0ZWQpKSB7XG5cdCAgICAgICAgICAgIHNob3dEaWZmID0gdHJ1ZTtcblx0ICAgICAgICAgICAgZGlmZiA9IGRldGFpbHMuYWN0dWFsIC0gZGV0YWlscy5leHBlY3RlZDtcblx0ICAgICAgICAgICAgZGlmZiA9IChkaWZmID4gMCA/IFwiK1wiIDogXCJcIikgKyBkaWZmO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRldGFpbHMuYWN0dWFsICE9PSBcImJvb2xlYW5cIiAmJiB0eXBlb2YgZGV0YWlscy5leHBlY3RlZCAhPT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICAgIGRpZmYgPSBRVW5pdC5kaWZmKGV4cGVjdGVkLCBhY3R1YWwpOyAvLyBkb24ndCBzaG93IGRpZmYgaWYgdGhlcmUgaXMgemVybyBvdmVybGFwXG5cblx0ICAgICAgICAgIHNob3dEaWZmID0gc3RyaXBIdG1sKGRpZmYpLmxlbmd0aCAhPT0gc3RyaXBIdG1sKGV4cGVjdGVkKS5sZW5ndGggKyBzdHJpcEh0bWwoYWN0dWFsKS5sZW5ndGg7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHNob3dEaWZmKSB7XG5cdCAgICAgICAgICBtZXNzYWdlICs9IFwiPHRyIGNsYXNzPSd0ZXN0LWRpZmYnPjx0aD5EaWZmOiA8L3RoPjx0ZD48cHJlPlwiICsgZGlmZiArIFwiPC9wcmU+PC90ZD48L3RyPlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChleHBlY3RlZC5pbmRleE9mKFwiW29iamVjdCBBcnJheV1cIikgIT09IC0xIHx8IGV4cGVjdGVkLmluZGV4T2YoXCJbb2JqZWN0IE9iamVjdF1cIikgIT09IC0xKSB7XG5cdCAgICAgICAgbWVzc2FnZSArPSBcIjx0ciBjbGFzcz0ndGVzdC1tZXNzYWdlJz48dGg+TWVzc2FnZTogPC90aD48dGQ+XCIgKyBcIkRpZmYgc3VwcHJlc3NlZCBhcyB0aGUgZGVwdGggb2Ygb2JqZWN0IGlzIG1vcmUgdGhhbiBjdXJyZW50IG1heCBkZXB0aCAoXCIgKyBRVW5pdC5jb25maWcubWF4RGVwdGggKyBcIikuPHA+SGludDogVXNlIDxjb2RlPlFVbml0LmR1bXAubWF4RGVwdGg8L2NvZGU+IHRvIFwiICsgXCIgcnVuIHdpdGggYSBoaWdoZXIgbWF4IGRlcHRoIG9yIDxhIGhyZWY9J1wiICsgZXNjYXBlVGV4dChzZXRVcmwoe1xuXHQgICAgICAgICAgbWF4RGVwdGg6IC0xXG5cdCAgICAgICAgfSkpICsgXCInPlwiICsgXCJSZXJ1bjwvYT4gd2l0aG91dCBtYXggZGVwdGguPC9wPjwvdGQ+PC90cj5cIjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBtZXNzYWdlICs9IFwiPHRyIGNsYXNzPSd0ZXN0LW1lc3NhZ2UnPjx0aD5NZXNzYWdlOiA8L3RoPjx0ZD5cIiArIFwiRGlmZiBzdXBwcmVzc2VkIGFzIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIHJlc3VsdHMgaGF2ZSBhbiBlcXVpdmFsZW50XCIgKyBcIiBzZXJpYWxpemF0aW9uPC90ZD48L3RyPlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGRldGFpbHMuc291cmNlKSB7XG5cdCAgICAgICAgbWVzc2FnZSArPSBcIjx0ciBjbGFzcz0ndGVzdC1zb3VyY2UnPjx0aD5Tb3VyY2U6IDwvdGg+PHRkPjxwcmU+XCIgKyBlc2NhcGVUZXh0KGRldGFpbHMuc291cmNlKSArIFwiPC9wcmU+PC90ZD48L3RyPlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgbWVzc2FnZSArPSBcIjwvdGFibGU+XCI7IC8vIFRoaXMgb2NjdXJzIHdoZW4gcHVzaEZhaWx1cmUgaXMgc2V0IGFuZCB3ZSBoYXZlIGFuIGV4dHJhY3RlZCBzdGFjayB0cmFjZVxuXHQgICAgfSBlbHNlIGlmICghZGV0YWlscy5yZXN1bHQgJiYgZGV0YWlscy5zb3VyY2UpIHtcblx0ICAgICAgbWVzc2FnZSArPSBcIjx0YWJsZT5cIiArIFwiPHRyIGNsYXNzPSd0ZXN0LXNvdXJjZSc+PHRoPlNvdXJjZTogPC90aD48dGQ+PHByZT5cIiArIGVzY2FwZVRleHQoZGV0YWlscy5zb3VyY2UpICsgXCI8L3ByZT48L3RkPjwvdHI+XCIgKyBcIjwvdGFibGU+XCI7XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydExpc3QgPSB0ZXN0SXRlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm9sXCIpWzBdO1xuXHQgICAgYXNzZXJ0TGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG5cdCAgICBhc3NlcnRMaS5jbGFzc05hbWUgPSBkZXRhaWxzLnJlc3VsdCA/IFwicGFzc1wiIDogXCJmYWlsXCI7XG5cdCAgICBhc3NlcnRMaS5pbm5lckhUTUwgPSBtZXNzYWdlO1xuXHQgICAgYXNzZXJ0TGlzdC5hcHBlbmRDaGlsZChhc3NlcnRMaSk7XG5cdCAgfSk7XG5cdCAgUVVuaXQudGVzdERvbmUoZnVuY3Rpb24gKGRldGFpbHMpIHtcblx0ICAgIHZhciB0ZXN0VGl0bGUsXG5cdCAgICAgICAgdGltZSxcblx0ICAgICAgICB0ZXN0SXRlbSxcblx0ICAgICAgICBhc3NlcnRMaXN0LFxuXHQgICAgICAgIHN0YXR1cyxcblx0ICAgICAgICBnb29kLFxuXHQgICAgICAgIGJhZCxcblx0ICAgICAgICB0ZXN0Q291bnRzLFxuXHQgICAgICAgIHNraXBwZWQsXG5cdCAgICAgICAgc291cmNlTmFtZSxcblx0ICAgICAgICB0ZXN0cyA9IGlkKFwicXVuaXQtdGVzdHNcIik7XG5cblx0ICAgIGlmICghdGVzdHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB0ZXN0SXRlbSA9IGlkKFwicXVuaXQtdGVzdC1vdXRwdXQtXCIgKyBkZXRhaWxzLnRlc3RJZCk7XG5cdCAgICByZW1vdmVDbGFzcyh0ZXN0SXRlbSwgXCJydW5uaW5nXCIpO1xuXG5cdCAgICBpZiAoZGV0YWlscy5mYWlsZWQgPiAwKSB7XG5cdCAgICAgIHN0YXR1cyA9IFwiZmFpbGVkXCI7XG5cdCAgICB9IGVsc2UgaWYgKGRldGFpbHMudG9kbykge1xuXHQgICAgICBzdGF0dXMgPSBcInRvZG9cIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0YXR1cyA9IGRldGFpbHMuc2tpcHBlZCA/IFwic2tpcHBlZFwiIDogXCJwYXNzZWRcIjtcblx0ICAgIH1cblxuXHQgICAgYXNzZXJ0TGlzdCA9IHRlc3RJdGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwib2xcIilbMF07XG5cdCAgICBnb29kID0gZGV0YWlscy5wYXNzZWQ7XG5cdCAgICBiYWQgPSBkZXRhaWxzLmZhaWxlZDsgLy8gVGhpcyB0ZXN0IHBhc3NlZCBpZiBpdCBoYXMgbm8gdW5leHBlY3RlZCBmYWlsZWQgYXNzZXJ0aW9uc1xuXG5cdCAgICB2YXIgdGVzdFBhc3NlZCA9IGRldGFpbHMuZmFpbGVkID4gMCA/IGRldGFpbHMudG9kbyA6ICFkZXRhaWxzLnRvZG87XG5cblx0ICAgIGlmICh0ZXN0UGFzc2VkKSB7XG5cdCAgICAgIC8vIENvbGxhcHNlIHRoZSBwYXNzaW5nIHRlc3RzXG5cdCAgICAgIGFkZENsYXNzKGFzc2VydExpc3QsIFwicXVuaXQtY29sbGFwc2VkXCIpO1xuXHQgICAgfSBlbHNlIGlmIChjb25maWcuY29sbGFwc2UpIHtcblx0ICAgICAgaWYgKCFjb2xsYXBzZU5leHQpIHtcblx0ICAgICAgICAvLyBTa2lwIGNvbGxhcHNpbmcgdGhlIGZpcnN0IGZhaWxpbmcgdGVzdFxuXHQgICAgICAgIGNvbGxhcHNlTmV4dCA9IHRydWU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gQ29sbGFwc2UgcmVtYWluaW5nIHRlc3RzXG5cdCAgICAgICAgYWRkQ2xhc3MoYXNzZXJ0TGlzdCwgXCJxdW5pdC1jb2xsYXBzZWRcIik7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gVGhlIHRlc3RJdGVtLmZpcnN0Q2hpbGQgaXMgdGhlIHRlc3QgbmFtZVxuXG5cblx0ICAgIHRlc3RUaXRsZSA9IHRlc3RJdGVtLmZpcnN0Q2hpbGQ7XG5cdCAgICB0ZXN0Q291bnRzID0gYmFkID8gXCI8YiBjbGFzcz0nZmFpbGVkJz5cIiArIGJhZCArIFwiPC9iPiwgXCIgKyBcIjxiIGNsYXNzPSdwYXNzZWQnPlwiICsgZ29vZCArIFwiPC9iPiwgXCIgOiBcIlwiO1xuXHQgICAgdGVzdFRpdGxlLmlubmVySFRNTCArPSBcIiA8YiBjbGFzcz0nY291bnRzJz4oXCIgKyB0ZXN0Q291bnRzICsgZGV0YWlscy5hc3NlcnRpb25zLmxlbmd0aCArIFwiKTwvYj5cIjtcblxuXHQgICAgaWYgKGRldGFpbHMuc2tpcHBlZCkge1xuXHQgICAgICBzdGF0cy5za2lwcGVkVGVzdHMrKztcblx0ICAgICAgdGVzdEl0ZW0uY2xhc3NOYW1lID0gXCJza2lwcGVkXCI7XG5cdCAgICAgIHNraXBwZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZW1cIik7XG5cdCAgICAgIHNraXBwZWQuY2xhc3NOYW1lID0gXCJxdW5pdC1za2lwcGVkLWxhYmVsXCI7XG5cdCAgICAgIHNraXBwZWQuaW5uZXJIVE1MID0gXCJza2lwcGVkXCI7XG5cdCAgICAgIHRlc3RJdGVtLmluc2VydEJlZm9yZShza2lwcGVkLCB0ZXN0VGl0bGUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYWRkRXZlbnQodGVzdFRpdGxlLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0b2dnbGVDbGFzcyhhc3NlcnRMaXN0LCBcInF1bml0LWNvbGxhcHNlZFwiKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRlc3RJdGVtLmNsYXNzTmFtZSA9IHRlc3RQYXNzZWQgPyBcInBhc3NcIiA6IFwiZmFpbFwiO1xuXG5cdCAgICAgIGlmIChkZXRhaWxzLnRvZG8pIHtcblx0ICAgICAgICB2YXIgdG9kb0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImVtXCIpO1xuXHQgICAgICAgIHRvZG9MYWJlbC5jbGFzc05hbWUgPSBcInF1bml0LXRvZG8tbGFiZWxcIjtcblx0ICAgICAgICB0b2RvTGFiZWwuaW5uZXJIVE1MID0gXCJ0b2RvXCI7XG5cdCAgICAgICAgdGVzdEl0ZW0uY2xhc3NOYW1lICs9IFwiIHRvZG9cIjtcblx0ICAgICAgICB0ZXN0SXRlbS5pbnNlcnRCZWZvcmUodG9kb0xhYmVsLCB0ZXN0VGl0bGUpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXHQgICAgICB0aW1lLmNsYXNzTmFtZSA9IFwicnVudGltZVwiO1xuXHQgICAgICB0aW1lLmlubmVySFRNTCA9IGRldGFpbHMucnVudGltZSArIFwiIG1zXCI7XG5cdCAgICAgIHRlc3RJdGVtLmluc2VydEJlZm9yZSh0aW1lLCBhc3NlcnRMaXN0KTtcblxuXHQgICAgICBpZiAoIXRlc3RQYXNzZWQpIHtcblx0ICAgICAgICBzdGF0cy5mYWlsZWRUZXN0cysrO1xuXHQgICAgICB9IGVsc2UgaWYgKGRldGFpbHMudG9kbykge1xuXHQgICAgICAgIHN0YXRzLnRvZG9UZXN0cysrO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0YXRzLnBhc3NlZFRlc3RzKys7XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gU2hvdyB0aGUgc291cmNlIG9mIHRoZSB0ZXN0IHdoZW4gc2hvd2luZyBhc3NlcnRpb25zXG5cblxuXHQgICAgaWYgKGRldGFpbHMuc291cmNlKSB7XG5cdCAgICAgIHNvdXJjZU5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcblx0ICAgICAgc291cmNlTmFtZS5pbm5lckhUTUwgPSBcIjxzdHJvbmc+U291cmNlOiA8L3N0cm9uZz5cIiArIGVzY2FwZVRleHQoZGV0YWlscy5zb3VyY2UpO1xuXHQgICAgICBhZGRDbGFzcyhzb3VyY2VOYW1lLCBcInF1bml0LXNvdXJjZVwiKTtcblxuXHQgICAgICBpZiAodGVzdFBhc3NlZCkge1xuXHQgICAgICAgIGFkZENsYXNzKHNvdXJjZU5hbWUsIFwicXVuaXQtY29sbGFwc2VkXCIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgYWRkRXZlbnQodGVzdFRpdGxlLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0b2dnbGVDbGFzcyhzb3VyY2VOYW1lLCBcInF1bml0LWNvbGxhcHNlZFwiKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRlc3RJdGVtLmFwcGVuZENoaWxkKHNvdXJjZU5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29uZmlnLmhpZGVwYXNzZWQgJiYgKHN0YXR1cyA9PT0gXCJwYXNzZWRcIiB8fCBkZXRhaWxzLnNraXBwZWQpKSB7XG5cdCAgICAgIC8vIHVzZSByZW1vdmVDaGlsZCBpbnN0ZWFkIG9mIHJlbW92ZSBiZWNhdXNlIG9mIHN1cHBvcnRcblx0ICAgICAgaGlkZGVuVGVzdHMucHVzaCh0ZXN0SXRlbSk7XG5cdCAgICAgIHRlc3RzLnJlbW92ZUNoaWxkKHRlc3RJdGVtKTtcblx0ICAgIH1cblx0ICB9KTsgLy8gQXZvaWQgcmVhZHlTdGF0ZSBpc3N1ZSB3aXRoIHBoYW50b21qc1xuXHQgIC8vIFJlZjogIzgxOFxuXG5cdCAgdmFyIG5vdFBoYW50b20gPSBmdW5jdGlvbiAocCkge1xuXHQgICAgcmV0dXJuICEocCAmJiBwLnZlcnNpb24gJiYgcC52ZXJzaW9uLm1ham9yID4gMCk7XG5cdCAgfSh3aW5kb3ckMS5waGFudG9tKTtcblxuXHQgIGlmIChub3RQaGFudG9tICYmIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuXHQgICAgUVVuaXQubG9hZCgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBhZGRFdmVudCh3aW5kb3ckMSwgXCJsb2FkXCIsIFFVbml0LmxvYWQpO1xuXHQgIH0gLy8gV3JhcCB3aW5kb3cub25lcnJvci4gV2Ugd2lsbCBjYWxsIHRoZSBvcmlnaW5hbCB3aW5kb3cub25lcnJvciB0byBzZWUgaWZcblx0ICAvLyB0aGUgZXhpc3RpbmcgaGFuZGxlciBmdWxseSBoYW5kbGVzIHRoZSBlcnJvcjsgaWYgbm90LCB3ZSB3aWxsIGNhbGwgdGhlXG5cdCAgLy8gUVVuaXQub25FcnJvciBmdW5jdGlvbi5cblxuXG5cdCAgdmFyIG9yaWdpbmFsV2luZG93T25FcnJvciA9IHdpbmRvdyQxLm9uZXJyb3I7IC8vIENvdmVyIHVuY2F1Z2h0IGV4Y2VwdGlvbnNcblx0ICAvLyBSZXR1cm5pbmcgdHJ1ZSB3aWxsIHN1cHByZXNzIHRoZSBkZWZhdWx0IGJyb3dzZXIgaGFuZGxlcixcblx0ICAvLyByZXR1cm5pbmcgZmFsc2Ugd2lsbCBsZXQgaXQgcnVuLlxuXG5cdCAgd2luZG93JDEub25lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBmaWxlTmFtZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyLCBlcnJvck9iaikge1xuXHQgICAgdmFyIHJldCA9IGZhbHNlO1xuXG5cdCAgICBpZiAob3JpZ2luYWxXaW5kb3dPbkVycm9yKSB7XG5cdCAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiA1ID8gX2xlbiAtIDUgOiAwKSwgX2tleSA9IDU7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgICBhcmdzW19rZXkgLSA1XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldCA9IG9yaWdpbmFsV2luZG93T25FcnJvci5jYWxsLmFwcGx5KG9yaWdpbmFsV2luZG93T25FcnJvciwgW3RoaXMsIG1lc3NhZ2UsIGZpbGVOYW1lLCBsaW5lTnVtYmVyLCBjb2x1bW5OdW1iZXIsIGVycm9yT2JqXS5jb25jYXQoYXJncykpO1xuXHQgICAgfSAvLyBUcmVhdCByZXR1cm4gdmFsdWUgYXMgd2luZG93Lm9uZXJyb3IgaXRzZWxmIGRvZXMsXG5cdCAgICAvLyBPbmx5IGRvIG91ciBoYW5kbGluZyBpZiBub3Qgc3VwcHJlc3NlZC5cblxuXG5cdCAgICBpZiAocmV0ICE9PSB0cnVlKSB7XG5cdCAgICAgIHZhciBlcnJvciA9IHtcblx0ICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuXHQgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcblx0ICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyXG5cdCAgICAgIH07IC8vIEFjY29yZGluZyB0b1xuXHQgICAgICAvLyBodHRwczovL2Jsb2cuc2VudHJ5LmlvLzIwMTYvMDEvMDQvY2xpZW50LWphdmFzY3JpcHQtcmVwb3J0aW5nLXdpbmRvdy1vbmVycm9yLFxuXHQgICAgICAvLyBtb3N0IG1vZGVybiBicm93c2VycyBzdXBwb3J0IGFuIGVycm9yT2JqIGFyZ3VtZW50OyB1c2UgdGhhdCB0b1xuXHQgICAgICAvLyBnZXQgYSBmdWxsIHN0YWNrIHRyYWNlIGlmIGl0J3MgYXZhaWxhYmxlLlxuXG5cdCAgICAgIGlmIChlcnJvck9iaiAmJiBlcnJvck9iai5zdGFjaykge1xuXHQgICAgICAgIGVycm9yLnN0YWNrdHJhY2UgPSBleHRyYWN0U3RhY2t0cmFjZShlcnJvck9iaiwgMCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXQgPSBRVW5pdC5vbkVycm9yKGVycm9yKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9OyAvLyBMaXN0ZW4gZm9yIHVuaGFuZGxlZCByZWplY3Rpb25zLCBhbmQgY2FsbCBRVW5pdC5vblVuaGFuZGxlZFJlamVjdGlvblxuXG5cblx0ICB3aW5kb3ckMS5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgUVVuaXQub25VbmhhbmRsZWRSZWplY3Rpb24oZXZlbnQucmVhc29uKTtcblx0ICB9KTtcblx0fSkoKTtcblxuXHQvKlxuXHQgKiBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGdvb2dsZS1kaWZmLW1hdGNoLXBhdGNoJ3MgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuXHQgKiAoaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9zb3VyY2UvYnJvd3NlL3RydW5rL2phdmFzY3JpcHQvZGlmZl9tYXRjaF9wYXRjaF91bmNvbXByZXNzZWQuanMpLFxuXHQgKiBtb2RpZmljYXRpb25zIGFyZSBsaWNlbnNlZCBhcyBtb3JlIGZ1bGx5IHNldCBmb3J0aCBpbiBMSUNFTlNFLnR4dC5cblx0ICpcblx0ICogVGhlIG9yaWdpbmFsIHNvdXJjZSBvZiBnb29nbGUtZGlmZi1tYXRjaC1wYXRjaCBpcyBhdHRyaWJ1dGFibGUgYW5kIGxpY2Vuc2VkIGFzIGZvbGxvd3M6XG5cdCAqXG5cdCAqIENvcHlyaWdodCAyMDA2IEdvb2dsZSBJbmMuXG5cdCAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvXG5cdCAqXG5cdCAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG5cdCAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cblx0ICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cdCAqXG5cdCAqIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblx0ICpcblx0ICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuXHQgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5cdCAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuXHQgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5cdCAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXHQgKlxuXHQgKiBNb3JlIEluZm86XG5cdCAqICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL1xuXHQgKlxuXHQgKiBVc2FnZTogUVVuaXQuZGlmZihleHBlY3RlZCwgYWN0dWFsKVxuXHQgKlxuXHQgKi9cblxuXHRRVW5pdC5kaWZmID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIERpZmZNYXRjaFBhdGNoKCkge30gLy8gIERJRkYgRlVOQ1RJT05TXG5cblx0ICAvKipcblx0ICAgKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XG5cdCAgICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG5cdCAgICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuXHQgICAqL1xuXG5cblx0ICB2YXIgRElGRl9ERUxFVEUgPSAtMSxcblx0ICAgICAgRElGRl9JTlNFUlQgPSAxLFxuXHQgICAgICBESUZGX0VRVUFMID0gMCxcblx0ICAgICAgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0ICAvKipcblx0ICAgKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIFNpbXBsaWZpZXMgdGhlIHByb2JsZW0gYnkgc3RyaXBwaW5nXG5cdCAgICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cblx0ICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRDaGVja2xpbmVzIE9wdGlvbmFsIHNwZWVkdXAgZmxhZy4gSWYgcHJlc2VudCBhbmQgZmFsc2UsXG5cdCAgICogICAgIHRoZW4gZG9uJ3QgcnVuIGEgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuXHQgICAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cblx0ICAgKiBAcmV0dXJuIHshQXJyYXkuPCFEaWZmTWF0Y2hQYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG5cdCAgICovXG5cblx0ICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuRGlmZk1haW4gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBvcHRDaGVja2xpbmVzKSB7XG5cdCAgICB2YXIgZGVhZGxpbmUsIGNoZWNrbGluZXMsIGNvbW1vbmxlbmd0aCwgY29tbW9ucHJlZml4LCBjb21tb25zdWZmaXgsIGRpZmZzOyAvLyBUaGUgZGlmZiBtdXN0IGJlIGNvbXBsZXRlIGluIHVwIHRvIDEgc2Vjb25kLlxuXG5cdCAgICBkZWFkbGluZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgMTAwMDsgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxuXG5cdCAgICBpZiAodGV4dDEgPT09IG51bGwgfHwgdGV4dDIgPT09IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKERpZmZNYWluKVwiKTtcblx0ICAgIH0gLy8gQ2hlY2sgZm9yIGVxdWFsaXR5IChzcGVlZHVwKS5cblxuXG5cdCAgICBpZiAodGV4dDEgPT09IHRleHQyKSB7XG5cdCAgICAgIGlmICh0ZXh0MSkge1xuXHQgICAgICAgIHJldHVybiBbW0RJRkZfRVFVQUwsIHRleHQxXV07XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gW107XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2Ygb3B0Q2hlY2tsaW5lcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICBvcHRDaGVja2xpbmVzID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgY2hlY2tsaW5lcyA9IG9wdENoZWNrbGluZXM7IC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxuXG5cdCAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcblx0ICAgIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuXHQgICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcblx0ICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7IC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuXG5cdCAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcblx0ICAgIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuXHQgICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblx0ICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7IC8vIENvbXB1dGUgdGhlIGRpZmYgb24gdGhlIG1pZGRsZSBibG9jay5cblxuXHQgICAgZGlmZnMgPSB0aGlzLmRpZmZDb21wdXRlKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcywgZGVhZGxpbmUpOyAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cblxuXHQgICAgaWYgKGNvbW1vbnByZWZpeCkge1xuXHQgICAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbW1vbnN1ZmZpeCkge1xuXHQgICAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5kaWZmQ2xlYW51cE1lcmdlKGRpZmZzKTtcblx0ICAgIHJldHVybiBkaWZmcztcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGVkaXRzIGJ5IGVsaW1pbmF0aW5nIG9wZXJhdGlvbmFsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuXHQgICAqIEBwYXJhbSB7IUFycmF5LjwhRGlmZk1hdGNoUGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuXHQgICAqL1xuXG5cblx0ICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZkNsZWFudXBFZmZpY2llbmN5ID0gZnVuY3Rpb24gKGRpZmZzKSB7XG5cdCAgICB2YXIgY2hhbmdlcywgZXF1YWxpdGllcywgZXF1YWxpdGllc0xlbmd0aCwgbGFzdGVxdWFsaXR5LCBwb2ludGVyLCBwcmVJbnMsIHByZURlbCwgcG9zdElucywgcG9zdERlbDtcblx0ICAgIGNoYW5nZXMgPSBmYWxzZTtcblx0ICAgIGVxdWFsaXRpZXMgPSBbXTsgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cblxuXHQgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7IC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cblxuXHQgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuXG5cdCAgICBsYXN0ZXF1YWxpdHkgPSBudWxsOyAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXG5cblx0ICAgIHBvaW50ZXIgPSAwOyAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuXHQgICAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG5cblx0ICAgIHByZUlucyA9IGZhbHNlOyAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG5cblx0ICAgIHByZURlbCA9IGZhbHNlOyAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuXG5cdCAgICBwb3N0SW5zID0gZmFsc2U7IC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxuXG5cdCAgICBwb3N0RGVsID0gZmFsc2U7XG5cblx0ICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG5cdCAgICAgIC8vIEVxdWFsaXR5IGZvdW5kLlxuXHQgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwpIHtcblx0ICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgNCAmJiAocG9zdElucyB8fCBwb3N0RGVsKSkge1xuXHQgICAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxuXHQgICAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcblx0ICAgICAgICAgIHByZUlucyA9IHBvc3RJbnM7XG5cdCAgICAgICAgICBwcmVEZWwgPSBwb3N0RGVsO1xuXHQgICAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIE5vdCBhIGNhbmRpZGF0ZSwgYW5kIGNhbiBuZXZlciBiZWNvbWUgb25lLlxuXHQgICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG5cdCAgICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBvc3RJbnMgPSBwb3N0RGVsID0gZmFsc2U7IC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfREVMRVRFKSB7XG5cdCAgICAgICAgICBwb3N0RGVsID0gdHJ1ZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcG9zdElucyA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qXG5cdCAgICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcblx0ICAgICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuXHQgICAgICAgICAqIDxpbnM+QTwvaW5zPlg8aW5zPkM8L2lucz48ZGVsPkQ8L2RlbD5cblx0ICAgICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XG5cdCAgICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxuXHQgICAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlg8ZGVsPkM8L2RlbD5cblx0ICAgICAgICAgKi9cblxuXG5cdCAgICAgICAgaWYgKGxhc3RlcXVhbGl0eSAmJiAocHJlSW5zICYmIHByZURlbCAmJiBwb3N0SW5zICYmIHBvc3REZWwgfHwgbGFzdGVxdWFsaXR5Lmxlbmd0aCA8IDIgJiYgcHJlSW5zICsgcHJlRGVsICsgcG9zdElucyArIHBvc3REZWwgPT09IDMpKSB7XG5cdCAgICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuXHQgICAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pOyAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuXG5cdCAgICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XG5cdCAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07IC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZDtcblxuXHQgICAgICAgICAgbGFzdGVxdWFsaXR5ID0gbnVsbDtcblxuXHQgICAgICAgICAgaWYgKHByZUlucyAmJiBwcmVEZWwpIHtcblx0ICAgICAgICAgICAgLy8gTm8gY2hhbmdlcyBtYWRlIHdoaWNoIGNvdWxkIGFmZmVjdCBwcmV2aW91cyBlbnRyeSwga2VlcCBnb2luZy5cblx0ICAgICAgICAgICAgcG9zdElucyA9IHBvc3REZWwgPSB0cnVlO1xuXHQgICAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXG5cblx0ICAgICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcblx0ICAgICAgICAgICAgcG9zdElucyA9IHBvc3REZWwgPSBmYWxzZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcG9pbnRlcisrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2hhbmdlcykge1xuXHQgICAgICB0aGlzLmRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLyoqXG5cdCAgICogQ29udmVydCBhIGRpZmYgYXJyYXkgaW50byBhIHByZXR0eSBIVE1MIHJlcG9ydC5cblx0ICAgKiBAcGFyYW0geyFBcnJheS48IURpZmZNYXRjaFBhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cblx0ICAgKiBAcGFyYW0ge2ludGVnZXJ9IHN0cmluZyB0byBiZSBiZWF1dGlmaWVkLlxuXHQgICAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cblx0ICAgKi9cblxuXG5cdCAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZQcmV0dHlIdG1sID0gZnVuY3Rpb24gKGRpZmZzKSB7XG5cdCAgICB2YXIgb3AsXG5cdCAgICAgICAgZGF0YSxcblx0ICAgICAgICB4LFxuXHQgICAgICAgIGh0bWwgPSBbXTtcblxuXHQgICAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG5cdCAgICAgIG9wID0gZGlmZnNbeF1bMF07IC8vIE9wZXJhdGlvbiAoaW5zZXJ0LCBkZWxldGUsIGVxdWFsKVxuXG5cdCAgICAgIGRhdGEgPSBkaWZmc1t4XVsxXTsgLy8gVGV4dCBvZiBjaGFuZ2UuXG5cblx0ICAgICAgc3dpdGNoIChvcCkge1xuXHQgICAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG5cdCAgICAgICAgICBodG1sW3hdID0gXCI8aW5zPlwiICsgZXNjYXBlVGV4dChkYXRhKSArIFwiPC9pbnM+XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG5cdCAgICAgICAgICBodG1sW3hdID0gXCI8ZGVsPlwiICsgZXNjYXBlVGV4dChkYXRhKSArIFwiPC9kZWw+XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgRElGRl9FUVVBTDpcblx0ICAgICAgICAgIGh0bWxbeF0gPSBcIjxzcGFuPlwiICsgZXNjYXBlVGV4dChkYXRhKSArIFwiPC9zcGFuPlwiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGh0bWwuam9pbihcIlwiKTtcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuXHQgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxuXHQgICAqICAgICBzdHJpbmcuXG5cdCAgICovXG5cblxuXHQgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmQ29tbW9uUHJlZml4ID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuXHQgICAgdmFyIHBvaW50ZXJtaWQsIHBvaW50ZXJtYXgsIHBvaW50ZXJtaW4sIHBvaW50ZXJzdGFydDsgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuXG5cdCAgICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT09IHRleHQyLmNoYXJBdCgwKSkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH0gLy8gQmluYXJ5IHNlYXJjaC5cblx0ICAgIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuXG5cblx0ICAgIHBvaW50ZXJtaW4gPSAwO1xuXHQgICAgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcblx0ICAgIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuXHQgICAgcG9pbnRlcnN0YXJ0ID0gMDtcblxuXHQgICAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG5cdCAgICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkpIHtcblx0ICAgICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcblx0ICAgICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuXHQgICAgICB9XG5cblx0ICAgICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBvaW50ZXJtaWQ7XG5cdCAgfTtcblx0ICAvKipcblx0ICAgKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cblx0ICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cblx0ICAgKi9cblxuXG5cdCAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZDb21tb25TdWZmaXggPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG5cdCAgICB2YXIgcG9pbnRlcm1pZCwgcG9pbnRlcm1heCwgcG9pbnRlcm1pbiwgcG9pbnRlcmVuZDsgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuXG5cdCAgICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0gMSkgIT09IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuXHQgICAgICByZXR1cm4gMDtcblx0ICAgIH0gLy8gQmluYXJ5IHNlYXJjaC5cblx0ICAgIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuXG5cblx0ICAgIHBvaW50ZXJtaW4gPSAwO1xuXHQgICAgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcblx0ICAgIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuXHQgICAgcG9pbnRlcmVuZCA9IDA7XG5cblx0ICAgIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xuXHQgICAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09PSB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcblx0ICAgICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcblx0ICAgICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwb2ludGVybWlkO1xuXHQgIH07XG5cdCAgLyoqXG5cdCAgICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxuXHQgICAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG5cdCAgICogQHBhcmFtIHtib29sZWFufSBjaGVja2xpbmVzIFNwZWVkdXAgZmxhZy4gIElmIGZhbHNlLCB0aGVuIGRvbid0IHJ1biBhXG5cdCAgICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cblx0ICAgKiAgICAgSWYgdHJ1ZSwgdGhlbiBydW4gYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlIGJ5LlxuXHQgICAqIEByZXR1cm4geyFBcnJheS48IURpZmZNYXRjaFBhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXG5cblx0ICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZkNvbXB1dGUgPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBjaGVja2xpbmVzLCBkZWFkbGluZSkge1xuXHQgICAgdmFyIGRpZmZzLCBsb25ndGV4dCwgc2hvcnR0ZXh0LCBpLCBobSwgdGV4dDFBLCB0ZXh0MkEsIHRleHQxQiwgdGV4dDJCLCBtaWRDb21tb24sIGRpZmZzQSwgZGlmZnNCO1xuXG5cdCAgICBpZiAoIXRleHQxKSB7XG5cdCAgICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG5cdCAgICAgIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRleHQyKSB7XG5cdCAgICAgIC8vIEp1c3QgZGVsZXRlIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG5cdCAgICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xuXHQgICAgfVxuXG5cdCAgICBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG5cdCAgICBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuXHQgICAgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcblxuXHQgICAgaWYgKGkgIT09IC0xKSB7XG5cdCAgICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cblx0ICAgICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLCBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSwgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV07IC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXG5cblx0ICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuXHQgICAgICAgIGRpZmZzWzBdWzBdID0gZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBkaWZmcztcblx0ICAgIH1cblxuXHQgICAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXG5cdCAgICAgIC8vIEFmdGVyIHRoZSBwcmV2aW91cyBzcGVlZHVwLCB0aGUgY2hhcmFjdGVyIGNhbid0IGJlIGFuIGVxdWFsaXR5LlxuXHQgICAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG5cdCAgICB9IC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxuXG5cblx0ICAgIGhtID0gdGhpcy5kaWZmSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG5cblx0ICAgIGlmIChobSkge1xuXHQgICAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG5cdCAgICAgIHRleHQxQSA9IGhtWzBdO1xuXHQgICAgICB0ZXh0MUIgPSBobVsxXTtcblx0ICAgICAgdGV4dDJBID0gaG1bMl07XG5cdCAgICAgIHRleHQyQiA9IGhtWzNdO1xuXHQgICAgICBtaWRDb21tb24gPSBobVs0XTsgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cblxuXHQgICAgICBkaWZmc0EgPSB0aGlzLkRpZmZNYWluKHRleHQxQSwgdGV4dDJBLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG5cdCAgICAgIGRpZmZzQiA9IHRoaXMuRGlmZk1haW4odGV4dDFCLCB0ZXh0MkIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTsgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG5cblx0ICAgICAgcmV0dXJuIGRpZmZzQS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRDb21tb25dXSwgZGlmZnNCKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNoZWNrbGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5kaWZmTGluZU1vZGUodGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLmRpZmZCaXNlY3QodGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XG5cdCAgfTtcblx0ICAvKipcblx0ICAgKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcblx0ICAgKiBsb25nZXIgdGV4dD9cblx0ICAgKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cblx0ICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2Zcblx0ICAgKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2Zcblx0ICAgKiAgICAgdGV4dDIgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG5cdCAgICogQHByaXZhdGVcblx0ICAgKi9cblxuXG5cdCAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZIYWxmTWF0Y2ggPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG5cdCAgICB2YXIgbG9uZ3RleHQsIHNob3J0dGV4dCwgZG1wLCB0ZXh0MUEsIHRleHQyQiwgdGV4dDJBLCB0ZXh0MUIsIG1pZENvbW1vbiwgaG0xLCBobTIsIGhtO1xuXHQgICAgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuXHQgICAgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcblxuXHQgICAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIG51bGw7IC8vIFBvaW50bGVzcy5cblx0ICAgIH1cblxuXHQgICAgZG1wID0gdGhpczsgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxuXG5cdCAgICAvKipcblx0ICAgICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xuXHQgICAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xuXHQgICAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGxvbmd0ZXh0IExvbmdlciBzdHJpbmcuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGkgU3RhcnQgaW5kZXggb2YgcXVhcnRlciBsZW5ndGggc3Vic3RyaW5nIHdpdGhpbiBsb25ndGV4dC5cblx0ICAgICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuXHQgICAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuXHQgICAgICogICAgIG9mIHNob3J0dGV4dCBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblxuXHQgICAgZnVuY3Rpb24gZGlmZkhhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xuXHQgICAgICB2YXIgc2VlZCwgaiwgYmVzdENvbW1vbiwgcHJlZml4TGVuZ3RoLCBzdWZmaXhMZW5ndGgsIGJlc3RMb25ndGV4dEEsIGJlc3RMb25ndGV4dEIsIGJlc3RTaG9ydHRleHRBLCBiZXN0U2hvcnR0ZXh0QjsgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuXG5cdCAgICAgIHNlZWQgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSwgaSArIE1hdGguZmxvb3IobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuXHQgICAgICBqID0gLTE7XG5cdCAgICAgIGJlc3RDb21tb24gPSBcIlwiO1xuXG5cdCAgICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT09IC0xKSB7XG5cdCAgICAgICAgcHJlZml4TGVuZ3RoID0gZG1wLmRpZmZDb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLCBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcblx0ICAgICAgICBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZkNvbW1vblN1ZmZpeChsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSksIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xuXG5cdCAgICAgICAgaWYgKGJlc3RDb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XG5cdCAgICAgICAgICBiZXN0Q29tbW9uID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqIC0gc3VmZml4TGVuZ3RoLCBqKSArIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG5cdCAgICAgICAgICBiZXN0TG9uZ3RleHRBID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xuXHQgICAgICAgICAgYmVzdExvbmd0ZXh0QiA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcblx0ICAgICAgICAgIGJlc3RTaG9ydHRleHRBID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcblx0ICAgICAgICAgIGJlc3RTaG9ydHRleHRCID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoYmVzdENvbW1vbi5sZW5ndGggKiAyID49IGxvbmd0ZXh0Lmxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBbYmVzdExvbmd0ZXh0QSwgYmVzdExvbmd0ZXh0QiwgYmVzdFNob3J0dGV4dEEsIGJlc3RTaG9ydHRleHRCLCBiZXN0Q29tbW9uXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cblxuXG5cdCAgICBobTEgPSBkaWZmSGFsZk1hdGNoSShsb25ndGV4dCwgc2hvcnR0ZXh0LCBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gNCkpOyAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cblxuXHQgICAgaG0yID0gZGlmZkhhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcblxuXHQgICAgaWYgKCFobTEgJiYgIWhtMikge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH0gZWxzZSBpZiAoIWhtMikge1xuXHQgICAgICBobSA9IGhtMTtcblx0ICAgIH0gZWxzZSBpZiAoIWhtMSkge1xuXHQgICAgICBobSA9IGhtMjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cblx0ICAgICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcblx0ICAgIH0gLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuXG5cblx0ICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcblx0ICAgICAgdGV4dDFBID0gaG1bMF07XG5cdCAgICAgIHRleHQxQiA9IGhtWzFdO1xuXHQgICAgICB0ZXh0MkEgPSBobVsyXTtcblx0ICAgICAgdGV4dDJCID0gaG1bM107XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0ZXh0MkEgPSBobVswXTtcblx0ICAgICAgdGV4dDJCID0gaG1bMV07XG5cdCAgICAgIHRleHQxQSA9IGhtWzJdO1xuXHQgICAgICB0ZXh0MUIgPSBobVszXTtcblx0ICAgIH1cblxuXHQgICAgbWlkQ29tbW9uID0gaG1bNF07XG5cdCAgICByZXR1cm4gW3RleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQiwgbWlkQ29tbW9uXTtcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIERvIGEgcXVpY2sgbGluZS1sZXZlbCBkaWZmIG9uIGJvdGggc3RyaW5ncywgdGhlbiByZWRpZmYgdGhlIHBhcnRzIGZvclxuXHQgICAqIGdyZWF0ZXIgYWNjdXJhY3kuXG5cdCAgICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXG5cdCAgICogQHJldHVybiB7IUFycmF5LjwhRGlmZk1hdGNoUGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cblxuXHQgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmTGluZU1vZGUgPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xuXHQgICAgdmFyIGEsIGRpZmZzLCBsaW5lYXJyYXksIHBvaW50ZXIsIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSwgdGV4dEluc2VydCwgdGV4dERlbGV0ZSwgajsgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cblxuXHQgICAgYSA9IHRoaXMuZGlmZkxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuXHQgICAgdGV4dDEgPSBhLmNoYXJzMTtcblx0ICAgIHRleHQyID0gYS5jaGFyczI7XG5cdCAgICBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcblx0ICAgIGRpZmZzID0gdGhpcy5EaWZmTWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlLCBkZWFkbGluZSk7IC8vIENvbnZlcnQgdGhlIGRpZmYgYmFjayB0byBvcmlnaW5hbCB0ZXh0LlxuXG5cdCAgICB0aGlzLmRpZmZDaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSk7IC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxuXG5cdCAgICB0aGlzLmRpZmZDbGVhbnVwU2VtYW50aWMoZGlmZnMpOyAvLyBSZWRpZmYgYW55IHJlcGxhY2VtZW50IGJsb2NrcywgdGhpcyB0aW1lIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXG5cdCAgICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuXG5cdCAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG5cdCAgICBwb2ludGVyID0gMDtcblx0ICAgIGNvdW50RGVsZXRlID0gMDtcblx0ICAgIGNvdW50SW5zZXJ0ID0gMDtcblx0ICAgIHRleHREZWxldGUgPSBcIlwiO1xuXHQgICAgdGV4dEluc2VydCA9IFwiXCI7XG5cblx0ICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG5cdCAgICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcblx0ICAgICAgICBjYXNlIERJRkZfSU5TRVJUOlxuXHQgICAgICAgICAgY291bnRJbnNlcnQrKztcblx0ICAgICAgICAgIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG5cdCAgICAgICAgICBjb3VudERlbGV0ZSsrO1xuXHQgICAgICAgICAgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBESUZGX0VRVUFMOlxuXHQgICAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cblx0ICAgICAgICAgIGlmIChjb3VudERlbGV0ZSA+PSAxICYmIGNvdW50SW5zZXJ0ID49IDEpIHtcblx0ICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cblx0ICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KTtcblx0ICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuXHQgICAgICAgICAgICBhID0gdGhpcy5EaWZmTWFpbih0ZXh0RGVsZXRlLCB0ZXh0SW5zZXJ0LCBmYWxzZSwgZGVhZGxpbmUpO1xuXG5cdCAgICAgICAgICAgIGZvciAoaiA9IGEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0ICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYVtqXSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIGEubGVuZ3RoO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBjb3VudEluc2VydCA9IDA7XG5cdCAgICAgICAgICBjb3VudERlbGV0ZSA9IDA7XG5cdCAgICAgICAgICB0ZXh0RGVsZXRlID0gXCJcIjtcblx0ICAgICAgICAgIHRleHRJbnNlcnQgPSBcIlwiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBwb2ludGVyKys7XG5cdCAgICB9XG5cblx0ICAgIGRpZmZzLnBvcCgpOyAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG5cblx0ICAgIHJldHVybiBkaWZmcztcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIEZpbmQgdGhlICdtaWRkbGUgc25ha2UnIG9mIGEgZGlmZiwgc3BsaXQgdGhlIHByb2JsZW0gaW4gdHdvXG5cdCAgICogYW5kIHJldHVybiB0aGUgcmVjdXJzaXZlbHkgY29uc3RydWN0ZWQgZGlmZi5cblx0ICAgKiBTZWUgTXllcnMgMTk4NiBwYXBlcjogQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIEl0cyBWYXJpYXRpb25zLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuXHQgICAqIEByZXR1cm4geyFBcnJheS48IURpZmZNYXRjaFBhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXG5cblx0ICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZkJpc2VjdCA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG5cdCAgICB2YXIgdGV4dDFMZW5ndGgsIHRleHQyTGVuZ3RoLCBtYXhELCB2T2Zmc2V0LCB2TGVuZ3RoLCB2MSwgdjIsIHgsIGRlbHRhLCBmcm9udCwgazFzdGFydCwgazFlbmQsIGsyc3RhcnQsIGsyZW5kLCBrMk9mZnNldCwgazFPZmZzZXQsIHgxLCB4MiwgeTEsIHkyLCBkLCBrMSwgazI7IC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cblxuXHQgICAgdGV4dDFMZW5ndGggPSB0ZXh0MS5sZW5ndGg7XG5cdCAgICB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aDtcblx0ICAgIG1heEQgPSBNYXRoLmNlaWwoKHRleHQxTGVuZ3RoICsgdGV4dDJMZW5ndGgpIC8gMik7XG5cdCAgICB2T2Zmc2V0ID0gbWF4RDtcblx0ICAgIHZMZW5ndGggPSAyICogbWF4RDtcblx0ICAgIHYxID0gbmV3IEFycmF5KHZMZW5ndGgpO1xuXHQgICAgdjIgPSBuZXcgQXJyYXkodkxlbmd0aCk7IC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG5cdCAgICAvLyBpbnRlZ2VycyBhbmQgdW5kZWZpbmVkLlxuXG5cdCAgICBmb3IgKHggPSAwOyB4IDwgdkxlbmd0aDsgeCsrKSB7XG5cdCAgICAgIHYxW3hdID0gLTE7XG5cdCAgICAgIHYyW3hdID0gLTE7XG5cdCAgICB9XG5cblx0ICAgIHYxW3ZPZmZzZXQgKyAxXSA9IDA7XG5cdCAgICB2Mlt2T2Zmc2V0ICsgMV0gPSAwO1xuXHQgICAgZGVsdGEgPSB0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoOyAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXMgb2RkLCB0aGVuIHRoZSBmcm9udCBwYXRoIHdpbGwgY29sbGlkZVxuXHQgICAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuXG5cdCAgICBmcm9udCA9IGRlbHRhICUgMiAhPT0gMDsgLy8gT2Zmc2V0cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBrIGxvb3AuXG5cdCAgICAvLyBQcmV2ZW50cyBtYXBwaW5nIG9mIHNwYWNlIGJleW9uZCB0aGUgZ3JpZC5cblxuXHQgICAgazFzdGFydCA9IDA7XG5cdCAgICBrMWVuZCA9IDA7XG5cdCAgICBrMnN0YXJ0ID0gMDtcblx0ICAgIGsyZW5kID0gMDtcblxuXHQgICAgZm9yIChkID0gMDsgZCA8IG1heEQ7IGQrKykge1xuXHQgICAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxuXHQgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBkZWFkbGluZSkge1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9IC8vIFdhbGsgdGhlIGZyb250IHBhdGggb25lIHN0ZXAuXG5cblxuXHQgICAgICBmb3IgKGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcblx0ICAgICAgICBrMU9mZnNldCA9IHZPZmZzZXQgKyBrMTtcblxuXHQgICAgICAgIGlmIChrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFPZmZzZXQgLSAxXSA8IHYxW2sxT2Zmc2V0ICsgMV0pIHtcblx0ICAgICAgICAgIHgxID0gdjFbazFPZmZzZXQgKyAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgeDEgPSB2MVtrMU9mZnNldCAtIDFdICsgMTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB5MSA9IHgxIC0gazE7XG5cblx0ICAgICAgICB3aGlsZSAoeDEgPCB0ZXh0MUxlbmd0aCAmJiB5MSA8IHRleHQyTGVuZ3RoICYmIHRleHQxLmNoYXJBdCh4MSkgPT09IHRleHQyLmNoYXJBdCh5MSkpIHtcblx0ICAgICAgICAgIHgxKys7XG5cdCAgICAgICAgICB5MSsrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHYxW2sxT2Zmc2V0XSA9IHgxO1xuXG5cdCAgICAgICAgaWYgKHgxID4gdGV4dDFMZW5ndGgpIHtcblx0ICAgICAgICAgIC8vIFJhbiBvZmYgdGhlIHJpZ2h0IG9mIHRoZSBncmFwaC5cblx0ICAgICAgICAgIGsxZW5kICs9IDI7XG5cdCAgICAgICAgfSBlbHNlIGlmICh5MSA+IHRleHQyTGVuZ3RoKSB7XG5cdCAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSBib3R0b20gb2YgdGhlIGdyYXBoLlxuXHQgICAgICAgICAgazFzdGFydCArPSAyO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZnJvbnQpIHtcblx0ICAgICAgICAgIGsyT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazE7XG5cblx0ICAgICAgICAgIGlmIChrMk9mZnNldCA+PSAwICYmIGsyT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MltrMk9mZnNldF0gIT09IC0xKSB7XG5cdCAgICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuXHQgICAgICAgICAgICB4MiA9IHRleHQxTGVuZ3RoIC0gdjJbazJPZmZzZXRdO1xuXG5cdCAgICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuXHQgICAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuXG5cblx0ICAgICAgZm9yIChrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG5cdCAgICAgICAgazJPZmZzZXQgPSB2T2Zmc2V0ICsgazI7XG5cblx0ICAgICAgICBpZiAoazIgPT09IC1kIHx8IGsyICE9PSBkICYmIHYyW2syT2Zmc2V0IC0gMV0gPCB2MltrMk9mZnNldCArIDFdKSB7XG5cdCAgICAgICAgICB4MiA9IHYyW2syT2Zmc2V0ICsgMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHgyID0gdjJbazJPZmZzZXQgLSAxXSArIDE7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgeTIgPSB4MiAtIGsyO1xuXG5cdCAgICAgICAgd2hpbGUgKHgyIDwgdGV4dDFMZW5ndGggJiYgeTIgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQodGV4dDFMZW5ndGggLSB4MiAtIDEpID09PSB0ZXh0Mi5jaGFyQXQodGV4dDJMZW5ndGggLSB5MiAtIDEpKSB7XG5cdCAgICAgICAgICB4MisrO1xuXHQgICAgICAgICAgeTIrKztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2MltrMk9mZnNldF0gPSB4MjtcblxuXHQgICAgICAgIGlmICh4MiA+IHRleHQxTGVuZ3RoKSB7XG5cdCAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSBsZWZ0IG9mIHRoZSBncmFwaC5cblx0ICAgICAgICAgIGsyZW5kICs9IDI7XG5cdCAgICAgICAgfSBlbHNlIGlmICh5MiA+IHRleHQyTGVuZ3RoKSB7XG5cdCAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSB0b3Agb2YgdGhlIGdyYXBoLlxuXHQgICAgICAgICAgazJzdGFydCArPSAyO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoIWZyb250KSB7XG5cdCAgICAgICAgICBrMU9mZnNldCA9IHZPZmZzZXQgKyBkZWx0YSAtIGsyO1xuXG5cdCAgICAgICAgICBpZiAoazFPZmZzZXQgPj0gMCAmJiBrMU9mZnNldCA8IHZMZW5ndGggJiYgdjFbazFPZmZzZXRdICE9PSAtMSkge1xuXHQgICAgICAgICAgICB4MSA9IHYxW2sxT2Zmc2V0XTtcblx0ICAgICAgICAgICAgeTEgPSB2T2Zmc2V0ICsgeDEgLSBrMU9mZnNldDsgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG5cblx0ICAgICAgICAgICAgeDIgPSB0ZXh0MUxlbmd0aCAtIHgyO1xuXG5cdCAgICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuXHQgICAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXG5cdCAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gLy8gRGlmZiB0b29rIHRvbyBsb25nIGFuZCBoaXQgdGhlIGRlYWRsaW5lIG9yXG5cdCAgICAvLyBudW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXG5cblxuXHQgICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuXHQgIH07XG5cdCAgLyoqXG5cdCAgICogR2l2ZW4gdGhlIGxvY2F0aW9uIG9mIHRoZSAnbWlkZGxlIHNuYWtlJywgc3BsaXQgdGhlIGRpZmYgaW4gdHdvIHBhcnRzXG5cdCAgICogYW5kIHJlY3Vyc2UuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0geSBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0Mi5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSBhdCB3aGljaCB0byBiYWlsIGlmIG5vdCB5ZXQgY29tcGxldGUuXG5cdCAgICogQHJldHVybiB7IUFycmF5LjwhRGlmZk1hdGNoUGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cblxuXHQgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmQmlzZWN0U3BsaXQgPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCB4LCB5LCBkZWFkbGluZSkge1xuXHQgICAgdmFyIHRleHQxYSwgdGV4dDFiLCB0ZXh0MmEsIHRleHQyYiwgZGlmZnMsIGRpZmZzYjtcblx0ICAgIHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KTtcblx0ICAgIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KTtcblx0ICAgIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcblx0ICAgIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KTsgLy8gQ29tcHV0ZSBib3RoIGRpZmZzIHNlcmlhbGx5LlxuXG5cdCAgICBkaWZmcyA9IHRoaXMuRGlmZk1haW4odGV4dDFhLCB0ZXh0MmEsIGZhbHNlLCBkZWFkbGluZSk7XG5cdCAgICBkaWZmc2IgPSB0aGlzLkRpZmZNYWluKHRleHQxYiwgdGV4dDJiLCBmYWxzZSwgZGVhZGxpbmUpO1xuXHQgICAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xuXHQgIH07XG5cdCAgLyoqXG5cdCAgICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgc2VtYW50aWNhbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cblx0ICAgKiBAcGFyYW0geyFBcnJheS48IURpZmZNYXRjaFBhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cblx0ICAgKi9cblxuXG5cdCAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZDbGVhbnVwU2VtYW50aWMgPSBmdW5jdGlvbiAoZGlmZnMpIHtcblx0ICAgIHZhciBjaGFuZ2VzLCBlcXVhbGl0aWVzLCBlcXVhbGl0aWVzTGVuZ3RoLCBsYXN0ZXF1YWxpdHksIHBvaW50ZXIsIGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMyLCBsZW5ndGhJbnNlcnRpb25zMSwgbGVuZ3RoRGVsZXRpb25zMSwgZGVsZXRpb24sIGluc2VydGlvbiwgb3ZlcmxhcExlbmd0aDEsIG92ZXJsYXBMZW5ndGgyO1xuXHQgICAgY2hhbmdlcyA9IGZhbHNlO1xuXHQgICAgZXF1YWxpdGllcyA9IFtdOyAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuXG5cdCAgICBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuXG5cdCAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG5cblx0ICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7IC8vIEFsd2F5cyBlcXVhbCB0byBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXV1bMV1cblxuXHQgICAgcG9pbnRlciA9IDA7IC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXG5cdCAgICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxuXG5cdCAgICBsZW5ndGhJbnNlcnRpb25zMSA9IDA7XG5cdCAgICBsZW5ndGhEZWxldGlvbnMxID0gMDsgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cblxuXHQgICAgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwO1xuXHQgICAgbGVuZ3RoRGVsZXRpb25zMiA9IDA7XG5cblx0ICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG5cdCAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCkge1xuXHQgICAgICAgIC8vIEVxdWFsaXR5IGZvdW5kLlxuXHQgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XG5cdCAgICAgICAgbGVuZ3RoSW5zZXJ0aW9uczEgPSBsZW5ndGhJbnNlcnRpb25zMjtcblx0ICAgICAgICBsZW5ndGhEZWxldGlvbnMxID0gbGVuZ3RoRGVsZXRpb25zMjtcblx0ICAgICAgICBsZW5ndGhJbnNlcnRpb25zMiA9IDA7XG5cdCAgICAgICAgbGVuZ3RoRGVsZXRpb25zMiA9IDA7XG5cdCAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxuXHQgICAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpIHtcblx0ICAgICAgICAgIGxlbmd0aEluc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG5cdCAgICAgICAgfSAvLyBFbGltaW5hdGUgYW4gZXF1YWxpdHkgdGhhdCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBlZGl0cyBvbiBib3RoXG5cdCAgICAgICAgLy8gc2lkZXMgb2YgaXQuXG5cblxuXHQgICAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgbGFzdGVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMSwgbGVuZ3RoRGVsZXRpb25zMSkgJiYgbGFzdGVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMiwgbGVuZ3RoRGVsZXRpb25zMikpIHtcblx0ICAgICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmQuXG5cdCAgICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7IC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXG5cblx0ICAgICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDsgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkLlxuXG5cdCAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07IC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5IChpdCBuZWVkcyB0byBiZSByZWV2YWx1YXRlZCkuXG5cblx0ICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcblx0ICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7IC8vIFJlc2V0IHRoZSBjb3VudGVycy5cblxuXHQgICAgICAgICAgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwO1xuXHQgICAgICAgICAgbGVuZ3RoRGVsZXRpb25zMSA9IDA7XG5cdCAgICAgICAgICBsZW5ndGhJbnNlcnRpb25zMiA9IDA7XG5cdCAgICAgICAgICBsZW5ndGhEZWxldGlvbnMyID0gMDtcblx0ICAgICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XG5cdCAgICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBwb2ludGVyKys7XG5cdCAgICB9IC8vIE5vcm1hbGl6ZSB0aGUgZGlmZi5cblxuXG5cdCAgICBpZiAoY2hhbmdlcykge1xuXHQgICAgICB0aGlzLmRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpO1xuXHQgICAgfSAvLyBGaW5kIGFueSBvdmVybGFwcyBiZXR3ZWVuIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucy5cblx0ICAgIC8vIGUuZzogPGRlbD5hYmN4eHg8L2RlbD48aW5zPnh4eGRlZjwvaW5zPlxuXHQgICAgLy8gICAtPiA8ZGVsPmFiYzwvZGVsPnh4eDxpbnM+ZGVmPC9pbnM+XG5cdCAgICAvLyBlLmc6IDxkZWw+eHh4YWJjPC9kZWw+PGlucz5kZWZ4eHg8L2lucz5cblx0ICAgIC8vICAgLT4gPGlucz5kZWY8L2lucz54eHg8ZGVsPmFiYzwvZGVsPlxuXHQgICAgLy8gT25seSBleHRyYWN0IGFuIG92ZXJsYXAgaWYgaXQgaXMgYXMgYmlnIGFzIHRoZSBlZGl0IGFoZWFkIG9yIGJlaGluZCBpdC5cblxuXG5cdCAgICBwb2ludGVyID0gMTtcblxuXHQgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcblx0ICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUKSB7XG5cdCAgICAgICAgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG5cdCAgICAgICAgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV07XG5cdCAgICAgICAgb3ZlcmxhcExlbmd0aDEgPSB0aGlzLmRpZmZDb21tb25PdmVybGFwKGRlbGV0aW9uLCBpbnNlcnRpb24pO1xuXHQgICAgICAgIG92ZXJsYXBMZW5ndGgyID0gdGhpcy5kaWZmQ29tbW9uT3ZlcmxhcChpbnNlcnRpb24sIGRlbGV0aW9uKTtcblxuXHQgICAgICAgIGlmIChvdmVybGFwTGVuZ3RoMSA+PSBvdmVybGFwTGVuZ3RoMikge1xuXHQgICAgICAgICAgaWYgKG92ZXJsYXBMZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDEgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcblx0ICAgICAgICAgICAgLy8gT3ZlcmxhcCBmb3VuZC4gIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXG5cdCAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMSldKTtcblx0ICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKTtcblx0ICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMSk7XG5cdCAgICAgICAgICAgIHBvaW50ZXIrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKG92ZXJsYXBMZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcblx0ICAgICAgICAgICAgLy8gUmV2ZXJzZSBvdmVybGFwIGZvdW5kLlxuXHQgICAgICAgICAgICAvLyBJbnNlcnQgYW4gZXF1YWxpdHkgYW5kIHN3YXAgYW5kIHRyaW0gdGhlIHN1cnJvdW5kaW5nIGVkaXRzLlxuXHQgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMildKTtcblx0ICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRElGRl9JTlNFUlQ7XG5cdCAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgyKTtcblx0ICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEU7XG5cdCAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMik7XG5cdCAgICAgICAgICAgIHBvaW50ZXIrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwb2ludGVyKys7XG5cdCAgICAgIH1cblxuXHQgICAgICBwb2ludGVyKys7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKipcblx0ICAgKiBEZXRlcm1pbmUgaWYgdGhlIHN1ZmZpeCBvZiBvbmUgc3RyaW5nIGlzIHRoZSBwcmVmaXggb2YgYW5vdGhlci5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuXHQgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdFxuXHQgICAqICAgICBzdHJpbmcgYW5kIHRoZSBzdGFydCBvZiB0aGUgc2Vjb25kIHN0cmluZy5cblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqL1xuXG5cblx0ICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZkNvbW1vbk92ZXJsYXAgPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG5cdCAgICB2YXIgdGV4dDFMZW5ndGgsIHRleHQyTGVuZ3RoLCB0ZXh0TGVuZ3RoLCBiZXN0LCBsZW5ndGgsIHBhdHRlcm4sIGZvdW5kOyAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXG5cblx0ICAgIHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xuXHQgICAgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGg7IC8vIEVsaW1pbmF0ZSB0aGUgbnVsbCBjYXNlLlxuXG5cdCAgICBpZiAodGV4dDFMZW5ndGggPT09IDAgfHwgdGV4dDJMZW5ndGggPT09IDApIHtcblx0ICAgICAgcmV0dXJuIDA7XG5cdCAgICB9IC8vIFRydW5jYXRlIHRoZSBsb25nZXIgc3RyaW5nLlxuXG5cblx0ICAgIGlmICh0ZXh0MUxlbmd0aCA+IHRleHQyTGVuZ3RoKSB7XG5cdCAgICAgIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgpO1xuXHQgICAgfSBlbHNlIGlmICh0ZXh0MUxlbmd0aCA8IHRleHQyTGVuZ3RoKSB7XG5cdCAgICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxTGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgdGV4dExlbmd0aCA9IE1hdGgubWluKHRleHQxTGVuZ3RoLCB0ZXh0Mkxlbmd0aCk7IC8vIFF1aWNrIGNoZWNrIGZvciB0aGUgd29yc3QgY2FzZS5cblxuXHQgICAgaWYgKHRleHQxID09PSB0ZXh0Mikge1xuXHQgICAgICByZXR1cm4gdGV4dExlbmd0aDtcblx0ICAgIH0gLy8gU3RhcnQgYnkgbG9va2luZyBmb3IgYSBzaW5nbGUgY2hhcmFjdGVyIG1hdGNoXG5cdCAgICAvLyBhbmQgaW5jcmVhc2UgbGVuZ3RoIHVudGlsIG5vIG1hdGNoIGlzIGZvdW5kLlxuXHQgICAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMTAvMTEvMDQvXG5cblxuXHQgICAgYmVzdCA9IDA7XG5cdCAgICBsZW5ndGggPSAxO1xuXG5cdCAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpO1xuXHQgICAgICBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG5cblx0ICAgICAgaWYgKGZvdW5kID09PSAtMSkge1xuXHQgICAgICAgIHJldHVybiBiZXN0O1xuXHQgICAgICB9XG5cblx0ICAgICAgbGVuZ3RoICs9IGZvdW5kO1xuXG5cdCAgICAgIGlmIChmb3VuZCA9PT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dExlbmd0aCAtIGxlbmd0aCkgPT09IHRleHQyLnN1YnN0cmluZygwLCBsZW5ndGgpKSB7XG5cdCAgICAgICAgYmVzdCA9IGxlbmd0aDtcblx0ICAgICAgICBsZW5ndGgrKztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLyoqXG5cdCAgICogU3BsaXQgdHdvIHRleHRzIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2Zcblx0ICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG5cdCAgICogQHJldHVybiB7e2NoYXJzMTogc3RyaW5nLCBjaGFyczI6IHN0cmluZywgbGluZUFycmF5OiAhQXJyYXkuPHN0cmluZz59fVxuXHQgICAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZW5jb2RlZCB0ZXh0MSwgdGhlIGVuY29kZWQgdGV4dDIgYW5kXG5cdCAgICogICAgIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cblx0ICAgKiAgICAgVGhlIHplcm90aCBlbGVtZW50IG9mIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyBpcyBpbnRlbnRpb25hbGx5IGJsYW5rLlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cblxuXHQgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmTGluZXNUb0NoYXJzID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuXHQgICAgdmFyIGxpbmVBcnJheSwgbGluZUhhc2gsIGNoYXJzMSwgY2hhcnMyO1xuXHQgICAgbGluZUFycmF5ID0gW107IC8vIEUuZy4gbGluZUFycmF5WzRdID09PSAnSGVsbG9cXG4nXG5cblx0ICAgIGxpbmVIYXNoID0ge307IC8vIEUuZy4gbGluZUhhc2hbJ0hlbGxvXFxuJ10gPT09IDRcblx0ICAgIC8vICdcXHgwMCcgaXMgYSB2YWxpZCBjaGFyYWN0ZXIsIGJ1dCB2YXJpb3VzIGRlYnVnZ2VycyBkb24ndCBsaWtlIGl0LlxuXHQgICAgLy8gU28gd2UnbGwgaW5zZXJ0IGEganVuayBlbnRyeSB0byBhdm9pZCBnZW5lcmF0aW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG5cblx0ICAgIGxpbmVBcnJheVswXSA9IFwiXCI7XG5cdCAgICAvKipcblx0ICAgICAqIFNwbGl0IGEgdGV4dCBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG5cdCAgICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxuXHQgICAgICogTW9kaWZpZXMgbGluZWFycmF5IGFuZCBsaW5laGFzaCB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFN0cmluZyB0byBlbmNvZGUuXG5cdCAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXG5cdCAgICBmdW5jdGlvbiBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dCkge1xuXHQgICAgICB2YXIgY2hhcnMsIGxpbmVTdGFydCwgbGluZUVuZCwgbGluZUFycmF5TGVuZ3RoLCBsaW5lO1xuXHQgICAgICBjaGFycyA9IFwiXCI7IC8vIFdhbGsgdGhlIHRleHQsIHB1bGxpbmcgb3V0IGEgc3Vic3RyaW5nIGZvciBlYWNoIGxpbmUuXG5cdCAgICAgIC8vIHRleHQuc3BsaXQoJ1xcbicpIHdvdWxkIHdvdWxkIHRlbXBvcmFyaWx5IGRvdWJsZSBvdXIgbWVtb3J5IGZvb3RwcmludC5cblx0ICAgICAgLy8gTW9kaWZ5aW5nIHRleHQgd291bGQgY3JlYXRlIG1hbnkgbGFyZ2Ugc3RyaW5ncyB0byBnYXJiYWdlIGNvbGxlY3QuXG5cblx0ICAgICAgbGluZVN0YXJ0ID0gMDtcblx0ICAgICAgbGluZUVuZCA9IC0xOyAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhcmlhYmxlIGlzIGZhc3RlciB0aGFuIGxvb2tpbmcgaXQgdXAuXG5cblx0ICAgICAgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcblxuXHQgICAgICB3aGlsZSAobGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgbGluZVN0YXJ0KTtcblxuXHQgICAgICAgIGlmIChsaW5lRW5kID09PSAtMSkge1xuXHQgICAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG5cdCAgICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG5cblx0ICAgICAgICBpZiAoaGFzT3duLmNhbGwobGluZUhhc2gsIGxpbmUpKSB7XG5cdCAgICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuXHQgICAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG5cdCAgICAgICAgICBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gY2hhcnM7XG5cdCAgICB9XG5cblx0ICAgIGNoYXJzMSA9IGRpZmZMaW5lc1RvQ2hhcnNNdW5nZSh0ZXh0MSk7XG5cdCAgICBjaGFyczIgPSBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dDIpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgY2hhcnMxOiBjaGFyczEsXG5cdCAgICAgIGNoYXJzMjogY2hhcnMyLFxuXHQgICAgICBsaW5lQXJyYXk6IGxpbmVBcnJheVxuXHQgICAgfTtcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG5cdCAgICogdGV4dC5cblx0ICAgKiBAcGFyYW0geyFBcnJheS48IURpZmZNYXRjaFBhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cblx0ICAgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gbGluZUFycmF5IEFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzLlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICovXG5cblxuXHQgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmQ2hhcnNUb0xpbmVzID0gZnVuY3Rpb24gKGRpZmZzLCBsaW5lQXJyYXkpIHtcblx0ICAgIHZhciB4LCBjaGFycywgdGV4dCwgeTtcblxuXHQgICAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG5cdCAgICAgIGNoYXJzID0gZGlmZnNbeF1bMV07XG5cdCAgICAgIHRleHQgPSBbXTtcblxuXHQgICAgICBmb3IgKHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHtcblx0ICAgICAgICB0ZXh0W3ldID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoeSldO1xuXHQgICAgICB9XG5cblx0ICAgICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKipcblx0ICAgKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxuXHQgICAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuXHQgICAqIEBwYXJhbSB7IUFycmF5LjwhRGlmZk1hdGNoUGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuXHQgICAqL1xuXG5cblx0ICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZkNsZWFudXBNZXJnZSA9IGZ1bmN0aW9uIChkaWZmcykge1xuXHQgICAgdmFyIHBvaW50ZXIsIGNvdW50RGVsZXRlLCBjb3VudEluc2VydCwgdGV4dEluc2VydCwgdGV4dERlbGV0ZSwgY29tbW9ubGVuZ3RoLCBjaGFuZ2VzLCBkaWZmUG9pbnRlciwgcG9zaXRpb247XG5cdCAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7IC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG5cblx0ICAgIHBvaW50ZXIgPSAwO1xuXHQgICAgY291bnREZWxldGUgPSAwO1xuXHQgICAgY291bnRJbnNlcnQgPSAwO1xuXHQgICAgdGV4dERlbGV0ZSA9IFwiXCI7XG5cdCAgICB0ZXh0SW5zZXJ0ID0gXCJcIjtcblxuXHQgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcblx0ICAgICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuXHQgICAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG5cdCAgICAgICAgICBjb3VudEluc2VydCsrO1xuXHQgICAgICAgICAgdGV4dEluc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcblx0ICAgICAgICAgIHBvaW50ZXIrKztcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBESUZGX0RFTEVURTpcblx0ICAgICAgICAgIGNvdW50RGVsZXRlKys7XG5cdCAgICAgICAgICB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuXHQgICAgICAgICAgcG9pbnRlcisrO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIERJRkZfRVFVQUw6XG5cdCAgICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuXHQgICAgICAgICAgaWYgKGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQgPiAxKSB7XG5cdCAgICAgICAgICAgIGlmIChjb3VudERlbGV0ZSAhPT0gMCAmJiBjb3VudEluc2VydCAhPT0gMCkge1xuXHQgICAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhlcy5cblx0ICAgICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZDb21tb25QcmVmaXgodGV4dEluc2VydCwgdGV4dERlbGV0ZSk7XG5cblx0ICAgICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgPiAwICYmIGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcblx0ICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVsxXSArPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLCB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XG5cdCAgICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICB0ZXh0RGVsZXRlID0gdGV4dERlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcblx0ICAgICAgICAgICAgICB9IC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXG5cblxuXHQgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZkNvbW1vblN1ZmZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKTtcblxuXHQgICAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XG5cdCAgICAgICAgICAgICAgICB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgdGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKDAsIHRleHREZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cblxuXG5cdCAgICAgICAgICAgIGlmIChjb3VudERlbGV0ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRJbnNlcnQsIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQsIFtESUZGX0lOU0VSVCwgdGV4dEluc2VydF0pO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50SW5zZXJ0ID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSwgY291bnREZWxldGUgKyBjb3VudEluc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0RGVsZXRlXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHREZWxldGVdLCBbRElGRl9JTlNFUlQsIHRleHRJbnNlcnRdKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCArIChjb3VudERlbGV0ZSA/IDEgOiAwKSArIChjb3VudEluc2VydCA/IDEgOiAwKSArIDE7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG5cdCAgICAgICAgICAgIC8vIE1lcmdlIHRoaXMgZXF1YWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuXHQgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG5cdCAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHBvaW50ZXIrKztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgY291bnRJbnNlcnQgPSAwO1xuXHQgICAgICAgICAgY291bnREZWxldGUgPSAwO1xuXHQgICAgICAgICAgdGV4dERlbGV0ZSA9IFwiXCI7XG5cdCAgICAgICAgICB0ZXh0SW5zZXJ0ID0gXCJcIjtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gXCJcIikge1xuXHQgICAgICBkaWZmcy5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuXHQgICAgfSAvLyBTZWNvbmQgcGFzczogbG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXG5cdCAgICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXG5cdCAgICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcblxuXG5cdCAgICBjaGFuZ2VzID0gZmFsc2U7XG5cdCAgICBwb2ludGVyID0gMTsgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuXG5cdCAgICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcblx0ICAgICAgICBkaWZmUG9pbnRlciA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuXHQgICAgICAgIHBvc2l0aW9uID0gZGlmZlBvaW50ZXIuc3Vic3RyaW5nKGRpZmZQb2ludGVyLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpOyAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuXG5cdCAgICAgICAgaWYgKHBvc2l0aW9uID09PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcblx0ICAgICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuXHQgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG5cdCAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG5cdCAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuXHQgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChkaWZmUG9pbnRlci5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xuXHQgICAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgbmV4dCBlcXVhbGl0eS5cblx0ICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG5cdCAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcblx0ICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG5cdCAgICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBwb2ludGVyKys7XG5cdCAgICB9IC8vIElmIHNoaWZ0cyB3ZXJlIG1hZGUsIHRoZSBkaWZmIG5lZWRzIHJlb3JkZXJpbmcgYW5kIGFub3RoZXIgc2hpZnQgc3dlZXAuXG5cblxuXHQgICAgaWYgKGNoYW5nZXMpIHtcblx0ICAgICAgdGhpcy5kaWZmQ2xlYW51cE1lcmdlKGRpZmZzKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChvLCBuKSB7XG5cdCAgICB2YXIgZGlmZiwgb3V0cHV0LCB0ZXh0O1xuXHQgICAgZGlmZiA9IG5ldyBEaWZmTWF0Y2hQYXRjaCgpO1xuXHQgICAgb3V0cHV0ID0gZGlmZi5EaWZmTWFpbihvLCBuKTtcblx0ICAgIGRpZmYuZGlmZkNsZWFudXBFZmZpY2llbmN5KG91dHB1dCk7XG5cdCAgICB0ZXh0ID0gZGlmZi5kaWZmUHJldHR5SHRtbChvdXRwdXQpO1xuXHQgICAgcmV0dXJuIHRleHQ7XG5cdCAgfTtcblx0fSgpO1xuXG59KChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKTtcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIi8qXG4gICAgSTE4TkRvbWFpbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xuXG52YXIgSTE4TkRvbWFpbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIFxuICAgIHZhciBwdXRUb0F1dG9EZWZpbmVIZWxwZXIgPSBmdW5jdGlvbiggc2NvcGUsIGF1dG9EZWZpbmVIZWxwZXIgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBuZXdTdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHZhciBjb25mID0gY29udGV4dC5nZXRDb25mKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGhlIGRvbWFpbnMgZGVmaW5lZCBwcmV2aW91c2x5XG4gICAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gc2NvcGUuZ2V0KCBjb25mLmkxOG5Eb21haW5WYXJOYW1lICk7XG4gICAgICAgIGlmICggcHJldmlvdXNWYWx1ZSApIHtcbiAgICAgICAgICAgIG5ld1N0cmluZyArPSBjb25mLmluRGVmaW5lRGVsaW1pdGVyICsgY29uZi5pMThuRG9tYWluVmFyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGJyYWNrZXRzIGlmIG5vdCBwcmVzZW50XG4gICAgICAgIGlmICggbmV3U3RyaW5nWyAwIF0gIT09ICdbJyApe1xuICAgICAgICAgICAgbmV3U3RyaW5nID0gJ1snICsgbmV3U3RyaW5nICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgaTE4bkRvbWFpblZhck5hbWUgdG8gdGhlIGF1dG9EZWZpbmVIZWxwZXJcbiAgICAgICAgYXV0b0RlZmluZUhlbHBlci5wdXQoXG4gICAgICAgICAgICBjb25mLmkxOG5Eb21haW5WYXJOYW1lLFxuICAgICAgICAgICAgbmV3U3RyaW5nXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHB1dFRvQXV0b0RlZmluZUhlbHBlcjogcHV0VG9BdXRvRGVmaW5lSGVscGVyLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgdHlwZTogSTE4TkRvbWFpbi5pZFxuICAgIH07XG59O1xuXG5JMThORG9tYWluLmlkID0gJ2kxOG46ZG9tYWluJztcblxuSTE4TkRvbWFpbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgcmV0dXJuIHN0cmluZz8gbmV3IEkxOE5Eb21haW4oIHN0cmluZy50cmltKCkgKTogbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSTE4TkRvbWFpbjtcbiIsIi8qXG4gICAgSTE4bkxhbmd1YWdlIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG5cbnZhciBJMThOTGFuZ3VhZ2UgPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICBcbiAgICB2YXIgcHV0VG9BdXRvRGVmaW5lSGVscGVyID0gZnVuY3Rpb24oIGF1dG9EZWZpbmVIZWxwZXIgKXtcblxuICAgICAgICAvLyBBZGQgaTE4bkxhbmd1YWdlVmFyTmFtZSB0byB0aGUgYXV0b0RlZmluZUhlbHBlclxuICAgICAgICBhdXRvRGVmaW5lSGVscGVyLnB1dChcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmkxOG5MYW5ndWFnZVZhck5hbWUsXG4gICAgICAgICAgICBzdHJpbmdcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiSTE4Tkxhbmd1YWdlOiBcIiArIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHB1dFRvQXV0b0RlZmluZUhlbHBlcjogcHV0VG9BdXRvRGVmaW5lSGVscGVyLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgdHlwZTogSTE4Tkxhbmd1YWdlLmlkXG4gICAgfTtcbn07XG5cbkkxOE5MYW5ndWFnZS5pZCA9ICdpMThuOmxhbmd1YWdlJztcblxuSTE4Tkxhbmd1YWdlLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICByZXR1cm4gc3RyaW5nPyBuZXcgSTE4Tkxhbmd1YWdlKCBzdHJpbmcudHJpbSgpICk6IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEkxOE5MYW5ndWFnZTtcbiIsIi8qXG4gICAgTUVUQUxEZWZpbmVNYWNybyBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTUVUQUxEZWZpbmVNYWNybyA9IGZ1bmN0aW9uKCBuYW1lVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgbmFtZSA9IG5hbWVUb0FwcGx5O1xuICAgIFxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24oIHNjb3BlLCBub2RlICl7XG4gICAgICAgIFxuICAgICAgICAvLyBIaWRlIG1hY3JvIGRlZmluaXRpb25zXG4gICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gXCJNRVRBTERlZmluZU1hY3JvOiBcIiArIG5hbWU7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICB0eXBlOiBNRVRBTERlZmluZU1hY3JvLmlkXG4gICAgfTtcbn07XG5cbk1FVEFMRGVmaW5lTWFjcm8uaWQgPSAnbWV0YWw6ZGVmaW5lLW1hY3JvJztcblxuTUVUQUxEZWZpbmVNYWNyby5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgcmV0dXJuIG5ldyBNRVRBTERlZmluZU1hY3JvKCBzdHJpbmcudHJpbSgpICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1FVEFMRGVmaW5lTWFjcm87XG4iLCIvKlxuICAgIE1FVEFMRmlsbFNsb3QgY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIE1FVEFMRmlsbFNsb3QgPSBmdW5jdGlvbiggX3N0cmluZywgX2V4cHJlc3Npb24sIF91c2VNYWNyb05vZGUgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IF9zdHJpbmc7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBfZXhwcmVzc2lvbjtcbiAgICB2YXIgdXNlTWFjcm9Ob2RlID0gX3VzZU1hY3JvTm9kZTtcbiAgICBcbiAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG9cbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCB1bmRlZmluZWQsIHNjb3BlLCBleHByZXNzaW9uICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oIHBhcnNlclVwZGF0ZXIgKXtcbiAgICAgICAgcGFyc2VyVXBkYXRlci51cGRhdGVOb2RlKCB1c2VNYWNyb05vZGUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBcIk1FVEFMRmlsbFNsb3Q6IFwiICsgc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2VzczogcHJvY2VzcyxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIHR5cGU6IE1FVEFMRmlsbFNsb3QuaWRcbiAgICB9O1xufTtcblxuTUVUQUxGaWxsU2xvdC5pZCA9ICdtZXRhbDpmaWxsLXNsb3QnO1xuXG5NRVRBTEZpbGxTbG90LmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZywgdXNlTWFjcm9Ob2RlICkge1xuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IE1FVEFMRmlsbFNsb3QoIFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIHN0cmluZyApLFxuICAgICAgICAgICAgdXNlTWFjcm9Ob2RlXG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTUVUQUxGaWxsU2xvdDtcbiIsIi8qXG4gICAgTUVUQUxVc2VNYWNybyBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcbnZhciBhdHRyaWJ1dGVJbmRleCA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVJbmRleC5qcycgKTtcbnZhciBhdHRyaWJ1dGVDYWNoZSA9IHJlcXVpcmUoICcuLi8uLi9jYWNoZS9hdHRyaWJ1dGVDYWNoZS5qcycgKTtcbnZhciBUQUxEZWZpbmUgPSByZXF1aXJlKCAnLi4vVEFML3RhbERlZmluZS5qcycgKTtcbnZhciBNRVRBTEZpbGxTbG90ID0gcmVxdWlyZSggJy4vbWV0YWxGaWxsU2xvdC5qcycgKTtcbnZhciByZXNvbHZlciA9IHJlcXVpcmUoICcuLi8uLi9yZXNvbHZlci5qcycgKTtcblxudmFyIE1FVEFMVXNlTWFjcm8gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgbWFjcm9FeHByZXNzaW9uVG9BcHBseSwgZGVmaW5lVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgbWFjcm9FeHByZXNzaW9uID0gbWFjcm9FeHByZXNzaW9uVG9BcHBseTtcbiAgICB2YXIgZGVmaW5lID0gZGVmaW5lVG9BcHBseTtcbiAgICBcbiAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCBzY29wZSwgbm9kZSwgYXV0b0RlZmluZUhlbHBlciwgaW5kZXhFeHByZXNzaW9ucyApe1xuXG4gICAgICAgIC8vIEluaXQgc29tZSB2YXJzXG4gICAgICAgIHZhciBtYWNyb0tleSA9IHJlc29sdmVyLmdldE1hY3JvS2V5KCBtYWNyb0V4cHJlc3Npb24sIHNjb3BlICk7XG4gICAgICAgIHZhciB0YWdzID0gY29udGV4dC5nZXRUYWdzKCk7XG4gICAgICAgIHZhciBuZXdOb2RlID0gcmVzb2x2ZXIuZ2V0Tm9kZSggbWFjcm9LZXksIHNjb3BlICk7IFxuICAgICAgICBcbiAgICAgICAgLy8gSGlkZSB1c2UgbWFjcm8gbm9kZVxuICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHN0eWxlIGF0dHJpYnV0ZSB0byBmb3JjZSBzaG93aW5nIHRoZSBuZXcgbm9kZVxuICAgICAgICBuZXdOb2RlLnJlbW92ZUF0dHJpYnV0ZSggJ3N0eWxlJyApO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBkZWZpbmUgYW5kIGF1dG9EZWZpbmUgYXR0cmlidXRlcyBvZiB0aGUgbmV3IG5vZGVcbiAgICAgICAgdXBkYXRlTmV3Tm9kZUF0dHJpYnV0ZXMoIG1hY3JvS2V5LCBuZXdOb2RlLCBhdXRvRGVmaW5lSGVscGVyLCB0YWdzLCBub2RlLCBpbmRleEV4cHJlc3Npb25zICk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaWxsIHNsb3RzXG4gICAgICAgIGZpbGxTbG90cyggc2NvcGUsIG5vZGUsIHRhZ3MsIG5ld05vZGUsIGluZGV4RXhwcmVzc2lvbnMgKTtcblxuICAgICAgICAvLyBBZGQgdGhlIG1hY3JvIG5vZGVcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggbmV3Tm9kZSwgbm9kZS5uZXh0U2libGluZyApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdXBkYXRlTmV3Tm9kZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiggbWFjcm9LZXksIG5ld05vZGUsIGF1dG9EZWZpbmVIZWxwZXIsIHRhZ3MsIG5vZGUsIGluZGV4RXhwcmVzc2lvbnMgKXtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHRhbERlZmluZSBhdHRyaWJ1dGVcbiAgICAgICAgVEFMRGVmaW5lLnVwZGF0ZUF0dHJpYnV0ZSggbmV3Tm9kZSwgZGVmaW5lICk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgdGhlIHRhbEF1dG9EZWZpbmUgYXR0cmlidXRlXG4gICAgICAgIHZhciBtYWNyb0RhdGEgPSByZXNvbHZlci5nZXRNYWNyb0RhdGEoIG1hY3JvS2V5ICk7XG4gICAgICAgIGlmICggbWFjcm9EYXRhLnVybCApe1xuICAgICAgICAgICAgYXV0b0RlZmluZUhlbHBlci5wdXQoIFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmV4dGVybmFsTWFjcm9VcmxWYXJOYW1lLCBcbiAgICAgICAgICAgICAgICBcIidcIiArIG1hY3JvRGF0YS51cmwgKyBcIidcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGF1dG9EZWZpbmVIZWxwZXIudXBkYXRlTm9kZSggbmV3Tm9kZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgcmVsYXRlZCBpZCBhdHRyaWJ1dGUgaWYgbmVlZGVkXG4gICAgICAgIGlmICggaW5kZXhFeHByZXNzaW9ucyApe1xuICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoIFxuICAgICAgICAgICAgICAgIHRhZ3MucmVsYXRlZElkLCBcbiAgICAgICAgICAgICAgICBub2RlLmdldEF0dHJpYnV0ZSggdGFncy5pZCApIFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIGZpbGxTbG90cyA9IGZ1bmN0aW9uKCBzY29wZSwgbm9kZSwgdGFncywgbmV3Tm9kZSwgaW5kZXhFeHByZXNzaW9ucyApe1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpc3QgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIFxuICAgICAgICAgICAgXCJbXCIgKyByZXNvbHZlci5maWx0ZXJTZWxlY3RvciggdGFncy5tZXRhbEZpbGxTbG90ICkgKyBcIl1cIlxuICAgICAgICApO1xuICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgIHdoaWxlICggZWxlbWVudCA9IGxpc3RbIHBvcysrIF0gKSB7XG4gICAgICAgICAgICB2YXIgc2xvdElkRXhwcmVzc2lvblN0cmluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCB0YWdzLm1ldGFsRmlsbFNsb3QgKTtcbiAgICAgICAgICAgIHZhciBzbG90SWRFeHByZXNzaW9uID0gZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIHNsb3RJZEV4cHJlc3Npb25TdHJpbmcgKTtcbiAgICAgICAgICAgIHZhciBzbG90SWQgPSBzbG90SWRFeHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApO1xuXG4gICAgICAgICAgICAvLyBJbmRleCBmaWxsIHNsb3QgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCBpbmRleEV4cHJlc3Npb25zICl7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFsRmlsbFNsb3QgPSBhdHRyaWJ1dGVDYWNoZS5nZXRCeUF0dHJpYnV0ZUNsYXNzKCBcbiAgICAgICAgICAgICAgICAgICAgTUVUQUxGaWxsU2xvdCwgXG4gICAgICAgICAgICAgICAgICAgIHNsb3RJZEV4cHJlc3Npb25TdHJpbmcsIFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zLFxuICAgICAgICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNRVRBTEZpbGxTbG90LmJ1aWxkKCBzbG90SWRFeHByZXNzaW9uU3RyaW5nLCBub2RlICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluZGV4LmFkZCggZWxlbWVudCwgbWV0YWxGaWxsU2xvdCwgc2NvcGUgKTsgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBzbG90SWRFeHByZXNzaW9uIGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAgICAgICAgaWYgKCAhIHNsb3RJZCApe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNsb3RDb250ZW50ID0gZWxlbWVudC5jbG9uZU5vZGUoIHRydWUgKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IG5ld05vZGUucXVlcnlTZWxlY3RvciggXG4gICAgICAgICAgICAgICAgXCJbXCIgKyByZXNvbHZlci5maWx0ZXJTZWxlY3RvciggdGFncy5tZXRhbERlZmluZVNsb3QgKSArIFwiPSdcIiArIHNsb3RJZCArIFwiJ11cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICggISBjdXJyZW50Tm9kZSApe1xuICAgICAgICAgICAgICAgIHRocm93ICdTbG90IFwiJyArIHNsb3RJZCArICdcIiBpbiBleHByZXNzaW9uIFwiJyArIHNsb3RJZEV4cHJlc3Npb25TdHJpbmcgKydcIiBub3QgZm91bmQhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBcbiAgICAgICAgICAgICAgICBzbG90Q29udGVudCwgXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzbG90Q29udGVudC5yZW1vdmVBdHRyaWJ1dGUoIHRhZ3MubWV0YWxGaWxsU2xvdCApO1xuICAgICAgICAgICAgc2xvdENvbnRlbnQuc2V0QXR0cmlidXRlKCB0YWdzLmlkLCBjb250ZXh0Lm5leHRFeHByZXNzaW9uQ291bnRlcigpICk7IC8vIFNldCBhIG5ldyBpZCBhdHRyaWJ1dGUgdG8gYXZvaWQgaWQgY29uZmxpY3RzXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIHVuZGVmaW5lZCwgc2NvcGUsIG1hY3JvRXhwcmVzc2lvbiApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCBwYXJzZXJVcGRhdGVyLCBub2RlICl7XG4gICAgICAgIHBhcnNlclVwZGF0ZXIudXBkYXRlTm9kZSggbm9kZSApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiTUVUQUxVc2VNYWNybzogXCIgKyBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgdHlwZTogTUVUQUxVc2VNYWNyby5pZFxuICAgIH07XG59O1xuXG5NRVRBTFVzZU1hY3JvLmlkID0gJ21ldGFsOnVzZS1tYWNybyc7XG5cbk1FVEFMVXNlTWFjcm8uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nLCBzdHJpbmdEZWZpbmUgKSB7XG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuICAgIFxuICAgIHJldHVybiBuZXcgTUVUQUxVc2VNYWNybyggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBleHByZXNzaW9uQnVpbGRlci5idWlsZCggc3RyaW5nLnRyaW0oKSApLFxuICAgICAgICAgICAgc3RyaW5nRGVmaW5lPyBzdHJpbmdEZWZpbmUudHJpbSgpOiB1bmRlZmluZWRcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNRVRBTFVzZU1hY3JvO1xuIiwiLyogXG4gICAgY29udGVudEhlbHBlciBzaW5nbGV0b24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbnZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9ldmFsdWF0ZUhlbHBlci5qcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZm9ybUlucHV0SGFzQm9keSA9IHtcbiAgICAgICAgQlVUVE9OOiAxLFxuICAgICAgICBMQUJFTDogMSxcbiAgICAgICAgTEVHRU5EOiAxLFxuICAgICAgICBGSUVMRFNFVDogMSxcbiAgICAgICAgT1BUSU9OOiAxXG4gICAgfTtcbiAgICBcbiAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiggdGFnLCBzdHJpbmcsIGNvbnN0cnVjdG9yRnVuY3Rpb24gKSB7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBpdFxuICAgICAgICB2YXIgY29udGVudCA9IHN0cmluZy50cmltKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXMgYW4gSFRNTCBleHByZXNzaW9uXG4gICAgICAgIHZhciBzdHJ1Y3R1cmUgPSBjb250ZW50LmluZGV4T2YoIGNvbnRleHQuZ2V0Q29uZigpLmh0bWxTdHJ1Y3R1cmVFeHByZXNzaW9uUHJlZml4ICsgJyAnICkgPT09IDA7XG4gICAgICAgIHZhciBleHByZXNzaW9uU3RyaW5nID0gc3RydWN0dXJlPyBcbiAgICAgICAgICAgIGNvbnRlbnQuc3Vic3RyKCAxICsgY29udGV4dC5nZXRDb25mKCkuaHRtbFN0cnVjdHVyZUV4cHJlc3Npb25QcmVmaXgubGVuZ3RoICk6IFxuICAgICAgICAgICAgY29udGVudDtcbiAgICAgICAgaWYgKCAhIGV4cHJlc3Npb25TdHJpbmcgKXtcbiAgICAgICAgICAgIHRocm93IHRhZyArICcgZXhwcmVzc2lvbiB2b2lkLic7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvckZ1bmN0aW9uKFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIGV4cHJlc3Npb25TdHJpbmcgKSxcbiAgICAgICAgICAgIHN0cnVjdHVyZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb25TdHJpbmdcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB1cGRhdGVOb2RlID0gZnVuY3Rpb24oIG5vZGUsIHN0cnVjdHVyZSwgZXZhbHVhdGVkICl7XG5cbiAgICAgICAgLy8gQ2hlY2sgZGVmYXVsdFxuICAgICAgICBpZiAoIGV2YWx1YXRlSGVscGVyLmlzRGVmYXVsdCggZXZhbHVhdGVkICkgKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm90aGluZ1xuICAgICAgICBpZiAoIGV2YWx1YXRlSGVscGVyLmlzTm90aGluZyggZXZhbHVhdGVkICkgKXtcbiAgICAgICAgICAgIGV2YWx1YXRlZCA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaXQgdG8gbm9kZVxuICAgICAgICBub2RlLmlubmVySFRNTCA9IGV2YWx1YXRlZDtcbiAgICAgICAgaWYgKCAhIHN0cnVjdHVyZSApIHtcbiAgICAgICAgICAgIG5vZGVbIFwiZm9ybVwiIGluIG5vZGUgJiYgIWZvcm1JbnB1dEhhc0JvZHlbIG5vZGUudGFnTmFtZSBdID8gXCJ2YWx1ZVwiOiBcImlubmVyVGV4dFwiIF0gPSBldmFsdWF0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGJ1aWxkOiBidWlsZCxcbiAgICAgICAgdXBkYXRlTm9kZTogdXBkYXRlTm9kZVxuICAgIH07XG59KSgpO1xuIiwiLypcbiAgICBUQUxBdHRyaWJ1dGVzIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoICcuLi8uLi91dGlscy5qcycgKTtcblxudmFyIFRBTEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgYXR0cmlidXRlSXRlbXNUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBhdHRyaWJ1dGVJdGVtcyA9IGF0dHJpYnV0ZUl0ZW1zVG9BcHBseTtcbiAgICBcbiAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCBzY29wZSwgbm9kZSwgYXR0cmlidXRlTmFtZSApe1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlSXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlSXRlbSA9IGF0dHJpYnV0ZUl0ZW1zWyBpIF07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZUl0ZW0ubmFtZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCAhIGF0dHJpYnV0ZU5hbWUgfHwgbmFtZSA9PT0gYXR0cmlidXRlTmFtZSApe1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZUl0ZW0uZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcblxuICAgICAgICAgICAgICAgIGlmICggbmFtZSApe1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzU2ltcGxlQXR0cmlidXRlSXRlbSggbm9kZSwgbmFtZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTWFwQXR0cmlidXRlSXRlbSggbm9kZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHByb2Nlc3NNYXBBdHRyaWJ1dGVJdGVtID0gZnVuY3Rpb24oIG5vZGUsIG1hcCApe1xuICAgIFxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG1hcCBpcyBudWxsXG4gICAgICAgIGlmICggISBtYXAgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCAhIHV0aWxzLmlzUGxhaW5PYmplY3QoIG1hcCApICl7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBhdHRyaWJ1dGUgdmFsdWU6IFwiJyArIG1hcCArICdcIi4gT2JqZWN0IGV4cGVjdGVkLic7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAoIHZhciBuYW1lIGluIG1hcCApe1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWFwWyBuYW1lIF07XG4gICAgICAgICAgICBwcm9jZXNzU2ltcGxlQXR0cmlidXRlSXRlbSggbm9kZSwgbmFtZSwgdmFsdWUgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIHByb2Nlc3NTaW1wbGVBdHRyaWJ1dGVJdGVtID0gZnVuY3Rpb24oIG5vZGUsIG5hbWUsIHZhbHVlICl7XG4gICAgICAgIFxuICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKCBjb250ZXh0LmlzQm9vbGVhbkF0dHJpYnV0ZSggbmFtZSApICl7XG4gICAgICAgICAgICBpZiAoIHZhbHVlICl7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIG5hbWUsICcnICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIHZhbHVlIGlzIHVuZGVmaW5lZCBkb24ndCBwYXJzZXIgdGhlIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoIHZhbHVlID09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIC8vIEFsdCBhdHRyaWJ1dGVzXG4gICAgICAgIGlmICggY29udGV4dC5pc0FsdEF0dHJpYnV0ZSggbmFtZSApICkge1xuICAgICAgICAgICAgc3dpdGNoICggbmFtZSApIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICB0aHJvdyBub2RlOyAvLyBzaG91bGQgdXNlIFwicXRleHRcIlxuICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICBub2RlWyBxdWVyeVNlbGVjdG9yQWxsID8gbmFtZSA6IGlubmVyVGV4dCBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIG9wdGlvbi50ZXh0IHVuc3RhYmxlIGluIElFXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiY2xhc3NOYW1lXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG5vZGVbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IFxuXG4gICAgICAgIC8vIFJlZ3VsYXIgYXR0cmlidXRlc1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBzY29wZSApe1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlSXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlSXRlbSA9IGF0dHJpYnV0ZUl0ZW1zWyBpIF07XG4gICAgICAgICAgICB2YXIgZGVwZW5kc09uTGlzdCA9IGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCB1bmRlZmluZWQsIHNjb3BlLCBhdHRyaWJ1dGVJdGVtLmV4cHJlc3Npb24gKTtcbiAgICAgICAgICAgIGlmICggZGVwZW5kc09uTGlzdCAmJiBkZXBlbmRzT25MaXN0Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgICAgICBvYmplY3RbIGF0dHJpYnV0ZUl0ZW0ubmFtZSBdID0gZGVwZW5kc09uTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCBPYmplY3Qua2V5cyggb2JqZWN0ICkubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goIG9iamVjdCApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCBwYXJzZXJVcGRhdGVyLCBub2RlLCBzY29wZSwgaW5kZXhJdGVtICl7XG4gICAgICAgIHByb2Nlc3MoIHNjb3BlLCBub2RlLCBpbmRleEl0ZW0uZ3JvdXBJZCApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiVEFMQXR0cmlidXRlczogXCIgKyBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgdHlwZTogVEFMQXR0cmlidXRlcy5pZFxuICAgIH07XG59O1xuXG5UQUxBdHRyaWJ1dGVzLmlkID0gJ3RhbDphdHRyaWJ1dGVzJztcblxuVEFMQXR0cmlidXRlcy5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cbiAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIGF0dHJpYnV0ZUl0ZW1zID0gW107XG4gICAgdmFyIGV4cHJlc3Npb25TdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICAgIHZhciB0b2tlbnMgPSBuZXcgRXhwcmVzc2lvblRva2VuaXplciggXG4gICAgICAgICAgICBleHByZXNzaW9uU3RyaW5nLCBcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmF0dHJpYnV0ZURlbGltaXRlciwgXG4gICAgICAgICAgICB0cnVlICk7XG5cbiAgICB3aGlsZSAoIHRva2Vucy5oYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0b2tlbnMubmV4dFRva2VuKCkudHJpbSgpO1xuICAgICAgICB2YXIgc3BhY2UgPSBhdHRyaWJ1dGUuaW5kZXhPZiggY29udGV4dC5nZXRDb25mKCkuaW5BdHRyaWJ1dGVEZWxpbWl0ZXIgKTtcbiAgICAgICAgaWYgKCBzcGFjZSA9PT0gLTEgKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIGF0dHJpYnV0ZSApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5zdWJzdHJpbmcoIDAsIHNwYWNlICk7XG4gICAgICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBhdHRyaWJ1dGUuc3Vic3RyaW5nKCBzcGFjZSArIDEgKS50cmltKCk7XG5cbiAgICAgICAgYXR0cmlidXRlSXRlbXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIHZhbHVlRXhwcmVzc2lvbiApXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbmV3IFRBTEF0dHJpYnV0ZXMoIHN0cmluZywgYXR0cmlidXRlSXRlbXMgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVEFMQXR0cmlidXRlcztcbiIsIi8qXG4gICAgVEFMQ29uZGl0aW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9ldmFsdWF0ZUhlbHBlci5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25zVXRpbHMuanMnICk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xuXG52YXIgVEFMQ29uZGl0aW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGV4cHJlc3Npb25Ub0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvblRvQXBwbHk7XG4gICAgXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggc2NvcGUsIG5vZGUgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsdWF0ZUhlbHBlci5ldmFsdWF0ZUJvb2xlYW4oIHNjb3BlLCBleHByZXNzaW9uICk7XG4gICAgICAgIFxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSggY29udGV4dC5nZXRUYWdzKCkuY29uZGl0aW9uUmVzdWx0LCByZXN1bHQgKTtcbiAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gcmVzdWx0ID8gJycgOiAnbm9uZSc7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggdW5kZWZpbmVkLCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCBwYXJzZXJVcGRhdGVyLCBub2RlICl7XG4gICAgICAgIHBhcnNlclVwZGF0ZXIudXBkYXRlTm9kZSggbm9kZSwgdHJ1ZSApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVwZGF0YWJsZUZyb21BY3Rpb24gPSBmdW5jdGlvbiggcGFyc2VyVXBkYXRlciwgbm9kZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIHNjb3BlID0gcGFyc2VyVXBkYXRlci5nZXROb2RlU2NvcGUoIG5vZGUgKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlQm9vbGVhbiggc2NvcGUsIGV4cHJlc3Npb24gKTtcbiAgICAgICAgdmFyIHZhbHVlRnJvbVRhZyA9ICd0cnVlJyA9PT0gbm9kZS5nZXRBdHRyaWJ1dGUoIGNvbnRleHQuZ2V0VGFncygpLmNvbmRpdGlvblJlc3VsdCApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gdmFsdWVGcm9tVGFnO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiVEFMQ29uZGl0aW9uOiBcIiArIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgdXBkYXRhYmxlRnJvbUFjdGlvbjogdXBkYXRhYmxlRnJvbUFjdGlvbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICB0eXBlOiBUQUxDb25kaXRpb24uaWRcbiAgICB9O1xufTtcblxuVEFMQ29uZGl0aW9uLmlkID0gJ3RhbDpjb25kaXRpb24nO1xuXG5UQUxDb25kaXRpb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFRBTENvbmRpdGlvbiggXG4gICAgICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzdHJpbmcgKSApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUQUxDb25kaXRpb247XG4iLCIvKlxuICAgIFRBTENvbnRlbnQgY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGV2YWx1YXRlSGVscGVyID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V2YWx1YXRlSGVscGVyLmpzJyApO1xudmFyIGNvbnRlbnRIZWxwZXIgPSByZXF1aXJlKCAnLi9jb250ZW50SGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIFRBTENvbnRlbnQgPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvblRvQXBwbHksIHN0cnVjdHVyZVRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICB2YXIgc3RydWN0dXJlID0gc3RydWN0dXJlVG9BcHBseTtcbiAgICBcbiAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCBzY29wZSwgbm9kZSApe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRIZWxwZXIudXBkYXRlTm9kZSggXG4gICAgICAgICAgICBub2RlLCBcbiAgICAgICAgICAgIHN0cnVjdHVyZSwgXG4gICAgICAgICAgICBldmFsdWF0ZUhlbHBlci5ldmFsdWF0ZVRvTm90TnVsbCggc2NvcGUsIGV4cHJlc3Npb24gKSBcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIHVuZGVmaW5lZCwgc2NvcGUsIGV4cHJlc3Npb24gKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiggcGFyc2VyVXBkYXRlciwgbm9kZSwgc2NvcGUgKXtcbiAgICAgICAgcHJvY2Vzcyggc2NvcGUsIG5vZGUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBcIlRBTENvbnRlbnQ6IFwiICsgc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2VzczogcHJvY2VzcyxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIHR5cGU6IFRBTENvbnRlbnQuaWRcbiAgICB9O1xufTtcblxuVEFMQ29udGVudC5pZCA9ICd0YWw6Y29udGVudCc7XG5cblRBTENvbnRlbnQuYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHJldHVybiBjb250ZW50SGVscGVyLmJ1aWxkKCBcbiAgICAgICAgJ1RBTENvbnRlbnQnLFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIGZ1bmN0aW9uKCBfc3RyaW5nLCBfZXhwcmVzc2lvbiwgX3N0cnVjdHVyZSApe1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUQUxDb250ZW50KCBfc3RyaW5nLCBfZXhwcmVzc2lvbiwgX3N0cnVjdHVyZSApO1xuICAgICAgICB9XG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVEFMQ29udGVudDtcbiIsIi8qXG4gICAgVEFMRGVjbGFyZSBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIEV4cHJlc3Npb25Ub2tlbml6ZXIgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvblRva2VuaXplci5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25zVXRpbHMuanMnICk7XG5cbnZhciBUQUxEZWNsYXJlID0gZnVuY3Rpb24oIF9zdHJpbmcsIF9kZWNsYXJlSXRlbXMgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IF9zdHJpbmc7XG4gICAgdmFyIGRlY2xhcmVJdGVtcyA9IF9kZWNsYXJlSXRlbXM7XG4gICAgXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggc2NvcGUsIGF1dG9EZWZpbmVIZWxwZXIgKXtcblxuICAgICAgICBwdXRWYXJpYWJsZXMoIHNjb3BlLCBhdXRvRGVmaW5lSGVscGVyICk7XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NEZWNsYXJlSXRlbXMoIHNjb3BlICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcHV0VmFyaWFibGVzID0gZnVuY3Rpb24oIHNjb3BlLCBhdXRvRGVmaW5lSGVscGVyICkge1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHN0cmljdE1vZGVWYXJOYW1lIHRvIHRoZSBhdXRvRGVmaW5lSGVscGVyIGlmIG5lZWRlZFxuICAgICAgICB2YXIgc3RyaWN0TW9kZVZhck5hbWUgPSBjb250ZXh0LmdldENvbmYoKS5zdHJpY3RNb2RlVmFyTmFtZTtcbiAgICAgICAgaWYgKCB0cnVlICE9PSBzY29wZS5nZXQoIHN0cmljdE1vZGVWYXJOYW1lICkgKXtcbiAgICAgICAgICAgIGF1dG9EZWZpbmVIZWxwZXIucHV0KCBzdHJpY3RNb2RlVmFyTmFtZSwgJ3RydWUnICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEJ1aWxkIGRlY2xhcmVkIGFuZCByZXF1aXJlZFxuICAgICAgICB2YXIgZGVjbGFyZWRWYXJzVmFyTmFtZSA9IGNvbnRleHQuZ2V0Q29uZigpLmRlY2xhcmVkVmFyc1Zhck5hbWU7XG4gICAgICAgIHZhciBkZWNsYXJlZCA9IHNjb3BlLmdldCggZGVjbGFyZWRWYXJzVmFyTmFtZSApIHx8IFtdO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWNsYXJlSXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgZGVjbGFyZUl0ZW0gPSBkZWNsYXJlSXRlbXNbIGkgXTtcbiAgICAgICAgICAgIGRlY2xhcmVkLnB1c2goIGRlY2xhcmVJdGVtLm5hbWUgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGRlY2xhcmVkVmFyc1Zhck5hbWUgdG8gdGhlIGF1dG9EZWZpbmVIZWxwZXJcbiAgICAgICAgYXV0b0RlZmluZUhlbHBlci5wdXQoIFxuICAgICAgICAgICAgZGVjbGFyZWRWYXJzVmFyTmFtZSwgXG4gICAgICAgICAgICBleHByZXNzaW9uc1V0aWxzLmJ1aWxkTGlzdCggZGVjbGFyZWQsIHRydWUgKVxuICAgICAgICApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHByb2Nlc3NEZWNsYXJlSXRlbXMgPSBmdW5jdGlvbiggc2NvcGUgKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgZXJyb3JzQXJyYXkgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWNsYXJlSXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgZGVjbGFyZUl0ZW0gPSBkZWNsYXJlSXRlbXNbIGkgXTtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBjaGVja0RlY2xhcmVJdGVtKFxuICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgIGRlY2xhcmVJdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVjbGFyZUl0ZW0udHlwZSxcbiAgICAgICAgICAgICAgICBkZWNsYXJlSXRlbS5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBkZWNsYXJlSXRlbS5kZWZhdWx0VmFsdWVTdHJpbmcsXG4gICAgICAgICAgICAgICAgZGVjbGFyZUl0ZW0uZGVmYXVsdFZhbHVlRXhwcmVzc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVycm9yc0FycmF5ID0gZXJyb3JzQXJyYXkuY29uY2F0KCBlcnJvcnMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3NFcnJvcnNBcnJheSggZXJyb3JzQXJyYXkgKTtcblxuICAgICAgICByZXR1cm4gZXJyb3JzQXJyYXkubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICB2YXIgY2hlY2tEZWNsYXJlSXRlbSA9IGZ1bmN0aW9uKCBzY29wZSwgbmFtZSwgdHlwZSwgcmVxdWlyZWQsIGRlZmF1bHRWYWx1ZVN0cmluZywgZGVmYXVsdFZhbHVlRXhwcmVzc2lvbiApIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBlcnJvcnNBcnJheSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgdmFyIHZhbHVlID0gc2NvcGUuZ2V0KCBuYW1lICk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZUV4cHJlc3Npb24gIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgdmFyIHNldERlZmF1bHRWYWx1ZUVycm9yID0gc2V0RGVmYXVsdFZhbHVlKCBzY29wZSwgbmFtZSwgdHlwZSwgZGVmYXVsdFZhbHVlU3RyaW5nLCBkZWZhdWx0VmFsdWVFeHByZXNzaW9uICk7XG4gICAgICAgICAgICBpZiAoIHNldERlZmF1bHRWYWx1ZUVycm9yICl7XG4gICAgICAgICAgICAgICAgZXJyb3JzQXJyYXkucHVzaCggc2V0RGVmYXVsdFZhbHVlRXJyb3IgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHNjb3BlLmdldCggbmFtZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayB0eXBlXG4gICAgICAgIHZhciB0eXBlQ2hlY2tFcnJvciA9IGNoZWNrVHlwZSggbmFtZSwgdHlwZSwgdmFsdWUgKTtcbiAgICAgICAgaWYgKCB0eXBlQ2hlY2tFcnJvciApe1xuICAgICAgICAgICAgZXJyb3JzQXJyYXkucHVzaCggdHlwZUNoZWNrRXJyb3IgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgcmVxdWlyZWRcbiAgICAgICAgdmFyIHJlcXVpcmVkQ2hlY2tFcnJvciA9IGNoZWNrUmVxdWlyZWQoIG5hbWUsIHJlcXVpcmVkLCB2YWx1ZSApO1xuICAgICAgICBpZiAoIHJlcXVpcmVkQ2hlY2tFcnJvciApe1xuICAgICAgICAgICAgZXJyb3JzQXJyYXkucHVzaCggcmVxdWlyZWRDaGVja0Vycm9yICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBlcnJvcnNBcnJheTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBjaGVja1R5cGUgPSBmdW5jdGlvbiggbmFtZSwgZXhwZWN0ZWRUeXBlLCB2YWx1ZSApIHtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBleHBlY3RlZFR5cGUgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHJlYWxUeXBlID0gZ2V0VHlwZU9mKCB2YWx1ZSApO1xuICAgICAgICByZXR1cm4gcmVhbFR5cGUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpPyBcbiAgICAgICAgICAgIGZhbHNlOiBcbiAgICAgICAgICAgICdFeHBlY3RlZCB2YWx1ZSB0eXBlICgnICsgZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCkgKyAnKSBvZiAnICsgbmFtZSArICcgcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggdHlwZSAoJyArIHJlYWxUeXBlICsgJyksIHZhbHVlIGlzIFwiJyArIHZhbHVlICsgJ1wiLic7XG4gICAgfTtcbiAgICBcbiAgICAvKlxuICAgICAgICB0eXBlT2YoKTsgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkXG4gICAgICAgIHR5cGVPZihudWxsKTsgICAgICAgICAgICAgICAvLyBudWxsXG4gICAgICAgIHR5cGVPZihOYU4pOyAgICAgICAgICAgICAgICAvLyBudW1iZXJcbiAgICAgICAgdHlwZU9mKDUpOyAgICAgICAgICAgICAgICAgIC8vIG51bWJlclxuICAgICAgICB0eXBlT2YoW10pOyAgICAgICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgdHlwZU9mKCcnKTsgICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgICAgICB0eXBlT2YoZnVuY3Rpb24gKCkge30pOyAgICAgLy8gZnVuY3Rpb25cbiAgICAgICAgdHlwZU9mKC9hLykgICAgICAgICAgICAgICAgIC8vIHJlZ2V4cFxuICAgICAgICB0eXBlT2YobmV3IERhdGUoKSkgICAgICAgICAgLy8gZGF0ZVxuICAgICAgICB0eXBlT2YobmV3IEVycm9yKSAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgdHlwZU9mKFByb21pc2UucmVzb2x2ZSgpKSAgIC8vIHByb21pc2VcbiAgICAgICAgdHlwZU9mKGZ1bmN0aW9uICooKSB7fSkgICAgIC8vIGdlbmVyYXRvcmZ1bmN0aW9uXG4gICAgICAgIHR5cGVPZihuZXcgV2Vha01hcCgpKSAgICAgICAvLyB3ZWFrbWFwXG4gICAgICAgIHR5cGVPZihuZXcgTWFwKCkpICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgdHlwZU9mKHt9KTsgICAgICAgICAgICAgICAgIC8vIG9iamVjdFxuICAgICAgICB0eXBlT2YobmV3IE15Q29uc3RydWN0b3IoKSkgLy8gTXlDb25zdHJ1Y3RvclxuICAgICovXG4gICAgdmFyIGdldFR5cGVPZiA9IGZ1bmN0aW9uKCB2YWx1ZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIHRlbXAgPSB7fS50b1N0cmluZy5jYWxsKCB2YWx1ZSApLnNwbGl0KCcgJylbIDEgXS5zbGljZSggMCwgLTEgKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdGVtcCA9PT0gJ29iamVjdCc/IFxuICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZS50b0xvd2VyQ2FzZSgpOiBcbiAgICAgICAgICAgIHRlbXA7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uKCBuYW1lLCByZXF1aXJlZCwgdmFsdWUgKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZSA9PT0gcmVxdWlyZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZD8gXG4gICAgICAgICAgICAnUmVxdWlyZWQgdmFsdWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkOiAnICsgbmFtZTpcbiAgICAgICAgICAgIGZhbHNlO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHNldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uKCBzY29wZSwgbmFtZSwgdHlwZSwgZGVmYXVsdFZhbHVlU3RyaW5nLCBkZWZhdWx0VmFsdWVFeHByZXNzaW9uICkge1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWVFeHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICAgICAgc2NvcGUuc2V0KCBuYW1lLCBkZWZhdWx0VmFsdWUgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgIHJldHVybiAnRXJyb3IgdHJ5aW5nIHRvIGV2YWx1YXRlIGRlZmF1bHQgdmFsdWUgb2YgZmllbGQgJyArIG5hbWUgKyAnLCBleHByZXNzaW9uIFsnICsgZGVmYXVsdFZhbHVlU3RyaW5nICsgJ106ICcgKyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcHJvY2Vzc0Vycm9yc0FycmF5ID0gZnVuY3Rpb24oIGVycm9yc0FycmF5ICkge1xuXG4gICAgICAgIGlmICggZXJyb3JzQXJyYXkubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRocm93IGVycm9yc0FycmF5O1xuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvXG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gXCJUQUxEZWNsYXJlOiBcIiArIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICB0eXBlOiBUQUxEZWNsYXJlLmlkXG4gICAgfTtcbn07XG5cblRBTERlY2xhcmUuaWQgPSAndGFsOmRlY2xhcmUnO1xuXG5UQUxEZWNsYXJlLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcblxuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcblxuICAgIHZhciBkZWNsYXJlSXRlbXMgPSBbXTtcbiAgICB2YXIgb21pdFR5cGVzID0gWyAndW5kZWZpbmVkJywgJ251bGwnIF07XG4gICAgXG4gICAgdmFyIHRva2VucyA9IG5ldyBFeHByZXNzaW9uVG9rZW5pemVyKCBcbiAgICAgICAgc3RyaW5nLnRyaW0oKSwgXG4gICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmRlY2xhcmVEZWxpbWl0ZXIsIFxuICAgICAgICB0cnVlIFxuICAgICk7XG5cbiAgICB3aGlsZSAoIHRva2Vucy5oYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgaW5Qcm9wVG9rZW5zID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgdG9rZW5zLm5leHRUb2tlbigpLnRyaW0oKSwgXG4gICAgICAgICAgICBjb250ZXh0LmdldENvbmYoKS5pbkRlY2xhcmVEZWxpbWl0ZXIsIFxuICAgICAgICAgICAgdHJ1ZSBcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZVN0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGF0ZSA9IDE7XG4gICAgICAgIHdoaWxlICggaW5Qcm9wVG9rZW5zLmhhc01vcmVUb2tlbnMoKSApe1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IGluUHJvcFRva2Vucy5uZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIGlmICggVEFMRGVjbGFyZS50b2tlbklzUmVxdWlyZWQoIGN1cnJlbnRUb2tlbiApICl7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICggc3RhdGUgKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gY3VycmVudFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICggLTEgPT09IG9taXRUeXBlcy5pbmRleE9mKCBjdXJyZW50VG9rZW4udG9Mb3dlckNhc2UoKSApICl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gY3VycmVudFRva2VuOyAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlU3RyaW5nID0gY3VycmVudFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVG9vIG1hbnkgYXJndW1lbnRzIGluIHRhbERlY2xhcmUgaXRlbTogJyArIHN0cmluZy50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3N0YXRlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUaGUgbmFtZSBpcyB0aGUgb25seSByZXF1aXJlZCBlbGVtZW50XG4gICAgICAgIGlmICggISBuYW1lICl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZGVjbGFyZUl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVTdHJpbmc6IGRlZmF1bHRWYWx1ZVN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZUV4cHJlc3Npb246IGRlZmF1bHRWYWx1ZVN0cmluZyA9PSB1bmRlZmluZWQ/IHVuZGVmaW5lZDogZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIGRlZmF1bHRWYWx1ZVN0cmluZyApXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVEFMRGVjbGFyZSggc3RyaW5nLCBkZWNsYXJlSXRlbXMgKTtcbn07XG5cblRBTERlY2xhcmUudG9rZW5Jc1JlcXVpcmVkID0gZnVuY3Rpb24oIHRva2VuICkge1xuICAgIHJldHVybiBcInJlcXVpcmVkXCIgPT09IHRva2VuLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRBTERlY2xhcmU7XG4iLCIvKlxuICAgIFRBTERlZmluZSBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIEV4cHJlc3Npb25Ub2tlbml6ZXIgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvblRva2VuaXplci5qcycgKTtcblxudmFyIFRBTERlZmluZSA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBkZWZpbmVJdGVtc1RvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGRlZmluZUl0ZW1zID0gZGVmaW5lSXRlbXNUb0FwcGx5O1xuICAgIFxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24oIHNjb3BlLCBmb3JjZUdsb2JhbCApe1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHNjb3BlXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRlZmluZUl0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGRlZmluZUl0ZW0gPSBkZWZpbmVJdGVtc1sgaSBdO1xuICAgICAgICAgICAgc2NvcGUuc2V0KCBcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lSXRlbS5uYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lSXRlbS5ub2NhbGw/IGRlZmluZUl0ZW0uZXhwcmVzc2lvbjogZGVmaW5lSXRlbS5leHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApLCBcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VHbG9iYWwgfHwgZGVmaW5lSXRlbS5nbG9iYWwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUl0ZW0ubm9jYWxsLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVJdGVtLmV4cHJlc3Npb25cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiVEFMRGVmaW5lOiBcIiArIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHByb2Nlc3M6IHByb2Nlc3MsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgICB0eXBlOiBUQUxEZWZpbmUuaWRcbiAgICB9O1xufTtcblxuVEFMRGVmaW5lLmlkID0gJ3RhbDpkZWZpbmUnO1xuXG5UQUxEZWZpbmUuYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuXG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuXG4gICAgdmFyIGRlZmluZUl0ZW1zID0gW107XG4gICAgdmFyIGV4cHJlc3Npb25TdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICAgIHZhciB0b2tlbnMgPSBuZXcgRXhwcmVzc2lvblRva2VuaXplciggXG4gICAgICAgIGV4cHJlc3Npb25TdHJpbmcsIFxuICAgICAgICBjb250ZXh0LmdldENvbmYoKS5kZWZpbmVEZWxpbWl0ZXIsIFxuICAgICAgICB0cnVlICk7XG5cbiAgICB3aGlsZSAoIHRva2Vucy5oYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZSA9IHRva2Vucy5uZXh0VG9rZW4oKS50cmltKCk7XG4gICAgICAgIHZhciBzcGFjZSA9IHZhcmlhYmxlLmluZGV4T2YoIGNvbnRleHQuZ2V0Q29uZigpLmluRGVmaW5lRGVsaW1pdGVyICk7XG4gICAgICAgIGlmICggc3BhY2UgPT09IC0xICkge1xuICAgICAgICAgICAgdGhyb3cgJ0JhZCB2YXJpYWJsZSBkZWZpbml0aW9uOiAnICsgdmFyaWFibGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9jYWxsID0gZmFsc2U7XG4gICAgICAgIHZhciBnbG9iYWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRUb2tlbiA9IHZhcmlhYmxlLnN1YnN0cmluZyggMCwgc3BhY2UgKTtcbiAgICAgICAgdmFyIG5leHRUb2tlbnMgPSB2YXJpYWJsZS5zdWJzdHJpbmcoIHNwYWNlICsgMSApLnRyaW0oKTtcbiAgICAgICAgdmFyIHRva2VuRG9uZSA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgc3BlY2lhbFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIGNvbnRleHQuZ2V0Q29uZigpLmdsb2JhbFZhcmlhYmxlRXhwcmVzc2lvblByZWZpeCA9PT0gY3VycmVudFRva2VuICl7XG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzcGVjaWFsVG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29udGV4dC5nZXRDb25mKCkubm9jYWxsVmFyaWFibGVFeHByZXNzaW9uUHJlZml4ID09PSBjdXJyZW50VG9rZW4gKXtcbiAgICAgICAgICAgICAgICBub2NhbGwgPSB0cnVlOyAgXG4gICAgICAgICAgICAgICAgc3BlY2lhbFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICggc3BlY2lhbFRva2VuICl7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSBuZXh0VG9rZW5zLmluZGV4T2YoIGNvbnRleHQuZ2V0Q29uZigpLmluRGVmaW5lRGVsaW1pdGVyICk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gbmV4dFRva2Vucy5zdWJzdHJpbmcoIDAsIHNwYWNlICk7XG4gICAgICAgICAgICAgICAgbmV4dFRva2VucyA9IG5leHRUb2tlbnMuc3Vic3RyaW5nKCBzcGFjZSArIDEgKS50cmltKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZUl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBuZXh0VG9rZW5zICksXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgICAgICBub2NhbGw6IG5vY2FsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRva2VuRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSB3aGlsZSggISB0b2tlbkRvbmUgJiYgc3BhY2UgIT09IC0xICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUQUxEZWZpbmUoIHN0cmluZywgZGVmaW5lSXRlbXMgKTtcbn07XG5cblxuVEFMRGVmaW5lLmFwcGVuZFN0cmluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzWyAwIF07XG4gICAgXG4gICAgZm9yICggdmFyIGMgPSAxOyBjIDwgYXJndW1lbnRzLmxlbmd0aDsgKytjICl7XG4gICAgICAgIHZhciBzdHJpbmcgPSBhcmd1bWVudHNbIGMgXTtcbiAgICAgICAgaWYgKCBzdHJpbmcgKXtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdD8gcmVzdWx0ICsgY29udGV4dC5nZXRDb25mKCkuZGVmaW5lRGVsaW1pdGVyICsgc3RyaW5nOiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRBTERlZmluZS51cGRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiggbm9kZSwgZGVmaW5lVG9BZGQgKXtcblxuICAgIHZhciB0YWdzID0gY29udGV4dC5nZXRUYWdzKCk7XG4gICAgdmFyIG5vZGVEZWZpbmUgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy50YWxEZWZpbmUgKTtcbiAgICB2YXIgZnVsbERlZmluZSA9IFRBTERlZmluZS5hcHBlbmRTdHJpbmdzKCBkZWZpbmVUb0FkZCwgbm9kZURlZmluZSApO1xuXG4gICAgaWYgKCBmdWxsRGVmaW5lICl7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCB0YWdzLnRhbERlZmluZSwgZnVsbERlZmluZSApO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVEFMRGVmaW5lO1xuIiwiLypcbiAgICBUQUxPbWl0VGFnIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBCb29sZWFuTGl0ZXJhbCA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9wYXRoL2xpdGVyYWxzL2Jvb2xlYW5MaXRlcmFsLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG5cbnZhciBUQUxPbWl0VGFnID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGV4cHJlc3Npb25Ub0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvblRvQXBwbHk7XG4gICAgXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggc2NvcGUsIG5vZGUsIHBhcnNlck5vZGVSZW5kZXJlciApe1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlc3VsdCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgIGlmICggISByZXN1bHQgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY29udGVudHNcbiAgICAgICAgcGFyc2VyTm9kZVJlbmRlcmVyLmRlZmF1bHRDb250ZW50KCBub2RlICk7XG4gICAgICAgIFxuICAgICAgICAvLyBNb3ZlIGNoaWxkcmVuIGZyb20gY3VycmVudCBub2RlIHRvIGl0cyBwYXJlbnQgYW5kIHRoZW4gcmVtb3ZlIGl0XG4gICAgICAgIHZhciB0YWdzID0gY29udGV4dC5nZXRUYWdzKCk7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoIG5vZGUuZmlyc3RDaGlsZCApIHtcbiAgICAgICAgICAgIGlmICggbm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09PSAxICl7XG4gICAgICAgICAgICAgICAgbm9kZS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggdGFncy5xZHVwLCAxICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKCBub2RlLmZpcnN0Q2hpbGQgKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggdW5kZWZpbmVkLCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG9cbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBcIlRBTE9taXRUYWc6IFwiICsgc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2VzczogcHJvY2VzcyxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIHR5cGU6IFRBTE9taXRUYWcuaWRcbiAgICB9O1xufTtcblxuVEFMT21pdFRhZy5pZCA9ICd0YWw6b21pdC10YWcnO1xuXG5UQUxPbWl0VGFnLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIGV4cHJlc3Npb25TdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvblN0cmluZyA9PSAnJz9cbiAgICAgICAgICAgIG5ldyBCb29sZWFuTGl0ZXJhbCggdHJ1ZSApOlxuICAgICAgICAgICAgZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIGV4cHJlc3Npb25TdHJpbmcgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFRBTE9taXRUYWcoIHN0cmluZywgZXhwcmVzc2lvbiApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUQUxPbWl0VGFnO1xuIiwiLypcbiAgICBUQUxPbkVycm9yIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgY29udGVudEhlbHBlciA9IHJlcXVpcmUoICcuL2NvbnRlbnRIZWxwZXIuanMnICk7XG5cbnZhciBUQUxPbkVycm9yID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIHN0cnVjdHVyZVRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIHN0cnVjdHVyZSA9IHN0cnVjdHVyZVRvQXBwbHk7XG4gICAgXG4gICAgdmFyIHB1dFRvQXV0b0RlZmluZUhlbHBlciA9IGZ1bmN0aW9uKCBhdXRvRGVmaW5lSGVscGVyICl7XG5cbiAgICAgICAgLy8gQWRkIG9uRXJyb3JWYXJOYW1lIHRvIHRoZSBhdXRvRGVmaW5lSGVscGVyXG4gICAgICAgIGF1dG9EZWZpbmVIZWxwZXIucHV0KFxuICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkub25FcnJvclZhck5hbWUsXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgb25FcnJvclN0cnVjdHVyZVZhck5hbWUgdG8gdGhlIGF1dG9EZWZpbmVIZWxwZXJcbiAgICAgICAgYXV0b0RlZmluZUhlbHBlci5wdXQoXG4gICAgICAgICAgICBjb250ZXh0LmdldENvbmYoKS5vbkVycm9yU3RydWN0dXJlVmFyTmFtZSxcbiAgICAgICAgICAgIHN0cnVjdHVyZSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiVEFMT25FcnJvcjogXCIgKyBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBwdXRUb0F1dG9EZWZpbmVIZWxwZXI6IHB1dFRvQXV0b0RlZmluZUhlbHBlcixcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIHR5cGU6IFRBTE9uRXJyb3IuaWRcbiAgICB9O1xufTtcblxuVEFMT25FcnJvci5pZCA9ICd0YWw6b24tZXJyb3InO1xuXG5UQUxPbkVycm9yLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcblxuICAgIHJldHVybiBjb250ZW50SGVscGVyLmJ1aWxkKCBcbiAgICAgICAgJ1RBTE9uRXJyb3InLFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIGZ1bmN0aW9uKCBfc3RyaW5nLCBfZXhwcmVzc2lvbiwgX3N0cnVjdHVyZSwgX2V4cHJlc3Npb25TdHJpbmcgKXtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEFMT25FcnJvciggX2V4cHJlc3Npb25TdHJpbmcsIF9zdHJ1Y3R1cmUgKTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRBTE9uRXJyb3I7XG4iLCIvKlxuICAgIFRBTFJlcGVhdCBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi8uLi9leHByZXNzaW9ucy9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xudmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xudmFyIExvb3AgPSByZXF1aXJlKCAnLi4vLi4vcGFyc2Vycy9sb29wLmpzJyApO1xuXG52YXIgVEFMUmVwZWF0ID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIHZhck5hbWVUb0FwcGx5LCBleHByZXNzaW9uU3RyaW5nVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgdmFyTmFtZSA9IHZhck5hbWVUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uU3RyaW5nID0gZXhwcmVzc2lvblN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggZXhwcmVzc2lvblN0cmluZyApO1xuICAgIHZhciBsb29wO1xuICAgIFxuICAgIHZhciBwcm9jZXNzID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIGxvb3AgPSBuZXcgTG9vcCggdmFyTmFtZSwgZXhwcmVzc2lvblN0cmluZywgc2NvcGUgKTtcbiAgICAgICAgcmV0dXJuIGxvb3A7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggdW5kZWZpbmVkLCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCBwYXJzZXJVcGRhdGVyLCBub2RlICl7XG4gICAgICAgIHBhcnNlclVwZGF0ZXIudXBkYXRlTm9kZSggbm9kZSApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFwiVEFMUmVwZWF0OiBcIiArIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRFeHByZXNzaW9uU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25TdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0VmFyTmFtZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB2YXJOYW1lO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2VzczogcHJvY2VzcyxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICAgIHR5cGU6IFRBTFJlcGVhdC5pZCxcbiAgICAgICAgZ2V0RXhwcmVzc2lvblN0cmluZzogZ2V0RXhwcmVzc2lvblN0cmluZyxcbiAgICAgICAgZ2V0VmFyTmFtZTogZ2V0VmFyTmFtZVxuICAgIH07XG59O1xuXG5UQUxSZXBlYXQuaWQgPSAndGFsOnJlcGVhdCc7XG5cblRBTFJlcGVhdC5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgXG4gICAgdmFyIGV4cHJlc3Npb25TdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICAgIHZhciBzcGFjZSA9IGV4cHJlc3Npb25TdHJpbmcuaW5kZXhPZiggJyAnICk7XG4gICAgaWYgKCBzcGFjZSA9PT0gLTEgKSB7XG4gICAgICAgIHRocm93ICdCYWQgcmVwZWF0IGV4cHJlc3Npb246ICcgKyBleHByZXNzaW9uU3RyaW5nO1xuICAgIH1cbiAgICB2YXIgdmFyTmFtZSA9IGV4cHJlc3Npb25TdHJpbmcuc3Vic3RyaW5nKCAwLCBzcGFjZSApO1xuICAgIHZhciBsb29wRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25TdHJpbmcuc3Vic3RyaW5nKCBzcGFjZSArIDEgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFRBTFJlcGVhdCggc3RyaW5nLCB2YXJOYW1lLCBsb29wRXhwcmVzc2lvbiApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUQUxSZXBlYXQ7XG4iLCIvKlxuICAgIFRBTFJlcGxhY2UgY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGV2YWx1YXRlSGVscGVyID0gcmVxdWlyZSggJy4uLy4uL2V4cHJlc3Npb25zL2V2YWx1YXRlSGVscGVyLmpzJyApO1xudmFyIGNvbnRlbnRIZWxwZXIgPSByZXF1aXJlKCAnLi9jb250ZW50SGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vZXhwcmVzc2lvbnMvZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIFRBTFJlcGxhY2UgPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvblRvQXBwbHksIHN0cnVjdHVyZVRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICB2YXIgc3RydWN0dXJlID0gc3RydWN0dXJlVG9BcHBseTtcbiAgICBcbiAgICB2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCBzY29wZSwgbm9kZSApe1xuICAgICAgICBcbiAgICAgICAgLy8gRXZhbHVhdGVcbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlVG9Ob3ROdWxsKCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZGVmYXVsdFxuICAgICAgICBpZiAoIGV2YWx1YXRlSGVscGVyLmlzRGVmYXVsdCggZXZhbHVhdGVkICkgKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm90aGluZ1xuICAgICAgICBpZiAoIGV2YWx1YXRlSGVscGVyLmlzTm90aGluZyggZXZhbHVhdGVkICkgKXtcbiAgICAgICAgICAgIGV2YWx1YXRlZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICggc3RydWN0dXJlICl7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIEhUTUxcbiAgICAgICAgICAgIG5vZGUub3V0ZXJIVE1MID0gZXZhbHVhdGVkO1xuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIG9yaWdpbmFsIG5vZGUgYnkgbmV3IHRleHQgbm9kZVxuICAgICAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBldmFsdWF0ZWQgKTtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoIHRleHROb2RlLCBub2RlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICAvL3JldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIHVuZGVmaW5lZCwgc2NvcGUsIGV4cHJlc3Npb24gKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvXG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gJ1RBTFJlcGxhY2U6ICcgKyBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9jZXNzOiBwcm9jZXNzLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICAgICAgdHlwZTogVEFMUmVwbGFjZS5pZFxuICAgIH07XG59O1xuXG5UQUxSZXBsYWNlLmlkID0gJ3RhbDpyZXBsYWNlJztcblxuVEFMUmVwbGFjZS5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cbiAgICByZXR1cm4gY29udGVudEhlbHBlci5idWlsZCggXG4gICAgICAgICdUQUxSZXBsYWNlJyxcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICBmdW5jdGlvbiggX3N0cmluZywgX2V4cHJlc3Npb24sIF9zdHJ1Y3R1cmUgKXtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVEFMUmVwbGFjZSggX3N0cmluZywgX2V4cHJlc3Npb24sIF9zdHJ1Y3R1cmUgKTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRBTFJlcGxhY2U7XG4iLCIvKiBcbiAgICBhdHRyaWJ1dGVJbmRleCBzaW5nbGV0b24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZSggJy4uL3V0aWxzLmpzJyApO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIG1hcDtcbiAgICBcbiAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbigpe1xuICAgICAgICBtYXAgPSB7fTtcbiAgICB9O1xuICAgIHJlc2V0KCk7XG4gICAgXG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBub2RlLCBhdHRyaWJ1dGVJbnN0YW5jZSwgc2NvcGUgKXtcbiAgICAgICAgXG4gICAgICAgIGFkZExpc3QoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgYXR0cmlidXRlSW5zdGFuY2UsXG4gICAgICAgICAgICBhdHRyaWJ1dGVJbnN0YW5jZS5kZXBlbmRzT24oIHNjb3BlIClcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBhZGRMaXN0ID0gZnVuY3Rpb24oIG5vZGUsIGF0dHJpYnV0ZUluc3RhbmNlLCBsaXN0LCBncm91cElkICl7XG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgYWRkQW55KCBub2RlLCBhdHRyaWJ1dGVJbnN0YW5jZSwgbGlzdFsgaSBdLCBncm91cElkICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBhZGRPYmplY3QgPSBmdW5jdGlvbiggbm9kZSwgYXR0cmlidXRlSW5zdGFuY2UsIGl0ZW0gKXtcbiAgICAgICAgXG4gICAgICAgIGZvciAoIHZhciBncm91cElkIGluIGl0ZW0gKXtcbiAgICAgICAgICAgIGFkZEFueSggbm9kZSwgYXR0cmlidXRlSW5zdGFuY2UsIGl0ZW1bIGdyb3VwSWQgXSwgZ3JvdXBJZCApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYWRkQW55ID0gZnVuY3Rpb24oIG5vZGUsIGF0dHJpYnV0ZUluc3RhbmNlLCBpdGVtLCBncm91cElkICl7XG4gICAgICAgIFxuICAgICAgICBpZiAoIHV0aWxzLmlzUGxhaW5PYmplY3QoIGl0ZW0gKSApe1xuICAgICAgICAgICAgYWRkT2JqZWN0KCBub2RlLCBhdHRyaWJ1dGVJbnN0YW5jZSwgaXRlbSApO1xuICAgICAgICB9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBpdGVtICkgKXtcbiAgICAgICAgICAgIGFkZExpc3QoIG5vZGUsIGF0dHJpYnV0ZUluc3RhbmNlLCBpdGVtLCBncm91cElkICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRWYXIoIG5vZGUsIGF0dHJpYnV0ZUluc3RhbmNlLCBpdGVtLCBncm91cElkICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXG4gICAgdmFyIGFkZFZhciA9IGZ1bmN0aW9uKCBub2RlLCBhdHRyaWJ1dGVJbnN0YW5jZSwgdmFyTmFtZSwgZ3JvdXBJZCAgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBsaXN0ID0gbWFwWyB2YXJOYW1lIF07XG4gICAgICAgIGlmICggISBsaXN0ICl7XG4gICAgICAgICAgICBsaXN0ID0gW107XG4gICAgICAgICAgICBtYXBbIHZhck5hbWUgXSA9IGxpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnB1c2goXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlSW5zdGFuY2U6IGF0dHJpYnV0ZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5nZXRBdHRyaWJ1dGUoIGNvbnRleHQuZ2V0VGFncygpLmlkICksXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG4gICAgKi9cbiAgICB2YXIgYWRkVmFyID0gZnVuY3Rpb24oIG5vZGUsIGF0dHJpYnV0ZUluc3RhbmNlLCB2YXJOYW1lLCBncm91cElkICApe1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpc3QgPSBtYXBbIHZhck5hbWUgXTtcbiAgICAgICAgaWYgKCAhIGxpc3QgKXtcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIG1hcFsgdmFyTmFtZSBdID0gbGlzdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIG5ld0l0ZW0gPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVJbnN0YW5jZTogYXR0cmlidXRlSW5zdGFuY2UsXG4gICAgICAgICAgICBub2RlSWQ6IG5vZGUuZ2V0QXR0cmlidXRlKCBjb250ZXh0LmdldFRhZ3MoKS5pZCApLFxuICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy92YXIgaW5kZXggPSBsaXN0LmZpbmRJbmRleCggaXRlbSA9PiB1dGlscy5kZWVwRXF1YWwoIGl0ZW0sIG5ld0l0ZW0gKSApO1xuICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmZpbmRJbmRleCggXG4gICAgICAgICAgICBmdW5jdGlvbiggaXRlbSApIHsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmRlZXBFcXVhbCggaXRlbSwgbmV3SXRlbSApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAoIGluZGV4ID09PSAtMSApe1xuICAgICAgICAgICAgbGlzdC5wdXNoKCBuZXdJdGVtICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0WyBpbmRleCBdID0gbmV3SXRlbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIGdldFZhcnNMaXN0ID0gZnVuY3Rpb24oIHZhck5hbWUgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBpdGVtcyA9IG1hcFsgdmFyTmFtZSBdO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJuIGFuIGVtcHR5IGxpc3QgaWYgbmVlZGVkXG4gICAgICAgIGlmICggaXRlbXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgaXRlbXMgd2l0aCByZW1vdmVkIG5vZGVzXG4gICAgICAgIGNsZWFuSXRlbXMoIGl0ZW1zICk7XG4gICAgICAgIFxuICAgICAgICAvLyBXZSBtdXN0IGJ1aWxkIGFub3RoZXIgbGlzdCB0byBhdm9pZCBzeW5jIGVycm9yc1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIGl0ZW1zICk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICAvL1RPRE8gZmluZE5vZGVCeUlkIGR1cGxpY2F0ZWRcbiAgICB2YXIgZmluZE5vZGVCeUlkID0gZnVuY3Rpb24gKCBub2RlSWQgKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIFxuICAgICAgICAgICAgJ1snICsgY29udGV4dC5nZXRUYWdzKCkuaWQgKyAnPVwiJyArIG5vZGVJZCArICdcIl0nIFxuICAgICAgICApO1xuICAgIH07XG4gICAgXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGl0ZW1zIGFuZCByZW1vdmUgdGhlbSB3aGVuIG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gRE9NXG4gICAgdmFyIGNsZWFuSXRlbXMgPSBmdW5jdGlvbiggaXRlbXMgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBpbmRleGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIEJ1aWxkIGxpc3Qgb2YgaXRlbXMgdG8gcmVtb3ZlXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpICl7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zWyBpIF07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQnlJZCggaXRlbS5ub2RlSWQgKTtcbiAgICAgICAgICAgIGlmICggISBub2RlICl7XG4gICAgICAgICAgICAgICAgaW5kZXhlc1RvUmVtb3ZlLnB1c2goIGkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGl0ZW1zXG4gICAgICAgIGZvciAoIHZhciBqID0gaW5kZXhlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGogPj0gMCA7IC0taiApe1xuICAgICAgICAgICAgdmFyIGluZGV4VG9SZW1vdmUgPSBpbmRleGVzVG9SZW1vdmVbIGogXTtcbiAgICAgICAgICAgIGl0ZW1zLnNwbGljZSggaW5kZXhUb1JlbW92ZSwgMSApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcbiAgICB2YXIgcmVtb3ZlVmFyID0gZnVuY3Rpb24oIHZhck5hbWUsIG5vZGVJZCApe1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpc3QgPSBtYXBbIHZhck5hbWUgXTtcblxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBsaXN0LmZpbHRlcihcbiAgICAgICAgICAgIGZ1bmN0aW9uKCB2YWx1ZSwgaW5kZXgsIGFyciApe1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ub2RlSWQgIT09IG5vZGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBtYXBbIHZhck5hbWUgXSA9IGZpbHRlcmVkO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHJlbW92ZVZhckZyb21Ob2RlcyA9IGZ1bmN0aW9uKCB2YXJOYW1lLCBub2RlSWRzICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGlzdCA9IG1hcFsgdmFyTmFtZSBdO1xuXG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IGxpc3QuZmlsdGVyKFxuICAgICAgICAgICAgZnVuY3Rpb24oIHZhbHVlLCBpbmRleCwgYXJyICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVJZHMuaW5kZXhPZiggdmFsdWUubm9kZUlkICkgPT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICggZmlsdGVyZWQubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICBkZWxldGUgbWFwWyB2YXJOYW1lIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBbIHZhck5hbWUgXSA9IGZpbHRlcmVkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgdmFyIGdldEFsbE5vZGVJZHMgPSBmdW5jdGlvbiggdGFyZ2V0ICl7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIGxpc3RcbiAgICAgICAgdmFyIGxpc3QgPSB0YXJnZXQucXVlcnlTZWxlY3RvckFsbCggJ1snICsgY29udGV4dC5nZXRUYWdzKCkuaWQgKyAnXScgKTtcblxuICAgICAgICAvLyBJdGVyYXRlIHRoZSBsaXN0XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVJZEF0dHJpYnV0ZU5hbWUgPSBjb250ZXh0LmdldFRhZ3MoKS5pZDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICB3aGlsZSAoIG5vZGUgPSBsaXN0WyBwb3MrKyBdICkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goIFxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKCBub2RlSWRBdHRyaWJ1dGVOYW1lICkgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIHJlbW92ZU5vZGUgPSBmdW5jdGlvbiggbm9kZSApe1xuXG4gICAgICAgIHZhciBub2RlSWRzID0gZ2V0QWxsTm9kZUlkcyggbm9kZSApO1xuXG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlLmdldEF0dHJpYnV0ZSggY29udGV4dC5nZXRUYWdzKCkuaWQgKTtcbiAgICAgICAgbm9kZUlkcy5wdXNoKCBub2RlSWQgKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoIHZhciB2YXJOYW1lIGluIG1hcCApe1xuICAgICAgICAgICAgcmVtb3ZlVmFyRnJvbU5vZGVzKCB2YXJOYW1lLCBub2RlSWRzICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHZhciByZW1vdmVNdWx0aXBsZU5vZGVzID0gZnVuY3Rpb24oIG5vZGVJZHMgKXtcblxuICAgICAgICBmb3IgKCB2YXIgdmFyTmFtZSBpbiBtYXAgKXtcbiAgICAgICAgICAgIHJlbW92ZVZhckZyb21Ob2RlcyggdmFyTmFtZSwgbm9kZUlkcyApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAqL1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBnZXRWYXJzTGlzdDogZ2V0VmFyc0xpc3QsXG4gICAgICAgIC8vcmVtb3ZlVmFyOiByZW1vdmVWYXIsXG4gICAgICAgIC8vcmVtb3ZlTm9kZTogcmVtb3ZlTm9kZSxcbiAgICAgICAgLy9yZW1vdmVNdWx0aXBsZU5vZGVzOiByZW1vdmVNdWx0aXBsZU5vZGVzLFxuICAgICAgICByZXNldDogcmVzZXRcbiAgICB9O1xufSkoKTtcbiIsIi8qXG4gICAgYXR0cmlidXRlQ2FjaGUgc2luZ2xldG9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDYWNoZUhlbHBlciA9IHJlcXVpcmUoICcuL2NhY2hlSGVscGVyLmpzJyApO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcbnZhciBsb2cgPSByZXF1aXJlKCAnLi4vbG9nSGVscGVyLmpzJyApO1xudmFyIGF0dHJpYnV0ZUluZGV4ID0gcmVxdWlyZSggJy4uL2F0dHJpYnV0ZXMvYXR0cmlidXRlSW5kZXguanMnICk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIHZhciBtYXA7XG4gICAgXG4gICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbWFwID0ge307XG4gICAgfTtcbiAgICByZXNldCgpO1xuICAgIFxuICAgIHZhciBnZXQgPSBmdW5jdGlvbiggYXR0cmlidXRlLCBzdHJpbmcgKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgYXR0cmlidXRlTWFwID0gbWFwWyBhdHRyaWJ1dGUgXTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBhdHRyaWJ1dGVNYXAgKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgICBcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU1hcFsgQ2FjaGVIZWxwZXIuaGFzaENvZGUoIHN0cmluZyApIF07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcHV0ID0gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgc3RyaW5nLCB2YWx1ZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU1hcCA9IG1hcFsgYXR0cmlidXRlIF07XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgYXR0cmlidXRlTWFwICl7XG4gICAgICAgICAgICBhdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICAgICAgICAgIG1hcFsgYXR0cmlidXRlIF0gPSBhdHRyaWJ1dGVNYXA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGF0dHJpYnV0ZU1hcFsgQ2FjaGVIZWxwZXIuaGFzaENvZGUoIHN0cmluZyApIF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBpbmRleCA9IGZ1bmN0aW9uKCBub2RlLCBhdHRyaWJ1dGUsIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICBpZiAoIG5vZGUgKXtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyggJ011c3QgaW5kZXghJyApO1xuICAgICAgICAgICAgYXR0cmlidXRlSW5kZXguYWRkKCBub2RlLCBhdHRyaWJ1dGUsIHNjb3BlICk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyggJ05vdCBpbmRleGVkIScgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRCeURldGFpbHMgPSBmdW5jdGlvbiggYXR0cmlidXRlVHlwZSwgc3RyaW5nLCBidWlsZEZ1bmN0aW9uLCBmb3JjZSwgbm9kZSwgc2NvcGUgKSB7XG4gICAgICAgIFxuICAgICAgICBsb2cuZGVidWcoIFxuICAgICAgICAgICAgJ1JlcXVlc3QgYnVpbGRpbmcgb2YgWlBUIGF0dHJpYnV0ZSBcIicgKyBzdHJpbmcgKyAnXCIsIGZvcmNlIFwiJyArIGZvcmNlICsgJ1wiJyApO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGZyb20gY2FjaGUgaWYgcG9zc2libGVcbiAgICAgICAgaWYgKCBmb3JjZSB8fCAhIGNvbnRleHQuZ2V0Q29uZigpLmF0dHJpYnV0ZUNhY2hlT24gKXtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyggJ0NhY2hlIE9GRiEnICk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyggJ0NhY2hlIE9OIScgKTtcbiAgICAgICAgICAgIHZhciBmcm9tQ2FjaGUgPSBnZXQoIGF0dHJpYnV0ZVR5cGUsIHN0cmluZyApO1xuICAgICAgICAgICAgaWYgKCBmcm9tQ2FjaGUgKXtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoICdGb3VuZCBpbiBjYWNoZSEnICk7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gZnJvbUNhY2hlO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCggbm9kZSwgZnJvbUNhY2hlLCBzY29wZSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoICdOT1QgZm91bmQgaW4gY2FjaGUhJyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBidWlsZCBhbmQgcHV0IGludG8gY2FjaGVcbiAgICAgICAgbG9nLmRlYnVnKCAnTXVzdCBidWlsZCEnICk7XG4gICAgICAgIHZhciBidWlsZGVkID0gYnVpbGRGdW5jdGlvbigpO1xuICAgICAgICBwdXQoIGF0dHJpYnV0ZVR5cGUsIHN0cmluZywgYnVpbGRlZCApO1xuICAgICAgICAvL3JldHVybiBidWlsZGVkO1xuICAgICAgICByZXR1cm4gaW5kZXgoIG5vZGUsIGJ1aWxkZWQsIHNjb3BlICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0QnlBdHRyaWJ1dGVDbGFzcyA9IGZ1bmN0aW9uKCBhdHRyaWJ1dGVJbnN0YW5jZSwgc3RyaW5nLCBub2RlLCBpbmRleEV4cHJlc3Npb25zLCBzY29wZSwgY29uc3RydWN0b3IgKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZ2V0QnlEZXRhaWxzKCBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnN0YW5jZS5pZCwgXG4gICAgICAgICAgICAgICAgc3RyaW5nLCBcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvciB8fCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlSW5zdGFuY2UuYnVpbGQoIHN0cmluZyApO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGluZGV4RXhwcmVzc2lvbnM/IG5vZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzY29wZVxuICAgICAgICApO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy9nZXRCeURldGFpbHM6IGdldEJ5RGV0YWlscyxcbiAgICAgICAgZ2V0QnlBdHRyaWJ1dGVDbGFzczogZ2V0QnlBdHRyaWJ1dGVDbGFzcyxcbiAgICAgICAgcmVzZXQ6IHJlc2V0XG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIGNhY2hlSGVscGVyIHNpbmdsZXRvbiBjbGFzc1xuKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBoYXNoQ29kZSA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cbiAgICAgICAgaWYgKCBBcnJheS5wcm90b3R5cGUucmVkdWNlICkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCggXCJcIiApLnJlZHVjZShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiggYSwgYiApe1xuICAgICAgICAgICAgICAgICAgICBhID0gKCAoIGEgPDwgNSApIC0gYSApICsgYi5jaGFyQ29kZUF0KCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhJmFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIDAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNoID0gMDtcbiAgICAgICAgaWYgKCBzdHJpbmcubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBjaHIgPSBzdHJpbmcuY2hhckNvZGVBdCggaSApO1xuICAgICAgICAgICAgaGFzaCA9ICggKCBoYXNoIDw8IDUgKSAtIGhhc2ggKSArIGNocjtcbiAgICAgICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaENvZGU6IGhhc2hDb2RlXG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIGV4cHJlc3Npb25DYWNoZSBzaW5nbGV0b24gY2xhc3NcbiovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgQ2FjaGVIZWxwZXIgPSByZXF1aXJlKCAnLi9jYWNoZUhlbHBlci5qcycgKTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi9jb250ZXh0LmpzJyApO1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCAnLi4vbG9nSGVscGVyLmpzJyApO1xuICAgIFxuICAgIHZhciBtYXAgPSB7fTtcbiAgICBcbiAgICB2YXIgZ2V0ID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICAgICAgcmV0dXJuIG1hcFsgQ2FjaGVIZWxwZXIuaGFzaENvZGUoIHN0cmluZyApIF07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcHV0ID0gZnVuY3Rpb24oIHN0cmluZywgdmFsdWUgKXtcbiAgICAgICAgbWFwWyBDYWNoZUhlbHBlci5oYXNoQ29kZSggc3RyaW5nICkgXSA9IHZhbHVlO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggc3RyaW5nLCBidWlsZEZ1bmN0aW9uLCBmb3JjZSApIHtcbiAgICAgICAgXG4gICAgICAgIGxvZy5kZWJ1ZyggXG4gICAgICAgICAgICAnUmVxdWVzdCBidWlsZGluZyBvZiBleHByZXNzaW9uIFwiJyArIHN0cmluZyArICdcIiwgZm9yY2UgXCInICsgZm9yY2UgKyAnXCInICk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgZnJvbSBjYWNoZSBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAoICEgZm9yY2UgJiYgY29udGV4dC5nZXRDb25mKCkuZXhwcmVzc2lvbkNhY2hlT24gKXtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyggJ0NhY2hlIE9OIScgKTtcbiAgICAgICAgICAgIHZhciBmcm9tQ2FjaGUgPSBnZXQoIHN0cmluZyApO1xuICAgICAgICAgICAgaWYgKCBmcm9tQ2FjaGUgKXtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoICdGb3VuZCBpbiBjYWNoZSEnICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21DYWNoZTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBsb2cuZGVidWcoICdOT1QgZm91bmQgaW4gY2FjaGUhJyApO1xuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoICdDYWNoZSBPRkYhJyApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBidWlsZCBhbmQgcHV0IGludG8gY2FjaGVcbiAgICAgICAgbG9nLmRlYnVnKCAnTXVzdCBidWlsZCEnICk7XG4gICAgICAgIHZhciBidWlsZGVkID0gYnVpbGRGdW5jdGlvbigpO1xuICAgICAgICBwdXQoIHN0cmluZywgYnVpbGRlZCApO1xuICAgICAgICByZXR1cm4gYnVpbGRlZDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBjbGVhbiA9IGZ1bmN0aW9uKCApIHtcbiAgICAgICAgbWFwID0ge307XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IHByb2Nlc3MsXG4gICAgICAgIGNsZWFuOiBjbGVhblxuICAgIH07XG59KSgpO1xuIiwiLyogXG4gICAgY29udGV4dCBzaW5nbGV0b24gY2xhc3NcbiovXG5cbnZhciBsb2c0amF2YXNjcmlwdCA9IHJlcXVpcmUoICdsb2c0amF2YXNjcmlwdCcgKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApO1xudmFyIExvb3BJdGVtID0gcmVxdWlyZSggJy4vcGFyc2Vycy9sb29wSXRlbS5qcycgKTtcbnZhciBDU1NBbmltYXRpb25NYW5hZ2VyID0gcmVxdWlyZSggJy4vcGFyc2Vycy9kaWN0aW9uYXJ5QWN0aW9ucy9jc3NBbmltYXRpb25NYW5hZ2VyLmpzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICAvKiBUYWdzICovXG4gICAgdmFyIGRlZmF1bHRUYWdzID0ge1xuICAgICAgICB0YWxDb25kaXRpb246ICAgICBcImRhdGEtY29uZGl0aW9uXCIsXG4gICAgICAgIHRhbFJlcGVhdDogICAgICAgIFwiZGF0YS1yZXBlYXRcIixcbiAgICAgICAgdGFsQXR0cmlidXRlczogICAgXCJkYXRhLWF0dHJpYnV0ZXNcIixcbiAgICAgICAgdGFsQ29udGVudDogICAgICAgXCJkYXRhLWNvbnRlbnRcIixcbiAgICAgICAgdGFsRGVmaW5lOiAgICAgICAgXCJkYXRhLWRlZmluZVwiLFxuICAgICAgICB0YWxBdXRvRGVmaW5lOiAgICBcImRhdGEtdGF1dG8tZGVmaW5lXCIsXG4gICAgICAgIHRhbE9taXRUYWc6ICAgICAgIFwiZGF0YS1vbWl0LXRhZ1wiLFxuICAgICAgICB0YWxSZXBsYWNlOiAgICAgICBcImRhdGEtcmVwbGFjZVwiLFxuICAgICAgICB0YWxPbkVycm9yOiAgICAgICBcImRhdGEtb24tZXJyb3JcIixcbiAgICAgICAgdGFsRGVjbGFyZTogICAgICAgICBcImRhdGEtZGVjbGFyZVwiLFxuICAgICAgICBtZXRhbERlZmluZU1hY3JvOiBcImRhdGEtZGVmaW5lLW1hY3JvXCIsXG4gICAgICAgIG1ldGFsVXNlTWFjcm86ICAgIFwiZGF0YS11c2UtbWFjcm9cIixcbiAgICAgICAgbWV0YWxEZWZpbmVTbG90OiAgXCJkYXRhLWRlZmluZS1zbG90XCIsXG4gICAgICAgIG1ldGFsRmlsbFNsb3Q6ICAgIFwiZGF0YS1maWxsLXNsb3RcIixcbiAgICAgICAgbWV0YWxNYWNybzogICAgICAgXCJkYXRhLW1tYWNyb1wiLFxuICAgICAgICBpMThuRG9tYWluOiAgICAgICBcImRhdGEtZG9tYWluXCIsXG4gICAgICAgIGkxOG5MYW5ndWFnZTogICAgIFwiZGF0YS1sYW5ndWFnZVwiLFxuICAgICAgICAvL3Njb3BlS2V5OiAgICAgICAgIFwiZGF0YS1zY29wZS1rZXlcIixcbiAgICAgICAgcm9vdEtleTogICAgICAgICAgXCJkYXRhLXJvb3Qta2V5XCIsXG4gICAgICAgIHFkdXA6ICAgICAgICAgICAgIFwiZGF0YS1xZHVwXCIsXG4gICAgICAgIGlkOiAgICAgICAgICAgICAgIFwiZGF0YS1pZFwiLFxuICAgICAgICByZWxhdGVkSWQ6ICAgICAgICBcImRhdGEtcmVsYXRlZC1pZFwiLFxuICAgICAgICBjb25kaXRpb25SZXN1bHQ6ICBcImRhdGEtY29uZGl0aW9uLXJlc3VsdFwiXG4gICAgfTtcbiAgICB2YXIgb3JpZ2luYWxUYWdzID0ge1xuICAgICAgICB0YWxDb25kaXRpb246ICAgICBcInRhbDpjb25kaXRpb25cIixcbiAgICAgICAgdGFsUmVwZWF0OiAgICAgICAgXCJ0YWw6cmVwZWF0XCIsXG4gICAgICAgIHRhbEF0dHJpYnV0ZXM6ICAgIFwidGFsOmF0dHJpYnV0ZXNcIixcbiAgICAgICAgdGFsQ29udGVudDogICAgICAgXCJ0YWw6Y29udGVudFwiLFxuICAgICAgICB0YWxEZWZpbmU6ICAgICAgICBcInRhbDpkZWZpbmVcIixcbiAgICAgICAgdGFsQXV0b0RlZmluZTogICAgXCJ0YWw6YXV0by1kZWZpbmVcIixcbiAgICAgICAgdGFsT21pdFRhZzogICAgICAgXCJ0YWw6b21pdC10YWdcIixcbiAgICAgICAgdGFsUmVwbGFjZTogICAgICAgXCJ0YWw6cmVwbGFjZVwiLFxuICAgICAgICB0YWxPbkVycm9yOiAgICAgICBcInRhbDpvbi1lcnJvclwiLFxuICAgICAgICB0YWxEZWNsYXJlOiAgICAgICBcInRhbDpkZWNsYXJlXCIsXG4gICAgICAgIG1ldGFsRGVmaW5lTWFjcm86IFwibWV0YWw6ZGVmaW5lLW1hY3JvXCIsXG4gICAgICAgIG1ldGFsVXNlTWFjcm86ICAgIFwibWV0YWw6dXNlLW1hY3JvXCIsXG4gICAgICAgIG1ldGFsRGVmaW5lU2xvdDogIFwibWV0YWw6ZGVmaW5lLXNsb3RcIixcbiAgICAgICAgbWV0YWxGaWxsU2xvdDogICAgXCJtZXRhbDpmaWxsLXNsb3RcIixcbiAgICAgICAgbWV0YWxNYWNybzogICAgICAgXCJkYXRhLW1tYWNyb1wiLFxuICAgICAgICBpMThuRG9tYWluOiAgICAgICBcImkxOG46ZG9tYWluXCIsXG4gICAgICAgIGkxOG5MYW5ndWFnZTogICAgIFwiaTE4bjpsYW5ndWFnZVwiLFxuICAgICAgICAvL3Njb3BlS2V5OiAgICAgICAgIFwiZGF0YS1zY29wZS1rZXlcIixcbiAgICAgICAgcm9vdEtleTogICAgICAgICAgXCJkYXRhLXJvb3Qta2V5XCIsXG4gICAgICAgIHFkdXA6ICAgICAgICAgICAgIFwiZGF0YS1xZHVwXCIsXG4gICAgICAgIGlkOiAgICAgICAgICAgICAgIFwiZGF0YS1pZFwiLFxuICAgICAgICByZWxhdGVkSWQ6ICAgICAgICBcImRhdGEtcmVsYXRlZC1pZFwiLFxuICAgICAgICBjb25kaXRpb25SZXN1bHQ6ICBcImRhdGEtY29uZGl0aW9uLXJlc3VsdFwiXG4gICAgfTtcbiAgICB2YXIgdGFncyA9IGRlZmF1bHRUYWdzO1xuICAgIHZhciB0YWwgPSAnJztcbiAgICBcbiAgICB2YXIgZ2V0VGFncyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9O1xuICAgIFxuICAgIHZhciBzZXRUYWdzID0gZnVuY3Rpb24gKCB0YWdzVG9TZXQgKXtcbiAgICAgICAgdGFncyA9IHRhZ3NUb1NldDtcbiAgICAgICAgdGFsID0gJyc7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0VGFsID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIGlmICggdGFsID09PSAnJyApe1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgdmFyIG5vdEluY2x1ZGUgPSB0YWdzLnFkdXA7XG4gICAgICAgICAgICBmb3IgKCB2YXIgcHJvcGVydHkgaW4gdGFncyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIG5vdEluY2x1ZGUgPT09IHRhZ3NbIHByb3BlcnR5IF0gKXtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggYysrID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIHRhbCArPSBcIixcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFsICs9IFwiKltcIiArIHRhZ3NbIHByb3BlcnR5IF0gKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRhbDtcbiAgICB9O1xuICAgIHZhciB1c2VPcmlnaW5hbFRhZ3MgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZXRUYWdzKCBvcmlnaW5hbFRhZ3MgKTtcbiAgICB9O1xuICAgIC8qIEVuZCBUYWdzICovXG4gICAgXG4gICAgLyogRm9ybWF0dGVycyAqL1xuICAgIHZhciBmb3JtYXR0ZXJzID0ge307XG4gICAgZm9ybWF0dGVycy5sb3dlckNhc2UgPSBmdW5jdGlvbiAoIHZhbHVlICl7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy51cHBlckNhc2UgPSBmdW5jdGlvbiAoIHZhbHVlICl7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy5sb2NhbGVEYXRlID0gZnVuY3Rpb24gKCB2YWx1ZSApe1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb2NhbGVEYXRlU3RyaW5nO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy5sb2NhbGVUaW1lID0gZnVuY3Rpb24gKCB2YWx1ZSApe1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb2NhbGVUaW1lU3RyaW5nO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy5sb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAoIHZhbHVlLCBsb2NhbGUgKXtcbiAgICAgICAgcmV0dXJuIGxvY2FsZT8gXG4gICAgICAgICAgICAgICB2YWx1ZS50b0xvY2FsZVN0cmluZyggdmFsdWUsIGxvY2FsZSApOiBcbiAgICAgICAgICAgICAgIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCB2YWx1ZSApO1xuICAgIH07XG4gICAgZm9ybWF0dGVycy5maXggPSBmdW5jdGlvbiAoIG51bWJlciwgZml4VG8gKXtcbiAgICAgICAgcmV0dXJuIG51bWJlci50b0ZpeGVkKCBmaXhUbyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGdldEZvcm1hdHRlciA9IGZ1bmN0aW9uICggaWQgKXtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcnNbIGlkIF07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcmVnaXN0ZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoIGlkLCBmb3JtYXR0ZXIgKXtcbiAgICAgICAgZm9ybWF0dGVyc1sgaWQgXSA9IGZvcm1hdHRlcjtcbiAgICB9O1xuICAgIHZhciB1bnJlZ2lzdGVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKCBpZCApe1xuICAgICAgICBkZWxldGUgZm9ybWF0dGVyc1sgaWQgXTtcbiAgICB9O1xuICAgIC8qIEVuZCBGb3JtYXR0ZXJzICovXG4gICAgXG4gICAgLyogQ29uZiAqL1xuICAgIHZhciBFWFBSRVNTSU9OX1NVRkZJWCA9ICc6JztcbiAgICB2YXIgUFJJVkFURV9WQVJTX1BSRUZJWCA9ICdfJztcbiAgICB2YXIgZGVmYXVsdENvbmYgPSB7XG4gICAgICAgIHBhdGhEZWxpbWl0ZXI6ICAgICAgICAgICd8JyxcbiAgICAgICAgcGF0aFNlZ21lbnREZWxpbWl0ZXI6ICAgJy8nLFxuICAgICAgICBleHByZXNzaW9uRGVsaW1pdGVyOiAgICAnICcsXG4gICAgICAgIGludGVydmFsRGVsaW1pdGVyOiAgICAgICc6JyxcbiAgICAgICAgcHJvcGVydHlEZWxpbWl0ZXI6ICAgICAgJy8nLFxuICAgICAgICBkZWZpbmVEZWxpbWl0ZXI6ICAgICAgICAnOycsXG4gICAgICAgIGluRGVmaW5lRGVsaW1pdGVyOiAgICAgICcgJyxcbiAgICAgICAgYXR0cmlidXRlRGVsaW1pdGVyOiAgICAgJzsnLFxuICAgICAgICBpbkF0dHJpYnV0ZURlbGltaXRlcjogICAnICcsXG4gICAgICAgIGRvbWFpbkRlbGltaXRlcjogICAgICAgICcgJyxcbiAgICAgICAgaTE4bk9wdGlvbnNEZWxpbWl0ZXI6ICAgJzsnLFxuICAgICAgICBpbkkxOG5PcHRpb25zRGVsaW1pdGVyOiAnICcsXG4gICAgICAgIGFyZ3VtZW50c0RlbGltaXRlcjogICAgICcsJyxcbiAgICAgICAgbWFjcm9EZWxpbWl0ZXI6ICAgICAgICAgJ0AnLFxuICAgICAgICBkZWNsYXJlRGVsaW1pdGVyOiAgICAgICAgICc7JyxcbiAgICAgICAgaW5EZWNsYXJlRGVsaW1pdGVyOiAgICAgICAnICcsXG4gICAgICAgIFxuICAgICAgICBpMThuQ29uZlJlc291cmNlSWQ6ICAgICAgXCIvQ09ORi9cIixcbiAgICAgICAgXG4gICAgICAgIGh0bWxTdHJ1Y3R1cmVFeHByZXNzaW9uUHJlZml4OiAgXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgZ2xvYmFsVmFyaWFibGVFeHByZXNzaW9uUHJlZml4OiBcImdsb2JhbFwiLFxuICAgICAgICBub2NhbGxWYXJpYWJsZUV4cHJlc3Npb25QcmVmaXg6IFwibm9jYWxsXCIsXG4gICAgICAgIFxuICAgICAgICB0ZW1wbGF0ZUVycm9yVmFyTmFtZTogICAgXCJlcnJvclwiLFxuICAgICAgICBvbkVycm9yVmFyTmFtZTogICAgICAgICAgUFJJVkFURV9WQVJTX1BSRUZJWCArIFwib24tZXJyb3JcIixcbiAgICAgICAgb25FcnJvclN0cnVjdHVyZVZhck5hbWU6IFBSSVZBVEVfVkFSU19QUkVGSVggKyBcIm9uLWVycm9yLXN0cnVjdHVyZVwiLFxuICAgICAgICBpMThuRG9tYWluVmFyTmFtZTogICAgICAgUFJJVkFURV9WQVJTX1BSRUZJWCArIFwiaTE4bkRvbWFpblwiLFxuICAgICAgICBpMThuTGFuZ3VhZ2VWYXJOYW1lOiAgICAgUFJJVkFURV9WQVJTX1BSRUZJWCArIFwiaTE4bkxhbmd1YWdlXCIsXG4gICAgICAgIGV4dGVybmFsTWFjcm9VcmxWYXJOYW1lOiBQUklWQVRFX1ZBUlNfUFJFRklYICsgXCJleHRlcm5hbE1hY3JvVXJsXCIsXG4gICAgICAgIHN0cmljdE1vZGVWYXJOYW1lOiAgICAgICBQUklWQVRFX1ZBUlNfUFJFRklYICsgXCJzdHJpY3RNb2RlXCIsXG4gICAgICAgIGRlY2xhcmVkVmFyc1Zhck5hbWU6ICAgICBQUklWQVRFX1ZBUlNfUFJFRklYICsgXCJkZWNsYXJlZFZhcnNcIixcbiAgICAgICAgcmVwZWF0VmFyTmFtZTogICAgICAgICAgIFBSSVZBVEVfVkFSU19QUkVGSVggKyBcInJlcGVhdFwiLFxuICAgICAgICBcbiAgICAgICAgd2luZG93VmFyTmFtZTogICAgICAgICAgIFwid2luZG93XCIsXG4gICAgICAgIGNvbnRleHRWYXJOYW1lOiAgICAgICAgICBcImNvbnRleHRcIixcbiAgICAgICAgXG4gICAgICAgIG5vdGhpbmdWYXJOYW1lOiAgICAgICAgICBcIm5vdGhpbmdcIixcbiAgICAgICAgZGVmYXVsdFZhck5hbWU6ICAgICAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgICBub3RoaW5nVmFyVmFsdWU6ICAgICAgICAgXCJfX19ub3RoaW5nX19fXCIsXG4gICAgICAgIGRlZmF1bHRWYXJWYWx1ZTogICAgICAgICBcIl9fX2RlZmF1bHRfX19cIixcbiAgICAgICAgXG4gICAgICAgIGxvZ2dpbmdPbjogICAgZmFsc2UsXG4gICAgICAgIGxvZ2dpbmdMZXZlbDogbG9nNGphdmFzY3JpcHQuTGV2ZWwuRVJST1IsXG5cbiAgICAgICAgZXh0ZXJuYWxNYWNyb1ByZWZpeFVSTDogXCJcIixcbiAgICAgICAgdmFyaWFibGVOYW1lUkU6ICAgICAgICAgL15bQS1aYS16MC05Xy8tXSskLyxcbiAgICAgICAgZXhwcmVzc2lvbkNhY2hlT246ICAgICAgdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlQ2FjaGVPbjogICAgICAgdHJ1ZSxcblxuICAgICAgICBleHByZXNzaW9uU3VmZml4OiAgICAgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIHN0cmluZ0V4cHJlc3Npb246ICAgICBcInN0cmluZ1wiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIGV4aXN0c0V4cHJlc3Npb246ICAgICBcImV4aXN0c1wiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIG5vdEV4cHJlc3Npb246ICAgICAgICBcIm5vdFwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIGphdmFTY3JpcHRFeHByZXNzaW9uOiBcImpzXCIgKyBFWFBSRVNTSU9OX1NVRkZJWCxcbiAgICAgICAgZXF1YWxzRXhwcmVzc2lvbjogICAgIFwiZXFcIiArIEVYUFJFU1NJT05fU1VGRklYLFxuICAgICAgICBncmVhdGVyRXhwcmVzc2lvbjogICAgXCJndFwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIGxvd2VyRXhwcmVzc2lvbjogICAgICBcImx0XCIgKyBFWFBSRVNTSU9OX1NVRkZJWCxcbiAgICAgICAgYWRkRXhwcmVzc2lvbjogICAgICAgIFwiK1wiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIHN1YkV4cHJlc3Npb246ICAgICAgICBcIi1cIiArIEVYUFJFU1NJT05fU1VGRklYLFxuICAgICAgICBtdWxFeHByZXNzaW9uOiAgICAgICAgXCIqXCIgKyBFWFBSRVNTSU9OX1NVRkZJWCxcbiAgICAgICAgZGl2RXhwcmVzc2lvbjogICAgICAgIFwiL1wiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIG1vZEV4cHJlc3Npb246ICAgICAgICBcIiVcIiArIEVYUFJFU1NJT05fU1VGRklYLFxuICAgICAgICBvckV4cHJlc3Npb246ICAgICAgICAgXCJvclwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIGFuZEV4cHJlc3Npb246ICAgICAgICBcImFuZFwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIGNvbmRFeHByZXNzaW9uOiAgICAgICBcImNvbmRcIiArIEVYUFJFU1NJT05fU1VGRklYLFxuICAgICAgICBmb3JtYXRFeHByZXNzaW9uOiAgICAgXCJmb3JtYXRcIiArIEVYUFJFU1NJT05fU1VGRklYLFxuICAgICAgICB0ckV4cHJlc3Npb246ICAgICAgICAgXCJ0clwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIHRyTnVtYmVyRXhwcmVzc2lvbjogICBcInRyTnVtYmVyXCIgKyBFWFBSRVNTSU9OX1NVRkZJWCxcbiAgICAgICAgdHJDdXJyZW5jeUV4cHJlc3Npb246IFwidHJDdXJyZW5jeVwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIHRyRGF0ZVRpbWVFeHByZXNzaW9uOiBcInRyRGF0ZVwiICsgRVhQUkVTU0lPTl9TVUZGSVgsXG4gICAgICAgIGluRXhwcmVzc2lvbjogICAgICAgICBcImluXCIgKyBFWFBSRVNTSU9OX1NVRkZJWCxcbiAgICAgICAgcXVlcnlFeHByZXNzaW9uOiAgICAgIFwicXVlcnlcIiArIEVYUFJFU1NJT05fU1VGRklYLFxuICAgICAgICBwYXRoRXhwcmVzc2lvbjogICAgICAgXCJcIixcbiAgICAgICAgXG4gICAgICAgIGZpcnN0SW5kZXhJZGVudGlmaWVyOiBcIl9maXJzdF9cIixcbiAgICAgICAgbGFzdEluZGV4SWRlbnRpZmllcjogIFwiX2xhc3RfXCJcbiAgICB9O1xuICAgIHZhciBjb25mID0gZGVmYXVsdENvbmY7XG4gICAgXG4gICAgdmFyIGdldENvbmYgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgcmV0dXJuIGNvbmY7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgc2V0Q29uZiA9IGZ1bmN0aW9uICggY29uZlRvU2V0ICl7XG4gICAgICAgIGNvbmYgPSBjb25mVG9TZXQ7XG4gICAgfTtcbiAgICAvKiBFbmQgY29uZiAqL1xuICAgIFxuICAgIC8qIExvZ2dlciAqL1xuICAgIHZhciBsb2dnZXI7XG4gICAgdmFyIGdldERlZmF1bHRMb2dnZXIgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbG9nNGphdmFzY3JpcHQuZ2V0RGVmYXVsdExvZ2dlcigpO1xuICAgICAgICBcbiAgICAgICAgZGVmYXVsdExvZ2dlci5zZXRMZXZlbCggZ2V0Q29uZigpLmxvZ2dpbmdMZXZlbCApO1xuICAgICAgICAvL2RlZmF1bHRMb2dnZXIucmVtb3ZlQWxsQXBwZW5kZXJzKCk7XG4gICAgICAgIC8vZGVmYXVsdExvZ2dlci5hZGRBcHBlbmRlciggbmV3IGxvZzRqYXZhc2NyaXB0LkJyb3dzZXJDb25zb2xlQXBwZW5kZXIoIHRydWUgKSApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcbiAgICB2YXIgZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgbG9nZ2VyICYmIGdldENvbmYoKS5sb2dnaW5nT24gKXtcbiAgICAgICAgICAgIGxvZ2dlciA9IGdldERlZmF1bHRMb2dnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuICAgIHZhciBzZXRMb2dnZXIgPSBmdW5jdGlvbiAoIGxvZ2dlclRvU2V0ICl7XG4gICAgICAgIGxvZ2dlciA9IGxvZ2dlclRvU2V0O1xuICAgIH07XG4gICAgLyogRW5kIExvZ2dlciAqL1xuICAgIFxuICAgIC8qIFxuICAgICAgICBCb29sZWFuIGF0dHJpYnV0ZXM6XG4gICAgICAgIFRoZSBwcmVzZW5jZSBvZiBhIGJvb2xlYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgcmVwcmVzZW50cyB0aGUgdHJ1ZSB2YWx1ZSwgYW5kIHRoZSBhYnNlbmNlIG9mIHRoZSBhdHRyaWJ1dGUgcmVwcmVzZW50cyB0aGUgZmFsc2UgdmFsdWUuXG4gICAgKi9cbiAgICB2YXIgYm9vbGVhbkF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNoZWNrZWQ6IDEsXG4gICAgICAgIGNvbXBhY3Q6IDEsXG4gICAgICAgIGRlY2xhcmU6IDEsXG4gICAgICAgIGRlZmVyOiAxLFxuICAgICAgICBkaXNhYmxlZDogMSxcbiAgICAgICAgaXNtYXA6IDEsXG4gICAgICAgIG11bHRpcGxlOiAxLFxuICAgICAgICBub2hyZWY6IDEsXG4gICAgICAgIG5vcmVzaXplOiAxLFxuICAgICAgICBub3NoYWRlOiAxLFxuICAgICAgICBub3dyYXA6IDEsXG4gICAgICAgIHJlYWRvbmx5OiAxLFxuICAgICAgICBzZWxlY3RlZDogMVxuICAgIH07XG4gICAgXG4gICAgdmFyIGdldEJvb2xlYW5BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHJldHVybiBib29sZWFuQXR0cmlidXRlcztcbiAgICB9O1xuICAgIHZhciBzZXRCb29sZWFuQXR0cmlidXRlcyA9IGZ1bmN0aW9uICggYm9vbGVhbkF0dHJpYnV0ZXNUb1NldCApe1xuICAgICAgICBib29sZWFuQXR0cmlidXRlcyA9IGJvb2xlYW5BdHRyaWJ1dGVzVG9TZXQ7XG4gICAgfTtcbiAgICB2YXIgaXNCb29sZWFuQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKXtcbiAgICAgICAgcmV0dXJuIGJvb2xlYW5BdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMTtcbiAgICB9O1xuICAgIC8qIEVuZCBCb29sZWFuIGF0dHJpYnV0ZXMgKi9cbiAgICBcbiAgICAvKiBcbiAgICAgICAgQWx0IGF0dHJpYnV0ZXM6XG4gICAgICAgIEF0dHJpYnV0ZXMgd2hpY2ggZG9uJ3Qgc3VwcG9ydCBzZXRBdHRyaWJ1dGUoKS5cbiAgICAqL1xuICAgIHZhciBhbHRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBjbGFzc05hbWU6IDEsXG4gICAgICAgIGNsYXNzOiAxLFxuICAgICAgICBocmVmOiAxLFxuICAgICAgICBodG1sRm9yOiAxLFxuICAgICAgICBpZDogMSxcbiAgICAgICAgaW5uZXJIVE1MOiAxLFxuICAgICAgICBsYWJlbDogMSxcbiAgICAgICAgc3R5bGU6IDEsXG4gICAgICAgIHNyYzogMSxcbiAgICAgICAgdGV4dDogMSxcbiAgICAgICAgdGl0bGU6IDEsXG4gICAgICAgIHZhbHVlOiAxXG4gICAgfTtcbiAgICAvLyBBbGwgYm9vbGVhbkF0dHJpYnV0ZXMgYXJlIGFsc28gYWx0QXR0cmlidXRlc1xuICAgIHV0aWxzLmV4dGVuZCggYWx0QXR0cmlidXRlcywgYm9vbGVhbkF0dHJpYnV0ZXMgKTtcbiAgICBcbiAgICB2YXIgZ2V0QWx0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICByZXR1cm4gYWx0QXR0cmlidXRlcztcbiAgICB9O1xuICAgIHZhciBzZXRBbHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCBhbHRBdHRyaWJ1dGVzVG9TZXQgKXtcbiAgICAgICAgYWx0QXR0cmlidXRlcyA9IGFsdEF0dHJpYnV0ZXNUb1NldDtcbiAgICB9O1xuICAgIHZhciBpc0FsdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXR0cmlidXRlICl7XG4gICAgICAgIHJldHVybiBhbHRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMTtcbiAgICB9O1xuICAgIC8qIEVuZCBBbHQgYXR0cmlidXRlcyAqL1xuICAgIFxuICAgIC8qIEVycm9ycyAqL1xuICAgIHZhciBkZWZhdWx0RXJyb3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBtc2cgPSBBcnJheS5pc0FycmF5KCBlcnJvciApP1xuICAgICAgICAgICAgZXJyb3Iuam9pbiggJ1xcbicgKTpcbiAgICAgICAgICAgIGVycm9yO1xuICAgICAgICBcbiAgICAgICAgd2luZG93LmFsZXJ0KCBtc2cgKTtcbiAgICAgICAgXG4gICAgICAgIHRocm93IG1zZztcbiAgICB9O1xuICAgIHZhciBlcnJvckZ1bmN0aW9uID0gZGVmYXVsdEVycm9yRnVuY3Rpb247XG4gICAgdmFyIHNldEVycm9yRnVuY3Rpb24gPSBmdW5jdGlvbiggX2Vycm9yRnVuY3Rpb24gKXtcbiAgICAgICAgc2VsZi5lcnJvckZ1bmN0aW9uID0gX2Vycm9yRnVuY3Rpb247XG4gICAgfTtcbiAgICB2YXIgYXN5bmNFcnJvciA9IGZ1bmN0aW9uKCB1cmwsIGVycm9yTWVzc2FnZSwgZmFpbENhbGxiYWNrICl7XG5cbiAgICAgICAgdmFyIG1zZyA9ICdFcnJvciB0cnlpbmcgdG8gZ2V0ICcgKyB1cmwgKyAnOiAnICsgZXJyb3JNZXNzYWdlO1xuICAgICAgICBpZiAoIGZhaWxDYWxsYmFjayApe1xuICAgICAgICAgICAgZmFpbENhbGxiYWNrKCBtc2cgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yRnVuY3Rpb24oIG1zZyApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBFbmQgZXJyb3JzICovXG4gICAgXG4gICAgLyogUmVwZWF0ICovXG4gICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uKCBpbmRleCwgbGVuZ3RoLCBvZmZzZXQgKXtcbiAgICAgICAgcmV0dXJuIG5ldyBMb29wSXRlbSggaW5kZXgsIGxlbmd0aCwgb2Zmc2V0ICk7XG4gICAgfTtcbiAgICAvKiBFbmQgcmVwZWF0Ki9cbiAgICBcbiAgICAvKiBGb2xkZXIgZGljdGlvbmFyaWVzICovXG4gICAgdmFyIGZvbGRlckRpY3Rpb25hcmllcyA9IFtdO1xuICAgIHZhciBzZXRGb2xkZXJEaWN0aW9uYXJpZXMgPSBmdW5jdGlvbiggX2ZvbGRlckRpY3Rpb25hcmllcyApe1xuICAgICAgICBmb2xkZXJEaWN0aW9uYXJpZXMgPSBfZm9sZGVyRGljdGlvbmFyaWVzO1xuICAgIH07XG4gICAgdmFyIGdldEZvbGRlckRpY3Rpb25hcmllcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBmb2xkZXJEaWN0aW9uYXJpZXM7XG4gICAgfTtcbiAgICAvKiBFbmQgZm9sZGVyIGRpY3Rpb25hcmllcyAqL1xuICAgIFxuICAgIC8qIFN0cmljdCBtb2RlICAqL1xuICAgIHZhciBzdHJpY3RNb2RlID0gZmFsc2U7XG4gICAgdmFyIHNldFN0cmljdE1vZGUgPSBmdW5jdGlvbiggX3N0cmljdE1vZGUgKXtcbiAgICAgICAgc3RyaWN0TW9kZSA9IF9zdHJpY3RNb2RlO1xuICAgIH07XG4gICAgdmFyIGlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpY3RNb2RlO1xuICAgIH07XG4gICAgLyogRW5kIHN0cmljdCBtb2RlICAqL1xuICAgIFxuICAgIC8qIEV4cHJlc3Npb24gY291bnRlciAqL1xuICAgIHZhciBleHByZXNzaW9uQ291bnRlciA9IDA7XG4gICAgdmFyIG5leHRFeHByZXNzaW9uQ291bnRlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiArK2V4cHJlc3Npb25Db3VudGVyO1xuICAgIH07XG4gICAgdmFyIHNldEV4cHJlc3Npb25Db3VudGVyID0gZnVuY3Rpb24oIF9leHByZXNzaW9uQ291bnRlciApe1xuICAgICAgICBleHByZXNzaW9uQ291bnRlciA9IF9leHByZXNzaW9uQ291bnRlcjtcbiAgICB9O1xuICAgIC8qIEVuZCBleHByZXNzaW9uIGNvdW50ZXIgKi9cbiAgICBcbiAgICAvKiBSdW4gY291bnRlciAqL1xuICAgIHZhciBydW5Db3VudGVyID0gMDtcbiAgICB2YXIgbmV4dFJ1bkNvdW50ZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gKytydW5Db3VudGVyO1xuICAgIH07XG4gICAgLyogRW5kIHJ1biBjb3VudGVyICovXG4gICAgXG4gICAgLyogQW5pbWF0aW9uIG1hbmFnZXJzICovXG4gICAgdmFyIGRlZmF1bHRBbmltYXRpb25NYW5hZ2VyID0gQ1NTQW5pbWF0aW9uTWFuYWdlcjtcbiAgICB2YXIgYW5pbWF0aW9uTWFuYWdlciA9IGRlZmF1bHRBbmltYXRpb25NYW5hZ2VyO1xuICAgIHZhciBnZXRBbmltYXRpb25NYW5hZ2VyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbk1hbmFnZXI7XG4gICAgfTtcbiAgICB2YXIgc2V0QW5pbWF0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCBfYW5pbWF0aW9uTWFuYWdlciApe1xuICAgICAgICBhbmltYXRpb25NYW5hZ2VyID0gX2FuaW1hdGlvbk1hbmFnZXI7XG4gICAgfTtcbiAgICAvKiBFbmQgYW5pbWF0aW9uIG1hbmFnZXJzKi9cbiAgICBcbiAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgZ2V0VGFnczogZ2V0VGFncyxcbiAgICAgICAgc2V0VGFnczogc2V0VGFncyxcbiAgICAgICAgZ2V0VGFsOiBnZXRUYWwsXG4gICAgICAgIGdldEZvcm1hdHRlcjogZ2V0Rm9ybWF0dGVyLFxuICAgICAgICByZWdpc3RlckZvcm1hdHRlcjogcmVnaXN0ZXJGb3JtYXR0ZXIsXG4gICAgICAgIHVucmVnaXN0ZXJGb3JtYXR0ZXI6IHVucmVnaXN0ZXJGb3JtYXR0ZXIsXG4gICAgICAgIGdldENvbmY6IGdldENvbmYsXG4gICAgICAgIHNldENvbmY6IHNldENvbmYsXG4gICAgICAgIGdldExvZ2dlcjogZ2V0TG9nZ2VyLFxuICAgICAgICBzZXRMb2dnZXI6IHNldExvZ2dlcixcbiAgICAgICAgdXNlT3JpZ2luYWxUYWdzOiB1c2VPcmlnaW5hbFRhZ3MsXG4gICAgICAgIGdldEJvb2xlYW5BdHRyaWJ1dGVzOiBnZXRCb29sZWFuQXR0cmlidXRlcyxcbiAgICAgICAgc2V0Qm9vbGVhbkF0dHJpYnV0ZXM6IHNldEJvb2xlYW5BdHRyaWJ1dGVzLFxuICAgICAgICBpc0Jvb2xlYW5BdHRyaWJ1dGU6IGlzQm9vbGVhbkF0dHJpYnV0ZSxcbiAgICAgICAgZ2V0QWx0QXR0cmlidXRlczogZ2V0QWx0QXR0cmlidXRlcyxcbiAgICAgICAgc2V0QWx0QXR0cmlidXRlczogc2V0QWx0QXR0cmlidXRlcyxcbiAgICAgICAgaXNBbHRBdHRyaWJ1dGU6IGlzQWx0QXR0cmlidXRlLFxuICAgICAgICBlcnJvckZ1bmN0aW9uOiBlcnJvckZ1bmN0aW9uLFxuICAgICAgICBzZXRFcnJvckZ1bmN0aW9uOiBzZXRFcnJvckZ1bmN0aW9uLFxuICAgICAgICBhc3luY0Vycm9yOiBhc3luY0Vycm9yLFxuICAgICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgICAgc2V0Rm9sZGVyRGljdGlvbmFyaWVzOiBzZXRGb2xkZXJEaWN0aW9uYXJpZXMsXG4gICAgICAgIGdldEZvbGRlckRpY3Rpb25hcmllczogZ2V0Rm9sZGVyRGljdGlvbmFyaWVzLFxuICAgICAgICBzZXRTdHJpY3RNb2RlOiBzZXRTdHJpY3RNb2RlLFxuICAgICAgICBpc1N0cmljdE1vZGU6IGlzU3RyaWN0TW9kZSxcbiAgICAgICAgbmV4dEV4cHJlc3Npb25Db3VudGVyOiBuZXh0RXhwcmVzc2lvbkNvdW50ZXIsXG4gICAgICAgIHNldEV4cHJlc3Npb25Db3VudGVyOiBzZXRFeHByZXNzaW9uQ291bnRlcixcbiAgICAgICAgbmV4dFJ1bkNvdW50ZXI6IG5leHRSdW5Db3VudGVyLFxuICAgICAgICBnZXRBbmltYXRpb25NYW5hZ2VyOiBnZXRBbmltYXRpb25NYW5hZ2VyLFxuICAgICAgICBzZXRBbmltYXRpb25NYW5hZ2VyOiBzZXRBbmltYXRpb25NYW5hZ2VyXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc2VsZjtcbn0pKCk7XG4iLCIvKlxuICAgIEFkZEV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBhcml0aG1ldGhpY0hlbHBlciA9IHJlcXVpcmUoICcuL2FyaXRobWV0aGljSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIEFkZEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvbkxpc3RUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGV4cHJlc3Npb25MaXN0VG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcblxuICAgICAgICByZXR1cm4gYXJpdGhtZXRoaWNIZWxwZXIuZXZhbHVhdGUoIFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBleHByZXNzaW9uTGlzdCwgXG4gICAgICAgICAgICBBZGRFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24sIFxuICAgICAgICAgICAgZnVuY3Rpb24oIHRvdGFsLCB2YWx1ZSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCArIHZhbHVlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb25MaXN0ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cbkFkZEV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbkFkZEV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLmFkZEV4cHJlc3Npb247XG59O1xuQWRkRXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uID0gJ2FkZCc7XG5BZGRFeHByZXNzaW9uLmdldElkID0gQWRkRXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uO1xuXG5BZGRFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBhcml0aG1ldGhpY0hlbHBlci5idWlsZCggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBBZGRFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24gXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgQWRkRXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uTGlzdCApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGRFeHByZXNzaW9uO1xuIiwiLyogXG4gICAgYXJpdGhtZXRoaWNIZWxwZXIgc2luZ2xldG9uIGNsYXNzXG4qL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbiAgICB2YXIgRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xuICAgIHZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi9ldmFsdWF0ZUhlbHBlci5qcycgKTtcbiAgICBcbiAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nLCB0YWcgKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcblxuICAgICAgICBpZiAoIHN0cmluZy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWcgKyBcIiBleHByZXNzaW9uIHZvaWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzZWdtZW50cyA9IG5ldyBFeHByZXNzaW9uVG9rZW5pemVyKCBcbiAgICAgICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmV4cHJlc3Npb25EZWxpbWl0ZXIsIFxuICAgICAgICAgICAgICAgIGZhbHNlIFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uQnVpbGRlci5idWlsZExpc3QoIHNlZ21lbnRzICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc3RyaW5nLCBzY29wZSwgZXhwcmVzc2lvbkxpc3QsIG1hdGhPcGVyYXRpb24sIGFyaXRobWV0aGljRnVuY3Rpb24gKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmFsdWF0ZSBzZWdtZW50c1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbkxpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25MaXN0WyBpIF07XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkID0gZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCAhIEFycmF5LmlzQXJyYXkoIGV2YWx1YXRlZCApICl7IFxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgbnVtZXJpYyB2YWx1ZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NJbnRlZ2VyKCBcbiAgICAgICAgICAgICAgICAgICAgYysrLCBcbiAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVkLCBcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LCBcbiAgICAgICAgICAgICAgICAgICAgYXJpdGhtZXRoaWNGdW5jdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgIG1hdGhPcGVyYXRpb24sIFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgYXJyYXkgb2YgbnVtZXJpY1xuICAgICAgICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGV2YWx1YXRlZC5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0ludGVnZXIoIFxuICAgICAgICAgICAgICAgICAgICAgICAgYysrLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlZFsgaiBdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBhcml0aG1ldGhpY0Z1bmN0aW9uLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhPcGVyYXRpb24sIFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCBjIDwgMiApIHtcbiAgICAgICAgICAgIHRocm93ICdFcnJvciBpbiBleHByZXNzaW9uIFwiJyArIHN0cmluZyArICdcIi4gT25seSBvbmUgZWxlbWVudCBpbiBldmFsdWF0aW9uIG9mIFwiJyArIG1hdGhPcGVyYXRpb24gXG4gICAgICAgICAgICAgICAgKyAnXCIgZXhwcmVzc2lvbiwgcGxlYXNlIGFkZCBhdCBsZWFzdCBvbmUgbW9yZS4nO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIHByb2Nlc3NJbnRlZ2VyID0gZnVuY3Rpb24oIGMsIHZhbHVlLCByZXN1bHQsIGFyaXRobWV0aGljRnVuY3Rpb24sIG1hdGhPcGVyYXRpb24sIGV4cHJlc3Npb24gKXtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBldmFsdWF0ZUhlbHBlci5pc051bWJlciggdmFsdWUgKSApIHtcbiAgICAgICAgICAgIHRocm93IFwiRXJyb3IgdHJ5aW5nIGRvaW5nIG1hdGggb3BlcmF0aW9uLCB2YWx1ZSAnXCIgKyB2YWx1ZSBcbiAgICAgICAgICAgICAgICAgICAgKyBcIicgaXMgbm90IGEgdmFsaWQgbnVtYmVyIGluIGV4cHJlc3Npb24gJ1wiICsgbWF0aE9wZXJhdGlvbiArICcgJyArIGV4cHJlc3Npb24gKyBcIidcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjID09IDA/IE51bWJlciggdmFsdWUgKTogYXJpdGhtZXRoaWNGdW5jdGlvbiggcmVzdWx0LCBOdW1iZXIoIHZhbHVlICkgKTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGJ1aWxkOiBidWlsZCxcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlXG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIERpdmlkZUV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBhcml0aG1ldGhpY0hlbHBlciA9IHJlcXVpcmUoICcuL2FyaXRobWV0aGljSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIERpdmlkZUV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvbkxpc3RUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGV4cHJlc3Npb25MaXN0VG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcblxuICAgICAgICByZXR1cm4gYXJpdGhtZXRoaWNIZWxwZXIuZXZhbHVhdGUoIFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBleHByZXNzaW9uTGlzdCwgXG4gICAgICAgICAgICBEaXZpZGVFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24sIFxuICAgICAgICAgICAgZnVuY3Rpb24oIHRvdGFsLCB2YWx1ZSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCAvIHZhbHVlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgZXhwcmVzc2lvbkxpc3QgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuRGl2aWRlRXhwcmVzc2lvbi5yZW1vdmVQcmVmaXggPSB0cnVlO1xuRGl2aWRlRXhwcmVzc2lvbi5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkuZGl2RXhwcmVzc2lvbjtcbn07XG5EaXZpZGVFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24gPSAnZGl2aWRlJztcbkRpdmlkZUV4cHJlc3Npb24uZ2V0SWQgPSBEaXZpZGVFeHByZXNzaW9uLm1hdGhPcGVyYXRpb247XG5cbkRpdmlkZUV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGFyaXRobWV0aGljSGVscGVyLmJ1aWxkKCBcbiAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgIERpdmlkZUV4cHJlc3Npb24ubWF0aE9wZXJhdGlvbiBcbiAgICApO1xuXG4gICAgcmV0dXJuIG5ldyBEaXZpZGVFeHByZXNzaW9uKCBzdHJpbmcsIGV4cHJlc3Npb25MaXN0ICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpdmlkZUV4cHJlc3Npb247XG4iLCIvKlxuICAgIE1vZEV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBhcml0aG1ldGhpY0hlbHBlciA9IHJlcXVpcmUoICcuL2FyaXRobWV0aGljSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIE1vZEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvbkxpc3RUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGV4cHJlc3Npb25MaXN0VG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcblxuICAgICAgICByZXR1cm4gYXJpdGhtZXRoaWNIZWxwZXIuZXZhbHVhdGUoIFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBleHByZXNzaW9uTGlzdCwgXG4gICAgICAgICAgICBNb2RFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24sIFxuICAgICAgICAgICAgZnVuY3Rpb24oIHRvdGFsLCB2YWx1ZSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCAlIHZhbHVlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb25MaXN0ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cbk1vZEV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbk1vZEV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLm1vZEV4cHJlc3Npb247XG59O1xuTW9kRXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uID0gJ21vZCc7XG5Nb2RFeHByZXNzaW9uLmdldElkID0gTW9kRXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uO1xuXG5Nb2RFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBhcml0aG1ldGhpY0hlbHBlci5idWlsZCggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBNb2RFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24gXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgTW9kRXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uTGlzdCApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RFeHByZXNzaW9uO1xuIiwiLypcbiAgICBNdWx0aXBseUV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBhcml0aG1ldGhpY0hlbHBlciA9IHJlcXVpcmUoICcuL2FyaXRobWV0aGljSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIE11bHRpcGx5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBleHByZXNzaW9uTGlzdFRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb25MaXN0ID0gZXhwcmVzc2lvbkxpc3RUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuXG4gICAgICAgIHJldHVybiBhcml0aG1ldGhpY0hlbHBlci5ldmFsdWF0ZSggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb25MaXN0LCBcbiAgICAgICAgICAgIE11bHRpcGx5RXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uLCBcbiAgICAgICAgICAgIGZ1bmN0aW9uKCB0b3RhbCwgdmFsdWUgKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwgKiB2YWx1ZTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb25MaXN0ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cbk11bHRpcGx5RXhwcmVzc2lvbi5yZW1vdmVQcmVmaXggPSB0cnVlO1xuTXVsdGlwbHlFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0LmdldENvbmYoKS5tdWxFeHByZXNzaW9uO1xufTtcbk11bHRpcGx5RXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uID0gJ211bHRpcGx5Jztcbk11bHRpcGx5RXhwcmVzc2lvbi5nZXRJZCA9IE11bHRpcGx5RXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uO1xuXG5NdWx0aXBseUV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGFyaXRobWV0aGljSGVscGVyLmJ1aWxkKCBcbiAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgIE11bHRpcGx5RXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uIFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IE11bHRpcGx5RXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uTGlzdCApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aXBseUV4cHJlc3Npb247XG4iLCIvKlxuICAgIFN1YnN0cmFjdEV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBhcml0aG1ldGhpY0hlbHBlciA9IHJlcXVpcmUoICcuL2FyaXRobWV0aGljSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIFN1YnN0cmFjdEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvbkxpc3RUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGV4cHJlc3Npb25MaXN0VG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcblxuICAgICAgICByZXR1cm4gYXJpdGhtZXRoaWNIZWxwZXIuZXZhbHVhdGUoIFxuICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBleHByZXNzaW9uTGlzdCwgXG4gICAgICAgICAgICBTdWJzdHJhY3RFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24sIFxuICAgICAgICAgICAgZnVuY3Rpb24oIHRvdGFsLCB2YWx1ZSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3RhbCAtIHZhbHVlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb25MaXN0ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cblN1YnN0cmFjdEV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcblN1YnN0cmFjdEV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLnN1YkV4cHJlc3Npb247XG59O1xuU3Vic3RyYWN0RXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uID0gJ3N1YnN0cmFjdCc7XG5TdWJzdHJhY3RFeHByZXNzaW9uLmdldElkID0gU3Vic3RyYWN0RXhwcmVzc2lvbi5tYXRoT3BlcmF0aW9uO1xuXG5TdWJzdHJhY3RFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBhcml0aG1ldGhpY0hlbHBlci5idWlsZCggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBTdWJzdHJhY3RFeHByZXNzaW9uLm1hdGhPcGVyYXRpb24gXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgU3Vic3RyYWN0RXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uTGlzdCApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJzdHJhY3RFeHByZXNzaW9uO1xuIiwiLypcbiAgICBBbmRFeHByZXNzaW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgZXZhbHVhdGVIZWxwZXIgPSByZXF1aXJlKCAnLi4vZXZhbHVhdGVIZWxwZXIuanMnICk7XG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgQW5kRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBleHByZXNzaW9uTGlzdFRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb25MaXN0ID0gZXhwcmVzc2lvbkxpc3RUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25MaXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uTGlzdFsgaSBdO1xuICAgICAgICAgICAgaWYgKCAhIGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlQm9vbGVhbiggc2NvcGUsIGV4cHJlc3Npb24gKSApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgZXhwcmVzc2lvbkxpc3QgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuQW5kRXhwcmVzc2lvbi5yZW1vdmVQcmVmaXggPSB0cnVlO1xuQW5kRXhwcmVzc2lvbi5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkuYW5kRXhwcmVzc2lvbjtcbn07XG5BbmRFeHByZXNzaW9uLmdldElkID0gQW5kRXhwcmVzc2lvbi5nZXRQcmVmaXg7XG5cbkFuZEV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIHZhciBib29sSGVscGVyID0gcmVxdWlyZSggJy4vYm9vbEhlbHBlci5qcycgKTtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBib29sSGVscGVyLmJ1aWxkKCBzdHJpbmcsICdBbmQnICk7XG5cbiAgICByZXR1cm4gbmV3IEFuZEV4cHJlc3Npb24oIHN0cmluZywgZXhwcmVzc2lvbkxpc3QgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5kRXhwcmVzc2lvbjtcbiIsIi8qIFxuICAgIGJvb2xIZWxwZXIgc2luZ2xldG9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkgeyAgICBcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xuICAgIHZhciBFeHByZXNzaW9uVG9rZW5pemVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25Ub2tlbml6ZXIuanMnICk7XG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuICAgIFxuICAgIHZhciBidWlsZCA9IGZ1bmN0aW9uKCBzLCB0YWcgKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RyaW5nID0gcy50cmltKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIHN0cmluZy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWcgKyAnIGV4cHJlc3Npb24gdm9pZC4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgICAgIHN0cmluZywgXG4gICAgICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkuZXhwcmVzc2lvbkRlbGltaXRlciwgXG4gICAgICAgICAgICAgICAgZmFsc2UgKTtcbiAgICAgICAgaWYgKCBzZWdtZW50cy5jb3VudFRva2VucygpID09PSAxICkge1xuICAgICAgICAgICAgdGhyb3cgJ1N5bnRheCBlcnJvciBpbiBleHByZXNzaW9uIFwiJyArIHN0cmluZyArICdcIi4gT25seSBvbmUgZWxlbWVudCBpbiAnICsgdGFnICsgJyBleHByZXNzaW9uLCBwbGVhc2UgYWRkIGF0IGxlYXN0IG9uZSBtb3JlLic7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uQnVpbGRlci5idWlsZExpc3QoIHNlZ21lbnRzICk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBidWlsZDogYnVpbGRcbiAgICB9O1xufSkoKTtcbiIsIi8qXG4gICAgQ29uZEV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBFeHByZXNzaW9uVG9rZW5pemVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25Ub2tlbml6ZXIuanMnICk7XG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xudmFyIGV2YWx1YXRlSGVscGVyID0gcmVxdWlyZSggJy4uL2V2YWx1YXRlSGVscGVyLmpzJyApO1xuXG52YXIgQ29uZEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvbjFUb0FwcGx5LCBleHByZXNzaW9uMlRvQXBwbHksIGV4cHJlc3Npb24zVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgZXhwcmVzc2lvbjEgPSBleHByZXNzaW9uMVRvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24yID0gZXhwcmVzc2lvbjJUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uMyA9IGV4cHJlc3Npb24zVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBldmFsdWF0ZUhlbHBlci5ldmFsdWF0ZUJvb2xlYW4oIHNjb3BlLCBleHByZXNzaW9uMSApP1xuICAgICAgICAgICAgZXhwcmVzc2lvbjIuZXZhbHVhdGUoIHNjb3BlICk6XG4gICAgICAgICAgICBleHByZXNzaW9uMy5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb24xLCBleHByZXNzaW9uMiwgZXhwcmVzc2lvbjMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuQ29uZEV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbkNvbmRFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0LmdldENvbmYoKS5jb25kRXhwcmVzc2lvbjtcbn07XG5Db25kRXhwcmVzc2lvbi5nZXRJZCA9IENvbmRFeHByZXNzaW9uLmdldFByZWZpeDtcblxuQ29uZEV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggcyApIHtcbiAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHMudHJpbSgpO1xuXG4gICAgaWYgKCBzdHJpbmcubGVuZ3RoID09PSAwICkge1xuICAgICAgICB0aHJvdyAnQ29uZCBleHByZXNzaW9uIHZvaWQuJztcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudHMgPSBuZXcgRXhwcmVzc2lvblRva2VuaXplciggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkuZXhwcmVzc2lvbkRlbGltaXRlciwgXG4gICAgICAgICAgICBmYWxzZSApO1xuICAgIGlmICggc2VnbWVudHMuY291bnRUb2tlbnMoKSAhPT0gMyApIHtcbiAgICAgICAgdGhyb3cgJ1N5bnRheCBlcnJvciBpbiBjb25kIGV4cHJlc3Npb24gXCInICsgc3RyaW5nICsgJ1wiLiAzIGVsZW1lbnQgYXJlIG5lZWRlZC4nO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uZEV4cHJlc3Npb24oIFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzZWdtZW50cy5uZXh0VG9rZW4oKSApLCBcbiAgICAgICAgZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIHNlZ21lbnRzLm5leHRUb2tlbigpICksIFxuICAgICAgICBleHByZXNzaW9uQnVpbGRlci5idWlsZCggc2VnbWVudHMubmV4dFRva2VuKCkgKSBcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25kRXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgTm90RXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIGV2YWx1YXRlSGVscGVyID0gcmVxdWlyZSggJy4uL2V2YWx1YXRlSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIE5vdEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvblRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuICEgZXZhbHVhdGVIZWxwZXIuZXZhbHVhdGVCb29sZWFuKCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cbk5vdEV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbk5vdEV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLm5vdEV4cHJlc3Npb247XG59O1xuTm90RXhwcmVzc2lvbi5nZXRJZCA9IE5vdEV4cHJlc3Npb24uZ2V0UHJlZml4O1xuXG5Ob3RFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggc3RyaW5nICk7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBOb3RFeHByZXNzaW9uKCBzdHJpbmcsIGV4cHJlc3Npb24gKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm90RXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgT3JFeHByZXNzaW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgZXZhbHVhdGVIZWxwZXIgPSByZXF1aXJlKCAnLi4vZXZhbHVhdGVIZWxwZXIuanMnICk7XG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgT3JFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGV4cHJlc3Npb25MaXN0VG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBleHByZXNzaW9uTGlzdFRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbkxpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25MaXN0WyBpIF07XG4gICAgICAgICAgICBpZiAoIGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlQm9vbGVhbiggc2NvcGUsIGV4cHJlc3Npb24gKSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uTGlzdCApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5PckV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbk9yRXhwcmVzc2lvbi5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkub3JFeHByZXNzaW9uO1xufTtcbk9yRXhwcmVzc2lvbi5nZXRJZCA9IE9yRXhwcmVzc2lvbi5nZXRQcmVmaXg7XG5cbk9yRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgdmFyIGJvb2xIZWxwZXIgPSByZXF1aXJlKCAnLi9ib29sSGVscGVyLmpzJyApO1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGJvb2xIZWxwZXIuYnVpbGQoIHN0cmluZywgJ09yJyApO1xuXG4gICAgcmV0dXJuIG5ldyBPckV4cHJlc3Npb24oIHN0cmluZywgZXhwcmVzc2lvbkxpc3QgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT3JFeHByZXNzaW9uO1xuIiwiLyogXG4gICAgY29tcGFyaXNvbkhlbHBlciBzaW5nbGV0b24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbiAgICB2YXIgRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xuICAgIHZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi9ldmFsdWF0ZUhlbHBlci5qcycgKTtcbiAgICBcbiAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiggcywgdGFnICkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RyaW5nID0gcy50cmltKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIHN0cmluZy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWcgKyAnIGV4cHJlc3Npb24gdm9pZC4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgICAgIHN0cmluZywgXG4gICAgICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkuZXhwcmVzc2lvbkRlbGltaXRlciwgXG4gICAgICAgICAgICAgICAgZmFsc2UgKTtcbiAgICAgICAgaWYgKCBzZWdtZW50cy5jb3VudFRva2VucygpICE9PSAyICkge1xuICAgICAgICAgICAgdGhyb3cgJ1dyb25nIG51bWJlciBvZiBlbGVtZW50cyBpbiBleHByZXNzaW9uIFwiJyArIHN0cmluZyArICdcIiwgJyArIHRhZyArICcgZXhwcmVzc2lvbnMgb25seSBzdXBwb3J0IHR3by4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cHJlc3Npb24xID0gZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIHNlZ21lbnRzLm5leHRUb2tlbigpICk7XG4gICAgICAgIHZhciBleHByZXNzaW9uMiA9IGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzZWdtZW50cy5uZXh0VG9rZW4oKSApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24xOiBleHByZXNzaW9uMSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24yOiBleHByZXNzaW9uMlxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlLCB2YWx1ZUV4cHJlc3Npb24xLCB2YWx1ZUV4cHJlc3Npb24yICkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bWJlcjE6IGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlTnVtYmVyKCBzY29wZSwgdmFsdWVFeHByZXNzaW9uMSApLFxuICAgICAgICAgICAgbnVtYmVyMjogZXZhbHVhdGVIZWxwZXIuZXZhbHVhdGVOdW1iZXIoIHNjb3BlLCB2YWx1ZUV4cHJlc3Npb24yIClcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGJ1aWxkOiBidWlsZCxcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlXG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIEVxdWFsc0V4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBFeHByZXNzaW9uVG9rZW5pemVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25Ub2tlbml6ZXIuanMnICk7XG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgRXF1YWxzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBhcmdzVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgYXJncyA9IGFyZ3NUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICB2YXIgYXJnMCA9IGFyZ3NbIDAgXTtcbiAgICAgICAgdmFyIHJlc3VsdDAgPSBhcmcwLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzWyBpIF07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJnLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICAgICAgaWYgKCByZXN1bHQwICE9IHJlc3VsdCApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGFyZ3MgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5FcXVhbHNFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IHRydWU7XG5FcXVhbHNFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0LmdldENvbmYoKS5lcXVhbHNFeHByZXNzaW9uO1xufTtcbkVxdWFsc0V4cHJlc3Npb24uZ2V0SWQgPSBFcXVhbHNFeHByZXNzaW9uLmdldFByZWZpeDtcblxuRXF1YWxzRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzICkge1xuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gcy50cmltKCk7XG4gICAgXG4gICAgaWYgKCBzdHJpbmcubGVuZ3RoID09PSAwICkge1xuICAgICAgICB0aHJvdyAnRXF1YWxzIGV4cHJlc3Npb24gdm9pZC4nO1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50cyA9IG5ldyBFeHByZXNzaW9uVG9rZW5pemVyKCBcbiAgICAgICAgICAgIHN0cmluZywgXG4gICAgICAgICAgICBjb250ZXh0LmdldENvbmYoKS5leHByZXNzaW9uRGVsaW1pdGVyLCBcbiAgICAgICAgICAgIGZhbHNlICk7XG4gICAgaWYgKCBzZWdtZW50cy5jb3VudFRva2VucygpID09PSAxICkge1xuICAgICAgICB0aHJvdyAnT25seSBvbmUgZWxlbWVudCBpbiBlcXVhbHMgZXhwcmVzc2lvbiBcIicgKyBzdHJpbmcgKyAnXCIsIHBsZWFzZSBhZGQgYXQgbGVhc3Qgb25lIG1vcmUuJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVxdWFsc0V4cHJlc3Npb24oIFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkTGlzdCggc2VnbWVudHMgKSBcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFcXVhbHNFeHByZXNzaW9uO1xuIiwiLypcbiAgICBHcmVhdGVyRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIGNvbXBhcmlzb25IZWxwZXIgPSByZXF1aXJlKCAnLi9jb21wYXJpc29uSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIEdyZWF0ZXJFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGV4cHJlc3Npb24xVG9BcHBseSwgZXhwcmVzc2lvbjJUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uMSA9IGV4cHJlc3Npb24xVG9BcHBseTtcbiAgICB2YXIgZXhwcmVzc2lvbjIgPSBleHByZXNzaW9uMlRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIHZhciBudW1iZXJzID0gY29tcGFyaXNvbkhlbHBlci5ldmFsdWF0ZSggc2NvcGUsIGV4cHJlc3Npb24xLCBleHByZXNzaW9uMiApO1xuICAgICAgICByZXR1cm4gbnVtYmVycy5udW1iZXIxID4gbnVtYmVycy5udW1iZXIyO1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuR3JlYXRlckV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbkdyZWF0ZXJFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0LmdldENvbmYoKS5ncmVhdGVyRXhwcmVzc2lvbjtcbn07XG5HcmVhdGVyRXhwcmVzc2lvbi5nZXRJZCA9IEdyZWF0ZXJFeHByZXNzaW9uLmdldFByZWZpeDtcblxuR3JlYXRlckV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciBkYXRhID0gY29tcGFyaXNvbkhlbHBlci5idWlsZCggc3RyaW5nLCAnZ3JlYXRlcicgKTtcblxuICAgIHJldHVybiBuZXcgR3JlYXRlckV4cHJlc3Npb24oIHN0cmluZywgZGF0YS5leHByZXNzaW9uMSwgZGF0YS5leHByZXNzaW9uMiApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmVhdGVyRXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgSW5FeHByZXNzaW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIEluRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBleHByZXNzaW9uTGlzdFRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb25MaXN0ID0gZXhwcmVzc2lvbkxpc3RUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjAgPSBleHByZXNzaW9uTGlzdFsgMCBdO1xuICAgICAgICB2YXIgZXZhbHVhdGVkMCA9IGV4cHJlc3Npb24wLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAxOyBpIDwgZXhwcmVzc2lvbkxpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25MaXN0WyBpIF07XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkID0gZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBldmFsdWF0ZWQgKSApeyBcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBldmFsdWF0ZWQubGVuZ3RoOyBqKysgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggZXZhbHVhdGVkMCA9PSBldmFsdWF0ZWRbIGogXSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICggZXZhbHVhdGVkMCA9PSBldmFsdWF0ZWQgKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uTGlzdCApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5JbkV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbkluRXhwcmVzc2lvbi5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkuaW5FeHByZXNzaW9uO1xufTtcbkluRXhwcmVzc2lvbi5nZXRJZCA9IEluRXhwcmVzc2lvbi5nZXRQcmVmaXg7XG5cbkluRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzICkge1xuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gcy50cmltKCk7XG4gICAgXG4gICAgaWYgKCBzdHJpbmcubGVuZ3RoID09PSAwICkge1xuICAgICAgICB0aHJvdyAnSW4gZXhwcmVzc2lvbiB2b2lkLic7XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnRzID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgc3RyaW5nLCBcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmV4cHJlc3Npb25EZWxpbWl0ZXIsIFxuICAgICAgICAgICAgZmFsc2UgXG4gICAgKTtcbiAgICBpZiAoIHNlZ21lbnRzLmNvdW50VG9rZW5zKCkgPT09IDEgKSB7XG4gICAgICAgIHRocm93ICdPbmx5IG9uZSBlbGVtZW50IGluIGluIGV4cHJlc3Npb24gXCInICsgc3RyaW5nICsgJ1wiLCBwbGVhc2UgYWRkIGF0IGxlYXN0IG9uZSBtb3JlLic7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbkV4cHJlc3Npb24oIFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkTGlzdCggc2VnbWVudHMgKSBcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbkV4cHJlc3Npb247XG4iLCIvKlxuICAgIExvd2VyRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIGNvbXBhcmlzb25IZWxwZXIgPSByZXF1aXJlKCAnLi9jb21wYXJpc29uSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIExvd2VyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBleHByZXNzaW9uMVRvQXBwbHksIGV4cHJlc3Npb24yVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgZXhwcmVzc2lvbjEgPSBleHByZXNzaW9uMVRvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24yID0gZXhwcmVzc2lvbjJUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICB2YXIgbnVtYmVycyA9IGNvbXBhcmlzb25IZWxwZXIuZXZhbHVhdGUoIHNjb3BlLCBleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIgKTtcbiAgICAgICAgcmV0dXJuIG51bWJlcnMubnVtYmVyMSA8IG51bWJlcnMubnVtYmVyMjtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb24xLCBleHByZXNzaW9uMiApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5Mb3dlckV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbkxvd2VyRXhwcmVzc2lvbi5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkubG93ZXJFeHByZXNzaW9uO1xufTtcbkxvd2VyRXhwcmVzc2lvbi5nZXRJZCA9IExvd2VyRXhwcmVzc2lvbi5nZXRQcmVmaXg7XG5cbkxvd2VyRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgXG4gICAgdmFyIGRhdGEgPSBjb21wYXJpc29uSGVscGVyLmJ1aWxkKCBzdHJpbmcsICdsb3dlcicgKTtcblxuICAgIHJldHVybiBuZXcgTG93ZXJFeHByZXNzaW9uKCBzdHJpbmcsIGRhdGEuZXhwcmVzc2lvbjEsIGRhdGEuZXhwcmVzc2lvbjIgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG93ZXJFeHByZXNzaW9uO1xuIiwiLyogXG4gICAgZXZhbHVhdGVIZWxwZXIgc2luZ2xldG9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uL2NvbnRleHQuanMnICk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIHZhciBldmFsdWF0ZVRvTm90TnVsbCA9IGZ1bmN0aW9uKCBzY29wZSwgZXhwcmVzc2lvbiApIHtcbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWQgPT0gdW5kZWZpbmVkPyAndW5kZWZpbmVkJzogZXZhbHVhdGVkO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlQm9vbGVhbiA9IGZ1bmN0aW9uKCBzY29wZSwgZXhwcmVzc2lvbiApIHtcbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIGV2YWx1YXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICB8fCBldmFsdWF0ZWQgPT0gbnVsbFxuICAgICAgICAgICAgfHwgZXZhbHVhdGVkID09ICdmYWxzZScgXG4gICAgICAgICAgICB8fCBldmFsdWF0ZWQgPT0gZmFsc2UgXG4gICAgICAgICAgICB8fCBldmFsdWF0ZWQgPT0gMCApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZU51bWJlciA9IGZ1bmN0aW9uKCBzY29wZSwgZXhwcmVzc2lvbiwgZXJyb3JNZXNzYWdlVG9BcHBseSApIHtcbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgaXNOdW1iZXIoIGV2YWx1YXRlZCApICl7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlVG9BcHBseT8gXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlVG9BcHBseTogXG4gICAgICAgICAgICAgICAgJ0V4cHJlc3Npb24gXCInICsgZXhwcmVzc2lvbiArICdcIiBpcyBub3QgYSB2YWxpZCBudW1iZXIuJztcbiAgICAgICAgICAgIHRocm93IGVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgICAgICAgcmV0dXJuICEgaXNOYU4oIHBhcnNlRmxvYXQoIHN0cmluZyApICkgfHwgISBpc0Zpbml0ZSggc3RyaW5nICk7XG4gICAgfTtcbiAgICAvKlxuICAgIHZhciBldmFsdWF0ZUludGVnZXIgPSBmdW5jdGlvbiggc2NvcGUsIGV4cHJlc3Npb24sIGVycm9yTWVzc2FnZVRvQXBwbHkgKSB7XG4gICAgICAgIHZhciBldmFsdWF0ZWQgPSBleHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCAhIGlzSW50ZWdlciggZXZhbHVhdGVkICkgKXtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VUb0FwcGx5PyBcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VUb0FwcGx5OiBcbiAgICAgICAgICAgICAgICAnRXhwcmVzc2lvbiBcIicgKyBleHByZXNzaW9uICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGludGVnZXIuJ1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZXZhbHVhdGVkO1xuICAgIH07Ki9cbiAgICAvKlxuICAgIHZhciBpc0ludGVnZXIgPSBmdW5jdGlvbiggc3RyaW5nICl7XG4gICAgICAgIHJldHVybiAhIGlzTmFOKCBwYXJzZUludCggc3RyaW5nICkgKSB8fCAhIGlzRmluaXRlKCBzdHJpbmcgKTtcbiAgICB9OyovXG4gICAgXG4gICAgdmFyIGV2YWx1YXRlRXhwcmVzc2lvbkxpc3QgPSBmdW5jdGlvbiAoIGxpc3QsIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBsaXN0WyBpIF07XG4gICAgICAgICAgICByZXN1bHQucHVzaCggZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIGlzRGVmYXVsdCA9IGZ1bmN0aW9uKCB2YWx1ZSApe1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGNvbnRleHQuZ2V0Q29uZigpLmRlZmF1bHRWYXJWYWx1ZTtcbiAgICB9O1xuICAgIHZhciBpc05vdGhpbmcgPSBmdW5jdGlvbiggdmFsdWUgKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBjb250ZXh0LmdldENvbmYoKS5ub3RoaW5nVmFyVmFsdWU7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZVRvTm90TnVsbDogZXZhbHVhdGVUb05vdE51bGwsXG4gICAgICAgIGV2YWx1YXRlQm9vbGVhbjogZXZhbHVhdGVCb29sZWFuLFxuICAgICAgICBldmFsdWF0ZU51bWJlcjogZXZhbHVhdGVOdW1iZXIsXG4gICAgICAgIC8vZXZhbHVhdGVJbnRlZ2VyOiBldmFsdWF0ZUludGVnZXIsXG4gICAgICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICAgICAgLy9pc0ludGVnZXI6IGlzSW50ZWdlcixcbiAgICAgICAgZXZhbHVhdGVFeHByZXNzaW9uTGlzdDogZXZhbHVhdGVFeHByZXNzaW9uTGlzdCxcbiAgICAgICAgaXNEZWZhdWx0OiBpc0RlZmF1bHQsXG4gICAgICAgIGlzTm90aGluZzogaXNOb3RoaW5nXG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIEV4aXN0c0V4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcblxudmFyIEV4aXN0c0V4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvblRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkICE9PSBleHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKCBlICl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgZXhwcmVzc2lvbiApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5FeGlzdHNFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IHRydWU7XG5FeGlzdHNFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0LmdldENvbmYoKS5leGlzdHNFeHByZXNzaW9uO1xufTtcbkV4aXN0c0V4cHJlc3Npb24uZ2V0SWQgPSBFeGlzdHNFeHByZXNzaW9uLmdldFByZWZpeDtcblxuRXhpc3RzRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggc3RyaW5nICk7XG4gICAgcmV0dXJuIG5ldyBFeGlzdHNFeHByZXNzaW9uKCBzdHJpbmcsIGV4cHJlc3Npb24gKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhpc3RzRXhwcmVzc2lvbjtcbiIsIi8qIFxuICAgIGV4cHJlc3Npb25CdWlsZGVyIHNpbmdsZXRvbiBjbGFzc1xuKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uL2NvbnRleHQuanMnICk7XG4gICAgdmFyIEV4cHJlc3Npb25Ub2tlbml6ZXIgPSByZXF1aXJlKCAnLi9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xuICAgIHZhciBQYXRoRXhwcmVzc2lvbiA9IHJlcXVpcmUoICcuL3BhdGgvcGF0aEV4cHJlc3Npb24uanMnICk7XG4gICAgdmFyIGV4cHJlc3Npb25DYWNoZSA9IHJlcXVpcmUoICcuLi9jYWNoZS9leHByZXNzaW9uQ2FjaGUuanMnICk7XG4gICAgLyp2YXIgbG9nID0gcmVxdWlyZSggJy4uL2xvZ0hlbHBlci5qcycgKTsqL1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uTWFuYWdlcnMgPSB7fTtcbiAgICB2YXIgd2l0aG91dFByZWZpeEV4cHJlc3Npb25NYW5hZ2VycyA9IHt9O1xuICAgIHZhciBERUZBVUxUX0lEID0gUGF0aEV4cHJlc3Npb24uZ2V0SWQoKTtcbiAgICBcbiAgICAvKiBSZWdpc3RlciBleHByZXNzaW9uIG1hbmFnZXJzICovXG4gICAgdmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24oIGV4cHJlc3Npb25zTWFuYWdlciwgaWQgKSB7XG4gICAgICAgIGV4cHJlc3Npb25NYW5hZ2Vyc1sgaWQgfHwgZXhwcmVzc2lvbnNNYW5hZ2VyLmdldFByZWZpeCgpIHx8IGV4cHJlc3Npb25zTWFuYWdlci5nZXRJZCgpIF0gPSBleHByZXNzaW9uc01hbmFnZXI7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgZXhwcmVzc2lvbnNNYW5hZ2VyLnJlbW92ZVByZWZpeCAmJiBleHByZXNzaW9uc01hbmFnZXIuZ2V0UHJlZml4KCkgKXtcbiAgICAgICAgICAgIHdpdGhvdXRQcmVmaXhFeHByZXNzaW9uTWFuYWdlcnNbIGV4cHJlc3Npb25zTWFuYWdlci5nZXRQcmVmaXgoKSBdID0gZXhwcmVzc2lvbnNNYW5hZ2VyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdW5yZWdpc3RlciA9IGZ1bmN0aW9uKCBleHByZXNzaW9uc01hbmFnZXIsIGlkICkge1xuICAgICAgICBkZWxldGUgZXhwcmVzc2lvbk1hbmFnZXJzWyBpZCB8fCBleHByZXNzaW9uc01hbmFnZXIuZ2V0UHJlZml4KCkgfHwgZXhwcmVzc2lvbnNNYW5hZ2VyLmdldElkKCkgXTtcbiAgICB9O1xuICAgIFxuICAgIHZhciByZWdpc3RlckdlbmVyYWxQdXJwb3NlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmVnaXN0ZXIoIHJlcXVpcmUoICcuL2V4aXN0c0V4cHJlc3Npb24uanMnICkgKTtcbiAgICAgICAgcmVnaXN0ZXIoIHJlcXVpcmUoICcuL2Zvcm1hdEV4cHJlc3Npb24uanMnICkgKTtcbiAgICAgICAgcmVnaXN0ZXIoIHJlcXVpcmUoICcuL3N0cmluZ0V4cHJlc3Npb24uanMnICkgKTtcbiAgICAgICAgcmVnaXN0ZXIoIHJlcXVpcmUoICcuL3BhdGgvcGF0aEV4cHJlc3Npb24uanMnICkgKTtcbiAgICB9O1xuICAgIHZhciByZWdpc3RlckNvbXBhcmlzb24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vY29tcGFyaXNvbi9lcXVhbHNFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9jb21wYXJpc29uL2dyZWF0ZXJFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9jb21wYXJpc29uL2xvd2VyRXhwcmVzc2lvbi5qcycgKSApO1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vY29tcGFyaXNvbi9pbkV4cHJlc3Npb24uanMnICkgKTtcbiAgICB9O1xuICAgIHZhciByZWdpc3RlckFyaXRobWV0aWMgPSBmdW5jdGlvbigpe1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vYXJpdGhtZXRoaWMvYWRkRXhwcmVzc2lvbi5qcycgKSApO1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vYXJpdGhtZXRoaWMvc3Vic3RyYWN0RXhwcmVzc2lvbi5qcycgKSApO1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vYXJpdGhtZXRoaWMvbXVsdGlwbHlFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9hcml0aG1ldGhpYy9kaXZpZGVFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9hcml0aG1ldGhpYy9tb2RFeHByZXNzaW9uLmpzJyApICk7XG4gICAgfTtcbiAgICB2YXIgcmVnaXN0ZXJMb2dpY2FsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmVnaXN0ZXIoIHJlcXVpcmUoICcuL2Jvb2wvYW5kRXhwcmVzc2lvbi5qcycgKSApO1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vYm9vbC9jb25kRXhwcmVzc2lvbi5qcycgKSApO1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vYm9vbC9ub3RFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9ib29sL29yRXhwcmVzc2lvbi5qcycgKSApO1xuICAgIH07XG4gICAgdmFyIHJlZ2lzdGVySTE4biA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9pMThuL3RyQ3VycmVuY3lFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9pMThuL3RyRGF0ZVRpbWVFeHByZXNzaW9uLmpzJyApICk7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9pMThuL3RyTnVtYmVyRXhwcmVzc2lvbi5qcycgKSApO1xuICAgICAgICByZWdpc3RlciggcmVxdWlyZSggJy4vaTE4bi90clN0cmluZ0V4cHJlc3Npb24uanMnICkgKTtcbiAgICB9O1xuICAgIHZhciByZWdpc3RlclNjcmlwdGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlZ2lzdGVyKCByZXF1aXJlKCAnLi9zY3JpcHRpbmcvamF2YXNjcmlwdEV4cHJlc3Npb24uanMnICkgKTtcbiAgICAgICAgcmVnaXN0ZXIoIHJlcXVpcmUoICcuL3NjcmlwdGluZy9xdWVyeUV4cHJlc3Npb24uanMnICkgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciByZWdpc3RlckFsbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlZ2lzdGVyR2VuZXJhbFB1cnBvc2UoKTtcbiAgICAgICAgcmVnaXN0ZXJDb21wYXJpc29uKCk7XG4gICAgICAgIHJlZ2lzdGVyQXJpdGhtZXRpYygpO1xuICAgICAgICByZWdpc3RlckxvZ2ljYWwoKTtcbiAgICAgICAgcmVnaXN0ZXJJMThuKCk7XG4gICAgICAgIHJlZ2lzdGVyU2NyaXB0aW5nKCk7XG4gICAgfSgpO1xuICAgIC8qIEVuZCBSZWdpc3RlciBleHByZXNzaW9uIG1hbmFnZXJzICovXG4gICAgXG4gICAgdmFyIGJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZywgZm9yY2UgKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uQ2FjaGUuZ2V0KFxuICAgICAgICAgICAgICAgIHN0cmluZywgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcmNlQnVpbGQoIHN0cmluZyApO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIGZvcmNlXG4gICAgICAgICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZm9yY2VCdWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgICAgIHZhciBlZmZlY3RpdmVTdHJpbmcgPSByZW1vdmVQYXJlbnRoZXNpc0lmQW55KCBzdHJpbmcudHJpbSgpICk7XG4gICAgICAgIHZhciBpbmRleCA9IGVmZmVjdGl2ZVN0cmluZy5pbmRleE9mKCBjb250ZXh0LmdldENvbmYoKS5leHByZXNzaW9uU3VmZml4ICk7XG4gICAgICAgIHZhciBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gSXMgdGhlIGRlZmF1bHQgZXhwcmVzc2lvbiB0eXBlPyBJcyByZWdpc3RlcmVkP1xuICAgICAgICBpZiAoIGluZGV4ICE9PSAtMSApe1xuICAgICAgICAgICAgaWQgPSBlZmZlY3RpdmVTdHJpbmcuc3Vic3RyaW5nKCAwLCBpbmRleCApICArICc6JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIGlkIGlzIG5vdCByZXNpc3RlcmVkIG11c3QgYmUgYSBwYXRoXG4gICAgICAgICAgICBpc0RlZmF1bHQgPSAhIGV4cHJlc3Npb25NYW5hZ2Vycy5oYXNPd25Qcm9wZXJ0eSggaWQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBwcmVmaXggYW5kIHNldCBpZCBpZiBpdCBpcyBkZWZhdWx0IGV4cHJlc3Npb24gdHlwZVxuICAgICAgICB2YXIgcmVtb3ZlUHJlZml4ID0gZmFsc2U7XG4gICAgICAgIHZhciBleHByZXNzaW9uTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCBpc0RlZmF1bHQgKXtcbiAgICAgICAgICAgIC8qaWQgPSBERUZBVUxUX0lEOyovXG4gICAgICAgICAgICBleHByZXNzaW9uTWFuYWdlciA9IGdldFdpdGhvdXRQcmVmaXhFeHByZXNzaW9uTWFuYWdlciggZWZmZWN0aXZlU3RyaW5nICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVQcmVmaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIGV4cHJlc3Npb24gbWFuYWdlciBhbmQgYnVpbGQgdGhlIGV4cHJlc3Npb25cbiAgICAgICAgZXhwcmVzc2lvbk1hbmFnZXIgPSBleHByZXNzaW9uTWFuYWdlciB8fCBleHByZXNzaW9uTWFuYWdlcnNbIGlkIF07XG4gICAgICAgIHZhciBmaW5hbFN0cmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCByZW1vdmVQcmVmaXggJiYgZXhwcmVzc2lvbk1hbmFnZXIucmVtb3ZlUHJlZml4ICl7XG4gICAgICAgICAgICBmaW5hbFN0cmluZyA9IGVmZmVjdGl2ZVN0cmluZy5zdWJzdHIoIGlkLmxlbmd0aCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmluYWxTdHJpbmcgPSBlZmZlY3RpdmVTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25NYW5hZ2VyLmJ1aWxkKCBmaW5hbFN0cmluZyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGdldFdpdGhvdXRQcmVmaXhFeHByZXNzaW9uTWFuYWdlciA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgICAgICAgXG4gICAgICAgIGZvciAoIHZhciBwcmVmaXggaW4gd2l0aG91dFByZWZpeEV4cHJlc3Npb25NYW5hZ2VycyApIHtcbiAgICAgICAgICAgIGlmICggc3RyaW5nLmluZGV4T2YoIHByZWZpeCApID09PSAwICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRob3V0UHJlZml4RXhwcmVzc2lvbk1hbmFnZXJzWyBwcmVmaXggXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25NYW5hZ2Vyc1sgREVGQVVMVF9JRCBdO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGJ1aWxkTGlzdCA9IGZ1bmN0aW9uKCBzZWdtZW50cyApIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICggc2VnbWVudHMuaGFzTW9yZVRva2VucygpICkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKFxuICAgICAgICAgICAgICAgIGJ1aWxkKCBcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMubmV4dFRva2VuKCkudHJpbSgpICApICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIFxuICAgIHZhciByZW1vdmVQcmVmaXggPSBmdW5jdGlvbiggc3RyaW5nLCBwcmVmaXggKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKCBwcmVmaXgubGVuZ3RoICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcmVtb3ZlUHJlZml4QW5kQnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nLCBwcmVmaXggKSB7XG4gICAgICAgIHJldHVybiBidWlsZChcbiAgICAgICAgICAgICAgICBzdHJpbmcuc3Vic3RyKCBwcmVmaXgubGVuZ3RoICkpO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHJlbW92ZVBhcmVudGhlc2lzSWZBbnkgPSBmdW5jdGlvbiggdG9rZW4gKXtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZVRva2VuID0gdG9rZW4udHJpbSgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCBlZmZlY3RpdmVUb2tlbiA9PSAnJyApe1xuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdGl2ZVRva2VuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIGVmZmVjdGl2ZVRva2VuLmNoYXJBdCggMCApID09PSAnKCcgKXtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVQYXJlbnRoZXNpc0lmQW55KCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVRva2VuLnN1YnN0cmluZyggMSwgZWZmZWN0aXZlVG9rZW4ubGFzdEluZGV4T2YoICcpJyApICkudHJpbSgpICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBlZmZlY3RpdmVUb2tlbjtcbiAgICB9O1xuICAgIFxuICAgIHZhciBlbmRzV2l0aCA9IGZ1bmN0aW9uKCBzdHIsIHN1ZmZpeCApIHtcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKCBzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoICkgIT09IC0xO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGdldEFyZ3VtZW50c0Zyb21TdHJpbmcgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgYW5kIGV2YWx1YXRlIGFyZ3VtZW50czsgdGhlbiBwdXNoIHRoZW0gdG8gYW4gYXJyYXlcbiAgICAgICAgdmFyIHRva2VucyA9IG5ldyBFeHByZXNzaW9uVG9rZW5pemVyKCBcbiAgICAgICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmFyZ3VtZW50c0RlbGltaXRlciwgXG4gICAgICAgICAgICAgICAgdHJ1ZSApO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB3aGlsZSAoIHRva2Vucy5oYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0cmluZyA9IHRva2Vucy5uZXh0VG9rZW4oKS50cmltKCk7XG4gICAgICAgICAgICBhcmdzLnB1c2goIFxuICAgICAgICAgICAgICAgICAgICBidWlsZCggY3VycmVudFN0cmluZyApICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICAgICAgICB1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyLFxuICAgICAgICByZWdpc3RlckFsbDogcmVnaXN0ZXJBbGwsXG4gICAgICAgIGJ1aWxkOiBidWlsZCxcbiAgICAgICAgYnVpbGRMaXN0OiBidWlsZExpc3QsXG4gICAgICAgIHJlbW92ZVByZWZpeDogcmVtb3ZlUHJlZml4LFxuICAgICAgICByZW1vdmVQcmVmaXhBbmRCdWlsZDogcmVtb3ZlUHJlZml4QW5kQnVpbGQsXG4gICAgICAgIHJlbW92ZVBhcmVudGhlc2lzSWZBbnk6IHJlbW92ZVBhcmVudGhlc2lzSWZBbnksXG4gICAgICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgICAgICAgZ2V0QXJndW1lbnRzRnJvbVN0cmluZzogZ2V0QXJndW1lbnRzRnJvbVN0cmluZ1xuICAgIH07XG59KSgpO1xuIiwiLyogXG4gICAgQ2xhc3MgRXhwcmVzc2lvblRva2VuaXplciBcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBleHAsIGRlbGltaXRlciwgZXNjYXBlICkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuICAgIHZhciByZW1vdmVQYXJlbnRoZXNpc0lmQW55ID0gZXhwcmVzc2lvbkJ1aWxkZXIucmVtb3ZlUGFyZW50aGVzaXNJZkFueTtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cC50cmltKCk7XG5cbiAgICB2YXIgaXRlcmF0b3I7XG4gICAgdmFyIGN1cnJJbmRleCA9IDA7XG4gICAgdmFyIGRlbGltaXRlckNvdW50ID0gMDtcbiAgICB2YXIgZGVsaW1pdGVycyA9IFtdO1xuICAgIFxuICAgIHZhciBtYWtlSXRlcmF0b3IgPSBmdW5jdGlvbiggYXJyYXkgKXtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgYXJyYXkubGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICBhcnJheSBbIG5leHRJbmRleCsrIF0gOlxuICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNOZXh0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXggPCBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgYW5hbHl6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhdm9pZFJlcGVhdGVkU2VwYXJhdG9ycyA9IGRlbGltaXRlciA9PT0gJyAnO1xuICAgICAgICBcbiAgICAgICAgLy8gR28gYWhlYWQgYW5kIGZpbmQgZGVsaW1pdGVycywgaWYgYW55LCBhdCBjb25zdHJ1Y3Rpb24gdGltZVxuICAgICAgICB2YXIgcGFyZW50TGV2ZWwgPSAwO1xuICAgICAgICB2YXIgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJldmlvdXNDaCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgLy8gU2NhbiBmb3IgZGVsaW1pdGVyc1xuICAgICAgICB2YXIgbGVuZ3RoID0gZXhwcmVzc2lvbi5sZW5ndGg7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGNoID0gZXhwcmVzc2lvbi5jaGFyQXQoIGkgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCBjaCA9PT0gZGVsaW1pdGVyICkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRlbGltaXRlciBpcyBub3QgYnVyaWVkIGluIHBhcmVudGhlc2VzIG9yIGEgcXVvdGVcbiAgICAgICAgICAgICAgICBpZiAoIHBhcmVudExldmVsID09PSAwICYmICEgaW5RdW90ZSAgKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIGF2b2lkUmVwZWF0ZWRTZXBhcmF0b3JzICYmICggcHJldmlvdXNDaCA9PT0gZGVsaW1pdGVyIHx8IHByZXZpb3VzQ2ggPT09ICdcXG4nICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaCA9ICggaSArIDEgPCBsZW5ndGggKSA/IGV4cHJlc3Npb24uY2hhckF0KCBpICsgMSApIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgaWYgZGVsaW1pdGVyIGlzIG5vdCBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICggISAoIGVzY2FwZSAmJiBuZXh0Q2ggPT09IGRlbGltaXRlciApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlcnMucHVzaCggaSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXdoYXQgaW5lZmZpY2llbnQgd2F5IHRvIHBhcmUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGVkIGRlbGltaXRlciBkb3duIHRvIGEgc2luZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgd2l0aG91dCBicmVha2luZyBvdXIgc3RyaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcoIDAsIGkgKyAxICkgKyBleHByZXNzaW9uLnN1YnN0cmluZyggaSArIDIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHBhcmVudGhlc2lzIGxldmVsXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PT0gJygnIHx8IGNoID09PSAnWycgKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50TGV2ZWwrKztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERlY3JlbWVudCBwYXJlbnRoZXNpcyBsZXZlbFxuICAgICAgICAgICAgfSBlbHNlIGlmICggY2ggPT09ICcpJyB8fCBjaCA9PT0gJ10nICkge1xuICAgICAgICAgICAgICAgIHBhcmVudExldmVsLS07XG4gICAgICAgICAgICAgICAgLy8gSWYgdW5tYXRjaGVkIHJpZ2h0IHBhcmVudGhlc2lzXG4gICAgICAgICAgICAgICAgaWYgKCBwYXJlbnRMZXZlbCA8IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdTeW50YXggZXJyb3IuIFVubWF0Y2hlZCByaWdodCBwYXJlbnRoZXNpczogJyArIGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RhcnQgb3IgZW5kIHF1b3RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PT0gJ1xcJycgKSB7XG4gICAgICAgICAgICAgICAgaW5RdW90ZSA9ICEgaW5RdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHJldmlvdXNDaCA9IGNoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB1bm1hdGNoZWQgbGVmdCBwYXJlbnRoZXNpc1xuICAgICAgICBpZiAoIHBhcmVudExldmVsID4gMCApIHtcbiAgICAgICAgICAgIHRocm93ICdTeW50YXggZXJyb3I6IHVubWF0Y2hlZCBsZWZ0IHBhcmVudGhlc2lzOiAnICsgZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgcnVuYXdheSBxdW90ZVxuICAgICAgICBpZiAoIGluUXVvdGUgKSB7XG4gICAgICAgICAgICB0aHJvdyAnU3ludGF4IGVycm9yOiBydW5hd2F5IHF1b3RhdGlvbjogJyArIGV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGl0ZXJhdG9yID0gbWFrZUl0ZXJhdG9yKCBkZWxpbWl0ZXJzICk7XG4gICAgfSgpO1xuICAgIFxuICAgIHZhciBoYXNNb3JlVG9rZW5zID0gZnVuY3Rpb24oICkge1xuICAgICAgICByZXR1cm4gY3VyckluZGV4IDwgZXhwcmVzc2lvbi5sZW5ndGg7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbmV4dFRva2VuID0gZnVuY3Rpb24oICkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIFxuICAgICAgICBpZiAoIGl0ZXJhdG9yLmhhc05leHQoKSApIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIGRlbGltID0gcGFyc2VJbnQoIG5leHQgKTtcbiAgICAgICAgICAgIHRva2VuID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcoIGN1cnJJbmRleCwgZGVsaW0gKS50cmltKCk7XG4gICAgICAgICAgICBjdXJySW5kZXggPSBkZWxpbSArIDE7XG4gICAgICAgICAgICBkZWxpbWl0ZXJDb3VudC0tO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlUGFyZW50aGVzaXNJZkFueSggdG9rZW4gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdG9rZW4gPSBleHByZXNzaW9uLnN1YnN0cmluZyggY3VyckluZGV4ICkudHJpbSgpO1xuICAgICAgICBjdXJySW5kZXggPSBleHByZXNzaW9uLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZW1vdmVQYXJlbnRoZXNpc0lmQW55KCB0b2tlbiApO1xuICAgIH07XG4gICAgICAgIFxuICAgIHZhciBjb3VudFRva2VucyA9IGZ1bmN0aW9uKCApIHtcbiAgICAgICAgaWYgKCBoYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsaW1pdGVyQ291bnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgXG4gICAgdmFyIG5leHRUb2tlbklmQW55ID0gZnVuY3Rpb24oIGRlZmF1bHRWYWx1ZSApIHtcbiAgICAgICAgcmV0dXJuIGhhc01vcmVUb2tlbnMoKT8gbmV4dFRva2VuKCk6IGRlZmF1bHRWYWx1ZTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGhhc01vcmVUb2tlbnM6IGhhc01vcmVUb2tlbnMsXG4gICAgICAgIG5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgICAgICBjb3VudFRva2VuczogY291bnRUb2tlbnMsXG4gICAgICAgIG5leHRUb2tlbklmQW55OiBuZXh0VG9rZW5JZkFueVxuICAgIH07XG59O1xuIiwiLyogXG4gICAgZXhwcmVzc2lvbnNVdGlscyBzaW5nbGV0b24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGV2YWx1YXRlSGVscGVyID0gcmVxdWlyZSggJy4vZXZhbHVhdGVIZWxwZXIuanMnICk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCAnLi4vdXRpbHMuanMnICk7XG52YXIgRGVwc0RhdGFJdGVtID0gcmVxdWlyZSggJy4uL3BhcnNlcnMvZGVwc0RhdGFJdGVtLmpzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgYnVpbGRMaXRlcmFsID0gZnVuY3Rpb24oIHZhbHVlICkge1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVIZWxwZXIuaXNOdW1iZXIoIHZhbHVlICk/IFwiXCIgKyB2YWx1ZTogXCInXCIgKyB2YWx1ZSArIFwiJ1wiO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGJ1aWxkTGlzdCA9IGZ1bmN0aW9uKCBpdGVtcywgYXNTdHJpbmdzICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbJztcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGFzU3RyaW5ncz8gXCInXCI6IFwiXCI7XG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZXBhcmF0b3IgKyBpdGVtc1sgaSBdICsgc2VwYXJhdG9yICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgYnVpbGREZXBlbmRzT25MaXN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkZXBzRGF0YUl0ZW0gPSBhcmd1bWVudHNbIDAgXTtcbiAgICAgICAgaWYgKCAhIGRlcHNEYXRhSXRlbSApe1xuICAgICAgICAgICAgZGVwc0RhdGFJdGVtID0gbmV3IERlcHNEYXRhSXRlbSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgc2NvcGUgPSBhcmd1bWVudHNbIDEgXTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoIHZhciBhcmdDb3VudGVyID0gMjsgYXJnQ291bnRlciA8IGFyZ3VtZW50cy5sZW5ndGg7IGFyZ0NvdW50ZXIrKyApe1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBhcmd1bWVudHNbIGFyZ0NvdW50ZXIgXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIFxuICAgICAgICAgICAgICAgIGdldERlcGVuZHNPbkZyb21MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBsaXN0IClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0RGVwZW5kc09uRnJvbUxpc3QgPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSwgYXJnICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgYXJnICl7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgQXJyYXkuaXNBcnJheSggYXJnICkgKXtcbiAgICAgICAgICAgIHJldHVybiBnZXREZXBlbmRzT25Gcm9tTm9uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgYXJnICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBsaXN0ID0gYXJnO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBsaXN0WyBpIF07XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KCBcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KCBpdGVtICk/IGdldERlcGVuZHNPbkZyb21MaXN0KCBzY29wZSwgaXRlbSApOiBnZXREZXBlbmRzT25Gcm9tTm9uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgaXRlbSApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXREZXBlbmRzT25Gcm9tTm9uTGlzdCA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBpdGVtICl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gISB1dGlscy5pc0Z1bmN0aW9uKCBpdGVtLmRlcGVuZHNPbiApIHx8ICggdXRpbHMuaXNGdW5jdGlvbiggaXRlbS5nZXRWYXJOYW1lICkgJiYgZGVwc0RhdGFJdGVtID09PSBpdGVtLmdldFZhck5hbWUoKSApPyBcbiAgICAgICAgICAgIFtdOiBcbiAgICAgICAgICAgIGl0ZW0uZGVwZW5kc09uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBidWlsZExpdGVyYWw6IGJ1aWxkTGl0ZXJhbCxcbiAgICAgICAgYnVpbGRMaXN0OiBidWlsZExpc3QsXG4gICAgICAgIGJ1aWxkRGVwZW5kc09uTGlzdDogYnVpbGREZXBlbmRzT25MaXN0XG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIEZvcm1hdEV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZSggJy4uL3V0aWxzLmpzJyApO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcbnZhciBFeHByZXNzaW9uVG9rZW5pemVyID0gcmVxdWlyZSggJy4vZXhwcmVzc2lvblRva2VuaXplci5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcbnZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuL2V2YWx1YXRlSGVscGVyLmpzJyApO1xuXG52YXIgRm9ybWF0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBmb3JtYXR0ZXJFeHByZXNzaW9uVG9BcHBseSwgYXJnc0V4cHJlc3Npb25zVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgZm9ybWF0dGVyRXhwcmVzc2lvbiA9IGZvcm1hdHRlckV4cHJlc3Npb25Ub0FwcGx5O1xuICAgIHZhciBhcmdzRXhwcmVzc2lvbnMgPSBhcmdzRXhwcmVzc2lvbnNUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGZvcm1hdHRlclxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gZXZhbHVhdGVGb3JtYXR0ZXIoIHNjb3BlLCBmb3JtYXR0ZXJFeHByZXNzaW9uICk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgYXJndW1lbnRzXG4gICAgICAgIHZhciBhcmdzID0gZXZhbHVhdGVIZWxwZXIuZXZhbHVhdGVFeHByZXNzaW9uTGlzdCggYXJnc0V4cHJlc3Npb25zLCBzY29wZSApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5hcHBseSggZm9ybWF0dGVyLCBhcmdzICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiggc2NvcGUsIGV4cHJlc3Npb24gKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgdG8gZ2V0IGEgYnVpbHQtaW4gZm9ybWF0dGVyXG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjb250ZXh0LmdldEZvcm1hdHRlciggZXhwcmVzc2lvbiApO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBhIGZ1bmN0aW9uIHdpdGggYSBuYW1lXG4gICAgICAgIGlmICggISBpc1ZhbGlkRm9ybWF0dGVyKCBmb3JtYXR0ZXIgKSApe1xuICAgICAgICAgICAgZm9ybWF0dGVyID0gc2NvcGUuZ2V0KCBleHByZXNzaW9uICk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBhIGZ1bmN0aW9uIGV2YWx1YXRpbmcgdGhlIGV4cHJlc3Npb25cbiAgICAgICAgaWYgKCAhIGlzVmFsaWRGb3JtYXR0ZXIoIGZvcm1hdHRlciApICl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZXJFeHByZXNzaW9uID0gZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIGV4cHJlc3Npb24gKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmb3JtYXR0ZXJFeHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUZvcm1hdHRlciggc2NvcGUsIHZhbHVlICk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2goIGUgKXtcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJldHVybiB0aGUgZm9ybWF0dGVyIG9ubHkgaWYgaXQgaXMgdmFsaWRcbiAgICAgICAgaWYgKCBpc1ZhbGlkRm9ybWF0dGVyKCBmb3JtYXR0ZXIgKSApe1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgJ05vIHZhbGlkIGZvcm1hdHRlciBmb3VuZDogJyArIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHZhciBpc1ZhbGlkRm9ybWF0dGVyID0gZnVuY3Rpb24oIGZvcm1hdHRlciApe1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyICYmIHV0aWxzLmlzRnVuY3Rpb24oIGZvcm1hdHRlciApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgZm9ybWF0dGVyRXhwcmVzc2lvbiwgYXJnc0V4cHJlc3Npb25zICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cbkZvcm1hdEV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcbkZvcm1hdEV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLmZvcm1hdEV4cHJlc3Npb247XG59O1xuRm9ybWF0RXhwcmVzc2lvbi5nZXRJZCA9IEZvcm1hdEV4cHJlc3Npb24uZ2V0UHJlZml4O1xuXG5Gb3JtYXRFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHMgKSB7XG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHMudHJpbSgpO1xuICAgIGlmICggc3RyaW5nLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgdGhyb3cgJ0Zvcm1hdCBleHByZXNzaW9uIHZvaWQuJztcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudHMgPSBuZXcgRXhwcmVzc2lvblRva2VuaXplciggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkuZXhwcmVzc2lvbkRlbGltaXRlciwgXG4gICAgICAgICAgICBmYWxzZSApO1xuICAgIHZhciBudW1iZXJPZlRva2VucyA9IHNlZ21lbnRzLmNvdW50VG9rZW5zKCk7XG4gICAgaWYgKCBudW1iZXJPZlRva2VucyA9PT0gMSApIHtcbiAgICAgICAgdGhyb3cgJ09ubHkgb25lIGVsZW1lbnQgaW4gZm9ybWF0IGV4cHJlc3Npb246IFwiJyArIHN0cmluZyArICdcIi4gUGxlYXNlIGFkZCBhdCBsZWFzdCBvbmUgbW9yZS4nO1xuICAgIH1cblxuICAgIC8vIEdldCBmb3JtYXR0ZXJcbiAgICB2YXIgZm9ybWF0dGVyID0gc2VnbWVudHMubmV4dFRva2VuKCkudHJpbSgpO1xuXG4gICAgLy8gR2V0IGFyZ3VtZW50c1xuICAgIHZhciBhcmdzRXhwcmVzc2lvbnMgPSBbXTtcbiAgICB3aGlsZSAoIHNlZ21lbnRzLmhhc01vcmVUb2tlbnMoKSApIHtcbiAgICAgICAgdmFyIGFyZ0V4cHJlc3Npb24gPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggc2VnbWVudHMubmV4dFRva2VuKCkgKTtcbiAgICAgICAgYXJnc0V4cHJlc3Npb25zLnB1c2goIGFyZ0V4cHJlc3Npb24gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oIHN0cmluZywgZm9ybWF0dGVyLCBhcmdzRXhwcmVzc2lvbnMgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybWF0RXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgVHJDdXJyZW5jeUV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciB0ckhlbHBlciA9IHJlcXVpcmUoICcuL3RySGVscGVyLmpzJyApO1xuXG52YXIgVHJDdXJyZW5jeUV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvblRvQXBwbHksIGFyZ3NFeHByZXNzaW9uc1RvQXBwbHksIHN1YmZvcm1hdFRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICB2YXIgYXJnc0V4cHJlc3Npb25zID0gYXJnc0V4cHJlc3Npb25zVG9BcHBseTtcbiAgICB2YXIgc3ViZm9ybWF0ID0gc3ViZm9ybWF0VG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IHRySGVscGVyLmV2YWx1YXRlKCBcbiAgICAgICAgICAgICAgICBzY29wZSwgXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiwgXG4gICAgICAgICAgICAgICAgYXJnc0V4cHJlc3Npb25zLCBcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knLCBcbiAgICAgICAgICAgICAgICBzdWJmb3JtYXQgKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gdHJIZWxwZXIuZGVwZW5kc09uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uLCBhcmdzRXhwcmVzc2lvbnMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuVHJDdXJyZW5jeUV4cHJlc3Npb24ucmVtb3ZlUHJlZml4ID0gdHJ1ZTtcblRyQ3VycmVuY3lFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb250ZXh0LmdldENvbmYoKS50ckN1cnJlbmN5RXhwcmVzc2lvbjtcbn07XG5UckN1cnJlbmN5RXhwcmVzc2lvbi5nZXRJZCA9IFRyQ3VycmVuY3lFeHByZXNzaW9uLmdldFByZWZpeDtcblxuVHJDdXJyZW5jeUV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciB0ckRhdGEgPSB0ckhlbHBlci5idWlsZCggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBUckN1cnJlbmN5RXhwcmVzc2lvbi5nZXRQcmVmaXgoKSwgXG4gICAgICAgICAgICAyLCBcbiAgICAgICAgICAgIDMsIFxuICAgICAgICAgICAgdHJ1ZSApO1xuXG4gICAgcmV0dXJuIG5ldyBUckN1cnJlbmN5RXhwcmVzc2lvbiggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgdHJEYXRhLmV4cHJlc3Npb24sIFxuICAgICAgICAgICAgdHJEYXRhLmFyZ3NFeHByZXNzaW9ucywgXG4gICAgICAgICAgICB0ckRhdGEuc3ViZm9ybWF0ICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyQ3VycmVuY3lFeHByZXNzaW9uO1xuIiwiLypcbiAgICBUckRhdGVUaW1lRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIHRySGVscGVyID0gcmVxdWlyZSggJy4vdHJIZWxwZXIuanMnICk7XG5cbnZhciBUckRhdGVUaW1lRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBleHByZXNzaW9uVG9BcHBseSwgYXJnc0V4cHJlc3Npb25zVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25Ub0FwcGx5O1xuICAgIHZhciBhcmdzRXhwcmVzc2lvbnMgPSBhcmdzRXhwcmVzc2lvbnNUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICB2YXIgZXZhbHVhdGVkID0gdHJIZWxwZXIuZXZhbHVhdGUoIFxuICAgICAgICAgICAgICAgIHNjb3BlLCBcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLCBcbiAgICAgICAgICAgICAgICBhcmdzRXhwcmVzc2lvbnMsIFxuICAgICAgICAgICAgICAgICdkYXRldGltZScsIFxuICAgICAgICAgICAgICAgIG51bGwgKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZDtcbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIHJldHVybiB0ckhlbHBlci5kZXBlbmRzT24oIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb24sIGFyZ3NFeHByZXNzaW9ucyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5UckRhdGVUaW1lRXhwcmVzc2lvbi5yZW1vdmVQcmVmaXggPSB0cnVlO1xuVHJEYXRlVGltZUV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLnRyRGF0ZVRpbWVFeHByZXNzaW9uO1xufTtcblRyRGF0ZVRpbWVFeHByZXNzaW9uLmdldElkID0gVHJEYXRlVGltZUV4cHJlc3Npb24uZ2V0UHJlZml4O1xuXG5UckRhdGVUaW1lRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgXG4gICAgdmFyIHRyRGF0YSA9IHRySGVscGVyLmJ1aWxkKCBcbiAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgIFRyRGF0ZVRpbWVFeHByZXNzaW9uLmdldFByZWZpeCgpLCBcbiAgICAgICAgICAgIDEsIFxuICAgICAgICAgICAgMiwgXG4gICAgICAgICAgICBmYWxzZSApO1xuXG4gICAgcmV0dXJuIG5ldyBUckRhdGVUaW1lRXhwcmVzc2lvbiggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgdHJEYXRhLmV4cHJlc3Npb24sIFxuICAgICAgICAgICAgdHJEYXRhLmFyZ3NFeHByZXNzaW9ucyApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUckRhdGVUaW1lRXhwcmVzc2lvbjtcbiIsIi8qIFxuICAgIHRySGVscGVyIHNpbmdsZXRvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIEV4cHJlc3Npb25Ub2tlbml6ZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvblRva2VuaXplci5qcycgKTtcbnZhciBpMThuSGVscGVyID0gcmVxdWlyZSggJy4uLy4uL2kxOG4vaTE4bkhlbHBlci5qcycgKTtcbnZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi9ldmFsdWF0ZUhlbHBlci5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25zVXRpbHMuanMnICk7XG52YXIgVmFyaWFibGVFeHByZXNzaW9uID0gcmVxdWlyZSggJy4uL3BhdGgvdmFyaWFibGVFeHByZXNzaW9uLmpzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nLCB0YWcsIG1pbkVsZW1lbnRzLCBtYXhFbGVtZW50cywgdXNlU3ViZm9ybWF0ICkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIHN0cmluZy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWcgKyAnIGV4cHJlc3Npb24gdm9pZC4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgICAgIHN0cmluZy50cmltKCksIFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmV4cHJlc3Npb25EZWxpbWl0ZXIsIFxuICAgICAgICAgICAgICAgIGZhbHNlICk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBudW1iZXIgb2YgdG9rZW5zXG4gICAgICAgIHZhciBjb3VudCA9IHNlZ21lbnRzLmNvdW50VG9rZW5zKCk7XG4gICAgICAgIGlmICggY291bnQgPCBtaW5FbGVtZW50cyApIHtcbiAgICAgICAgICAgIHRocm93ICdUb28gZmV3IGVsZW1lbnRzIGluICcgKyB0YWcgKyAnIGV4cHJlc3Npb24gKG1pbmltdW0gaXMgJyArIG1pbkVsZW1lbnRzIFxuICAgICAgICAgICAgICAgICAgICArICcsICcgKyBjb3VudCArICcgcHJlc2VudCk6ICcgKyBzdHJpbmcudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICggY291bnQgPiBtYXhFbGVtZW50cyApIHtcbiAgICAgICAgICAgIHRocm93ICdUb28gbWFueSBlbGVtZW50cyBpbiAnICsgdGFnICsgJyBleHByZXNzaW9uIChtYXhpbXVtIGlzICcgKyBtYXhFbGVtZW50cyBcbiAgICAgICAgICAgICAgICAgICAgKyAnLCAnICsgY291bnQgKyAnIHByZXNlbnQpOicgKyBzdHJpbmcudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdG9rZW5zXG4gICAgICAgIHZhciBzdWJmb3JtYXQgPSB1c2VTdWJmb3JtYXQ/IFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzZWdtZW50cy5uZXh0VG9rZW4oKSApOiBcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLm5leHRUb2tlbigpLnRyaW0oKSApO1xuICAgICAgICB2YXIgYXJnc1NlZ21lbnQgPSBzZWdtZW50cy5oYXNNb3JlVG9rZW5zKCk/IFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLm5leHRUb2tlbigpLnRyaW0oKTogXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICBhcmdzRXhwcmVzc2lvbnM6IGJ1aWxkSTE4bkFyZ3MoIGFyZ3NTZWdtZW50ICksXG4gICAgICAgICAgICBzdWJmb3JtYXQ6IHN1YmZvcm1hdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgdmFyIGJ1aWxkSTE4bkFyZ3MgPSBmdW5jdGlvbiggc2VnbWVudCApe1xuICAgICAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgICAgIFxuICAgICAgICB2YXIgYXJncyA9IHt9O1xuICAgICAgICBpZiAoICEgc2VnbWVudCApe1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VucyA9IG5ldyBFeHByZXNzaW9uVG9rZW5pemVyKCBcbiAgICAgICAgICAgICAgICBzZWdtZW50LCBcbiAgICAgICAgICAgICAgICBjb250ZXh0LmdldENvbmYoKS5pMThuT3B0aW9uc0RlbGltaXRlciwgXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICB3aGlsZSAoIHRva2Vucy5oYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnMubmV4dFRva2VuKCkudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGFyZ3NUb2tlbnMgPSBuZXcgRXhwcmVzc2lvblRva2VuaXplciggXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLCBcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkuaW5JMThuT3B0aW9uc0RlbGltaXRlciwgXG4gICAgICAgICAgICAgICAgICAgIHRydWUgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCBhcmdzVG9rZW5zLmNvdW50VG9rZW5zKCkgIT09IDIgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJzIgZWxlbWVudHMgYXJlIG5lZWRlZCBpbiBpMThuIGV4cHJlc3Npb24uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGFyZ0tleSA9IGFyZ3NUb2tlbnMubmV4dFRva2VuKCkudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGFyZ0V4cHJlc3Npb24gPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NUb2tlbnMubmV4dFRva2VuKCkudHJpbSgpICk7XG4gICAgICAgICAgICBhcmdzWyBhcmdLZXkgXSA9IGFyZ0V4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGVJMThuQXJncyA9IGZ1bmN0aW9uKCBzY29wZSwgaTE4bkFyZ3MgKXtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGFyZ0tleSBpbiBpMThuQXJncyApIHtcbiAgICAgICAgICAgIHZhciBhcmdFeHByZXNzaW9uID0gaTE4bkFyZ3NbIGFyZ0tleSBdO1xuICAgICAgICAgICAgdmFyIGFyZ1ZhbHVlID0gZXZhbHVhdGVIZWxwZXIuZXZhbHVhdGVUb05vdE51bGwoIHNjb3BlLCBhcmdFeHByZXNzaW9uICk7XG4gICAgICAgICAgICB2YWx1ZXNbIGFyZ0tleSBdID0gYXJnVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUsIHZhbHVlRXhwcmVzc2lvbiwgYXJnc0V4cHJlc3Npb25zLCBmb3JtYXQsIHN1YmZvcm1hdCApIHtcbiAgICAgICAgdmFyIGFyZ1ZhbHVlcyA9IGV2YWx1YXRlSTE4bkFyZ3MoIHNjb3BlLCBhcmdzRXhwcmVzc2lvbnMgKTtcbiAgICAgICAgdmFyIHN1YmZvcm1hdEV2YWx1YXRlZCA9IFxuICAgICAgICAgICAgICAgIHN1YmZvcm1hdD8gXG4gICAgICAgICAgICAgICAgZXZhbHVhdGVIZWxwZXIuZXZhbHVhdGVUb05vdE51bGwoIHNjb3BlLCBzdWJmb3JtYXQgKTogXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdmFsdWVFdmFsdWF0ZWQgPSBldmFsdWF0ZUhlbHBlci5ldmFsdWF0ZVRvTm90TnVsbCggc2NvcGUsIHZhbHVlRXhwcmVzc2lvbiApO1xuICAgICAgICB2YXIgZXZhbHVhdGVkID0gdHJhbnNsYXRlKCBcbiAgICAgICAgICAgICAgICBzY29wZSwgXG4gICAgICAgICAgICAgICAgdmFsdWVFdmFsdWF0ZWQsIFxuICAgICAgICAgICAgICAgIGFyZ1ZhbHVlcywgXG4gICAgICAgICAgICAgICAgZm9ybWF0LCBcbiAgICAgICAgICAgICAgICBzdWJmb3JtYXRFdmFsdWF0ZWQgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBldmFsdWF0ZWQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdHJhbnNsYXRlID0gZnVuY3Rpb24oIHNjb3BlLCBpZCwgaTE4bkFyZ3MsIGZvcm1hdCwgc3ViZm9ybWF0ICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgaTE4bkxpc3QgPSBzY29wZS5nZXQoIGNvbnRleHQuZ2V0Q29uZigpLmkxOG5Eb21haW5WYXJOYW1lICk7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IHNjb3BlLmdldCggY29udGV4dC5nZXRDb25mKCkuaTE4bkxhbmd1YWdlVmFyTmFtZSApO1xuICAgICAgICByZXR1cm4gaTE4bkhlbHBlci50ciggXG4gICAgICAgICAgICBpMThuTGlzdCwgXG4gICAgICAgICAgICBpZCwgXG4gICAgICAgICAgICBpMThuQXJncywgXG4gICAgICAgICAgICBmb3JtYXQsIFxuICAgICAgICAgICAgc3ViZm9ybWF0LFxuICAgICAgICAgICAgbGFuZ3VhZ2UgXG4gICAgICAgICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb24sIGFyZ3NFeHByZXNzaW9ucyApe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBcbiAgICAgICAgICAgIGRlcHNEYXRhSXRlbSwgXG4gICAgICAgICAgICBzY29wZSwgXG4gICAgICAgICAgICBuZXcgVmFyaWFibGVFeHByZXNzaW9uKCBjb250ZXh0LmdldENvbmYoKS5pMThuRG9tYWluVmFyTmFtZSApLFxuICAgICAgICAgICAgbmV3IFZhcmlhYmxlRXhwcmVzc2lvbiggY29udGV4dC5nZXRDb25mKCkuaTE4bkxhbmd1YWdlVmFyTmFtZSApLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiwgXG4gICAgICAgICAgICBhcmdzRXhwcmVzc2lvbnNcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGJ1aWxkOiBidWlsZCxcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPblxuICAgIH07XG59KSgpO1xuIiwiLypcbiAgICBUck51bWJlckV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciB0ckhlbHBlciA9IHJlcXVpcmUoICcuL3RySGVscGVyLmpzJyApO1xuXG52YXIgVHJOdW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGV4cHJlc3Npb25Ub0FwcGx5LCBhcmdzRXhwcmVzc2lvbnNUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvblRvQXBwbHk7XG4gICAgdmFyIGFyZ3NFeHByZXNzaW9ucyA9IGFyZ3NFeHByZXNzaW9uc1RvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIHZhciBldmFsdWF0ZWQgPSB0ckhlbHBlci5ldmFsdWF0ZSggXG4gICAgICAgICAgICAgICAgc2NvcGUsIFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sIFxuICAgICAgICAgICAgICAgIGFyZ3NFeHByZXNzaW9ucywgXG4gICAgICAgICAgICAgICAgJ251bWJlcicsIFxuICAgICAgICAgICAgICAgIG51bGwgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWQ7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gdHJIZWxwZXIuZGVwZW5kc09uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uLCBhcmdzRXhwcmVzc2lvbnMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuVHJOdW1iZXJFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IHRydWU7XG5Uck51bWJlckV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLnRyTnVtYmVyRXhwcmVzc2lvbjtcbn07XG5Uck51bWJlckV4cHJlc3Npb24uZ2V0SWQgPSBUck51bWJlckV4cHJlc3Npb24uZ2V0UHJlZml4O1xuXG5Uck51bWJlckV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciB0ckRhdGEgPSB0ckhlbHBlci5idWlsZCggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBUck51bWJlckV4cHJlc3Npb24uZ2V0UHJlZml4KCksIFxuICAgICAgICAgICAgMSwgXG4gICAgICAgICAgICAyLCBcbiAgICAgICAgICAgIGZhbHNlIFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IFRyTnVtYmVyRXhwcmVzc2lvbiggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgdHJEYXRhLmV4cHJlc3Npb24sIFxuICAgICAgICAgICAgdHJEYXRhLmFyZ3NFeHByZXNzaW9ucyBcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUck51bWJlckV4cHJlc3Npb247XG4iLCIvKlxuICAgIFRyU3RyaW5nRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIHRySGVscGVyID0gcmVxdWlyZSggJy4vdHJIZWxwZXIuanMnICk7XG5cbnZhciBUclN0cmluZ0V4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvblRvQXBwbHksIGFyZ3NFeHByZXNzaW9uc1RvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICB2YXIgYXJnc0V4cHJlc3Npb25zID0gYXJnc0V4cHJlc3Npb25zVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IHRySGVscGVyLmV2YWx1YXRlKCBcbiAgICAgICAgICAgICAgICBzY29wZSwgXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiwgXG4gICAgICAgICAgICAgICAgYXJnc0V4cHJlc3Npb25zLCBcbiAgICAgICAgICAgICAgICAnc3RyaW5nJywgXG4gICAgICAgICAgICAgICAgbnVsbCBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gdHJIZWxwZXIuZGVwZW5kc09uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uLCBhcmdzRXhwcmVzc2lvbnMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuVHJTdHJpbmdFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IHRydWU7XG5UclN0cmluZ0V4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLnRyRXhwcmVzc2lvbjtcbn07XG5UclN0cmluZ0V4cHJlc3Npb24uZ2V0SWQgPSBUclN0cmluZ0V4cHJlc3Npb24uZ2V0UHJlZml4O1xuXG5UclN0cmluZ0V4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIHZhciB0ckRhdGEgPSB0ckhlbHBlci5idWlsZCggXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBUclN0cmluZ0V4cHJlc3Npb24uZ2V0UHJlZml4KCksIFxuICAgICAgICAgICAgMSwgXG4gICAgICAgICAgICAyLCBcbiAgICAgICAgICAgIGZhbHNlIFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IFRyU3RyaW5nRXhwcmVzc2lvbiggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgdHJEYXRhLmV4cHJlc3Npb24sIFxuICAgICAgICAgICAgdHJEYXRhLmFyZ3NFeHByZXNzaW9ucyBcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUclN0cmluZ0V4cHJlc3Npb247XG4iLCIvKlxuICAgIEFycmF5RXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24oIGFycmF5QmFzZVRvQXBwbHksIGluZGV4ZXNUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBhcnJheUJhc2UgPSBhcnJheUJhc2VUb0FwcGx5O1xuICAgIHZhciBpbmRleGVzID0gaW5kZXhlc1RvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmFsdWF0ZSBhbmQgY2hlY2sgYXJyYXkgYmFzZXMgYW5kIGluZGV4ZXNcbiAgICAgICAgdmFyIGV2YWx1YXRlZEFycmF5QmFzZSA9IGFycmF5QmFzZS5ldmFsdWF0ZSggc2NvcGUgKTtcblxuICAgICAgICAvLyBJdGVyYXRlIGluZGV4ZXNcbiAgICAgICAgdmFyIHJlc3VsdCA9IGV2YWx1YXRlZEFycmF5QmFzZTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IGFuZCBldmFsdWF0ZSBpbmRleCBhcyBpbnRlZ2VyXG4gICAgICAgICAgICB2YXIgaW5kZXhFeHByZXNzaW9uID0gaW5kZXhlc1sgaSBdO1xuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSBhcnJheSBhY2Nlc3NcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFsgaW5kZXhFeHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApIF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgXG4gICAgICAgIC8vIEJ1aWxkIHRoZSBhcnJheUJhc2VEZXBlbmRzT25cbiAgICAgICAgdmFyIGFycmF5QmFzZURlcGVuZHNPbiA9IGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBhcnJheUJhc2UgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoaXMgbXVzdCBiZSByYXJlIVxuICAgICAgICBpZiAoIGFycmF5QmFzZURlcGVuZHNPbi5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIGlmICggYXJyYXlCYXNlRGVwZW5kc09uLmxlbmd0aCA+IDEgKXtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgYXJyYXlCYXNlLCBpbmRleGVzICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEpvaW4gYWxsIHRvZ2V0aGVyXG4gICAgICAgIHZhciBkZXAgPSBhcnJheUJhc2VEZXBlbmRzT25bIDAgXTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7ICsraSApe1xuICAgICAgICAgICAgdmFyIGluZGV4RXhwcmVzc2lvbiA9IGluZGV4ZXNbIGkgXTtcbiAgICAgICAgICAgIHZhciBpbmRleEV2YWx1YXRlZCA9IGluZGV4RXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICAgICAgICAgIGRlcCArPSAnWycgKyBpbmRleEV2YWx1YXRlZCArICddJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFsgZGVwIF07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gYXJyYXlCYXNlICsgJ1snICsgaW5kZXhlcyArICddJztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5BcnJheUV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggYXJyYXlCYXNlLCBhY2Nlc3NvciApIHtcbiAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICBcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHdoaWxlICggISBkb25lICl7XG5cbiAgICAgICAgLy8gQXJyYXkgYWNjZXNzb3IgbXVzdCBiZWdpbiBhbmQgZW5kIHdpdGggYnJhY2tldHNcbiAgICAgICAgdmFyIGNsb3NlID0gYWNjZXNzb3IuaW5kZXhPZiggJ10nICk7XG4gICAgICAgIGlmICggYWNjZXNzb3IuY2hhckF0KCAwICkgIT09ICdbJyB8fCBjbG9zZSA9PT0gLTEgKSB7XG4gICAgICAgICAgICB0aHJvdyAnQmFkIGFycmF5IGFjY2Vzc29yOiAnICArIGFjY2Vzc29yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGluZGV4IGFuZCBhZGQgdG8gaW5kZXhlc1xuICAgICAgICB2YXIgaW5kZXggPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggXG4gICAgICAgICAgICAgICAgYWNjZXNzb3Iuc3Vic3RyaW5nKCAxLCBjbG9zZSApIFxuICAgICAgICApO1xuICAgICAgICBpbmRleGVzLnB1c2goIGluZGV4ICk7XG5cbiAgICAgICAgLy8gY29udGludWUgcHJvY2Vzc2luZyBhcnJheSBhY2Nlc3MgZm9yIG11bHRpZGltZW5zaW9uYWwgYXJyYXlzXG4gICAgICAgIGNsb3NlKys7XG4gICAgICAgIGlmICggYWNjZXNzb3IubGVuZ3RoID4gY2xvc2UgKSB7XG4gICAgICAgICAgICBhY2Nlc3NvciA9IGFjY2Vzc29yLnN1YnN0cmluZyggY2xvc2UgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXcgQXJyYXlFeHByZXNzaW9uKCBhcnJheUJhc2UsIGluZGV4ZXMgKTtcbn07XG5cbkFycmF5RXhwcmVzc2lvbi5idWlsZEFycmF5RGF0YSA9IGZ1bmN0aW9uKCB0b2tlbiApIHtcbiAgICBcbiAgICB2YXIgYnJhY2tldCA9IEFycmF5RXhwcmVzc2lvbi5maW5kQXJyYXlBY2Nlc3NvciggdG9rZW4gKTtcbiAgICBcbiAgICBpZiAoIGJyYWNrZXQgPD0gMCApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJyYXlBY2Nlc3NvcjogdG9rZW4uc3Vic3RyaW5nKCBicmFja2V0ICkudHJpbSgpLFxuICAgICAgICB0b2tlbjogdG9rZW4uc3Vic3RyaW5nKCAwLCBicmFja2V0ICkudHJpbSgpXG4gICAgfTtcbn07XG5cbkFycmF5RXhwcmVzc2lvbi5maW5kQXJyYXlBY2Nlc3NvciA9IGZ1bmN0aW9uKCB0b2tlbiApIHtcbiAgICB2YXIgU0NBTk5JTkcgPSAwO1xuICAgIHZhciBJTl9QQVJFTiA9IDE7XG4gICAgdmFyIElOX1FVT1RFID0gMjtcblxuICAgIHZhciBsZW5ndGggPSB0b2tlbi5sZW5ndGg7XG4gICAgdmFyIHN0YXRlID0gU0NBTk5JTkc7XG4gICAgdmFyIHBhcmVuRGVwdGggPSAwO1xuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICB2YXIgY2ggPSB0b2tlbi5jaGFyQXQoIGkgKTtcbiAgICAgICAgc3dpdGNoKCBzdGF0ZSApIHtcbiAgICAgICAgY2FzZSBJTl9QQVJFTjpcbiAgICAgICAgICAgIGlmICggY2ggPT09ICcpJyApIHtcbiAgICAgICAgICAgICAgICBwYXJlbkRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKCBwYXJlbkRlcHRoID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNDQU5OSU5HO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNoID09PSAnKCcgKSB7XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBJTl9RVU9URTpcbiAgICAgICAgICAgIGlmICggY2ggPT09ICdcXCcnICkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gU0NBTk5JTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNDQU5OSU5HOlxuICAgICAgICAgICAgaWYgKCBjaCA9PT0gJ1xcJycgKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBJTl9RVU9URTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNoID09PSAnKCcgKSB7XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aCsrO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gSU5fUEFSRU47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PT0gJ1snICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheUV4cHJlc3Npb247XG4iLCIvKlxuICAgIEZ1bmN0aW9uRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZXZhbHVhdGVIZWxwZXIgPSByZXF1aXJlKCAnLi4vZXZhbHVhdGVIZWxwZXIuanMnICk7XG5cbnZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgbmFtZVRvQXBwbHksIGFyZ3NUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBuYW1lID0gbmFtZVRvQXBwbHk7XG4gICAgdmFyIGFyZ3MgPSBhcmdzVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBldmFsdWF0ZUhlbHBlci5ldmFsdWF0ZUV4cHJlc3Npb25MaXN0KCBhcmdzLCBzY29wZSApO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHNjb3BlLmdldCggbmFtZSApO1xuICAgICAgICByZXR1cm4gISBlbGVtZW50PyB1bmRlZmluZWQ6IGVsZW1lbnQuYXBwbHkoIGVsZW1lbnQsIGV2YWx1YXRlZEFyZ3MgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuRnVuY3Rpb25FeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICB2YXIgZXhwcmVzc2lvbkJ1aWxkZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbkJ1aWxkZXIuanMnICk7XG4gICAgXG4gICAgdmFyIGxlZnRQYXJlbnQgPSBzdHJpbmcuaW5kZXhPZiggJygnICk7XG4gICAgaWYgKCBsZWZ0UGFyZW50ID09PSAtMSApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgXG4gICAgaWYgKCAhIGV4cHJlc3Npb25CdWlsZGVyLmVuZHNXaXRoKCBzdHJpbmcsICcpJyApICkge1xuICAgICAgICB0aHJvdyAnU3ludGF4IGVycm9yLiBCYWQgZnVuY3Rpb24gY2FsbDogJyArIHN0cmluZztcbiAgICB9XG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0cmluZy5zdWJzdHJpbmcoIDAsIGxlZnRQYXJlbnQgKS50cmltKCk7XG4gICAgdmFyIGFyZ3NTdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKCBsZWZ0UGFyZW50ICsgMSwgc3RyaW5nLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgYXJncyA9IGV4cHJlc3Npb25CdWlsZGVyLmdldEFyZ3VtZW50c0Zyb21TdHJpbmcoIGFyZ3NTdHJpbmcgKTtcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKCBzdHJpbmcsIGZ1bmN0aW9uTmFtZSwgYXJncyApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbkV4cHJlc3Npb247XG4iLCIvKlxuICAgIEluZGlyZWN0aW9uRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSW5kaXJlY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24oIG5hbWVUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBuYW1lID0gbmFtZVRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlLCBwYXJlbnQgKXtcbiAgICAgICAgcmV0dXJuIHBhcmVudFsgc2NvcGUuZ2V0KCBuYW1lICkgXTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gJz8nICsgbmFtZTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5JbmRpcmVjdGlvbkV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIGlmICggc3RyaW5nLmNoYXJBdCggMCApICE9PSAnPycgKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXcgSW5kaXJlY3Rpb25FeHByZXNzaW9uKCBzdHJpbmcuc3Vic3RyaW5nKCAxICkgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5kaXJlY3Rpb25FeHByZXNzaW9uO1xuIiwiLypcbiAgICBMaXN0RXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIEV4cHJlc3Npb25Ub2tlbml6ZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvblRva2VuaXplci5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25zVXRpbHMuanMnICk7XG52YXIgUmFuZ2VFeHByZXNzaW9uID0gcmVxdWlyZSggJy4vcmFuZ2VFeHByZXNzaW9uLmpzJyApO1xuXG52YXIgTGlzdEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgaXRlbXNUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBpdGVtcyA9IGl0ZW1zVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBpdGVtc1sgaSBdO1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZXZhbHVhdGVkICkgKXsgXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCggZXZhbHVhdGVkICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCBldmFsdWF0ZWQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBpdGVtcyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcbiAgICAgICAgZGVwZW5kc09uOiBkZXBlbmRzT24sXG4gICAgICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICAgIH07XG59O1xuXG5MaXN0RXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzICkge1xuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICBpZiAoIHMuY2hhckF0KCAwICkgIT09ICdbJyB8fCBzLmNoYXJBdCggcy5sZW5ndGggLSAxICkgIT09ICAnXScgKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzLnN1YnN0cmluZyggMSwgcy5sZW5ndGggLSAxICk7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIHNlZ21lbnRzID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgc3RyaW5nLCBcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmV4cHJlc3Npb25EZWxpbWl0ZXIsIFxuICAgICAgICAgICAgdHJ1ZSApO1xuXG4gICAgd2hpbGUgKCBzZWdtZW50cy5oYXNNb3JlVG9rZW5zKCkgKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHMubmV4dFRva2VuKCkudHJpbSgpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZUV4cHJlc3Npb24uYnVpbGQoIHNlZ21lbnQgKTtcblxuICAgICAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgcmFuZ2U/XG4gICAgICAgICAgICByYW5nZTpcbiAgICAgICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzZWdtZW50IClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExpc3RFeHByZXNzaW9uKCBzdHJpbmcsIGl0ZW1zICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RFeHByZXNzaW9uO1xuIiwiLypcbiAgICBCb29sZWFuTGl0ZXJhbCBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQm9vbGVhbkxpdGVyYWwgPSBmdW5jdGlvbiggbGl0ZXJhbFRvQXBwbHkgKSB7XG5cbiAgICB2YXIgbGl0ZXJhbCA9IGxpdGVyYWxUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICByZXR1cm4gbGl0ZXJhbDtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBcIlwiICsgbGl0ZXJhbDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuQm9vbGVhbkxpdGVyYWwuYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIGlmICggJ3RydWUnID09PSBzdHJpbmcgKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkxpdGVyYWwoIHRydWUgKTtcbiAgICB9XG4gICAgaWYgKCAnZmFsc2UnID09PSBzdHJpbmcgKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkxpdGVyYWwoIGZhbHNlICk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvb2xlYW5MaXRlcmFsO1xuIiwiLypcbiAgICBOdW1lcmljTGl0ZXJhbCBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTnVtZXJpY0xpdGVyYWwgPSBmdW5jdGlvbiggbGl0ZXJhbFRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIGxpdGVyYWwgPSBsaXRlcmFsVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWw7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWw7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuTnVtZXJpY0xpdGVyYWwuYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIGlmICggaXNGaW5pdGUoIHN0cmluZyApICl7XG4gICAgICAgIHZhciBpbnRlZ2VyVmFsdWUgPSBwYXJzZUludCggc3RyaW5nICk7XG4gICAgICAgIGlmICggaW50ZWdlclZhbHVlID09IHN0cmluZyApe1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljTGl0ZXJhbCggaW50ZWdlclZhbHVlICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoIHN0cmluZyApO1xuICAgICAgICBpZiAoIGZsb2F0VmFsdWUgPT0gc3RyaW5nICl7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNMaXRlcmFsKCBmbG9hdFZhbHVlICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1lcmljTGl0ZXJhbDtcbiIsIi8qXG4gICAgU3RyaW5nTGl0ZXJhbCBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCBsaXRlcmFsVG9BcHBseSApIHtcblxuICAgIHZhciBsaXRlcmFsID0gbGl0ZXJhbFRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cblN0cmluZ0xpdGVyYWwuYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIFxuICAgIGlmICggc3RyaW5nLmNoYXJBdCggMCApID09PSBcIidcIiAmJiBzdHJpbmcuY2hhckF0KCBzdHJpbmcubGVuZ3RoIC0gMSApID09PSAgXCInXCIgKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nTGl0ZXJhbCggXG4gICAgICAgICAgICBzdHJpbmcuc3Vic3RyaW5nKCAxLCBzdHJpbmcubGVuZ3RoIC0gMSApICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nTGl0ZXJhbDtcbiIsIi8qXG4gICAgTWV0aG9kRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZXZhbHVhdGVIZWxwZXIgPSByZXF1aXJlKCAnLi4vZXZhbHVhdGVIZWxwZXIuanMnICk7XG5cbnZhciBNZXRob2RFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIG5hbWVUb0FwcGx5LCBhcmdzVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgbmFtZSA9IG5hbWVUb0FwcGx5O1xuICAgIHZhciBhcmdzID0gYXJnc1RvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlLCBwYXJlbnQgKXtcbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBldmFsdWF0ZUhlbHBlci5ldmFsdWF0ZUV4cHJlc3Npb25MaXN0KCBhcmdzLCBzY29wZSApO1xuICAgICAgICByZXR1cm4gcGFyZW50WyBuYW1lIF0uYXBwbHkoIHBhcmVudCwgZXZhbHVhdGVkQXJncyApO1xuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuTWV0aG9kRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuICAgIFxuICAgIHZhciBsZWZ0UGFyZW50ID0gc3RyaW5nLmluZGV4T2YoICcoJyApO1xuICAgIGlmICggbGVmdFBhcmVudCA9PT0gLTEgKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFxuICAgIGlmICggISBleHByZXNzaW9uQnVpbGRlci5lbmRzV2l0aCggc3RyaW5nLCAnKScgKSApIHtcbiAgICAgICAgdGhyb3cgJ1N5bnRheCBlcnJvci4gQmFkIG1ldGhvZCBjYWxsOiAnICsgc3RyaW5nO1xuICAgIH1cbiAgICBcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHN0cmluZy5zdWJzdHJpbmcoIDAsIGxlZnRQYXJlbnQgKS50cmltKCk7XG4gICAgdmFyIGFyZ3NTdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKCBsZWZ0UGFyZW50ICsgMSwgc3RyaW5nLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgYXJncyA9IGV4cHJlc3Npb25CdWlsZGVyLmdldEFyZ3VtZW50c0Zyb21TdHJpbmcoIGFyZ3NTdHJpbmcgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IE1ldGhvZEV4cHJlc3Npb24oIHN0cmluZywgbWV0aG9kTmFtZSwgYXJncyApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXRob2RFeHByZXNzaW9uO1xuIiwiLypcbiAgICBQYXRoRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIEV4cHJlc3Npb25Ub2tlbml6ZXIgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvblRva2VuaXplci5qcycgKTtcbnZhciBTdHJpbmdMaXRlcmFsID0gcmVxdWlyZSggJy4vbGl0ZXJhbHMvc3RyaW5nTGl0ZXJhbC5qcycgKTtcbnZhciBQYXRoU2VnbWVudEV4cHJlc3Npb24gPSByZXF1aXJlKCAnLi9wYXRoU2VnbWVudEV4cHJlc3Npb24uanMnICk7XG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgUGF0aEV4cHJlc3Npb24gPSBmdW5jdGlvbiggc3RyaW5nVG9BcHBseSwgZXhwcmVzc2lvbkxpc3RUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uTGlzdCA9IGV4cHJlc3Npb25MaXN0VG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcblxuICAgICAgICB2YXIgZXhjZXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbkxpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvbkxpc3RbIGkgXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICAgICAgICAgICAgICBpZiAoIHJlc3VsdCAhPSBudWxsICl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCggZSApIHtcbiAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIGV4Y2VwdGlvbiApIHtcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGV4cHJlc3Npb25MaXN0ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cblBhdGhFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IGZhbHNlO1xuUGF0aEV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLnBhdGhFeHByZXNzaW9uO1xufTtcblBhdGhFeHByZXNzaW9uLmdldElkID0gZnVuY3Rpb24oKSB7IFxuICAgIHJldHVybiAncGF0aCc7XG59O1xuXG5QYXRoRXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzICkge1xuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gcy50cmltKCk7XG4gICAgXG4gICAgLy8gQmxhbmsgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYmxhbmsgc3RyaW5nXG4gICAgaWYgKCBzdHJpbmcubGVuZ3RoID09PSAwICkge1xuICAgICAgICByZXR1cm4gU3RyaW5nTGl0ZXJhbC5idWlsZCggJycgKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHNlZ21lbnRzID0gbmV3IEV4cHJlc3Npb25Ub2tlbml6ZXIoIFxuICAgICAgICAgICAgc3RyaW5nLCBcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLnBhdGhEZWxpbWl0ZXIsIFxuICAgICAgICAgICAgZmFsc2UgKTtcblxuICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgMSBtdXN0IGJlIGEgcGF0aCBzZWdtZW50XG4gICAgaWYgKCBzZWdtZW50cy5jb3VudFRva2VucygpID09PSAxICkge1xuICAgICAgICByZXR1cm4gUGF0aFNlZ21lbnRFeHByZXNzaW9uLmJ1aWxkKCBzdHJpbmcgKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDEgdGhleSBjYW4gYmUgYW55IGV4cHJlc3Npb24gaW5zdGFuY2VcbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBbXTtcbiAgICB3aGlsZSAoIHNlZ21lbnRzLmhhc01vcmVUb2tlbnMoKSApIHtcbiAgICAgICAgdmFyIG5leHRUb2tlbiA9IHNlZ21lbnRzLm5leHRUb2tlbigpO1xuICAgICAgICBpZiAoICEgbmV4dFRva2VuICl7XG4gICAgICAgICAgICB0aHJvdyAnTnVsbCB0b2tlbiBpbnNpZGUgcGF0aCBleHByZXNzaW9uOiAnICsgc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb25MaXN0LnB1c2goIFxuICAgICAgICAgICAgZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIFxuICAgICAgICAgICAgICAgIG5leHRUb2tlblxuICAgICAgICAgICAgKSBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXRoRXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uTGlzdCApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXRoRXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgUGF0aFNlZ21lbnRFeHByZXNzaW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcbnZhciBBcnJheUV4cHJlc3Npb24gPSByZXF1aXJlKCAnLi9hcnJheUV4cHJlc3Npb24uanMnICk7XG52YXIgU3RyaW5nTGl0ZXJhbCA9IHJlcXVpcmUoICcuL2xpdGVyYWxzL3N0cmluZ0xpdGVyYWwuanMnICk7XG52YXIgTnVtZXJpY0xpdGVyYWwgPSByZXF1aXJlKCAnLi9saXRlcmFscy9udW1lcmljTGl0ZXJhbC5qcycgKTtcbnZhciBCb29sZWFuTGl0ZXJhbCA9IHJlcXVpcmUoICcuL2xpdGVyYWxzL2Jvb2xlYW5MaXRlcmFsLmpzJyApO1xudmFyIExpc3RFeHByZXNzaW9uID0gcmVxdWlyZSggJy4vbGlzdEV4cHJlc3Npb24uanMnICk7XG52YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gcmVxdWlyZSggJy4vZnVuY3Rpb25FeHByZXNzaW9uLmpzJyApO1xudmFyIFZhcmlhYmxlRXhwcmVzc2lvbiA9IHJlcXVpcmUoICcuL3ZhcmlhYmxlRXhwcmVzc2lvbi5qcycgKTtcbnZhciBJbmRpcmVjdGlvbkV4cHJlc3Npb24gPSByZXF1aXJlKCAnLi9pbmRpcmVjdGlvbkV4cHJlc3Npb24uanMnICk7XG52YXIgTWV0aG9kRXhwcmVzc2lvbiA9IHJlcXVpcmUoICcuL21ldGhvZEV4cHJlc3Npb24uanMnICk7XG52YXIgUHJvcGVydHlFeHByZXNzaW9uID0gcmVxdWlyZSggJy4vcHJvcGVydHlFeHByZXNzaW9uLmpzJyApO1xuXG52YXIgUGF0aFNlZ21lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGl0ZW1zVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgc3RyaW5nID0gc3RyaW5nVG9BcHBseTtcbiAgICB2YXIgaXRlbXMgPSBpdGVtc1RvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgdG9rZW4gPSBpdGVtc1sgMCBdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdG9rZW4uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgLy8gT25seSBsYXN0IGVsZW1lbnQgY2FuIGJlIG51bGxcbiAgICAgICAgICAgIGlmICggcmVzdWx0ID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIGV2YWx1YXRpbmcgXCInICsgc3RyaW5nICsgJ1wiOiBcIicgICsgdG9rZW4gKyAnXCIgaXMgbnVsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IGl0ZW1zWyBpIF07XG4gICAgICAgICAgICByZXN1bHQgPSB0b2tlbi5ldmFsdWF0ZSggc2NvcGUsIHJlc3VsdCApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgZmlyc3RTZWdtZW50RGVwZW5kc09uID0gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIGl0ZW1zWyAwIF0gKTtcbiAgICAgICAgaWYgKCBmaXJzdFNlZ21lbnREZXBlbmRzT24ubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSBpZiAoIGZpcnN0U2VnbWVudERlcGVuZHNPbi5sZW5ndGggPiAxICl7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RTZWdtZW50RGVwZW5kc09uO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdGVtcCA9IGZpcnN0U2VnbWVudERlcGVuZHNPblsgMCBdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gWyB0ZW1wIF07XG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gaXRlbXNbIGkgXTtcbiAgICAgICAgICAgIHZhciB0b2tlbkRlcGVuZHNPbiA9IHRva2VuLmRlcGVuZHNPbiggdGVtcCApO1xuICAgICAgICAgICAgaWYgKCAhIHRva2VuRGVwZW5kc09uICl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGVtcCArPSB0b2tlbkRlcGVuZHNPbjtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCB0ZW1wICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cblBhdGhTZWdtZW50RXhwcmVzc2lvbi5idWlsZCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG4gICAgXG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgXG4gICAgLy8gQmxhbmsgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYmxhbmsgc3RyaW5nXG4gICAgaWYgKCBzdHJpbmcubGVuZ3RoID09PSAwICkge1xuICAgICAgICBpdGVtcy5wdXNoKCBcbiAgICAgICAgICAgIFN0cmluZ0xpdGVyYWwuYnVpbGQoICcnICkgKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIGZpcnN0IHRva2VuXG4gICAgdmFyIHBhdGggPSBuZXcgRXhwcmVzc2lvblRva2VuaXplciggXG4gICAgICAgICAgICBzdHJpbmcsIFxuICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkucGF0aFNlZ21lbnREZWxpbWl0ZXIsIFxuICAgICAgICAgICAgZmFsc2UgKTtcbiAgICB2YXIgdG9rZW4gPSBwYXRoLm5leHRUb2tlbigpLnRyaW0oKTtcbiAgICBpdGVtcy5wdXNoKFxuICAgICAgICAgICAgUGF0aFNlZ21lbnRFeHByZXNzaW9uLmJ1aWxkRmlyc3RQYXRoVG9rZW4oIHRva2VuICkgKTtcblxuICAgIC8vIFRyYXZlcnNlIHRoZSBwYXRoXG4gICAgd2hpbGUgKCBwYXRoLmhhc01vcmVUb2tlbnMoKSApIHtcbiAgICAgICAgdG9rZW4gPSBwYXRoLm5leHRUb2tlbigpLnRyaW0oKTtcbiAgICAgICAgaXRlbXMucHVzaChcbiAgICAgICAgICAgIFBhdGhTZWdtZW50RXhwcmVzc2lvbi5idWlsZE5leHRQYXRoVG9rZW4oIHRva2VuICkgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQYXRoU2VnbWVudEV4cHJlc3Npb24oIHN0cmluZywgaXRlbXMgKTtcbn07XG5cblBhdGhTZWdtZW50RXhwcmVzc2lvbi5idWlsZEZpcnN0UGF0aFRva2VuID0gZnVuY3Rpb24oIHQgKXtcblxuICAgIC8vIFNlcGFyYXRlIGlkZW50aWZpZXIgZnJvbSBhbnkgYXJyYXkgYWNjZXNzb3JzXG4gICAgdmFyIGFycmF5RGF0YSA9IEFycmF5RXhwcmVzc2lvbi5idWlsZEFycmF5RGF0YSggdCApO1xuICAgIHZhciBhcnJheUFjY2Vzc29yID0gYXJyYXlEYXRhPyBhcnJheURhdGEuYXJyYXlBY2Nlc3NvcjogdW5kZWZpbmVkO1xuICAgIHZhciB0b2tlbiA9IGFycmF5RGF0YT8gYXJyYXlEYXRhLnRva2VuOiB0O1xuXG4gICAgLy8gRmlyc3QgdG9rZW4gbXVzdCBjb21lIGZyb20gZGljdGlvbmFyeSBvciBiZSBhIGxpdGVyYWxcblxuICAgIC8vIEZpcnN0IHNlZSBpZiBpdCdzIGEgc3RyaW5nIGxpdGVyYWxcbiAgICB2YXIgcmVzdWx0ID0gU3RyaW5nTGl0ZXJhbC5idWlsZCggdG9rZW4gKTtcblxuICAgIC8vIElmIGl0J3Mgbm90LCB0cnkgdG8gc2VlIGlmIGl0J3MgYSBudW1iZXJcbiAgICBpZiAoIHJlc3VsdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICByZXN1bHQgPSBOdW1lcmljTGl0ZXJhbC5idWlsZCggdG9rZW4gKTtcblxuICAgICAgICAvLyBNYXliZSBpdCdzIGEgYm9vbGVhbiBsaXRlcmFsXG4gICAgICAgIGlmICggcmVzdWx0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBCb29sZWFuTGl0ZXJhbC5idWlsZCggdG9rZW4gKTtcblxuICAgICAgICAgICAgLy8gQSBsaXN0P1xuICAgICAgICAgICAgaWYgKCByZXN1bHQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IExpc3RFeHByZXNzaW9uLmJ1aWxkKCB0b2tlbiApO1xuXG4gICAgICAgICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsP1xuICAgICAgICAgICAgICAgIGlmICggcmVzdWx0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEZ1bmN0aW9uRXhwcmVzc2lvbi5idWlsZCggdG9rZW4gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGFuIG9iamVjdCBpbiBzY29wZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3VsdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVmFyaWFibGVFeHByZXNzaW9uLmJ1aWxkKCB0b2tlbiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcmVjb2duaXplZCBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3VsdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdVbmtub3duIGV4cHJlc3Npb246ICcgKyB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICggYXJyYXlBY2Nlc3NvciAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICByZXN1bHQgPSBBcnJheUV4cHJlc3Npb24uYnVpbGQoIHJlc3VsdCwgYXJyYXlBY2Nlc3NvciApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXRoU2VnbWVudEV4cHJlc3Npb24uYnVpbGROZXh0UGF0aFRva2VuID0gZnVuY3Rpb24oIHQgKXtcbiAgICBcbiAgICAvLyBTZXBhcmF0ZSBpZGVudGlmaWVyIGZyb20gYW55IGFycmF5IGFjY2Vzc29yc1xuICAgIHZhciBhcnJheURhdGEgPSBBcnJheUV4cHJlc3Npb24uYnVpbGRBcnJheURhdGEoIHQgKTtcbiAgICB2YXIgYXJyYXlBY2Nlc3NvciA9IGFycmF5RGF0YT8gYXJyYXlEYXRhLmFycmF5QWNjZXNzb3I6IHVuZGVmaW5lZDtcbiAgICB2YXIgdG9rZW4gPSBhcnJheURhdGE/IGFycmF5RGF0YS50b2tlbjogdDtcblxuICAgIC8vIFRlc3QgZm9yIGluZGlyZWN0aW9uXG4gICAgdmFyIHJlc3VsdCA9IEluZGlyZWN0aW9uRXhwcmVzc2lvbi5idWlsZCggdG9rZW4gKTtcbiAgICBcbiAgICAvLyBBIG1ldGhvZCBjYWxsP1xuICAgIGlmICggcmVzdWx0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHJlc3VsdCA9IE1ldGhvZEV4cHJlc3Npb24uYnVpbGQoIHRva2VuICk7XG5cbiAgICAgICAgLy8gQSBwcm9wZXJ0eVxuICAgICAgICBpZiAoIHJlc3VsdCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcmVzdWx0ID0gUHJvcGVydHlFeHByZXNzaW9uLmJ1aWxkKCB0b2tlbiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBhcnJheUFjY2Vzc29yICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHJlc3VsdCA9IEFycmF5RXhwcmVzc2lvbi5idWlsZCggcmVzdWx0LCBhcnJheUFjY2Vzc29yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0aFNlZ21lbnRFeHByZXNzaW9uO1xuIiwiLypcbiAgICBQcm9wZXJ0eUV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFByb3BlcnR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBuYW1lVG9BcHBseSApIHtcbiAgICBcbiAgICB2YXIgbmFtZSA9IG5hbWVUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSwgcGFyZW50ICl7XG4gICAgICAgIHJldHVybiBwYXJlbnRbIG5hbWUgXTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggcGFyZW50ICl7XG4gICAgICAgIHJldHVybiAnLicgKyBuYW1lO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuUHJvcGVydHlFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5RXhwcmVzc2lvbiggc3RyaW5nICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BlcnR5RXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgUmFuZ2VFeHByZXNzaW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uVG9rZW5pemVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi4vZXhwcmVzc2lvbnNVdGlscy5qcycgKTtcbnZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi9ldmFsdWF0ZUhlbHBlci5qcycgKTtcbnZhciBOdW1lcmljTGl0ZXJhbCA9IHJlcXVpcmUoICcuL2xpdGVyYWxzL251bWVyaWNMaXRlcmFsLmpzJyApO1xuXG52YXIgUmFuZ2VFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIHN0YXJ0RXhwcmVzc2lvblRvQXBwbHksIGVuZEV4cHJlc3Npb25Ub0FwcGx5LCBzdGVwRXhwcmVzc2lvblRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIHN0YXJ0RXhwcmVzc2lvbiA9IHN0YXJ0RXhwcmVzc2lvblRvQXBwbHk7XG4gICAgdmFyIGVuZEV4cHJlc3Npb24gPSBlbmRFeHByZXNzaW9uVG9BcHBseTtcbiAgICB2YXIgc3RlcEV4cHJlc3Npb24gPSBzdGVwRXhwcmVzc2lvblRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmFsdWF0ZSBhbGwgZXhwcmVzc2lvbnNcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXZhbHVhdGVIZWxwZXIuZXZhbHVhdGVOdW1iZXIoIHNjb3BlLCBzdGFydEV4cHJlc3Npb24gKTtcbiAgICAgICAgdmFyIGVuZCA9IGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlTnVtYmVyKCBzY29wZSwgZW5kRXhwcmVzc2lvbiApO1xuICAgICAgICB2YXIgc3RlcCA9IGV2YWx1YXRlSGVscGVyLmV2YWx1YXRlTnVtYmVyKCBzY29wZSwgc3RlcEV4cHJlc3Npb24gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRoZSByYW5nZSBpcyB2YWxpZCwgZXZhbHVhdGUgaXRcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgZm9yd2FyZCA9IHN0ZXAgPiAwOyBcbiAgICAgICAgXG4gICAgICAgIHZhciBjID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlKCBmb3J3YXJkPyBjIDw9IGVuZDogYyA+PSBlbmQgKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCBjICk7XG4gICAgICAgICAgICBjICs9IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIHN0YXJ0RXhwcmVzc2lvbiwgZW5kRXhwcmVzc2lvbiwgc3RlcEV4cHJlc3Npb24gKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuUmFuZ2VFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHMgKSB7XG4gICAgdmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuICAgIFxuICAgIGlmICggISBzICkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmcgPSBzLnRyaW0oKTtcbiAgICBcbiAgICAvLyBJZiBpdCBjb250YWlucyBzcGFjZXMgaXQgaXMgbm90IGEgdmFsaWQgcmFuZ2VcbiAgICBpZiAoIHN0cmluZy5pbmRleE9mKCAnICcgKSAhPT0gLTEgKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIFxuICAgIHZhciBzZWdtZW50cyA9IG5ldyBFeHByZXNzaW9uVG9rZW5pemVyKCBcbiAgICAgICAgICAgIHN0cmluZywgXG4gICAgICAgICAgICBjb250ZXh0LmdldENvbmYoKS5pbnRlcnZhbERlbGltaXRlciwgXG4gICAgICAgICAgICBmYWxzZSApO1xuXG4gICAgdmFyIG51bWJlck9mVG9rZW5zID0gc2VnbWVudHMuY291bnRUb2tlbnMoKTtcbiAgICBpZiAoIG51bWJlck9mVG9rZW5zICE9PSAyICYmIG51bWJlck9mVG9rZW5zICE9PSAzICkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBSQU5HRV9ERUZBVUxUX1NUQVJUID0gMDtcbiAgICB2YXIgUkFOR0VfREVGQVVMVF9TVEVQID0gMTtcbiAgICBcbiAgICAvLyBCdWlsZCBzdGFydCBleHByZXNzaW9uXG4gICAgdmFyIHN0YXJ0ID0gc2VnbWVudHMubmV4dFRva2VuKCkudHJpbSgpO1xuICAgIHZhciBzdGFydEV4cHJlc3Npb24gPSBzdGFydCA9PSAnJz8gXG4gICAgICAgICAgICBOdW1lcmljTGl0ZXJhbC5idWlsZCggUkFOR0VfREVGQVVMVF9TVEFSVCApOiBcbiAgICAgICAgICAgIGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzdGFydCApO1xuXG4gICAgLy8gQnVpbGQgZW5kIGV4cHJlc3Npb25cbiAgICB2YXIgZW5kRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzZWdtZW50cy5uZXh0VG9rZW4oKSApO1xuXG4gICAgLy8gQnVpbGQgc3RlcCBleHByZXNzaW9uXG4gICAgdmFyIHN0ZXBFeHByZXNzaW9uID0gbnVtYmVyT2ZUb2tlbnMgPT09IDM/IFxuICAgICAgICAgICAgZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIHNlZ21lbnRzLm5leHRUb2tlbigpICk6XG4gICAgICAgICAgICBOdW1lcmljTGl0ZXJhbC5idWlsZCggUkFOR0VfREVGQVVMVF9TVEVQICk7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBSYW5nZUV4cHJlc3Npb24oIHN0cmluZywgc3RhcnRFeHByZXNzaW9uLCBlbmRFeHByZXNzaW9uLCBzdGVwRXhwcmVzc2lvbiApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZUV4cHJlc3Npb247XG4iLCIvKlxuICAgIFZhcmlhYmxlRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xuXG52YXIgVmFyaWFibGVFeHByZXNzaW9uID0gZnVuY3Rpb24oIG5hbWVUb0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBuYW1lID0gbmFtZVRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgc2NvcGUuaXNWYWxpZFZhcmlhYmxlKCBuYW1lICkgKXtcbiAgICAgICAgICAgIHRocm93ICdOb3QgZGVjbGFyZWQgdmFyaWFibGUgZm91bmQgdXNpbmcgc3RyaWN0IG1vZGU6JyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzY29wZS5nZXQoIG5hbWUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICBcbiAgICAgICAgaWYgKCAhIGRlcHNEYXRhSXRlbS5tdXN0QWRkVmFyKCBuYW1lICkgKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzY29wZS5nZXRWYXJFeHByZXNzaW9uKCBuYW1lICk7XG4gICAgICAgIGlmICggISBleHByZXNzaW9uICl7XG4gICAgICAgICAgICBkZXBzRGF0YUl0ZW0uYWRkMU5vbkV4cHJlc3Npb25WYXIoIG5hbWUgKTtcbiAgICAgICAgICAgIHJldHVybiBbIG5hbWUgXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZGVwc0RhdGFJdGVtLmFkZDFFeHByZXNzaW9uVmFyKCBuYW1lICk7XG4gICAgICAgIHZhciByZXN1bHQgPSBleHByZXNzaW9uLmRlcGVuZHNPbiggZGVwc0RhdGFJdGVtLCBzY29wZSApO1xuICAgICAgICBkZXBzRGF0YUl0ZW0uYWRkQWxsVmFycyggcmVzdWx0LCBzY29wZSApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIGdldFZhck5hbWUgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICBnZXRWYXJOYW1lOiBnZXRWYXJOYW1lLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuVmFyaWFibGVFeHByZXNzaW9uLmJ1aWxkID0gZnVuY3Rpb24oIHN0cmluZyApIHtcbiAgICBcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkudmFyaWFibGVOYW1lUkUudGVzdCggc3RyaW5nICk/XG4gICAgICAgIG5ldyBWYXJpYWJsZUV4cHJlc3Npb24oIHN0cmluZyApOlxuICAgICAgICB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhcmlhYmxlRXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgSmF2YXNjcmlwdEV4cHJlc3Npb24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcbnZhciBleHByZXNzaW9uc1V0aWxzID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25zVXRpbHMuanMnICk7XG52YXIgU3RyaW5nRXhwcmVzc2lvbiA9IHJlcXVpcmUoICcuLi9zdHJpbmdFeHByZXNzaW9uLmpzJyApO1xuXG52YXIgSmF2YXNjcmlwdEV4cHJlc3Npb24gPSBmdW5jdGlvbiggZXhwcmVzc2lvblRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZ0V4cHJlc3Npb24gPSBleHByZXNzaW9uVG9BcHBseTtcbiAgICBcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiggc2NvcGUgKXtcbiAgICAgICAgdmFyIGV2YWx1YXRlZFN0cmluZyA9IHN0cmluZ0V4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgIHJldHVybiBldmFsKCBldmFsdWF0ZWRTdHJpbmcgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZXBlbmRzT24gPSBmdW5jdGlvbiggZGVwc0RhdGFJdGVtLCBzY29wZSApe1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNVdGlscy5idWlsZERlcGVuZHNPbkxpc3QoIGRlcHNEYXRhSXRlbSwgc2NvcGUsIHN0cmluZ0V4cHJlc3Npb24gKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmdFeHByZXNzaW9uO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxuICAgICAgICBkZXBlbmRzT246IGRlcGVuZHNPbixcbiAgICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gICAgfTtcbn07XG5cbkphdmFzY3JpcHRFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IHRydWU7XG5cbkphdmFzY3JpcHRFeHByZXNzaW9uLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICggSmF2YXNjcmlwdEV4cHJlc3Npb24ucHJlZml4ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgSmF2YXNjcmlwdEV4cHJlc3Npb24ucHJlZml4ID0gY29udGV4dC5nZXRDb25mKCkuamF2YVNjcmlwdEV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBKYXZhc2NyaXB0RXhwcmVzc2lvbi5wcmVmaXg7XG59O1xuXG5KYXZhc2NyaXB0RXhwcmVzc2lvbi5nZXRJZCA9IEphdmFzY3JpcHRFeHByZXNzaW9uLmdldFByZWZpeDtcblxuSmF2YXNjcmlwdEV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIHJldHVybiBuZXcgSmF2YXNjcmlwdEV4cHJlc3Npb24oXG4gICAgICAgICAgICBTdHJpbmdFeHByZXNzaW9uLmJ1aWxkKCBzdHJpbmcgKSApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKYXZhc2NyaXB0RXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgUXVlcnlFeHByZXNzaW9uIGNsYXNzXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uLy4uL2NvbnRleHQuanMnICk7XG52YXIgZXhwcmVzc2lvbnNVdGlscyA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgUXVlcnlFeHByZXNzaW9uID0gZnVuY3Rpb24oIHN0cmluZ1RvQXBwbHksIGV4cHJlc3Npb25Ub0FwcGx5ICkge1xuICAgIFxuICAgIHZhciBzdHJpbmcgPSBzdHJpbmdUb0FwcGx5O1xuICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvblRvQXBwbHk7XG4gICAgXG4gICAgdmFyIGV2YWx1YXRlID0gZnVuY3Rpb24oIHNjb3BlICl7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZCA9IGV4cHJlc3Npb24uZXZhbHVhdGUoIHNjb3BlICk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudExpc3QgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggZXZhbHVhdGVkICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGVsZW1lbnRMaXN0IHdpdGggbGVuZ3RoIDFcbiAgICAgICAgICAgIGlmICggZWxlbWVudExpc3QubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRMaXN0WyAwIF0uaW5uZXJUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBlbGVtZW50TGlzdCB3aXRoIGxlbmd0aCA+IDFcbiAgICAgICAgICAgIHZhciB0ZXh0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudExpc3QubGVuZ3RoOyArK2kgKXtcbiAgICAgICAgICAgICAgICB0ZXh0cy5wdXNoKCBlbGVtZW50TGlzdFsgaSBdLmlubmVyVGV4dCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHRzO1xuICAgICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKCBlICl7XG4gICAgICAgICAgICByZXR1cm4gJ1F1ZXJ5IGV4cHJlc3Npb24gZXJyb3IgaW4gXCInICsgc3RyaW5nICsgJ1wiOiAnICsgZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVwZW5kc09uID0gZnVuY3Rpb24oIGRlcHNEYXRhSXRlbSwgc2NvcGUgKXtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zVXRpbHMuYnVpbGREZXBlbmRzT25MaXN0KCBkZXBzRGF0YUl0ZW0sIHNjb3BlLCBleHByZXNzaW9uICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuUXVlcnlFeHByZXNzaW9uLnJlbW92ZVByZWZpeCA9IHRydWU7XG5RdWVyeUV4cHJlc3Npb24uZ2V0UHJlZml4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0Q29uZigpLnF1ZXJ5RXhwcmVzc2lvbjtcbn07XG5RdWVyeUV4cHJlc3Npb24uZ2V0SWQgPSBRdWVyeUV4cHJlc3Npb24uZ2V0UHJlZml4O1xuXG5RdWVyeUV4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIHZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9uQnVpbGRlci5qcycgKTtcbiAgICBcbiAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkKCBzdHJpbmcgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5RXhwcmVzc2lvbjtcbiIsIi8qXG4gICAgU3RyaW5nRXhwcmVzc2lvbiBjbGFzc1xuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi9jb250ZXh0LmpzJyApO1xudmFyIFN0cmluZ0xpdGVyYWwgPSByZXF1aXJlKCAnLi9wYXRoL2xpdGVyYWxzL3N0cmluZ0xpdGVyYWwuanMnICk7XG52YXIgUGF0aEV4cHJlc3Npb24gPSByZXF1aXJlKCAnLi9wYXRoL3BhdGhFeHByZXNzaW9uLmpzJyApO1xudmFyIGV4cHJlc3Npb25zVXRpbHMgPSByZXF1aXJlKCAnLi9leHByZXNzaW9uc1V0aWxzLmpzJyApO1xuXG52YXIgU3RyaW5nRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCBzdHJpbmdUb0FwcGx5LCBleHByZXNzaW9uTGlzdFRvQXBwbHkgKSB7XG4gICAgXG4gICAgdmFyIHN0cmluZyA9IHN0cmluZ1RvQXBwbHk7XG4gICAgdmFyIGV4cHJlc3Npb25MaXN0ID0gZXhwcmVzc2lvbkxpc3RUb0FwcGx5O1xuICAgIFxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uKCBzY29wZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbkxpc3QubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25MaXN0WyBpIF07XG4gICAgICAgICAgICByZXN1bHQgKz0gZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIGRlcGVuZHNPbiA9IGZ1bmN0aW9uKCBkZXBzRGF0YUl0ZW0sIHNjb3BlICl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uc1V0aWxzLmJ1aWxkRGVwZW5kc09uTGlzdCggZGVwc0RhdGFJdGVtLCBzY29wZSwgZXhwcmVzc2lvbkxpc3QgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBldmFsdWF0ZTogZXZhbHVhdGUsXG4gICAgICAgIGRlcGVuZHNPbjogZGVwZW5kc09uLFxuICAgICAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgICB9O1xufTtcblxuU3RyaW5nRXhwcmVzc2lvbi5yZW1vdmVQcmVmaXggPSB0cnVlO1xuU3RyaW5nRXhwcmVzc2lvbi5nZXRQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRDb25mKCkuc3RyaW5nRXhwcmVzc2lvbjtcbn07XG5TdHJpbmdFeHByZXNzaW9uLmdldElkID0gU3RyaW5nRXhwcmVzc2lvbi5nZXRQcmVmaXg7XG5cblN0cmluZ0V4cHJlc3Npb24uYnVpbGQgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIHZhciBTVEFURV9TQ0FOTklORyA9IDA7XG4gICAgdmFyIFNUQVRFX0FUX0RPTExBUiA9IDE7XG4gICAgdmFyIFNUQVRFX0lOX0VYUFJFU1NJT04gPSAyO1xuICAgIHZhciBTVEFURV9JTl9CUkFDS0VURURfRVhQUkVTU0lPTiA9IDM7XG5cbiAgICB2YXIgZXhwcmVzc2lvbkxpc3QgPSBbXTtcbiAgICB2YXIgbGl0ZXJhbCA9ICcnO1xuICAgIHZhciBzdWJleHByZXNzaW9uID0gJyc7XG4gICAgdmFyIHN0YXRlID0gU1RBVEVfU0NBTk5JTkc7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQXQoIGkgKTtcblxuICAgICAgICBzd2l0Y2ggKCBzdGF0ZSApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgLy8gSW4gdGhlIHN0cmluZyBwYXJ0IG9mIHRoZSBleHByZXNzaW9uXG4gICAgICAgIGNhc2UgU1RBVEVfU0NBTk5JTkc6XG4gICAgICAgICAgICAvLyBGb3VuZCBhIGRvbGxhciBzaWduXG4gICAgICAgICAgICBpZiAoIGNoID09PSAnJCcgKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9BVF9ET0xMQVI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBKdXN0IGtlZXAgYXBwZW5kaW5nIHRvIGJ1ZmZlclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gTmV4dCBjaGFyYWN0ZXIgYWZ0ZXIgZG9sbGFyIHNpZ25cbiAgICAgICAgY2FzZSBTVEFURV9BVF9ET0xMQVI6XG4gICAgICAgICAgICAvLyBBbiBlc2NhcGVkIGRvbGxhciBzaWduXG4gICAgICAgICAgICBpZiAoIGNoID09PSAnJCcgKSB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbCArPSAnJCc7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9TQ0FOTklORztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEJlZ2lubmluZyBvZiBhIGJyYWNrZXRlZCBleHByZXNzaW9uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjaCA9PT0gJ3snICkge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHN1YmV4cHJlc3Npb24gYW5kIGNoYW5nZSBzdGF0ZVxuICAgICAgICAgICAgICAgIHN1YmV4cHJlc3Npb24gPSAnJztcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX0lOX0JSQUNLRVRFRF9FWFBSRVNTSU9OO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpdGVyYWwgYW5kIHJlc2V0IGl0IGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmICggbGl0ZXJhbCApe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uTGlzdC5wdXNoKCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3RyaW5nTGl0ZXJhbCggbGl0ZXJhbCApIFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQmVnaW5uaW5nIG9mIGEgbm9uIGJyYWNrZXRlZCBleHByZXNzaW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YmV4cHJlc3Npb24gKz0gY2g7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9JTl9FWFBSRVNTSU9OO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCBsaXRlcmFsIGFuZCByZXNldCBpdCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoIGxpdGVyYWwgKXtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbkxpc3QucHVzaCggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0cmluZ0xpdGVyYWwoIGxpdGVyYWwgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSW4gc3ViZXhwcmVzc2lvblxuICAgICAgICBjYXNlIFNUQVRFX0lOX0JSQUNLRVRFRF9FWFBSRVNTSU9OOlxuICAgICAgICBjYXNlIFNUQVRFX0lOX0VYUFJFU1NJT046XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZW5kXG4gICAgICAgICAgICBpZiAoICggc3RhdGUgPT09IFNUQVRFX0lOX0JSQUNLRVRFRF9FWFBSRVNTSU9OICYmIGNoID09PSAnfScgKVxuICAgICAgICAgICAgICAgICAgICB8fCAoIHN0YXRlID09PSBTVEFURV9JTl9FWFBSRVNTSU9OICYmIGNoID09ICcgJyApICkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25MaXN0LnB1c2goIFxuICAgICAgICAgICAgICAgICAgICAgICAgUGF0aEV4cHJlc3Npb24uYnVpbGQoIHN1YmV4cHJlc3Npb24gKSBcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gU1RBVEVfSU5fRVhQUkVTU0lPTiApIHtcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9TQ0FOTklORztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEtlZXAgYXBwZW5kaW5nIHRvIHN1YmV4cHJlc3Npb25cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViZXhwcmVzc2lvbiArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuZGVkIGluIHVuY2xvc2VkIGJyYWNrZXRcbiAgICBpZiAoIHN0YXRlID09PSBTVEFURV9JTl9CUkFDS0VURURfRVhQUkVTU0lPTiApIHtcbiAgICAgICAgdGhyb3cgJ1VuY2xvc2VkIGxlZnQgY3VybHkgYnJhY2U6ICcgKyBzdHJpbmc7XG4gICAgICAgIFxuICAgIC8vIEVuZGVkIGF0IGV4cHJlc3Npb25cbiAgICB9IGVsc2UgaWYgKCBzdGF0ZSA9PSBTVEFURV9JTl9FWFBSRVNTSU9OICkge1xuICAgICAgICBleHByZXNzaW9uTGlzdC5wdXNoKCBcbiAgICAgICAgICAgICAgICBQYXRoRXhwcmVzc2lvbi5idWlsZCggc3ViZXhwcmVzc2lvbiApIFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICggbGl0ZXJhbCApe1xuICAgICAgICBleHByZXNzaW9uTGlzdC5wdXNoKCBcbiAgICAgICAgICAgICAgICBuZXcgU3RyaW5nTGl0ZXJhbCggbGl0ZXJhbCApIFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RyaW5nRXhwcmVzc2lvbiggc3RyaW5nLCBleHByZXNzaW9uTGlzdCApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdFeHByZXNzaW9uO1xuIiwiLyogXG4gICAgSTE4biBjbGFzcyBcbiAgICBFeHRlcm5hbCBkZXBlbmRlbmNpZXM6IEludGwgKHN1cHBvcnRlZCBieSByZWNlbnQgYnJvd3NlcnMpIGFuZCBNZXNzYWdlRm9ybWF0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggbGFuZ3VhZ2VJZCwgcmVzICkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSggJ21lc3NhZ2Vmb3JtYXQnICk7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCAnLi4vdXRpbHMuanMnICk7XG4gICAgXG4gICAgdmFyIHJlc291cmNlcyA9IHJlcztcbiAgICB2YXIgbWYgPSBuZXcgTWVzc2FnZUZvcm1hdCggbGFuZ3VhZ2VJZCApO1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHZhciBudW1iZXJGb3JtYXRDYWNoZSA9IHt9O1xuICAgIHZhciBkYXRlVGltZUZvcm1hdENhY2hlID0ge307XG4gICAgLyp2YXIgQ09ORl9SRVNPVVJDRV9JRCA9ICcvQ09ORi8nOyovXG4gICAgdmFyIENPTkZfUkVTT1VSQ0VfSUQgPSBjb250ZXh0LmdldENvbmYoKS5pMThuQ29uZlJlc291cmNlSWQ7XG4gICAgXG4gICAgdmFyIGdldExhbmd1YWdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy9yZXR1cm4gcmVzb3VyY2VzWyBjb250ZXh0LmdldENvbmYoKS5pMThuQ29uZlJlc291cmNlSWQgXS5sYW5ndWFnZTtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlc1sgQ09ORl9SRVNPVVJDRV9JRCBdLmxhbmd1YWdlO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGdldExvY2FsZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vcmV0dXJuIHJlc291cmNlc1sgY29udGV4dC5nZXRDb25mKCkuaTE4bkNvbmZSZXNvdXJjZUlkIF0ubG9jYWxlO1xuICAgICAgICByZXR1cm4gcmVzb3VyY2VzWyBDT05GX1JFU09VUkNFX0lEIF0ubG9jYWxlO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGV4aXN0cyA9IGZ1bmN0aW9uKCBpZCApIHtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlc1sgaWQgXSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRyID0gZnVuY3Rpb24oIGlkLCBwYXJhbXMsIGZvcm1hdCwgc3ViZm9ybWF0ICkge1xuICAgICAgICBcbiAgICAgICAgc3dpdGNoICggZm9ybWF0ICkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHRyU3RyaW5nKCBpZCwgcGFyYW1zICk7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJOdW1iZXIoIGlkLCBwYXJhbXMgKTtcbiAgICAgICAgY2FzZSAnY3VycmVuY3knOlxuICAgICAgICAgICAgcmV0dXJuIHRyQ3VycmVuY3koIGlkLCBwYXJhbXMsIHN1YmZvcm1hdCApO1xuICAgICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJEYXRlVGltZSggaWQsIHBhcmFtcyApO1xuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgdGhyb3cgJ0kxOG4gZm9ybWF0IHR5cGUgbm90IHN1cHBvcnRlZDogJyArIGZvcm1hdDtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0clN0cmluZyA9IGZ1bmN0aW9uKCBpZCwgcGFyYW1zICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIG1mdW5jID0gY2FjaGVbIGlkIF07XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgbWZ1bmMgKXtcbiAgICAgICAgICAgIG1mdW5jID0gbWYuY29tcGlsZSggcmVzb3VyY2VzWyBpZCBdICk7XG4gICAgICAgICAgICBjYWNoZVsgaWQgXSA9IG1mdW5jO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbWZ1bmMoIHBhcmFtcyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGdldFNvdXJjZSA9IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwYXJhbXMgJiYgdXRpbHMuaXNGdW5jdGlvbiggcGFyYW1zLnRvU291cmNlICk/XG4gICAgICAgICAgICBwYXJhbXMudG9Tb3VyY2UoKTpcbiAgICAgICAgICAgICcnO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRyTnVtYmVyID0gZnVuY3Rpb24oIHZhbHVlLCBwYXJhbXMgKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgc291cmNlID0gZ2V0U291cmNlKCBwYXJhbXMgKTtcbiAgICAgICAgdmFyIG51bWJlckZvcm1hdCA9IG51bWJlckZvcm1hdENhY2hlWyBzb3VyY2UgXTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBudW1iZXJGb3JtYXQgKXtcbiAgICAgICAgICAgIG51bWJlckZvcm1hdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCggZ2V0TG9jYWxlKCksIHBhcmFtcyApO1xuICAgICAgICAgICAgbnVtYmVyRm9ybWF0Q2FjaGVbIHNvdXJjZSBdID0gbnVtYmVyRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbnVtYmVyRm9ybWF0LmZvcm1hdCggdmFsdWUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0ckN1cnJlbmN5ID0gZnVuY3Rpb24oIHZhbHVlLCBwYXJhbXMsIHRoZUN1cnJlbmN5ICkge1xuICAgICAgICBcbiAgICAgICAgcGFyYW1zLnN0eWxlID0gJ2N1cnJlbmN5JztcbiAgICAgICAgcGFyYW1zLmN1cnJlbmN5ID0gdGhlQ3VycmVuY3k7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJOdW1iZXIoIHZhbHVlLCBwYXJhbXMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB0ckRhdGVUaW1lID0gZnVuY3Rpb24oIHZhbHVlLCBwYXJhbXMgKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgc291cmNlID0gZ2V0U291cmNlKCBwYXJhbXMgKTtcbiAgICAgICAgdmFyIGRhdGVUaW1lRm9ybWF0ID0gZGF0ZVRpbWVGb3JtYXRDYWNoZVsgc291cmNlIF07XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgZGF0ZVRpbWVGb3JtYXQgKXtcbiAgICAgICAgICAgIGRhdGVUaW1lRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoIGdldExvY2FsZSgpLCBwYXJhbXMgKTtcbiAgICAgICAgICAgIGRhdGVUaW1lRm9ybWF0Q2FjaGVbIHNvdXJjZSBdID0gZGF0ZVRpbWVGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkYXRlVGltZUZvcm1hdC5mb3JtYXQoIHZhbHVlICk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRMYW5ndWFnZTogZ2V0TGFuZ3VhZ2UsXG4gICAgICAgIGdldExvY2FsZTogZ2V0TG9jYWxlLFxuICAgICAgICBleGlzdHM6IGV4aXN0cyxcbiAgICAgICAgdHI6IHRyXG4gICAgfTtcbn07XG4iLCIvKiBcbiAgICBJMThuQnVuZGxlIGNsYXNzIFxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oICkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBpMThuTGlzdCA9IHt9O1xuICAgIHZhciBmaXJzdCA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiggaTE4biApe1xuICAgICAgICBpMThuTGlzdFsgaTE4bi5nZXRMYW5ndWFnZSgpIF0gPSBpMThuO1xuICAgICAgICBpZiAoICEgZmlyc3QgKXtcbiAgICAgICAgICAgIGZpcnN0ID0gaTE4bjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIGV4aXN0cyA9IGZ1bmN0aW9uKCBpZCApe1xuICAgICAgICByZXR1cm4gZmlyc3QuZXhpc3RzKCBpZCApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHRyID0gZnVuY3Rpb24oIGlkLCBwYXJhbXMsIGZvcm1hdCwgc3ViZm9ybWF0LCBsYW5ndWFnZSApIHtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBsYW5ndWFnZSApe1xuICAgICAgICAgICAgdGhyb3cgJ0xhbmd1YWdlIG5vdCBkZWZpbmVkISBQbGVhc2UsIHVzZSBkYXRhLWlMYW5ndWFnZSB0byBkZWZpbmUgaXQgYmVmb3JlIHRyeWluZyB0byB0cmFuc2xhdGUgYW55dGhpbmchJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGkxOG4gPSBpMThuTGlzdFsgbGFuZ3VhZ2UgXTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBpMThuICl7XG4gICAgICAgICAgICB0aHJvdyAnTGFuZ3VhZ2UgXCInICsgbGFuZ3VhZ2UgKyAnXCIgbm90IGZvdW5kIGluIEkxOG5CdW5kbGUhJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGkxOG4udHIoIGlkLCBwYXJhbXMsIGZvcm1hdCwgc3ViZm9ybWF0ICk7XG4gICAgfTtcblxuICAgIC8vIEluaXQhXG4gICAgZm9yICggdmFyIGMgPSAwOyBjIDwgYXJndW1lbnRzLmxlbmd0aDsgYysrICkge1xuICAgICAgICBhZGQoIGFyZ3VtZW50c1sgYyBdICk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogYWRkLFxuICAgICAgICBleGlzdHM6IGV4aXN0cyxcbiAgICAgICAgdHI6IHRyXG4gICAgfTtcbn07XG4iLCIvKiBcbiAgICBpMThuSGVscGVyIHNpbmdsZXRvbiBjbGFzcyBcbiovXG52YXIgdXRpbHMgPSByZXF1aXJlKCAnLi4vdXRpbHMuanMnICk7XG52YXIgSTE4biA9IHJlcXVpcmUoICcuL2kxOG4uanMnICk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi9jb250ZXh0LmpzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgdHIgPSBmdW5jdGlvbiAoIGkxOG5MaXN0LCBpZCwgcGFyYW1zLCBmb3JtYXQsIHN1YmZvcm1hdCwgbGFuZ3VhZ2UgKXtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBpMThuTGlzdCApIHtcbiAgICAgICAgICAgIHJldHVybiAnTm8gSTE4biBpbnN0YW5jZSBkZWZpbmVkISc7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB2YXIgbGVuZ3RoID0gaTE4bkxpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoICEgbGVuZ3RoICl7XG4gICAgICAgICAgICByZXR1cm4gJ1ZvaWQgSTE4biBsaXN0ISc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBpMThuID0gaTE4bkxpc3RbIGkgXTtcbiAgICAgICAgICAgIGlmICggZm9ybWF0ICE9PSAnc3RyaW5nJyB8fCBpMThuLmV4aXN0cyggaWQgKSApe1xuICAgICAgICAgICAgICAgIHJldHVybiBpMThuLnRyKCBpZCwgcGFyYW1zLCBmb3JtYXQsIHN1YmZvcm1hdCwgbGFuZ3VhZ2UgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuICdJMThuIHJlc291cmNlIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCEnO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGxvYWRBc3luYyA9IGZ1bmN0aW9uKCByZW1vdGVMaXN0LCBjYWxsYmFjaywgZmFpbENhbGxiYWNrICl7XG4gICAgICAgIFxuICAgICAgICBsb2FkQXN5bmNJdGVtKCBcbiAgICAgICAgICAgIHt9LCBcbiAgICAgICAgICAgIGNhbGxiYWNrLCBcbiAgICAgICAgICAgIGZhaWxDYWxsYmFjayxcbiAgICAgICAgICAgIHJlbW90ZUxpc3QsIFxuICAgICAgICAgICAgcmVtb3RlTGlzdC5sZW5ndGggLSAxICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbG9hZEFzeW5jSXRlbSA9IGZ1bmN0aW9uKCBtYXAsIGNhbGxiYWNrLCBmYWlsQ2FsbGJhY2ssIHJlbW90ZUxpc3QsIGN1cnJlbnRJbmRleCApe1xuICAgICAgICBcbiAgICAgICAgdmFyIHVybCA9IHJlbW90ZUxpc3RbIGN1cnJlbnRJbmRleCBdO1xuICAgICAgICB1dGlscy5nZXRKU09OKCBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBkb25lOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwWyB1cmwgXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VycmVudEluZGV4ID4gMCApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEFzeW5jSXRlbSggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbENhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUxpc3QsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tY3VycmVudEluZGV4ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggbWFwICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uKCBqcXhociwgdGV4dFN0YXR1cywgZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXN5bmNFcnJvciggdXJsLCBlcnJvciwgZmFpbENhbGxiYWNrICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG4gICAgLypcbiAgICB2YXIgbG9hZEFzeW5jSXRlbSA9IGZ1bmN0aW9uKCBtYXAsIGNhbGxiYWNrLCBmYWlsQ2FsbGJhY2ssIHJlbW90ZUxpc3QsIGN1cnJlbnRJbmRleCApe1xuICAgICAgICBcbiAgICAgICAgdmFyIHVybCA9IHJlbW90ZUxpc3RbIGN1cnJlbnRJbmRleCBdO1xuICAgICAgICAkLmdldEpTT04oIHVybCApXG4gICAgICAgICAgICAuZG9uZShcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwWyB1cmwgXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICggY3VycmVudEluZGV4ID4gMCApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEFzeW5jSXRlbSggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbENhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUxpc3QsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tY3VycmVudEluZGV4ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayggbWFwICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmFpbChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigganF4aHIsIHRleHRTdGF0dXMsIGVycm9yICkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFzeW5jRXJyb3IoIHVybCwgZXJyb3IsIGZhaWxDYWxsYmFjayApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgfTtcbiAgICAqL1xuICAgIFxuICAgIHZhciBsb2FkQXN5bmNBdXRvID0gZnVuY3Rpb24oIGRpY3Rpb25hcnksIGkxOG4sIGNhbGxiYWNrLCBmYWlsQ2FsbGJhY2sgKXtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldHVybiBpZiBpdCBpcyBub3RoaW5nIHRvIGRvXG4gICAgICAgIGlmICggISBpMThuIHx8ICEgaTE4bi5maWxlcyB8fCAhIE9iamVjdC5rZXlzKCBpMThuLmZpbGVzICkubGVuZ3RoICl7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBCdWlsZCBqc29uRmlsZXMgYXJyYXlcbiAgICAgICAgdmFyIG51bWJlck9mTGFuZ3VhZ2VzID0gT2JqZWN0LmtleXMoIGkxOG4uZmlsZXMgKS5sZW5ndGg7XG4gICAgICAgIHZhciBqc29uRmlsZXMgPSBbXTtcbiAgICAgICAgdmFyIHVybFByZWZpeCA9IGkxOG4udXJsUHJlZml4IHx8ICcnO1xuICAgICAgICBmb3IgKCB2YXIgbGFuZyBpbiBpMThuLmZpbGVzICl7XG4gICAgICAgICAgICB2YXIgbGFuZ0ZpbGVzID0gaTE4bi5maWxlc1sgbGFuZyBdO1xuICAgICAgICAgICAgZm9yICggdmFyIGluZGV4IGluIGxhbmdGaWxlcyApe1xuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbGFuZ0ZpbGVzWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSB1cmxQcmVmaXggKyBmaWxlO1xuICAgICAgICAgICAgICAgIGpzb25GaWxlcy5wdXNoKCB1cmwgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXNlIGxvYWRBc3luYyBtZXRob2QgdG8gbG9hZCBhbGwganNvbkZpbGVzOyB0aGVuIHJlZ2lzdGVyIEkxOG4gaW5zdGFuY2VzIGFuZCBhcnJheXNcbiAgICAgICAgbG9hZEFzeW5jKCBcbiAgICAgICAgICAgIGpzb25GaWxlcywgXG4gICAgICAgICAgICBmdW5jdGlvbiggaTE4bk1hcCApe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoIHZhciBsYW5nIGluIGkxOG4uZmlsZXMgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdGaWxlcyA9IGkxOG4uZmlsZXNbIGxhbmcgXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkxOG5JbnN0YW5jZUFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBSZWdpc3RlciBhcnJheSB2YXJzXG4gICAgICAgICAgICAgICAgICAgIGRpY3Rpb25hcnlbIGJ1aWxkSTE4bkluc3RhbmNlQXJyYXlOYW1lKCBsYW5nICkgXSA9IGkxOG5JbnN0YW5jZUFycmF5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG51bWJlck9mTGFuZ3VhZ2VzID09PSAxICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5WyAnaTE4bkFycmF5JyBdID0gaTE4bkluc3RhbmNlQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIHZhciBpbmRleCBpbiBsYW5nRmlsZXMgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbGFuZ0ZpbGVzWyBpbmRleCBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHVybFByZWZpeCArIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTE4bkluc3RhbmNlID0gbmV3IEkxOG4oIGxhbmcsIGkxOG5NYXBbIHVybCBdICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGkxOG4gaW5zdGFuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5WyBidWlsZEkxOG5JbnN0YW5jZU5hbWUoIGZpbGUgKSBdID0gaTE4bkluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bkluc3RhbmNlQXJyYXkudW5zaGlmdCggaTE4bkluc3RhbmNlICk7IC8vIEFkZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFpbENhbGxiYWNrIFxuICAgICAgICApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGJ1aWxkSTE4bkluc3RhbmNlQXJyYXlOYW1lID0gZnVuY3Rpb24oIGxhbmcgKXtcbiAgICAgICAgcmV0dXJuICdpMThuJyArIGxhbmcudG9VcHBlckNhc2UoKSArICdBcnJheSc7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgYnVpbGRJMThuSW5zdGFuY2VOYW1lID0gZnVuY3Rpb24oIGZpbGUgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBmaWxlV2l0aG91dEV4dGVuc2lvbiA9IGZpbGUuc3Vic3RyKCAwLCBmaWxlLmxhc3RJbmRleE9mKCAnLicgKSApO1xuICAgICAgICByZXR1cm4gJ2kxOG4nICsgZmlsZVdpdGhvdXRFeHRlbnNpb24udG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHI6IHRyLFxuICAgICAgICBsb2FkQXN5bmM6IGxvYWRBc3luYyxcbiAgICAgICAgbG9hZEFzeW5jQXV0bzogbG9hZEFzeW5jQXV0b1xuICAgIH07XG59KSgpO1xuIiwiLypcbiAgICBsb2dIZWxwZXIgc2luZ2xldG9uIGNsYXNzXG4qL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi9jb250ZXh0LmpzJyApO1xuICAgIFxuICAgIHZhciB0cmFjZSA9IGZ1bmN0aW9uICgpe1xuICAgICAgICBcbiAgICAgICAgdmFyIGxvZ2dlciA9IGNvbnRleHQuZ2V0TG9nZ2VyKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgbG9nZ2VyICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxvZ2dlci50cmFjZS5hcHBseSggbG9nZ2VyLCBhcmd1bWVudHMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBkZWJ1ZyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICBcbiAgICAgICAgdmFyIGxvZ2dlciA9IGNvbnRleHQuZ2V0TG9nZ2VyKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgbG9nZ2VyICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1Zy5hcHBseSggbG9nZ2VyLCBhcmd1bWVudHMgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBpbmZvID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIFxuICAgICAgICB2YXIgbG9nZ2VyID0gY29udGV4dC5nZXRMb2dnZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBsb2dnZXIgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmluZm8uYXBwbHkoIGxvZ2dlciwgYXJndW1lbnRzICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgd2FybiA9IGZ1bmN0aW9uICgpe1xuICAgICAgICBcbiAgICAgICAgdmFyIGxvZ2dlciA9IGNvbnRleHQuZ2V0TG9nZ2VyKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgbG9nZ2VyICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxvZ2dlci53YXJuLmFwcGx5KCBsb2dnZXIsIGFyZ3VtZW50cyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGVycm9yID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIFxuICAgICAgICB2YXIgbG9nZ2VyID0gY29udGV4dC5nZXRMb2dnZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBsb2dnZXIgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmVycm9yLmFwcGx5KCBsb2dnZXIsIGFyZ3VtZW50cyApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGZhdGFsID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIFxuICAgICAgICB2YXIgbG9nZ2VyID0gY29udGV4dC5nZXRMb2dnZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBsb2dnZXIgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbG9nZ2VyLmZhdGFsLmFwcGx5KCBsb2dnZXIsIGFyZ3VtZW50cyApO1xuICAgIH07XG4gICAgXG4gICAgLypcbiAgICB2YXIgZmF0YWxBbmRUaHJvdyA9IGZ1bmN0aW9uICggbWVzc2FnZSApe1xuICAgICAgICBcbiAgICAgICAgZmF0YWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH07Ki9cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICB0cmFjZTogdHJhY2UsXG4gICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgaW5mbzogaW5mbyxcbiAgICAgICAgd2Fybjogd2FybixcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBmYXRhbDogZmF0YWxcbiAgICAgICAgLy9mYXRhbEFuZFRocm93OiBmYXRhbEFuZFRocm93XG4gICAgfTtcbn0pKCk7XG4iLCIvKlxyXG4gICAgRXhwb3J0ZWQgZnVuY3Rpb25zXHJcbiovXHJcbmV4cG9ydHMucnVuID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcclxuICAgIFxyXG4gICAgdmFyIHBhcnNlciA9IHJlcXVpcmUoICcuL3BhcnNlcnMvcGFyc2VyLmpzJyApO1xyXG4gICAgcmV0dXJuIHBhcnNlci5ydW4oIG9wdGlvbnMgKTtcclxufTtcclxuXHJcbi8qIERlY2xhcmUgZXhwb3J0cyAqL1xyXG5leHBvcnRzLkkxOG4gPSByZXF1aXJlKCAnLi9pMThuL2kxOG4uanMnICk7XHJcbmV4cG9ydHMuSTE4bkJ1bmRsZSA9IHJlcXVpcmUoICcuL2kxOG4vaTE4bkJ1bmRsZS5qcycgKTtcclxuZXhwb3J0cy5pMThuSGVscGVyID0gcmVxdWlyZSggJy4vaTE4bi9pMThuSGVscGVyLmpzJyApO1xyXG5leHBvcnRzLmNvbnRleHQgPSByZXF1aXJlKCAnLi9jb250ZXh0LmpzJyApO1xyXG5leHBvcnRzLmxvZ0hlbHBlciA9IHJlcXVpcmUoICcuL2xvZ0hlbHBlci5qcycgKTtcclxuZXhwb3J0cy5leHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xyXG5leHBvcnRzLmV2YWx1YXRlSGVscGVyID0gcmVxdWlyZSggJy4vZXhwcmVzc2lvbnMvZXZhbHVhdGVIZWxwZXIuanMnICk7XHJcbmV4cG9ydHMuRXhwcmVzc2lvblRva2VuaXplciA9IHJlcXVpcmUoICcuL2V4cHJlc3Npb25zL2V4cHJlc3Npb25Ub2tlbml6ZXIuanMnICk7XHJcbmV4cG9ydHMuUmVhY3RpdmVEaWN0aW9uYXJ5ID0gcmVxdWlyZSggJy4vc2NvcGVzL3JlYWN0aXZlRGljdGlvbmFyeS5qcycgKTtcclxuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSggJy4vdmVyc2lvbi5qcycgKTtcclxuXHJcbi8qIFN1cHBvcnQgUmVxdWlyZUpTIG1vZHVsZSBwYXR0ZXJuICovXHJcbmlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xyXG4gICAgZGVmaW5lKCAnenB0LnJ1bicsIGV4cG9ydHMucnVuICk7XHJcbiAgICBkZWZpbmUoICd6cHQuSTE4bicsIGV4cG9ydHMuSTE4biApO1xyXG4gICAgZGVmaW5lKCAnenB0LkkxOG5CdW5kbGUnLCBleHBvcnRzLkkxOG5CdW5kbGUgKTtcclxuICAgIGRlZmluZSggJ3pwdC5pMThuSGVscGVyJywgZXhwb3J0cy5pMThuSGVscGVyICk7XHJcbiAgICBkZWZpbmUoICd6cHQuY29udGV4dCcsIGV4cG9ydHMuY29udGV4dCApO1xyXG4gICAgZGVmaW5lKCAnenB0LmxvZ0hlbHBlcicsIGV4cG9ydHMubG9nSGVscGVyICk7XHJcbiAgICBkZWZpbmUoICd6cHQuZXhwcmVzc2lvbkJ1aWxkZXInLCBleHBvcnRzLmV4cHJlc3Npb25CdWlsZGVyICk7XHJcbiAgICBkZWZpbmUoICd6cHQuZXZhbHVhdGVIZWxwZXInLCBleHBvcnRzLmV2YWx1YXRlSGVscGVyICk7XHJcbiAgICBkZWZpbmUoICd6cHQuRXhwcmVzc2lvblRva2VuaXplcicsIGV4cG9ydHMuRXhwcmVzc2lvblRva2VuaXplciApO1xyXG4gICAgZGVmaW5lKCAnenB0LlJlYWN0aXZlRGljdGlvbmFyeScsIGV4cG9ydHMuUmVhY3RpdmVEaWN0aW9uYXJ5ICk7XHJcbiAgICBkZWZpbmUoICd6cHQudmVyc2lvbicsIGV4cG9ydHMudmVyc2lvbiApO1xyXG59XHJcbiIsIi8qIFxuICAgIENsYXNzIEF1dG9EZWZpbmVIZWxwZXIgXG4qL1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcbnZhciBUQUxEZWZpbmUgPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9UQUwvdGFsRGVmaW5lLmpzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICggbm9kZSApIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICB2YXIgZGVmaW5lRGVsaW1pdGVyID0gY29udGV4dC5nZXRDb25mKCkuZGVmaW5lRGVsaW1pdGVyO1xuICAgIHZhciBpbkRlZmluZURlbGltaXRlciA9IGNvbnRleHQuZ2V0Q29uZigpLmluRGVmaW5lRGVsaW1pdGVyO1xuICAgIHZhciBub2NhbGxFeHByZXNzaW9uUHJlZml4ID0gY29udGV4dC5nZXRDb25mKCkubm9jYWxsVmFyaWFibGVFeHByZXNzaW9uUHJlZml4O1xuICAgIHZhciB0YWxBdXRvRGVmaW5lID0gY29udGV4dC5nZXRUYWdzKCkudGFsQXV0b0RlZmluZTtcblxuICAgIHZhciBidWZmZXIgPSAnJztcbiAgICBpZiAoIG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIHRhbEF1dG9EZWZpbmUgKSApe1xuICAgICAgICBidWZmZXIgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFsQXV0b0RlZmluZSApO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcHV0ID0gZnVuY3Rpb24oIG5hbWUsIHN0cmluZywgbm9jYWxsICl7XG4gICAgICAgIFxuICAgICAgICBpZiAoIGJ1ZmZlciAhPT0gJycgKXtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBkZWZpbmVEZWxpbWl0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyICs9IChub2NhbGw/IG5vY2FsbEV4cHJlc3Npb25QcmVmaXggKyBpbkRlZmluZURlbGltaXRlcjogJycpICsgbmFtZSArIGluRGVmaW5lRGVsaW1pdGVyICsgc3RyaW5nO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlTm9kZSA9IGZ1bmN0aW9uKCBub2RlICl7XG5cbiAgICAgICAgaWYgKCBidWZmZXIgKXtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCB0YWxBdXRvRGVmaW5lLCBidWZmZXIgKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHB1dDogcHV0LFxuICAgICAgICB1cGRhdGVOb2RlOiB1cGRhdGVOb2RlXG4gICAgfTtcbn07XG4iLCIvKiBcbiAgICBDbGFzcyBEZXBzRGF0YUl0ZW0gXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBEZXBzRGF0YUl0ZW0gPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICB0aGlzLm5vbkV4cHJlc3Npb25WYXJzID0ge307XG4gICAgdGhpcy5leHByZXNzaW9uVmFycyA9IHt9O1xufTtcblxuRGVwc0RhdGFJdGVtLnByb3RvdHlwZS5tdXN0QWRkVmFyID0gZnVuY3Rpb24oIHZhck5hbWUgKXtcbiAgICByZXR1cm4gdGhpcy5ub25FeHByZXNzaW9uVmFyc1sgdmFyTmFtZSBdID09PSB1bmRlZmluZWQgJiYgdGhpcy5leHByZXNzaW9uVmFyc1sgdmFyTmFtZSBdID09PSB1bmRlZmluZWQ7XG59O1xuXG5EZXBzRGF0YUl0ZW0ucHJvdG90eXBlLmFkZEFsbFZhcnMgPSBmdW5jdGlvbiggdmFyTmFtZXMsIHNjb3BlICl7XG4gICAgXG4gICAgZm9yICggdmFyIG5hbWUgaW4gdmFyTmFtZXMgKXtcbiAgICAgICAgdGhpcy5hZGQxVmFyKCB2YXJOYW1lc1sgbmFtZSBdLCBzY29wZSApO1xuICAgIH1cbn07XG5cbkRlcHNEYXRhSXRlbS5wcm90b3R5cGUuYWRkMUV4cHJlc3Npb25WYXIgPSBmdW5jdGlvbiggdmFyTmFtZSApe1xuICAgIHRoaXMuZXhwcmVzc2lvblZhcnNbIHZhck5hbWUgXSA9IHRydWU7XG59O1xuXG5EZXBzRGF0YUl0ZW0ucHJvdG90eXBlLmFkZDFOb25FeHByZXNzaW9uVmFyID0gZnVuY3Rpb24oIHZhck5hbWUgKXtcbiAgICB0aGlzLm5vbkV4cHJlc3Npb25WYXJzWyB2YXJOYW1lIF0gPSB0cnVlO1xufTtcblxuRGVwc0RhdGFJdGVtLnByb3RvdHlwZS5hZGQxVmFyID0gZnVuY3Rpb24oIHZhck5hbWUsIHNjb3BlICl7XG5cbiAgICB2YXIgbWFwID0gc2NvcGUuaXNMb2NhbFZhciggdmFyTmFtZSApPyB0aGlzLmV4cHJlc3Npb25WYXJzOiB0aGlzLm5vbkV4cHJlc3Npb25WYXJzO1xuICAgIG1hcFsgdmFyTmFtZSBdID0gdHJ1ZTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXBzRGF0YUl0ZW07XG4iLCIvKiBcbiAgICBDbGFzcyBBYnN0cmFjdEFjdGlvblxuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vdXRpbHMuanMnICk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xuXG52YXIgQWJzdHJhY3RBY3Rpb24gPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICkge1xuICAgIFxuICAgIHRoaXMuaWQgPSBvYmplY3QuaWQ7XG4gICAgdGhpcy52YXIgPSBvYmplY3QudmFyO1xuICAgIHRoaXMuY3VycmVudEVsZW1lbnQgPSBvYmplY3QuY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5hbmltYXRpb24gPSBvYmplY3QuYW5pbWF0aW9uO1xuICAgIHRoaXMuYW5pbWF0aW9uQ2FsbGJhY2sgPSBvYmplY3QuYW5pbWF0aW9uQ2FsbGJhY2s7XG4gICAgaWYgKCBvYmplY3Quc2VhcmNoICl7XG4gICAgICAgIGlmICggdGhpcy5pZCB8fCB0aGlzLnZhciApe1xuICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIGluIGFjdGlvbjogeW91IGNhbiBub3Qgc2V0IGEgc2VhcmNoIGFuZCB0aGVuIGFuZCBpZDogaWYgeW91IHNldCBhIHNlYXJjaCBaUFQtSlMgd2lsbCBzZXQgdGhlIGlkIGZvciB5b3UhJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVVc2luZ1NlYXJjaCggb2JqZWN0LnNlYXJjaCwgZGljdGlvbmFyeSApO1xuICAgIH1cbn07XG5cbkFic3RyYWN0QWN0aW9uLnByb3RvdHlwZS5pbml0aWFsaXplVXNpbmdTZWFyY2ggPSBmdW5jdGlvbiggc2VhcmNoLCBkaWN0aW9uYXJ5ICl7XG5cbiAgICB0aGlzLmlkID0gJyc7XG4gICAgdGhpcy52YXIgPSBkaWN0aW9uYXJ5O1xuICAgIFxuICAgIC8vIEl0ZXJhdGUgc2VhcmNoIGl0ZW1zIGFuZCBidWlsZCBpZCBhbmQgdmFyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2VhcmNoLmxlbmd0aDsgKytpICl7XG4gICAgICAgIHZhciBpdGVtID0gc2VhcmNoWyBpIF07XG4gICAgICAgIFxuICAgICAgICAvLyBSZXBsYWNlIGl0ZW0gaXMgaXQgYSBzZWFyY2ggb2JqZWN0LCAnX2ZpcnN0Xycgb3IgJ19sYXN0XydcbiAgICAgICAgaWYgKCB1dGlscy5pc1BsYWluT2JqZWN0KCBpdGVtICkgKXtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnNlYXJjaCggdGhpcy52YXIsIGl0ZW0gKTtcbiAgICAgICAgfSBlbHNlIGlmICggaXRlbSA9PT0gY29udGV4dC5nZXRDb25mKCkuZmlyc3RJbmRleElkZW50aWZpZXIgKXtcbiAgICAgICAgICAgIGl0ZW0gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKCBpdGVtID09PSBjb250ZXh0LmdldENvbmYoKS5sYXN0SW5kZXhJZGVudGlmaWVyICl7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy52YXIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQnVpbGQgdGhlIGlkXG4gICAgICAgIGlmICggTnVtYmVyLmlzSW50ZWdlciggaXRlbSApICl7XG4gICAgICAgICAgICB0aGlzLmlkICs9ICdbJyArIGl0ZW0gKyAnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gaSA9PT0gMD8gJyc6ICcuJztcbiAgICAgICAgICAgIHRoaXMuaWQgKz0gc2VwYXJhdG9yICsgaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQnVpbGQgdGhlIHZhclxuICAgICAgICB0aGlzLnZhciA9IHRoaXMudmFyWyBpdGVtIF07XG4gICAgfVxufTtcblxuQWJzdHJhY3RBY3Rpb24ucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKCBsaXN0LCBleHByZXNzaW9uRWxlbWVudCApe1xuICAgIFxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kgKXtcbiAgICAgICAgdmFyIHJlY29yZCA9IGxpc3RbIGkgXTtcbiAgICAgICAgaWYgKCBBYnN0cmFjdEFjdGlvbi5lbGVtZW50TWFjaGVzKCByZWNvcmQsIGV4cHJlc3Npb25FbGVtZW50ICkgKXtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRocm93ICdObyByZWNvcmQgZm91bmQgbWF0Y2hpbmcgeW91ciBjcml0ZXJpYSEnO1xufTtcblxuQWJzdHJhY3RBY3Rpb24uZWxlbWVudE1hY2hlcyA9IGZ1bmN0aW9uKCBlbGVtZW50LCBleHByZXNzaW9uRWxlbWVudCApe1xuICAgIFxuICAgIGlmICggZXhwcmVzc2lvbkVsZW1lbnQgPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRocm93ICdFeHByZXNzaW9uIHRvIG1hdGNoIG11c3Qgbm90IGJlIG51bGwhJztcbiAgICB9XG5cbiAgICBpZiAoIEFycmF5LmlzQXJyYXkoIGV4cHJlc3Npb25FbGVtZW50ICkgKXtcbiAgICAgICAgdGhyb3cgJ0V4cHJlc3Npb24gJyArIHV0aWxzLmdlbmVyaWNUb1N0cmluZyggZXhwcmVzc2lvbkVsZW1lbnQgKSArICcgdG8gbWF0Y2ggbXVzdCBub3QgYmUgYW4gYXJyYXkhJztcbiAgICB9XG5cbiAgICBpZiAoIHV0aWxzLmlzUGxhaW5PYmplY3QoIGV4cHJlc3Npb25FbGVtZW50ICkgKXtcbiAgICAgICAgZm9yICggdmFyIGkgaW4gZXhwcmVzc2lvbkVsZW1lbnQgKXtcbiAgICAgICAgICAgIGlmICggZXhwcmVzc2lvbkVsZW1lbnRbIGkgXSAhPT0gZWxlbWVudFsgaSBdICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE11c3QgYmUgbnVtZXJpYyBvciBzdHJpbmdcbiAgICByZXR1cm4gZWxlbWVudCA9PT0gZXhwcmVzc2lvbkVsZW1lbnQ7XG59O1xuXG5BYnN0cmFjdEFjdGlvbi5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiggZGljdGlvbmFyeSApe1xuICAgIHJldHVybiB0aGlzLnZhciA9PT0gdW5kZWZpbmVkP1xuICAgICAgICBkaWN0aW9uYXJ5WyB0aGlzLmlkIF06XG4gICAgICAgIHRoaXMudmFyO1xufTtcblxuQWJzdHJhY3RBY3Rpb24ucHJvdG90eXBlLnJlc29sdmVUaGlzTm9kZSA9IGZ1bmN0aW9uKCBpbmRleEl0ZW0sIHBhcnNlclVwZGF0ZXIgKXtcbiAgICBcbiAgICAvL3ZhciBhdHRyaWJ1dGVJbnN0YW5jZSA9IGluZGV4SXRlbS5hdHRyaWJ1dGVJbnN0YW5jZTtcbiAgICB2YXIgbm9kZSA9IHBhcnNlclVwZGF0ZXIuZmluZE5vZGVCeUlkKCBpbmRleEl0ZW0ubm9kZUlkICk7XG4gICAgaWYgKCAhIG5vZGUgKXtcbiAgICAgICAgLy8gUmVtb3ZlZCBub2RlIVxuICAgICAgICBwYXJzZXJVcGRhdGVyLmFkZFJlbW92ZWRUb1N0YXRpc3RpY3MoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwYXJzZXJVcGRhdGVyLmFkZFVwZGF0ZWRUb1N0YXRpc3RpY3MoKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gdGhlIG5vZGVcbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbkFic3RyYWN0QWN0aW9uLnByb3RvdHlwZS5hdHRyaWJ1dGVJbnN0YW5jZUlzUmVsYXRlZCA9IGZ1bmN0aW9uKCBhdHRyaWJ1dGVJbnN0YW5jZSApe1xuICAgIHRocm93ICdFcnJvcjogYXR0cmlidXRlSW5zdGFuY2VJc1JlbGF0ZWQgbXVzdCBiZSBpbXBsZW1lbnRlZCEnO1xufTtcblxuQWJzdHJhY3RBY3Rpb24ucHJvdG90eXBlLnVwZGF0ZURpY3Rpb25hcnkgPSBmdW5jdGlvbigpe1xuICAgIHRocm93ICdFcnJvcjogdXBkYXRlRGljdGlvbmFyeSBtdXN0IGJlIGltcGxlbWVudGVkISc7XG59O1xuXG5BYnN0cmFjdEFjdGlvbi5wcm90b3R5cGUudXBkYXRlSFRNTCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgJ0Vycm9yOiB1cGRhdGVIVE1MIG11c3QgYmUgaW1wbGVtZW50ZWQhJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RBY3Rpb247XG4iLCIvKiBcbiAgICBDbGFzcyBBYnN0cmFjdEFycmF5QWN0aW9uXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBYnN0cmFjdEFjdGlvbiA9IHJlcXVpcmUoICcuL2Fic3RyYWN0QWN0aW9uLmpzJyApO1xudmFyIHV0aWxzID0gcmVxdWlyZSggJy4uLy4uL3V0aWxzLmpzJyApO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vLi4vY29udGV4dC5qcycgKTtcblxudmFyIEFic3RyYWN0QXJyYXlBY3Rpb24gPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICkge1xuICAgIEFic3RyYWN0QWN0aW9uLmNhbGwoIHRoaXMsIG9iamVjdCwgZGljdGlvbmFyeSApO1xuICAgIFxuICAgIHRoaXMuaW5kZXggPSBvYmplY3QuaW5kZXg7XG59O1xuXG5BYnN0cmFjdEFycmF5QWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0QWN0aW9uLnByb3RvdHlwZSApO1xuXG5BYnN0cmFjdEFycmF5QWN0aW9uLmdldEluZGV4TnVtZXJpY1ZhbHVlID0gZnVuY3Rpb24oIGluZGV4ICl7XG4gICAgXG4gICAgaWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7ICAgXG4gICAgfVxuICAgIFxuICAgIGlmICggaW5kZXggPT09IGNvbnRleHQuZ2V0Q29uZigpLmZpcnN0SW5kZXhJZGVudGlmaWVyICl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoIGluZGV4ID09PSBjb250ZXh0LmdldENvbmYoKS5sYXN0SW5kZXhJZGVudGlmaWVyICl7XG4gICAgICAgIHJldHVybiAtMTsgLy8gVGhpcyBtZWFucyBpdCBpcyB0aGUgbGFzdFxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG5BYnN0cmFjdEFycmF5QWN0aW9uLnByb3RvdHlwZS5nZXRJbmRleE51bWVyaWNWYWx1ZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIEFic3RyYWN0QXJyYXlBY3Rpb24uZ2V0SW5kZXhOdW1lcmljVmFsdWUoIHRoaXMuaW5kZXggKTtcbn07XG5cbkFic3RyYWN0QXJyYXlBY3Rpb24ucHJvdG90eXBlLmdldEluZGV4VG9Vc2UgPSBmdW5jdGlvbiggZGljdGlvbmFyeSApe1xuXG4gICAgaWYgKCB0aGlzLmluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5jdXJyZW50RWxlbWVudCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRocm93ICdpbmRleCBvciBjdXJyZW50RWxlbWVudCBtdXN0IGJlIGRlZmluZWQgaW4gJyArIHRoaXMuaWQgKyAnIGFycmF5IGFjdGlvbiEnO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBpdCB1c2VzIHRoZSBpbmRleFxuICAgIHZhciBpbmRleE51bWVyaWNWYWx1ZSA9IHRoaXMuZ2V0SW5kZXhOdW1lcmljVmFsdWUoKTtcbiAgICBpZiAoIGluZGV4TnVtZXJpY1ZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIGluZGV4TnVtZXJpY1ZhbHVlO1xuICAgIH1cblxuICAgIC8vIE11c3QgdXNlIGN1cnJlbnRFbGVtZW50XG4gICAgdmFyIGFycmF5VmFsdWUgPSB0aGlzLmdldFZhbHVlKCBkaWN0aW9uYXJ5ICk7XG4gICAgXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJyYXlWYWx1ZS5sZW5ndGg7ICsraSApe1xuICAgICAgICB2YXIgZWxlbWVudCA9IGFycmF5VmFsdWVbIGkgXTtcbiAgICAgICAgaWYgKCBBYnN0cmFjdEFjdGlvbi5lbGVtZW50TWFjaGVzKCBlbGVtZW50LCB0aGlzLmN1cnJlbnRFbGVtZW50ICkgKXtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRocm93ICdjdXJyZW50RWxlbWVudCAnICsgdXRpbHMuZ2VuZXJpY1RvU3RyaW5nKCB0aGlzLmN1cnJlbnRFbGVtZW50ICkgKyAnIG5vdCBmb3VuZCBpbiAnICsgdGhpcy5pZCArICcgYXJyYXkgYWN0aW9uISc7XG59O1xuXG5BYnN0cmFjdEFycmF5QWN0aW9uLnByb3RvdHlwZS5hdHRyaWJ1dGVJbnN0YW5jZUlzUmVsYXRlZCA9IGZ1bmN0aW9uKCBhdHRyaWJ1dGVJbnN0YW5jZSApe1xuICAgIHJldHVybiBBYnN0cmFjdEFycmF5QWN0aW9uLnN0YXRpY0F0dHJpYnV0ZUluc3RhbmNlSXNSZWxhdGVkKCBhdHRyaWJ1dGVJbnN0YW5jZSApO1xufTtcblxuQWJzdHJhY3RBcnJheUFjdGlvbi5zdGF0aWNBdHRyaWJ1dGVJbnN0YW5jZUlzUmVsYXRlZCA9IGZ1bmN0aW9uKCBhdHRyaWJ1dGVJbnN0YW5jZSApe1xuICAgIHJldHVybiBhdHRyaWJ1dGVJbnN0YW5jZS50eXBlID09PSAndGFsOnJlcGVhdCc7XG59O1xuXG5BYnN0cmFjdEFycmF5QWN0aW9uLnByb3RvdHlwZS51cGRhdGVEaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyAnRXJyb3I6IHVwZGF0ZURpY3Rpb25hcnkgbXVzdCBiZSBpbXBsZW1lbnRlZCEnO1xufTtcblxuQWJzdHJhY3RBcnJheUFjdGlvbi5wcm90b3R5cGUudXBkYXRlSFRNTCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgJ0Vycm9yOiB1cGRhdGVIVE1MIG11c3QgYmUgaW1wbGVtZW50ZWQhJztcbn07XG5cbkFic3RyYWN0QXJyYXlBY3Rpb24ucHJvdG90eXBlLnJlc29sdmVDaGlsZE5vZGUgPSBmdW5jdGlvbiggaW5kZXhJdGVtLCBwYXJzZXJVcGRhdGVyICl7XG4gICAgXG4gICAgLy92YXIgYXR0cmlidXRlSW5zdGFuY2UgPSBpbmRleEl0ZW0uYXR0cmlidXRlSW5zdGFuY2U7XG4gICAgdmFyIG5vZGUgPSBwYXJzZXJVcGRhdGVyLmZpbmROb2RlQnlJZCggaW5kZXhJdGVtLm5vZGVJZCApO1xuICAgIGlmICggISBub2RlICl7XG4gICAgICAgIC8vIFJlbW92ZWQgbm9kZSFcbiAgICAgICAgcGFyc2VyVXBkYXRlci5hZGRSZW1vdmVkVG9TdGF0aXN0aWNzKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcGFyc2VyVXBkYXRlci5hZGRVcGRhdGVkVG9TdGF0aXN0aWNzKCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIHRoZSBub2RlXG4gICAgcmV0dXJuIHRoaXMuaW5kZXhUb1VzZSA9PT0gLTE/XG4gICAgICAgIG51bGw6XG4gICAgICAgIHRoaXMuZ2V0SW5kZXhPZkxvb3AoIG5vZGUucGFyZW50Tm9kZSwgaW5kZXhJdGVtLm5vZGVJZCwgdGhpcy5pbmRleFRvVXNlICk7XG59O1xuXG5BYnN0cmFjdEFycmF5QWN0aW9uLnByb3RvdHlwZS5nZXRJbmRleE9mTG9vcCA9IGZ1bmN0aW9uKCBwYXJlbnROb2RlLCBub2RlSWQsIGluZGV4SW5Mb29wICl7XG4gICAgXG4gICAgdmFyIG51bWJlck9mQ2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkRWxlbWVudENvdW50O1xuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG51bWJlck9mQ2hpbGRyZW47ICsraSApe1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gcGFyZW50Tm9kZS5jaGlsZHJlblsgaSBdO1xuICAgICAgICB2YXIgY3VycmVudE5vZGVJZCA9IGNoaWxkTm9kZS5nZXRBdHRyaWJ1dGUoIGNvbnRleHQuZ2V0VGFncygpLmlkICk7XG4gICAgICAgIGlmICggY3VycmVudE5vZGVJZCA9PT0gbm9kZUlkICl7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZS5jaGlsZHJlblsgMSArIGkgKyBpbmRleEluTG9vcCBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdEFycmF5QWN0aW9uO1xuIiwiLyogXG4gICAgQ2xhc3MgQWJzdHJhY3RPYmplY3RBY3Rpb25cbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEFic3RyYWN0QWN0aW9uID0gcmVxdWlyZSggJy4vYWJzdHJhY3RBY3Rpb24uanMnICk7XG5cbnZhciBBYnN0cmFjdE9iamVjdEFjdGlvbiA9IGZ1bmN0aW9uKCBvYmplY3QsIGRpY3Rpb25hcnkgKSB7XG4gICAgQWJzdHJhY3RBY3Rpb24uY2FsbCggdGhpcywgb2JqZWN0LCBkaWN0aW9uYXJ5ICk7XG4gICAgXG4gICAgdGhpcy5wcm9wZXJ0eSA9IG9iamVjdC5wcm9wZXJ0eTtcbiAgICB0aGlzLmlkICs9ICcuJyArIG9iamVjdC5wcm9wZXJ0eTtcbn07XG5cbkFic3RyYWN0T2JqZWN0QWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0QWN0aW9uLnByb3RvdHlwZSApO1xuXG5BYnN0cmFjdE9iamVjdEFjdGlvbi5wcm90b3R5cGUuYXR0cmlidXRlSW5zdGFuY2VJc1JlbGF0ZWQgPSBmdW5jdGlvbiggYXR0cmlidXRlSW5zdGFuY2UgKXtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkFic3RyYWN0T2JqZWN0QWN0aW9uLnByb3RvdHlwZS51cGRhdGVIVE1MID0gZnVuY3Rpb24oIGluZGV4SXRlbSwgcGFyc2VyVXBkYXRlciwgYWN0aW9uSW5zdGFuY2UgKXtcbiAgICBcbiAgICAvLyBNdXN0IGdldCB0aGUgbm9kZVxuICAgIHZhciBub2RlID0gdGhpcy5yZXNvbHZlVGhpc05vZGUoIGluZGV4SXRlbSwgcGFyc2VyVXBkYXRlciApO1xuICAgIGlmICggISBub2RlICl7XG4gICAgICAgIHRocm93ICdObyBub2RlIGZvdW5kIHRvIHVwZGF0ZSc7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgbm9kZVxuICAgIHBhcnNlclVwZGF0ZXIudXBkYXRlTm9kZSggbm9kZSApO1xuICAgIFxuICAgIC8vIFJ1biBhbmltYXRpb25cbiAgICBwYXJzZXJVcGRhdGVyLnJ1bkFuaW1hdGlvbiggYWN0aW9uSW5zdGFuY2UsIG5vZGUgKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RPYmplY3RBY3Rpb247XG4iLCIvKiBcbiAgICBDbGFzcyBBcnJheUNyZWF0ZVxuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQWJzdHJhY3RBcnJheUFjdGlvbiA9IHJlcXVpcmUoICcuL2Fic3RyYWN0QXJyYXlBY3Rpb24uanMnICk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi8uLi9jb250ZXh0LmpzJyApO1xudmFyIFBhcnNlck5vZGVSZW5kZXJlciA9IHJlcXVpcmUoICcuLi8uLi9wYXJzZXJzL3BhcnNlck5vZGVSZW5kZXJlci5qcycgKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoICcuLi8uLi91dGlscy5qcycgKTtcblxudmFyIEFycmF5Q3JlYXRlID0gZnVuY3Rpb24oIG9iamVjdCwgZGljdGlvbmFyeSApIHtcbiAgICBBYnN0cmFjdEFycmF5QWN0aW9uLmNhbGwoIHRoaXMsIG9iamVjdCwgZGljdGlvbmFyeSApO1xuICAgIFxuICAgIHRoaXMubmV3RWxlbWVudCA9IG9iamVjdC5uZXdFbGVtZW50O1xufTtcblxuQXJyYXlDcmVhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWJzdHJhY3RBcnJheUFjdGlvbi5wcm90b3R5cGUgKTtcblxuQXJyYXlDcmVhdGUucHJvdG90eXBlLnVwZGF0ZURpY3Rpb25hcnkgPSBmdW5jdGlvbiggZGljdGlvbmFyeSApe1xuICAgIFxuICAgIHRoaXMuaW5kZXhUb1VzZSA9IHRoaXMuZ2V0SW5kZXhUb1VzZSggZGljdGlvbmFyeSApO1xuICAgIHZhciBhcnJheVZhbHVlID0gdGhpcy5nZXRWYWx1ZSggZGljdGlvbmFyeSApO1xuICAgIFxuICAgIGlmICggdGhpcy5pbmRleFRvVXNlID09PSAtMSApe1xuICAgICAgICB0aGlzLnJlc29sdmVkSW5kZXggPSBhcnJheVZhbHVlLmxlbmd0aDtcbiAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKCB0aGlzLm5ld0VsZW1lbnQgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc29sdmVkSW5kZXggPSB0aGlzLmluZGV4VG9Vc2U7XG4gICAgICAgIGFycmF5VmFsdWUuc3BsaWNlKCB0aGlzLmluZGV4VG9Vc2UsIDAsIHRoaXMubmV3RWxlbWVudCApO1xuICAgIH1cbn07XG5cbkFycmF5Q3JlYXRlLnByb3RvdHlwZS51cGRhdGVIVE1MID0gZnVuY3Rpb24oIGluZGV4SXRlbSwgcGFyc2VyVXBkYXRlciwgYWN0aW9uSW5zdGFuY2UgKXtcbiAgICBcbiAgICAvLyBNdXN0IGdldCB0aGUgbm9kZVRvVXBkYXRlXG4gICAgdmFyIG5vZGUgPSB0aGlzLnJlc29sdmVUaGlzTm9kZSggaW5kZXhJdGVtLCBwYXJzZXJVcGRhdGVyICk7XG4gICAgaWYgKCAhIG5vZGUgKXtcbiAgICAgICAgdGhyb3cgJ05vIG5vZGUgZm91bmQgdG8gY2xvbmUnO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbml0IHNvbWUgdmFyc1xuICAgIHZhciB0YWdzID0gY29udGV4dC5nZXRUYWdzKCk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgXG4gICAgLy8gQ2xvbmUgYW5kIGNvbmZpZ3VyZSB0aGUgbm9kZVxuICAgIHZhciB0bXBOb2RlID0gUGFyc2VyTm9kZVJlbmRlcmVyLmNsb25lQW5kQ29uZmlndXJlTm9kZSggXG4gICAgICAgIG5vZGUsIFxuICAgICAgICB0cnVlLCBcbiAgICAgICAgdGFncywgXG4gICAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLmlkICkgXG4gICAgKTtcbiAgICBQYXJzZXJOb2RlUmVuZGVyZXIuY29uZmlndXJlTm9kZUZvck5ld0l0ZW0oIFxuICAgICAgICB0bXBOb2RlLCBcbiAgICAgICAgdGFncywgXG4gICAgICAgIHBhcmVudE5vZGUsIFxuICAgICAgICBpbmRleEl0ZW0sIFxuICAgICAgICB0aGlzLnJlc29sdmVkSW5kZXhcbiAgICApO1xuICAgIFxuICAgIC8vIEluc2VydCBpdFxuICAgIHZhciBzaWJsaW5nID0gdGhpcy5pbmRleFRvVXNlID09PSAtMT9cbiAgICAgICAgbnVsbDpcbiAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlblsgMSArIHRoaXMuaW5kZXhUb1VzZSBdO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCB0bXBOb2RlLCBzaWJsaW5nICk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgcGFyc2VyVXBkYXRlci51cGRhdGVOb2RlKCB0bXBOb2RlICk7XG4gICAgXG4gICAgLy8gUnVuIGFuaW1hdGlvblxuICAgIHBhcnNlclVwZGF0ZXIucnVuQW5pbWF0aW9uKCBhY3Rpb25JbnN0YW5jZSwgdG1wTm9kZSApO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQXJyYXlDcmVhdGUuYnVpbGRNdWx0aXBsZSA9IGZ1bmN0aW9uKCBvYmplY3QsIGRpY3Rpb25hcnkgKXtcblxuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgXG4gICAgLy8gQ29weSBuZXdFbGVtZW50cyB0byBhIG5ldyBhcnJheVxuICAgIHZhciBuZXdFbGVtZW50cyA9IHV0aWxzLmNvcHlBcnJheSggb2JqZWN0Lm5ld0VsZW1lbnQgKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmUgdGhlIG9iamVjdCwgY3JlYXRlIHRoZSBmaXJzdCBpbnN0YW5jZSBhbmQgYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgb2JqZWN0Lm5ld0VsZW1lbnQgPSBuZXdFbGVtZW50c1sgMCBdO1xuICAgIHZhciBmaXJzdEFjdGlvbkluc3RhbmNlID0gbmV3IEFycmF5Q3JlYXRlKCBvYmplY3QsIGRpY3Rpb25hcnkgKTtcbiAgICBhY3Rpb25zLnB1c2goIGZpcnN0QWN0aW9uSW5zdGFuY2UgKTtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGZpcnN0SW5kZXggYW5kIGlmIHRoZSBuZXcgZWxtZW50cyBtdXN0IGJlIHRoZSBsYXN0XG4gICAgdmFyIGZpcnN0SW5kZXggPSBmaXJzdEFjdGlvbkluc3RhbmNlLmdldEluZGV4TnVtZXJpY1ZhbHVlKCk7XG4gICAgdmFyIGlzTGFzdCA9IC0xID09PSBmaXJzdEluZGV4O1xuICAgICAgICBcbiAgICAvLyBCdWlsZCBhY3Rpb25zIGxpc3RcbiAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPCBuZXdFbGVtZW50cy5sZW5ndGg7ICsraSApe1xuICAgICAgICB2YXIgbmV3RWxlbWVudCA9IG5ld0VsZW1lbnRzWyBpIF07XG4gICAgICAgIFxuICAgICAgICAvLyBDbG9uZSB0aGUgb2JqZWN0IGFuZCBjb25maWd1cmUgdGhlIG5ld0VsZW1lbnQgYW5kIHRoZSBpbmRleFxuICAgICAgICB2YXIgbmV3T2JqZWN0ID0gdXRpbHMuZGVlcEV4dGVuZCggb2JqZWN0ICk7XG4gICAgICAgIG5ld09iamVjdC5uZXdFbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICAgICAgbmV3T2JqZWN0LmluZGV4ID0gaXNMYXN0P1xuICAgICAgICAgICAgLTE6XG4gICAgICAgICAgICBmaXJzdEluZGV4ICsgaTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluc3RhbmNlIHRoZSBhY3Rpb24gaW5zdGFuY2UgYW5kIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgICB2YXIgbmV3QWN0aW9uSW5zdGFuY2UgPSBuZXcgQXJyYXlDcmVhdGUoIG5ld09iamVjdCwgZGljdGlvbmFyeSApO1xuICAgICAgICBhY3Rpb25zLnB1c2goIG5ld0FjdGlvbkluc3RhbmNlICk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhY3Rpb25zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheUNyZWF0ZTtcbiIsIi8qIFxuICAgIENsYXNzIEFycmF5RGVsZXRlXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBYnN0cmFjdEFycmF5QWN0aW9uID0gcmVxdWlyZSggJy4vYWJzdHJhY3RBcnJheUFjdGlvbi5qcycgKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoICcuLi8uLi91dGlscy5qcycgKTtcbnZhciBhdHRyaWJ1dGVJbmRleCA9IHJlcXVpcmUoICcuLi8uLi9hdHRyaWJ1dGVzL2F0dHJpYnV0ZUluZGV4LmpzJyApO1xudmFyIG5vZGVSZW1vdmVyID0gcmVxdWlyZSggJy4uL25vZGVSZW1vdmVyLmpzJyApO1xuXG52YXIgQXJyYXlEZWxldGUgPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICkge1xuICAgIEFic3RyYWN0QXJyYXlBY3Rpb24uY2FsbCggdGhpcywgb2JqZWN0LCBkaWN0aW9uYXJ5ICk7XG59O1xuXG5BcnJheURlbGV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBYnN0cmFjdEFycmF5QWN0aW9uLnByb3RvdHlwZSApO1xuXG5BcnJheURlbGV0ZS5wcm90b3R5cGUudXBkYXRlRGljdGlvbmFyeSA9IGZ1bmN0aW9uKCBkaWN0aW9uYXJ5ICl7XG5cbiAgICB0aGlzLmluZGV4VG9Vc2UgPSB0aGlzLmdldEluZGV4VG9Vc2UoIGRpY3Rpb25hcnkgKTtcbiAgICB2YXIgYXJyYXlWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoIGRpY3Rpb25hcnkgKTtcbiAgICBhcnJheVZhbHVlLnNwbGljZSggdGhpcy5pbmRleFRvVXNlLCAxICk7XG59O1xuXG5BcnJheURlbGV0ZS5wcm90b3R5cGUudXBkYXRlSFRNTCA9IGZ1bmN0aW9uKCBpbmRleEl0ZW0sIHBhcnNlclVwZGF0ZXIsIGFjdGlvbkluc3RhbmNlLCBjb250aW51ZURhdGEgKXtcbiAgICBcbiAgICAvLyBNdXN0IGdldCB0aGUgbm9kZVRvVXBkYXRlXG4gICAgdmFyIG5vZGVUb0RlbGV0ZSA9IHRoaXMucmVzb2x2ZUNoaWxkTm9kZSggaW5kZXhJdGVtLCBwYXJzZXJVcGRhdGVyICk7XG4gICAgaWYgKCAhIG5vZGVUb0RlbGV0ZSApe1xuICAgICAgICB0aHJvdyAnTm8gbm9kZSBmb3VuZCB0byBiZSBkZWxldGVkIGF0IHRoaXMgaW5kZXg6ICcgKyB0aGlzLmluZGV4VG9Vc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIFJ1biBhbmltYXRpb25cbiAgICBwYXJzZXJVcGRhdGVyLnJ1bkFuaW1hdGlvbiggXG4gICAgICAgIGFjdGlvbkluc3RhbmNlLCBcbiAgICAgICAgbm9kZVRvRGVsZXRlLCBcbiAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZWxlY3RlZCBub2RlIGZyb20gdGhlIGluZGV4IGFuZCBmcm9tIEhUTUxcbiAgICAgICAgICAgIC8vYXR0cmlidXRlSW5kZXgucmVtb3ZlTm9kZSggbm9kZVRvRGVsZXRlICk7IFxuICAgICAgICAgICAgbm9kZVJlbW92ZXIucmVtb3ZlTm9kZSggbm9kZVRvRGVsZXRlICk7XG4gICAgICAgICAgICAvL1RPRE8gdXBkYXRlIG5leHQgc2libGluZ3M/XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnRpbnVlXG4gICAgICAgICAgICBwYXJzZXJVcGRhdGVyLmNvbnRpbnVlVXBkYXRlSFRNTCggY29udGludWVEYXRhICk7XG4gICAgICAgIH0gXG4gICAgKTtcbiAgICBcbiAgICAvL3JldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkFycmF5RGVsZXRlLmJ1aWxkTXVsdGlwbGUgPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICl7XG5cbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIHZhciBwcm9wZXJ0eSA9IG9iamVjdC5pbmRleD8gJ2luZGV4JzogJ2N1cnJlbnRFbGVtZW50JztcblxuICAgIC8vIENvcHkgaW5kZXhlcyB0byBhIG5ldyBhcnJheVxuICAgIHZhciBhbGxJdGVtcyA9IHV0aWxzLmNvcHlBcnJheSggb2JqZWN0WyBwcm9wZXJ0eSBdICk7XG4gICAgXG4gICAgLy8gQnVpbGQgYWN0aW9ucyBsaXN0XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYWxsSXRlbXMubGVuZ3RoOyArK2kgKXtcbiAgICAgICAgdmFyIGl0ZW0gPSBhbGxJdGVtc1sgaSBdO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xvbmUgdGhlIG9iamVjdCBhbmQgY29uZmlndXJlIHRoZSBpbmRleFxuICAgICAgICB2YXIgbmV3T2JqZWN0ID0gdXRpbHMuZGVlcEV4dGVuZCggb2JqZWN0ICk7XG4gICAgICAgIG5ld09iamVjdFsgcHJvcGVydHkgXSA9IGl0ZW07XG4gICAgICAgIFxuICAgICAgICAvLyBJbnN0YW5jZSB0aGUgYWN0aW9uIGluc3RhbmNlIGFuZCBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgICAgdmFyIG5ld0FjdGlvbkluc3RhbmNlID0gbmV3IEFycmF5RGVsZXRlKCBuZXdPYmplY3QsIGRpY3Rpb25hcnkgKTtcbiAgICAgICAgbmV3QWN0aW9uSW5zdGFuY2UuaW5kZXggPSBuZXdBY3Rpb25JbnN0YW5jZS5nZXRJbmRleFRvVXNlKCBkaWN0aW9uYXJ5ICk7XG4gICAgICAgIGFjdGlvbnMucHVzaCggbmV3QWN0aW9uSW5zdGFuY2UgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBhY3Rpb25zXG4gICAgYWN0aW9ucy5zb3J0KFxuICAgICAgICBmdW5jdGlvbiggYSwgYiApeyByZXR1cm4gYi5pbmRleCAtIGEuaW5kZXg7IH1cbiAgICApO1xuICAgIFxuICAgIHJldHVybiBhY3Rpb25zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheURlbGV0ZTtcbiIsIi8qIFxuICAgIENsYXNzIEFycmF5VXBkYXRlXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBYnN0cmFjdEFycmF5QWN0aW9uID0gcmVxdWlyZSggJy4vYWJzdHJhY3RBcnJheUFjdGlvbi5qcycgKTtcblxudmFyIEFycmF5VXBkYXRlID0gZnVuY3Rpb24oIG9iamVjdCwgZGljdGlvbmFyeSApIHtcbiAgICBBYnN0cmFjdEFycmF5QWN0aW9uLmNhbGwoIHRoaXMsIG9iamVjdCwgZGljdGlvbmFyeSApO1xuICAgIFxuICAgIHRoaXMubmV3RWxlbWVudCA9IG9iamVjdC5uZXdFbGVtZW50O1xufTtcblxuQXJyYXlVcGRhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWJzdHJhY3RBcnJheUFjdGlvbi5wcm90b3R5cGUgKTtcblxuQXJyYXlVcGRhdGUucHJvdG90eXBlLnVwZGF0ZURpY3Rpb25hcnkgPSBmdW5jdGlvbiggZGljdGlvbmFyeSApe1xuICAgIFxuICAgIHRoaXMuaW5kZXhUb1VzZSA9IHRoaXMuZ2V0SW5kZXhUb1VzZSggZGljdGlvbmFyeSApO1xuICAgIHZhciBhcnJheVZhbHVlID0gdGhpcy5nZXRWYWx1ZSggZGljdGlvbmFyeSApO1xuICAgIGFycmF5VmFsdWVbIHRoaXMuaW5kZXhUb1VzZSBdID0gdGhpcy5uZXdFbGVtZW50O1xufTtcblxuQXJyYXlVcGRhdGUucHJvdG90eXBlLnVwZGF0ZUhUTUwgPSBmdW5jdGlvbiggaW5kZXhJdGVtLCBwYXJzZXJVcGRhdGVyLCBhY3Rpb25JbnN0YW5jZSApe1xuICAgIFxuICAgIC8vIE11c3QgZ2V0IHRoZSBub2RlVG9VcGRhdGVcbiAgICB2YXIgbm9kZVRvVXBkYXRlID0gdGhpcy5yZXNvbHZlQ2hpbGROb2RlKCBpbmRleEl0ZW0sIHBhcnNlclVwZGF0ZXIgKTtcbiAgICBpZiAoICEgbm9kZVRvVXBkYXRlICl7XG4gICAgICAgIHRocm93ICdObyBub2RlIGZvdW5kIHRvIGJlIHVwZGF0ZWQgYXQgdGhpcyBpbmRleDogJyArIHRoaXMuaW5kZXhUb1VzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgcGFyc2VyVXBkYXRlci51cGRhdGVOb2RlKCBub2RlVG9VcGRhdGUsIHRydWUgKTtcbiAgICBcbiAgICAvLyBSdW4gYW5pbWF0aW9uXG4gICAgcGFyc2VyVXBkYXRlci5ydW5BbmltYXRpb24oIGFjdGlvbkluc3RhbmNlLCBub2RlVG9VcGRhdGUgKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlVcGRhdGU7XG4iLCIvKiBcclxuICAgIENsYXNzIENTU0FuaW1hdGlvbk1hbmFnZXIgXHJcbiovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICBcclxuICAgIHZhciBhbmltYXRlID0gZnVuY3Rpb24oIGRpY3Rpb25hcnlBY3Rpb24sIG5vZGUsIGNhbGxiYWNrICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJ1biBjYWxsYmFjayBhbmQgcmV0dXJuIGlmIHRoZXJlIGlzIG5vIGFuaW1hdGlvblxyXG4gICAgICAgIGlmICggISBkaWN0aW9uYXJ5QWN0aW9uLmFuaW1hdGlvbiApe1xyXG4gICAgICAgICAgICBpZiAoIGNhbGxiYWNrICl7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNldCB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSAnbm9uZSc7XHJcbiAgICAgICAgc2V0VGltZW91dChcclxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGFuaW1hdGlvbmVuZCBsaXN0ZW5lclxyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbmVuZENhbGxiYWNrID0gZnVuY3Rpb24oIGV2ZW50ICl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvL25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2FuaW1hdGlvbmVuZCcsIGFuaW1hdGlvbmVuZENhbGxiYWNrICk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdhbmltYXRpb25lbmQnLCBhbmltYXRpb25lbmRDYWxsYmFjayApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGRpY3Rpb25hcnlBY3Rpb24uYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICB9LCBcclxuICAgICAgICAgICAgMTBcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24oIG5vZGUgKSB7XHJcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSAnbm9uZSc7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHtcclxuICAgICAgICBhbmltYXRlOiBhbmltYXRlLFxyXG4gICAgICAgIHJlc2V0OiByZXNldFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKCk7XHJcbiIsIi8qIFxyXG4gICAgQ2xhc3MgZGljdGlvbmFyeUFjdGlvbkJ1aWxkZXIgXHJcbiovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIEFycmF5VXBkYXRlID0gcmVxdWlyZSggJy4vYXJyYXlVcGRhdGUuanMnICk7XHJcbnZhciBBcnJheURlbGV0ZSA9IHJlcXVpcmUoICcuL2FycmF5RGVsZXRlLmpzJyApO1xyXG52YXIgQXJyYXlDcmVhdGUgPSByZXF1aXJlKCAnLi9hcnJheUNyZWF0ZS5qcycgKTtcclxudmFyIE9iamVjdFVwZGF0ZSA9IHJlcXVpcmUoICcuL29iamVjdFVwZGF0ZS5qcycgKTtcclxudmFyIE9iamVjdERlbGV0ZSA9IHJlcXVpcmUoICcuL29iamVjdERlbGV0ZS5qcycgKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgXHJcbiAgICB2YXIgYnVpbGQgPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAoIG9iamVjdC5hY3Rpb24gKSB7XHJcbiAgICAgICAgY2FzZSAndXBkYXRlQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5VXBkYXRlKCBvYmplY3QsIGRpY3Rpb25hcnkgKTtcclxuICAgICAgICBjYXNlICdkZWxldGVBcnJheSc6XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KCBvYmplY3QuaW5kZXggKSB8fCBBcnJheS5pc0FycmF5KCBvYmplY3QuY3VycmVudEVsZW1lbnQgKT8gXHJcbiAgICAgICAgICAgICAgICBBcnJheURlbGV0ZS5idWlsZE11bHRpcGxlKCBvYmplY3QsIGRpY3Rpb25hcnkgKTpcclxuICAgICAgICAgICAgICAgIG5ldyBBcnJheURlbGV0ZSggb2JqZWN0LCBkaWN0aW9uYXJ5ICk7XHJcbiAgICAgICAgY2FzZSAnY3JlYXRlQXJyYXknOlxyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSggb2JqZWN0Lm5ld0VsZW1lbnQgKT8gXHJcbiAgICAgICAgICAgICAgICBBcnJheUNyZWF0ZS5idWlsZE11bHRpcGxlKCBvYmplY3QsIGRpY3Rpb25hcnkgKTpcclxuICAgICAgICAgICAgICAgIG5ldyBBcnJheUNyZWF0ZSggb2JqZWN0LCBkaWN0aW9uYXJ5ICk7XHJcbiAgICAgICAgY2FzZSAndXBkYXRlT2JqZWN0JzpcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5lZGl0ZWRQcm9wZXJ0aWVzIHx8IG9iamVjdC5kZWxldGVkUHJvcGVydGllcz9cclxuICAgICAgICAgICAgICAgIE9iamVjdFVwZGF0ZS5idWlsZE11bHRpcGxlKCBvYmplY3QsIGRpY3Rpb25hcnkgKTpcclxuICAgICAgICAgICAgICAgIG5ldyBPYmplY3RVcGRhdGUoIG9iamVjdCwgZGljdGlvbmFyeSApO1xyXG4gICAgICAgIGNhc2UgJ2RlbGV0ZU9iamVjdCc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JqZWN0RGVsZXRlKCBvYmplY3QsIGRpY3Rpb25hcnkgKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBkaWN0aW9uYXJ5IGFjdGlvbjogJyArIG9iamVjdC5hY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHNlbGYgPSB7XHJcbiAgICAgICAgYnVpbGQ6IGJ1aWxkXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gc2VsZjtcclxufSkoKTtcclxuIiwiLyogXG4gICAgQ2xhc3MgT2JqZWN0RGVsZXRlXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBYnN0cmFjdE9iamVjdEFjdGlvbiA9IHJlcXVpcmUoICcuL2Fic3RyYWN0T2JqZWN0QWN0aW9uLmpzJyApO1xuXG52YXIgT2JqZWN0RGVsZXRlID0gZnVuY3Rpb24oIG9iamVjdCwgZGljdGlvbmFyeSApIHtcbiAgICBBYnN0cmFjdE9iamVjdEFjdGlvbi5jYWxsKCB0aGlzLCBvYmplY3QsIGRpY3Rpb25hcnkgKTtcbn07XG5cbk9iamVjdERlbGV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBYnN0cmFjdE9iamVjdEFjdGlvbi5wcm90b3R5cGUgKTtcblxuT2JqZWN0RGVsZXRlLnByb3RvdHlwZS51cGRhdGVEaWN0aW9uYXJ5ID0gZnVuY3Rpb24oIGRpY3Rpb25hcnkgKXtcbiAgICBcbiAgICB2YXIgb2JqZWN0VmFsdWUgPSB0aGlzLmdldFZhbHVlKCBkaWN0aW9uYXJ5ICk7XG4gICAgZGVsZXRlIG9iamVjdFZhbHVlWyB0aGlzLnByb3BlcnR5IF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdERlbGV0ZTtcbiIsIi8qIFxuICAgIENsYXNzIE9iamVjdFVwZGF0ZVxuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQWJzdHJhY3RPYmplY3RBY3Rpb24gPSByZXF1aXJlKCAnLi9hYnN0cmFjdE9iamVjdEFjdGlvbi5qcycgKTtcbnZhciBPYmplY3REZWxldGUgPSByZXF1aXJlKCAnLi9vYmplY3REZWxldGUuanMnICk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCAnLi4vLi4vdXRpbHMuanMnICk7XG5cbnZhciBPYmplY3RVcGRhdGUgPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICkge1xuICAgIEFic3RyYWN0T2JqZWN0QWN0aW9uLmNhbGwoIHRoaXMsIG9iamVjdCwgZGljdGlvbmFyeSApO1xuICAgIFxuICAgIHRoaXMubmV3RWxlbWVudCA9IG9iamVjdC5uZXdFbGVtZW50O1xufTtcblxuT2JqZWN0VXBkYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0T2JqZWN0QWN0aW9uLnByb3RvdHlwZSApO1xuXG5PYmplY3RVcGRhdGUucHJvdG90eXBlLnVwZGF0ZURpY3Rpb25hcnkgPSBmdW5jdGlvbiggZGljdGlvbmFyeSApe1xuICAgIFxuICAgIHZhciBvYmplY3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoIGRpY3Rpb25hcnkgKTtcbiAgICBvYmplY3RWYWx1ZVsgdGhpcy5wcm9wZXJ0eSBdID0gdGhpcy5uZXdFbGVtZW50O1xufTtcblxuT2JqZWN0VXBkYXRlLmJ1aWxkTXVsdGlwbGUgPSBmdW5jdGlvbiggb2JqZWN0LCBkaWN0aW9uYXJ5ICl7XG5cbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIHZhciBjbG9uZWRPYmplY3QgPSB1dGlscy5kZWVwRXh0ZW5kKCBvYmplY3QgKTtcbiAgICBcbiAgICAvLyBDb3B5IGVkaXRlZFByb3BlcnRpZXMgYW5kIGRlbGV0ZWRQcm9wZXJ0aWVzXG4gICAgdmFyIGVkaXRlZFByb3BlcnRpZXMgPSBjbG9uZWRPYmplY3QuZWRpdGVkUHJvcGVydGllcztcbiAgICB2YXIgZGVsZXRlZFByb3BlcnRpZXMgPSBjbG9uZWRPYmplY3QuZGVsZXRlZFByb3BlcnRpZXM7XG4gICAgXG4gICAgLy8gRGVsZXRlIHRoZW1cbiAgICBkZWxldGUgY2xvbmVkT2JqZWN0LmVkaXRlZFByb3BlcnRpZXM7XG4gICAgZGVsZXRlIGNsb25lZE9iamVjdC5kZWxldGVkUHJvcGVydGllcztcbiAgICAgICAgXG4gICAgLy8gQnVpbGQgYWN0aW9ucyBsaXN0IGZvciBlZGl0ZWRQcm9wZXJ0aWVzXG4gICAgaWYgKCBlZGl0ZWRQcm9wZXJ0aWVzICl7XG4gICAgICAgIGNsb25lZE9iamVjdC5hY3Rpb24gPSAndXBkYXRlT2JqZWN0JztcbiAgICAgICAgZm9yICggdmFyIGVkaXRlZFByb3BlcnRpZXNJZCBpbiBlZGl0ZWRQcm9wZXJ0aWVzICl7XG4gICAgICAgICAgICB2YXIgZWRpdGVkUHJvcGVydGllc1ZhbHVlID0gZWRpdGVkUHJvcGVydGllc1sgZWRpdGVkUHJvcGVydGllc0lkIF07XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBvYmplY3QgYW5kIGNvbmZpZ3VyZSBwcm9wZXJ0eSBhbmQgbmV3RWxlbWVudFxuICAgICAgICAgICAgdmFyIG5ld09iamVjdCA9IHV0aWxzLmRlZXBFeHRlbmQoIGNsb25lZE9iamVjdCApO1xuICAgICAgICAgICAgbmV3T2JqZWN0LnByb3BlcnR5ID0gZWRpdGVkUHJvcGVydGllc0lkO1xuICAgICAgICAgICAgbmV3T2JqZWN0Lm5ld0VsZW1lbnQgPSBlZGl0ZWRQcm9wZXJ0aWVzVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIEluc3RhbmNlIHRoZSBhY3Rpb24gaW5zdGFuY2UgYW5kIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgdmFyIG5ld0FjdGlvbkluc3RhbmNlID0gbmV3IE9iamVjdFVwZGF0ZSggbmV3T2JqZWN0LCBkaWN0aW9uYXJ5ICk7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goIG5ld0FjdGlvbkluc3RhbmNlICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQnVpbGQgYWN0aW9ucyBsaXN0IGZvciBkZWxldGVkUHJvcGVydGllc1xuICAgIGlmICggZGVsZXRlZFByb3BlcnRpZXMgKXtcbiAgICAgICAgY2xvbmVkT2JqZWN0LmFjdGlvbiA9ICdkZWxldGVPYmplY3QnO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWxldGVkUHJvcGVydGllcy5sZW5ndGg7ICsraSApe1xuICAgICAgICAgICAgdmFyIGRlbGV0ZWRQcm9wZXJ0aWVzSXRlbSA9IGRlbGV0ZWRQcm9wZXJ0aWVzWyBpIF07XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBvYmplY3QgYW5kIGNvbmZpZ3VyZSBwcm9wZXJ0eVxuICAgICAgICAgICAgbmV3T2JqZWN0ID0gdXRpbHMuZGVlcEV4dGVuZCggY2xvbmVkT2JqZWN0ICk7XG4gICAgICAgICAgICBuZXdPYmplY3QucHJvcGVydHkgPSBkZWxldGVkUHJvcGVydGllc0l0ZW07XG5cbiAgICAgICAgICAgIC8vIEluc3RhbmNlIHRoZSBhY3Rpb24gaW5zdGFuY2UgYW5kIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgbmV3QWN0aW9uSW5zdGFuY2UgPSBuZXcgT2JqZWN0RGVsZXRlKCBuZXdPYmplY3QsIGRpY3Rpb25hcnkgKTtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaCggbmV3QWN0aW9uSW5zdGFuY2UgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYWN0aW9ucztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0VXBkYXRlO1xuIiwiLyogXG4gICAgQ2xhc3MgTG9vcCBcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEF1dG9EZWZpbmVIZWxwZXIgPSByZXF1aXJlKCAnLi9hdXRvRGVmaW5lSGVscGVyLmpzJyApO1xudmFyIGV4cHJlc3Npb25CdWlsZGVyID0gcmVxdWlyZSggJy4uL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcblxudmFyIExvb3AgPSBmdW5jdGlvbiAoIF9pdGVtVmFyaWFibGVOYW1lLCBfZXhwcmVzc2lvblN0cmluZywgc2NvcGUgKSB7XG4gICAgXG4gICAgdmFyIGl0ZW1WYXJpYWJsZU5hbWUgPSBfaXRlbVZhcmlhYmxlTmFtZTtcbiAgICB2YXIgZXhwcmVzc2lvblN0cmluZyA9IF9leHByZXNzaW9uU3RyaW5nO1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGQoIGV4cHJlc3Npb25TdHJpbmcgKTtcbiAgICB2YXIgZ2V0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGl0ZW1zID0gZXhwcmVzc2lvbi5ldmFsdWF0ZSggc2NvcGUgKTtcbiAgICB2YXIgZ2V0SXRlbXMgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgY3VycmVudEluZGV4ID0gLTE7XG4gICAgdmFyIG1heEluZGV4ID0gaXRlbXM/IGl0ZW1zLmxlbmd0aCAtIDE6IC0xO1xuICAgIFxuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBzZXRPZmZzZXQgPSBmdW5jdGlvbiggX29mZnNldCApe1xuICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0O1xuICAgIH07XG4gICAgXG4gICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICBpZiAoIGN1cnJlbnRJbmRleCsrIDwgbWF4SW5kZXggKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBMb29wLmJ1aWxkQXV0b0RlZmluZUhlbHBlciggXG4gICAgICAgICAgICAgICAgaXRlbVZhcmlhYmxlTmFtZSwgXG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4LCBcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uU3RyaW5nLCBcbiAgICAgICAgICAgICAgICBpdGVtcy5sZW5ndGgsIFxuICAgICAgICAgICAgICAgIG9mZnNldCBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0T2Zmc2V0OiBzZXRPZmZzZXQsXG4gICAgICAgIHJlcGVhdDpyZXBlYXQsXG4gICAgICAgIGdldEl0ZW1zOiBnZXRJdGVtcyxcbiAgICAgICAgZ2V0RXhwcmVzc2lvbjogZ2V0RXhwcmVzc2lvblxuICAgIH07XG59O1xuXG5Mb29wLmJ1aWxkQXV0b0RlZmluZUhlbHBlciA9IGZ1bmN0aW9uKCBpdGVtVmFyaWFibGVOYW1lLCBpdGVtSW5kZXgsIGV4cHJlc3Npb25TdHJpbmcsIG51bWJlck9mSXRlbXMsIG9mZnNldCApe1xuICAgIFxuICAgIHZhciBhdXRvRGVmaW5lSGVscGVyID0gbmV3IEF1dG9EZWZpbmVIZWxwZXIoKTtcblxuICAgIC8vIERlY2xhcmUgaXRlbS1pbmRleCwgaXRlbS1hbGwsIGl0ZW0gYW5kIGl0ZW0tcmVwZWF0IHZhcmlhYmxlc1xuICAgIGF1dG9EZWZpbmVIZWxwZXIucHV0KFxuICAgICAgICBpdGVtVmFyaWFibGVOYW1lICsgJy1pbmRleCcsXG4gICAgICAgIGl0ZW1JbmRleFxuICAgICk7XG4gICAgYXV0b0RlZmluZUhlbHBlci5wdXQoXG4gICAgICAgIGl0ZW1WYXJpYWJsZU5hbWUgKyAnLWFsbCcsXG4gICAgICAgIGV4cHJlc3Npb25TdHJpbmdcbiAgICApO1xuICAgIGF1dG9EZWZpbmVIZWxwZXIucHV0KFxuICAgICAgICBpdGVtVmFyaWFibGVOYW1lLFxuICAgICAgICBpdGVtVmFyaWFibGVOYW1lICsgJy1hbGwnICsgJ1snICsgaXRlbVZhcmlhYmxlTmFtZSArICctaW5kZXgnICsgJ10nXG4gICAgKTtcbiAgICBhdXRvRGVmaW5lSGVscGVyLnB1dChcbiAgICAgICAgaXRlbVZhcmlhYmxlTmFtZSArICctcmVwZWF0JyxcbiAgICAgICAgXCJjb250ZXh0L3JlcGVhdChcIiBcbiAgICAgICAgICAgICsgaXRlbVZhcmlhYmxlTmFtZSArIFwiLWluZGV4XCIgKyBcIixcIlxuICAgICAgICAgICAgKyBudW1iZXJPZkl0ZW1zICsgXCIsXCJcbiAgICAgICAgICAgICsgb2Zmc2V0XG4gICAgICAgICAgICArIFwiKVwiXG4gICAgKTtcblxuICAgIHJldHVybiBhdXRvRGVmaW5lSGVscGVyO1xufTtcblxuTG9vcC5zZXRBdXRvRGVmaW5lQXR0cmlidXRlID0gZnVuY3Rpb24oIG5vZGUsIGl0ZW1WYXJpYWJsZU5hbWUsIGl0ZW1JbmRleCwgZXhwcmVzc2lvblN0cmluZywgbnVtYmVyT2ZJdGVtcywgb2Zmc2V0ICl7XG4gICAgXG4gICAgLy8gU2V0IGl0ZW0taW5kZXgsIGl0ZW0tYWxsLCBpdGVtIGFuZCBpdGVtLXJlcGVhdCBhdHRyaWJ1dGVzXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoIFxuICAgICAgICBjb250ZXh0LmdldFRhZ3MoKS50YWxBdXRvRGVmaW5lLFxuICAgICAgICBpdGVtVmFyaWFibGVOYW1lICsgJy1pbmRleCAnICsgaXRlbUluZGV4ICsgJzsnXG4gICAgICAgICAgICArIGl0ZW1WYXJpYWJsZU5hbWUgKyAnLWFsbCAnICsgZXhwcmVzc2lvblN0cmluZyArICc7J1xuICAgICAgICAgICAgKyBpdGVtVmFyaWFibGVOYW1lICsgJyAnICsgaXRlbVZhcmlhYmxlTmFtZSArJy1hbGxbJyArIGl0ZW1WYXJpYWJsZU5hbWUgKyAnLWluZGV4XTsnXG4gICAgICAgICAgICArIGl0ZW1WYXJpYWJsZU5hbWUgKyAnLXJlcGVhdCBjb250ZXh0L3JlcGVhdCgnICsgaXRlbVZhcmlhYmxlTmFtZSArICctaW5kZXgsJyArIG51bWJlck9mSXRlbXMgKyAnLCcgKyBvZmZzZXQgKyAnKSdcbiAgICApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb29wO1xuIiwiLyogXG4gICAgQ2xhc3MgTG9vcEl0ZW1cbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIExvb3BJdGVtID0gZnVuY3Rpb24gKCBfY3VycmVudEluZGV4LCBfaXRlbXNMZW5ndGgsIF9vZmZzZXQgKSB7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSBfY3VycmVudEluZGV4O1xuICAgIHRoaXMuaXRlbXNMZW5ndGggPSBfaXRlbXNMZW5ndGg7XG4gICAgdGhpcy5vZmZzZXQgPSBfb2Zmc2V0O1xufTtcblxuTG9vcEl0ZW0ucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oICkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMuY3VycmVudEluZGV4O1xufTtcblxuTG9vcEl0ZW0ucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCApIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCgpICsgMTtcbn07XG5cbkxvb3BJdGVtLnByb3RvdHlwZS5ldmVuID0gZnVuY3Rpb24oICkge1xuICAgIHJldHVybiB0aGlzLmluZGV4KCkgJSAyID09PSAwO1xufTtcblxuTG9vcEl0ZW0ucHJvdG90eXBlLm9kZCA9IGZ1bmN0aW9uICggKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXgoKSAlIDIgPT09IDE7XG59O1xuXG5Mb29wSXRlbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoICkge1xuICAgIHJldHVybiB0aGlzLmluZGV4KCkgPT09IDA7XG59O1xuXG5Mb29wSXRlbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCApIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50SW5kZXggPT09IHRoaXMuaXRlbXNMZW5ndGggLSAxO1xufTtcblxuTG9vcEl0ZW0ucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLml0ZW1zTGVuZ3RoO1xufTtcblxuTG9vcEl0ZW0ucHJvdG90eXBlLmxldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMZXR0ZXIoIHRoaXMuaW5kZXgoKSwgJ2EnICk7XG59O1xuXG5Mb29wSXRlbS5wcm90b3R5cGUuTGV0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExldHRlciggdGhpcy5pbmRleCgpLCAnQScgKTtcbn07XG5cbkxvb3BJdGVtLnByb3RvdHlwZS5mb3JtYXRMZXR0ZXIgPSBmdW5jdGlvbiAoIGlpLCBzdGFydENoYXIgKSB7XG4gICAgdmFyIGkgPSBpaTtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRDaGFyLmNoYXJDb2RlQXQoIDAgKTsgXG4gICAgdmFyIGRpZ2l0ID0gaSAlIDI2O1xuICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBzdGFydCArIGRpZ2l0ICk7XG5cbiAgICB3aGlsZSggaSA+IDI1ICkge1xuICAgICAgICBpIC89IDI2O1xuICAgICAgICBkaWdpdCA9IChpIC0gMSApICUgMjY7XG4gICAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBzdGFydCArIGRpZ2l0ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xufTtcblxuTG9vcEl0ZW0ucHJvdG90eXBlLnJvbWFuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFJvbWFuKCB0aGlzLmluZGV4KCkgKyAxLCAwICk7XG59O1xuXG5Mb29wSXRlbS5wcm90b3R5cGUuUm9tYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0Um9tYW4oIHRoaXMuaW5kZXgoKSArIDEsIDEgKTtcbn07XG5cbkxvb3BJdGVtLnByb3RvdHlwZS5mb3JtYXRSb21hbiA9IGZ1bmN0aW9uICggbm4sIGNhcGl0YWwgKSB7XG4gICAgdmFyIG4gPSBubjtcblxuICAgIC8vIENhbid0IHJlcHJlc2VudCBhbnkgbnVtYmVyIDQwMDAgb3IgZ3JlYXRlclxuICAgIGlmICggbiA+PSA0MDAwICkge1xuICAgICAgICByZXR1cm4gJ092ZXJmbG93IGZvcm1hdHRpbmcgcm9tYW4hJztcbiAgICB9XG5cbiAgICB2YXIgYnVmID0gJyc7XG4gICAgZm9yICggdmFyIGRlY2FkZSA9IDA7IG4gIT09IDA7IGRlY2FkZSsrICkge1xuICAgICAgICB2YXIgZGlnaXQgPSBuICUgMTA7XG4gICAgICAgIGlmICggZGlnaXQgPiAwICkge1xuICAgICAgICAgICAgZGlnaXQtLTtcbiAgICAgICAgICAgIGJ1ZiArPSB0aGlzLnJvbWFuQXJyYXkgWyBkZWNhZGUgXVsgZGlnaXQgXVsgY2FwaXRhbCBdO1xuICAgICAgICB9XG4gICAgICAgIG4gPSAobiAvIDEwKSA+PiAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWYuc3BsaXQoICcnICkucmV2ZXJzZSgpLmpvaW4oICcnICk7XG59O1xuXG5Mb29wSXRlbS5wcm90b3R5cGUucm9tYW5BcnJheSA9IFtcbiAgICAvKiBPbmUncyBwbGFjZSAqL1xuICAgIFtcbiAgICAgICAgWyBcImlcIiwgXCJJXCIgXSxcbiAgICAgICAgWyBcImlpXCIsIFwiSUlcIiBdLCBcbiAgICAgICAgWyBcImlpaVwiLCBcIklJSVwiIF0sXG4gICAgICAgIFsgXCJ2aVwiLCBcIlZJXCIgXSxcbiAgICAgICAgWyBcInZcIiwgXCJWXCIgXSxcbiAgICAgICAgWyBcIml2XCIsIFwiSVZcIiBdLFxuICAgICAgICBbIFwiaWl2XCIsIFwiSUlWXCIgXSxcbiAgICAgICAgWyBcImlpaXZcIiwgXCJJSUlWXCIgXSxcbiAgICAgICAgWyBcInhpXCIsIFwiWElcIiBdXG4gICAgXSxcblxuICAgIC8qIDEwJ3MgcGxhY2UgKi9cbiAgICBbXG4gICAgICAgIFsgXCJ4XCIsIFwiWFwiIF0sXG4gICAgICAgIFsgXCJ4eFwiLCBcIlhYXCIgXSxcbiAgICAgICAgWyBcInh4eFwiLCBcIlhYWFwiIF0sXG4gICAgICAgIFsgXCJseFwiLCBcIkxYXCIgXSxcbiAgICAgICAgWyBcImxcIiwgXCJMXCIgXSxcbiAgICAgICAgWyBcInhsXCIsIFwiWExcIiBdLFxuICAgICAgICBbIFwieHhsXCIsIFwiWFhMXCIgXSxcbiAgICAgICAgWyBcInh4eGxcIiwgXCJYWFhMXCIgXSxcbiAgICAgICAgWyBcImN4XCIsIFwiQ1hcIiBdXG4gICAgXSxcblxuICAgIC8qIDEwMCdzIHBsYWNlICovXG4gICAgW1xuICAgICAgICBbIFwiY1wiLCBcIkNcIiBdLFxuICAgICAgICBbIFwiY2NcIiwgXCJDQ1wiIF0sXG4gICAgICAgIFsgXCJjY2NcIiwgXCJDQ0NcIiBdLFxuICAgICAgICBbIFwiZGNcIiwgXCJEQ1wiIF0sXG4gICAgICAgIFsgXCJkXCIsIFwiRFwiIF0sXG4gICAgICAgIFsgXCJjZFwiLCBcIkNEXCIgXSxcbiAgICAgICAgWyBcImNjZFwiLCBcIkNDRFwiIF0sXG4gICAgICAgIFsgXCJjY2NkXCIsIFwiQ0NDRFwiIF0sXG4gICAgICAgIFsgXCJtY1wiLCBcIk1DXCIgXVxuICAgIF0sXG5cbiAgICAvKiAxMDAwJ3MgcGxhY2UgKi9cbiAgICBbXG4gICAgICAgIFsgXCJtXCIsIFwiTVwiIF0sXG4gICAgICAgIFsgXCJtbVwiLCBcIk1NXCIgXSxcbiAgICAgICAgWyBcIm1tbVwiLCBcIk1NTVwiIF1cbiAgICBdXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvb3BJdGVtO1xuIiwiLyogXG4gICAgQ2xhc3MgTm9kZUF0dHJpYnV0ZXMgXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uL2NvbnRleHQuanMnICk7XG5cbnZhciBOb2RlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBub2RlLCBpbmRleEV4cHJlc3Npb25zICkge1xuICAgIFxuICAgIHZhciB0YWdzID0gY29udGV4dC5nZXRUYWdzKCk7XG4gICAgXG4gICAgLy8gdGFsIG5hbWVzcGFjZVxuICAgIHRoaXMudGFsRGVmaW5lID0gbm9kZS5nZXRBdHRyaWJ1dGUoIHRhZ3MudGFsRGVmaW5lICk7XG4gICAgdGhpcy50YWxDb25kaXRpb24gPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy50YWxDb25kaXRpb24gKTtcbiAgICB0aGlzLnRhbFJlcGVhdCA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLnRhbFJlcGVhdCApO1xuICAgIHRoaXMudGFsQ29udGVudCA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLnRhbENvbnRlbnQgKTtcbiAgICB0aGlzLnRhbEF0dHJpYnV0ZXMgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy50YWxBdHRyaWJ1dGVzICk7XG4gICAgdGhpcy50YWxPbWl0VGFnID0gbm9kZS5nZXRBdHRyaWJ1dGUoIHRhZ3MudGFsT21pdFRhZyApO1xuICAgIHRoaXMudGFsUmVwbGFjZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLnRhbFJlcGxhY2UgKTtcbiAgICB0aGlzLnRhbE9uRXJyb3IgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy50YWxPbkVycm9yICk7XG4gICAgdGhpcy50YWxEZWNsYXJlID0gbm9kZS5nZXRBdHRyaWJ1dGUoIHRhZ3MudGFsRGVjbGFyZSApO1xuICAgIC8vdGhpcy50YWxUYWcgPSB1bmRlZmluZWQ7XG4gICAgXG4gICAgLy8gbWV0YWwgbmFtZXNwYWNlXG4gICAgdGhpcy5tZXRhbERlZmluZU1hY3JvID0gbm9kZS5nZXRBdHRyaWJ1dGUoIHRhZ3MubWV0YWxEZWZpbmVNYWNybyApO1xuICAgIHRoaXMubWV0YWxVc2VNYWNybyA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLm1ldGFsVXNlTWFjcm8gKTtcbiAgICB0aGlzLm1ldGFsRGVmaW5lU2xvdCA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLm1ldGFsRGVmaW5lU2xvdCApO1xuICAgIHRoaXMubWV0YWxGaWxsU2xvdCA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLm1ldGFsRmlsbFNsb3QgKTtcbiAgICBcbiAgICAvLyBpMThuIG5hbWVzcGFjZVxuICAgIHRoaXMuaTE4bkRvbWFpbiA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLmkxOG5Eb21haW4gKTtcbiAgICB0aGlzLmkxOG5MYW5ndWFnZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLmkxOG5MYW5ndWFnZSApO1xuICAgIFxuICAgIC8vIEZvciBpbnRlcm5hbCB1c2VcbiAgICB0aGlzLnFkdXAgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy5xZHVwICk7XG4gICAgXG4gICAgLy8gSW5pdCB0aGlzLmlkIGFuZCBzZXQgdGhlIG5vZGUgaWQgaWYgaW5kZXhFeHByZXNzaW9ucyBpcyB0cnVlLCBzb21lIGF0dHJpYnV0ZSBpcyBzZXQgYW5kIGl0IGlzIHVuZGVmaW5lZFxuICAgIGlmICggaW5kZXhFeHByZXNzaW9ucyAmJiB0aGlzLmlzRHluYW1pY0NvbnRlbnRPbigpICl7XG4gICAgICAgIHRoaXMuaWQgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy5pZCApO1xuICAgICAgICBpZiAoICEgdGhpcy5pZCApe1xuICAgICAgICAgICAgLy90aGlzLmlkID0gdXRpbHMuZ2VuZXJhdGVJZCggNiApO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGNvbnRleHQubmV4dEV4cHJlc3Npb25Db3VudGVyKCk7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSggdGFncy5pZCwgdGhpcy5pZCApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTm9kZUF0dHJpYnV0ZXMucHJvdG90eXBlLmlzRHluYW1pY0NvbnRlbnRPbiA9IGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIHJldHVybiB0aGlzLnRhbERlZmluZSBcbiAgICAgICAgfHwgdGhpcy50YWxDb25kaXRpb25cbiAgICAgICAgfHwgdGhpcy50YWxSZXBlYXRcbiAgICAgICAgfHwgdGhpcy50YWxDb250ZW50XG4gICAgICAgIHx8IHRoaXMudGFsQXR0cmlidXRlc1xuICAgICAgICB8fCB0aGlzLnRhbE9taXRUYWcgXG4gICAgICAgIHx8IHRoaXMudGFsUmVwbGFjZVxuICAgICAgICB8fCB0aGlzLnRhbE9uRXJyb3JcbiAgICAgICAgfHwgdGhpcy50YWxEZWNsYXJlXG4gICAgICAgIC8vfHwgdGhpcy50YWxUYWdcbiAgICAgICAgLy98fCB0aGlzLm1ldGFsRGVmaW5lTWFjcm8gXG4gICAgICAgIHx8IHRoaXMubWV0YWxVc2VNYWNybyBcbiAgICAgICAgLy98fCB0aGlzLm1ldGFsRGVmaW5lU2xvdCBcbiAgICAgICAgfHwgdGhpcy5tZXRhbEZpbGxTbG90IFxuICAgICAgICB8fCB0aGlzLmkxOG5Eb21haW5cbiAgICAgICAgfHwgdGhpcy5pMThuTGFuZ3VhZ2U7XG4gICAgICAgIC8vfHwgdGhpcy5xZHVwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlQXR0cmlidXRlcztcbiIsIi8qIFxyXG4gICAgQ2xhc3MgTm9kZVJlbW92ZXIgXHJcbiovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgXHJcbiAgICB2YXIgdGFncyA9IGNvbnRleHQuZ2V0VGFncygpO1xyXG4gICAgXHJcbiAgICB2YXIgcmVtb3ZlR2VuZXJhdGVkTm9kZXMgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElzIG11bHRpcm9vdD9cclxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHRhcmdldCApICl7IFxyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgc2V2ZXJhbCByb290c1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCB0YXJnZXQubGVuZ3RoOyBjKysgKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KCBcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlcyggdGFyZ2V0WyBjIF0gKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSByb290XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZU5vZGVzKCB0YXJnZXQgKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciByZW1vdmVOb2RlcyA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIHJlbW92ZU5vZGVzQnlUYWcoIHRhcmdldCwgdGFncy5xZHVwICkgKTsgICAgICAgLy8gUmVtb3ZlIGFsbCBnZW5lcmF0ZWQgbm9kZXMgKHJlcGVhdHMpXHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCggcmVtb3ZlTm9kZXNCeVRhZyggdGFyZ2V0LCB0YWdzLm1ldGFsTWFjcm8gKSApOyAvLyBSZW1vdmUgYWxsIGdlbmVyYXRlZCBub2RlcyAobWFjcm9zKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcmVtb3ZlTm9kZXNCeVRhZyA9IGZ1bmN0aW9uKCB0YXJnZXQsIHRhZyApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsaXN0ID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKltcIiArIHRhZyArIFwiXVwiICk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3QoIGxpc3QgKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciByZW1vdmVSZWxhdGVkTm9kZXMgPSBmdW5jdGlvbiggdGFyZ2V0ICl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxpc3QgPSB0YXJnZXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBcclxuICAgICAgICAgICAgJ1snICsgY29udGV4dC5nZXRUYWdzKCkucmVsYXRlZElkICsgJz1cIicgKyB0YXJnZXQuZ2V0QXR0cmlidXRlKCBjb250ZXh0LmdldFRhZ3MoKS5pZCApICsgJ1wiXScgXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlTGlzdCggbGlzdCApO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHJlbW92ZUxpc3QgPSBmdW5jdGlvbiggbGlzdCApe1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG5vZGU7XHJcbiAgICAgICAgdmFyIHBvcyA9IDA7XHJcbiAgICAgICAgd2hpbGUgKCBub2RlID0gbGlzdFsgcG9zKysgXSApIHtcclxuICAgICAgICAgICAgLy8gQWRkIG5vZGVJZCB0byByZXN1bHQgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBnZXROb2RlSWQoIG5vZGUgKTtcclxuICAgICAgICAgICAgaWYgKCBub2RlSWQgIT09IHVuZGVmaW5lZCApe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goIG5vZGVJZCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5vZGVJZHMgb2YgaXRzIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGFkZE5vZGVJZHNUb0xpc3QoIG5vZGUsIHJlc3VsdCApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG5vZGVcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgYWRkTm9kZUlkc1RvTGlzdCA9IGZ1bmN0aW9uKCB0YXJnZXQsIHJlc3VsdCApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEdldCB0aGUgbm9kZXMgd2l0aCBkYXRhLWlkXHJcbiAgICAgICAgdmFyIG5vZGVJZEF0dHJpYnV0ZU5hbWUgPSBjb250ZXh0LmdldFRhZ3MoKS5pZDtcclxuICAgICAgICB2YXIgbGlzdCA9IHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKCAnWycgKyBub2RlSWRBdHRyaWJ1dGVOYW1lICsgJ10nICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aGUgbGlzdFxyXG4gICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgIHZhciBwb3MgPSAwO1xyXG4gICAgICAgIHdoaWxlICggbm9kZSA9IGxpc3RbIHBvcysrIF0gKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCBcclxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKCBub2RlSWRBdHRyaWJ1dGVOYW1lICkgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIGdldE5vZGVJZCA9IGZ1bmN0aW9uKCBub2RlICl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG5vZGVJZEF0dHJpYnV0ZU5hbWUgPSBjb250ZXh0LmdldFRhZ3MoKS5pZDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbm9kZS5oYXNBdHRyaWJ1dGUoIG5vZGVJZEF0dHJpYnV0ZU5hbWUgKT9cclxuICAgICAgICAgICAgbm9kZS5nZXRBdHRyaWJ1dGUoIG5vZGVJZEF0dHJpYnV0ZU5hbWUgKTpcclxuICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHJlbW92ZU5vZGUgPSBmdW5jdGlvbiggbm9kZSApe1xyXG4gICAgICAgIHZhciBub2RlSWQgPSBnZXROb2RlSWQoIG5vZGUgKTtcclxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAoIHBhcmVudE5vZGUgKXtcclxuICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZUlkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHJlbW92ZU11bHRpcGxlTm9kZXMgPSBmdW5jdGlvbiggbm9kZSwgbXVzdFJlbW92ZUdlbmVyYXRlZE5vZGVzICl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlbW92ZVJlbGF0ZWROb2Rlcyggbm9kZSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggbXVzdFJlbW92ZUdlbmVyYXRlZE5vZGVzICl7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICByZW1vdmVHZW5lcmF0ZWROb2Rlcyggbm9kZSApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHtcclxuICAgICAgICByZW1vdmVHZW5lcmF0ZWROb2RlczogcmVtb3ZlR2VuZXJhdGVkTm9kZXMsXHJcbiAgICAgICAgLy9yZW1vdmVSZWxhdGVkTm9kZXM6IHJlbW92ZVJlbGF0ZWROb2RlcyxcclxuICAgICAgICByZW1vdmVOb2RlOiByZW1vdmVOb2RlLFxyXG4gICAgICAgIHJlbW92ZU11bHRpcGxlTm9kZXM6IHJlbW92ZU11bHRpcGxlTm9kZXNcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBzZWxmO1xyXG59KSgpO1xyXG4iLCIvKiBcclxuICAgIENsYXNzIFBhcnNlciBcclxuKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi9jb250ZXh0LmpzJyApO1xyXG52YXIgUGFyc2VyUmVuZGVyZXIgPSByZXF1aXJlKCAnLi9wYXJzZXJSZW5kZXJlci5qcycgKTtcclxudmFyIFBhcnNlclVwZGF0ZXIgPSByZXF1aXJlKCAnLi9wYXJzZXJVcGRhdGVyLmpzJyApO1xyXG52YXIgUGFyc2VyUHJlbG9hZGVyID0gcmVxdWlyZSggJy4vcGFyc2VyUHJlbG9hZGVyLmpzJyApO1xyXG52YXIgUmVhY3RpdmVEaWN0aW9uYXJ5ID0gcmVxdWlyZSggJy4uL3Njb3Blcy9yZWFjdGl2ZURpY3Rpb25hcnkuanMnICk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuICAgIFxyXG4gICAgdmFyIHBhcnNlck9wdGlvbnMgPSB7XHJcbiAgICAgICAgY29tbWFuZDogdW5kZWZpbmVkLCAvLyBwcmVsb2FkLCBmdWxsUmVuZGVyIG9yIHBhcnRpYWxSZW5kZXJcclxuICAgICAgICByb290OiB1bmRlZmluZWQsXHJcbiAgICAgICAgZGljdGlvbmFyeToge30sXHJcbiAgICAgICAgaW5kZXhFeHByZXNzaW9uczogdHJ1ZVxyXG4gICAgICAgIC8vbm90UmVtb3ZlR2VuZXJhdGVkVGFncyxcclxuICAgICAgICAvL3RhcmdldCxcclxuICAgICAgICAvL2RlY2xhcmVkUmVtb3RlUGFnZVVybHMsXHJcbiAgICAgICAgLy9pMThuLFxyXG4gICAgICAgIC8vY2FsbGJhY2ssXHJcbiAgICAgICAgLy9mYWlsQ2FsbGJhY2ssXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgdXBkYXRlUGFyc2VyT3B0aW9ucyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcGFyc2VyT3B0aW9ucy5jb21tYW5kID0gb3B0aW9ucy5jb21tYW5kIHx8ICdmdWxsUmVuZGVyJztcclxuICAgICAgICBwYXJzZXJPcHRpb25zLnJvb3QgPSBvcHRpb25zLnJvb3QgPT09IHVuZGVmaW5lZD8gcGFyc2VyT3B0aW9ucy5yb290OiBvcHRpb25zLnJvb3Q7XHJcbiAgICAgICAgcGFyc2VyT3B0aW9ucy5kaWN0aW9uYXJ5ID0gKCBvcHRpb25zLmRpY3Rpb25hcnkgaW5zdGFuY2VvZiBSZWFjdGl2ZURpY3Rpb25hcnk/XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZGljdGlvbmFyeS5fZ2V0Tm9uUmVhY3RpdmVEaWN0aW9uYXJ5KCk6IFxyXG4gICAgICAgICAgICBvcHRpb25zLmRpY3Rpb25hcnkgKVxyXG4gICAgICAgICAgICB8fCBwYXJzZXJPcHRpb25zLmRpY3Rpb25hcnk7XHJcbiAgICAgICAgLy9wYXJzZXJPcHRpb25zLmRpY3Rpb25hcnkgPSBvcHRpb25zLmRpY3Rpb25hcnkgfHwgcGFyc2VyT3B0aW9ucy5kaWN0aW9uYXJ5O1xyXG4gICAgICAgIHBhcnNlck9wdGlvbnMuaW5kZXhFeHByZXNzaW9ucyA9IG9wdGlvbnMuaW5kZXhFeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkPyBwYXJzZXJPcHRpb25zLmluZGV4RXhwcmVzc2lvbnM6IG9wdGlvbnMuaW5kZXhFeHByZXNzaW9ucztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBydW4gPSBmdW5jdGlvbiggX29wdGlvbnMgKXtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEluaXQgcGFyc2VyIG9wdGlvbnNcclxuICAgICAgICB1cGRhdGVQYXJzZXJPcHRpb25zKCBvcHRpb25zICk7XHJcbiAgICBcclxuICAgICAgICB2YXIgY29tbWFuZCA9IG9wdGlvbnMuY29tbWFuZCB8fCAnZnVsbFJlbmRlcic7XHJcbiAgICAgICAgc3dpdGNoICggY29tbWFuZCApIHtcclxuICAgICAgICAgICAgY2FzZSAncHJlbG9hZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1ByZWxvYWQoXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZhaWxDYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlY2xhcmVkUmVtb3RlUGFnZVVybHMgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pMThuLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm90UmVtb3ZlR2VuZXJhdGVkVGFncyxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1heEZvbGRlckRpY3Rpb25hcmllc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY2FzZSAnZnVsbFJlbmRlcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ3BhcnRpYWxSZW5kZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NSZW5kZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9PT0gJ3BhcnRpYWxSZW5kZXInPyBvcHRpb25zLnRhcmdldDogcGFyc2VyT3B0aW9ucy5yb290LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGljdGlvbmFyeUV4dGVuc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm5vdFJlbW92ZUdlbmVyYXRlZFRhZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyT3B0aW9ucy5pbmRleEV4cHJlc3Npb25zICYmIGNvbW1hbmQgPT09ICdmdWxsUmVuZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmdvVG9VUkxIYXNoID09PSB1bmRlZmluZWQ/IGNvbnRleHQubmV4dFJ1bkNvdW50ZXIoKSA9PT0gMTogZmFsc2VcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1VwZGF0ZSggXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kaWN0aW9uYXJ5Q2hhbmdlcyxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRpY3Rpb25hcnlBY3Rpb25zXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gY29tbWFuZDogJyArIGNvbW1hbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3NQcmVsb2FkID0gZnVuY3Rpb24oIGNhbGxiYWNrLCBmYWlsQ2FsbGJhY2ssIGRlY2xhcmVkUmVtb3RlUGFnZVVybHMsIGkxOG4sIG5vdFJlbW92ZUdlbmVyYXRlZFRhZ3MsIG1heEZvbGRlckRpY3Rpb25hcmllcyApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwYXJzZXJQcmVsb2FkZXIgPSBuZXcgUGFyc2VyUHJlbG9hZGVyKCBcclxuICAgICAgICAgICAgcGFyc2VyT3B0aW9ucywgXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLCBcclxuICAgICAgICAgICAgZmFpbENhbGxiYWNrLCBcclxuICAgICAgICAgICAgZGVjbGFyZWRSZW1vdGVQYWdlVXJscywgXHJcbiAgICAgICAgICAgIGkxOG4sIFxyXG4gICAgICAgICAgICBub3RSZW1vdmVHZW5lcmF0ZWRUYWdzLCBcclxuICAgICAgICAgICAgbWF4Rm9sZGVyRGljdGlvbmFyaWVzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcGFyc2VyUHJlbG9hZGVyLnJ1bigpO1xyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VyUHJlbG9hZGVyO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3NSZW5kZXIgPSBmdW5jdGlvbiggdGFyZ2V0LCBkaWN0aW9uYXJ5RXh0ZW5zaW9uLCBub3RSZW1vdmVHZW5lcmF0ZWRUYWdzLCByZXNldEluZGV4LCBnb1RvVVJMSGFzaCApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwYXJzZXJSZW5kZXJlciA9IG5ldyBQYXJzZXJSZW5kZXJlciggXHJcbiAgICAgICAgICAgIHBhcnNlck9wdGlvbnMsIFxyXG4gICAgICAgICAgICB0YXJnZXQsIFxyXG4gICAgICAgICAgICBkaWN0aW9uYXJ5RXh0ZW5zaW9uLCBcclxuICAgICAgICAgICAgbm90UmVtb3ZlR2VuZXJhdGVkVGFncywgXHJcbiAgICAgICAgICAgIHJlc2V0SW5kZXgsXHJcbiAgICAgICAgICAgIGdvVG9VUkxIYXNoXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcGFyc2VyUmVuZGVyZXIucnVuKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlclJlbmRlcmVyO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3NVcGRhdGUgPSBmdW5jdGlvbiggZGljdGlvbmFyeUNoYW5nZXMsIGRpY3Rpb25hcnlBY3Rpb25zICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwYXJzZXJVcGRhdGVyID0gbmV3IFBhcnNlclVwZGF0ZXIoIFxyXG4gICAgICAgICAgICBkaWN0aW9uYXJ5Q2hhbmdlcyxcclxuICAgICAgICAgICAgZGljdGlvbmFyeUFjdGlvbnMsXHJcbiAgICAgICAgICAgIHBhcnNlck9wdGlvbnNcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBwYXJzZXJVcGRhdGVyLnJ1bigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBwYXJzZXJVcGRhdGVyO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIGdldE9wdGlvbnMgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBwYXJzZXJPcHRpb25zO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHNlbGYgPSB7XHJcbiAgICAgICAgcnVuOiBydW4sXHJcbiAgICAgICAgZ2V0T3B0aW9uczogZ2V0T3B0aW9uc1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKCk7XHJcbiIsIi8qIFxyXG4gICAgQ2xhc3MgUGFyc2VyTm9kZVJlbmRlcmVyXHJcbiovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcclxudmFyIGxvZyA9IHJlcXVpcmUoICcuLi9sb2dIZWxwZXIuanMnICk7XHJcbnZhciBOb2RlQXR0cmlidXRlcyA9IHJlcXVpcmUoICcuL25vZGVBdHRyaWJ1dGVzLmpzJyApO1xyXG52YXIgYXR0cmlidXRlQ2FjaGUgPSByZXF1aXJlKCAnLi4vY2FjaGUvYXR0cmlidXRlQ2FjaGUuanMnICk7XHJcbnZhciBhdHRyaWJ1dGVJbmRleCA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVzL2F0dHJpYnV0ZUluZGV4LmpzJyApO1xyXG52YXIgQXV0b0RlZmluZUhlbHBlciA9IHJlcXVpcmUoICcuL2F1dG9EZWZpbmVIZWxwZXIuanMnICk7XHJcbnZhciBldmFsdWF0ZUhlbHBlciA9IHJlcXVpcmUoICcuLi9leHByZXNzaW9ucy9ldmFsdWF0ZUhlbHBlci5qcycgKTtcclxudmFyIExvb3AgPSByZXF1aXJlKCAnLi9sb29wLmpzJyApO1xyXG5cclxudmFyIEkxOE5Eb21haW4gPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9JMThOL2kxOG5Eb21haW4uanMnICk7XHJcbnZhciBJMThOTGFuZ3VhZ2UgPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9JMThOL2kxOG5MYW5ndWFnZS5qcycgKTtcclxudmFyIE1FVEFMRGVmaW5lTWFjcm8gPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9NRVRBTC9tZXRhbERlZmluZU1hY3JvLmpzJyApO1xyXG52YXIgTUVUQUxVc2VNYWNybyA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVzL01FVEFML21ldGFsVXNlTWFjcm8uanMnICk7XHJcbnZhciBUQUxBdHRyaWJ1dGVzID0gcmVxdWlyZSggJy4uL2F0dHJpYnV0ZXMvVEFML3RhbEF0dHJpYnV0ZXMuanMnICk7XHJcbnZhciBUQUxDb25kaXRpb24gPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9UQUwvdGFsQ29uZGl0aW9uLmpzJyApO1xyXG52YXIgVEFMQ29udGVudCA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVzL1RBTC90YWxDb250ZW50LmpzJyApO1xyXG52YXIgVEFMRGVmaW5lID0gcmVxdWlyZSggJy4uL2F0dHJpYnV0ZXMvVEFML3RhbERlZmluZS5qcycgKTtcclxudmFyIFRBTE9taXRUYWcgPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9UQUwvdGFsT21pdFRhZy5qcycgKTtcclxudmFyIFRBTE9uRXJyb3IgPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9UQUwvdGFsT25FcnJvci5qcycgKTtcclxudmFyIFRBTFJlcGVhdCA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVzL1RBTC90YWxSZXBlYXQuanMnICk7XHJcbnZhciBUQUxSZXBsYWNlID0gcmVxdWlyZSggJy4uL2F0dHJpYnV0ZXMvVEFML3RhbFJlcGxhY2UuanMnICk7XHJcbnZhciBUQUxEZWNsYXJlID0gcmVxdWlyZSggJy4uL2F0dHJpYnV0ZXMvVEFML3RhbERlY2xhcmUuanMnICk7XHJcbnZhciBjb250ZW50SGVscGVyID0gcmVxdWlyZSggJy4uL2F0dHJpYnV0ZXMvVEFML2NvbnRlbnRIZWxwZXIuanMnICk7XHJcblxyXG52YXIgUGFyc2VyTm9kZVJlbmRlcmVyID0gZnVuY3Rpb24oIF90YXJnZXQsIF9zY29wZSwgX2luZGV4RXhwcmVzc2lvbnMgKSB7XHJcbiAgICBcclxuICAgIHZhciB0YXJnZXQgPSBfdGFyZ2V0OyBcclxuICAgIHZhciBzY29wZSA9IF9zY29wZTtcclxuICAgIHZhciBpbmRleEV4cHJlc3Npb25zID0gX2luZGV4RXhwcmVzc2lvbnM7XHJcbiAgICBcclxuICAgIHZhciB0YWdzID0gY29udGV4dC5nZXRUYWdzKCk7XHJcbiAgICBcclxuICAgIHZhciBydW4gPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHByb2Nlc3MoIHRhcmdldCApO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggbm9kZSApIHtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBhdHRyaWJ1dGVzIGZyb20gdGhlIG5vZGVcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgTm9kZUF0dHJpYnV0ZXMoIG5vZGUsIGluZGV4RXhwcmVzc2lvbnMgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNjb3BlLnN0YXJ0RWxlbWVudCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBpbnN0cnVjdGlvbnNcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50YWxSZXBlYXQgIT0gbnVsbCA/IFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0xvb3AoIG5vZGUsIGF0dHJpYnV0ZXMgKTpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KCBub2RlLCBhdHRyaWJ1dGVzICk7XHJcblxyXG4gICAgICAgICAgICBzY29wZS5lbmRFbGVtZW50KCk7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKCBlICkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIHRyZWF0IGVycm9yXHJcbiAgICAgICAgICAgIGlmICggISB0cmVhdEVycm9yKCBub2RlLCBlICkgKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3NMb29wTmV4dFNpYmxpbmcgPSBmdW5jdGlvbiggbm9kZSApe1xyXG5cclxuICAgICAgICB2YXIgY291bnRlciA9IC0xO1xyXG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IG5vZGU7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICArK2NvdW50ZXI7XHJcbiAgICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgICAgICAgICBpZiAoICEgbmV4dFNpYmxpbmcgKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogY291bnRlclxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKCBuZXh0U2libGluZy5oYXNBdHRyaWJ1dGUoIHRhZ3MucWR1cCApICk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcclxuICAgICAgICAgICAgY291bnRlcjogY291bnRlclxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcHJvY2Vzc0xvb3AgPSBmdW5jdGlvbiggbm9kZSwgYXR0cmlidXRlcyApIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBQcm9jZXNzIHJlcGVhdFxyXG4gICAgICAgIC8vdmFyIHRhbFJlcGVhdCA9IFRBTFJlcGVhdC5idWlsZCggYXR0cmlidXRlcy50YWxSZXBlYXQgKTtcclxuICAgICAgICB2YXIgdGFsUmVwZWF0ID0gYXR0cmlidXRlQ2FjaGUuZ2V0QnlBdHRyaWJ1dGVDbGFzcyggXHJcbiAgICAgICAgICAgIFRBTFJlcGVhdCwgXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudGFsUmVwZWF0LCBcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgaW5kZXhFeHByZXNzaW9ucyxcclxuICAgICAgICAgICAgc2NvcGVcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciBsb29wID0gdGFsUmVwZWF0LnByb2Nlc3MoIHNjb3BlLCBub2RlICk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGRlZmF1bHRcclxuICAgICAgICBpZiAoIGV2YWx1YXRlSGVscGVyLmlzRGVmYXVsdCggbG9vcC5nZXRJdGVtcygpICkgKXtcclxuICAgICAgICAgICAgcHJvY2Vzc0VsZW1lbnQoIG5vZGUsIGF0dHJpYnV0ZXMgKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgbm9kZSB0byBjbG9uZSBpdCBsYXRlclxyXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCB0YWdzLnRhbFJlcGVhdCApO1xyXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnc3R5bGUnICk7XHJcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIHRhZ3MucWR1cCwgMSApO1xyXG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xyXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnaWQnICk7XHJcbiAgICAgICAgdmFyIG5vZGVEYXRhSWQgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFncy5pZCApO1xyXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCB0YWdzLmlkICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nRGF0YSA9IHByb2Nlc3NMb29wTmV4dFNpYmxpbmcoIG5vZGUgKTtcclxuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZ0RhdGEubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgbG9vcC5zZXRPZmZzZXQoIG5leHRTaWJsaW5nRGF0YS5jb3VudGVyICk7XHJcbiAgICAgICAgLy9sb2cud2FybiggJ2xvb3AgY291bnRlcjogJyArIG5leHRTaWJsaW5nRGF0YS5jb3VudGVyICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGF1dG9EZWZpbmVIZWxwZXI7XHJcbiAgICAgICAgd2hpbGUgKCBhdXRvRGVmaW5lSGVscGVyID0gbG9vcC5yZXBlYXQoKSApIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNjb3BlLnN0YXJ0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2xvbmUgYW5kIGNvbmZpZ3VyZSB0aGUgbm9kZVxyXG4gICAgICAgICAgICB2YXIgdG1wTm9kZSA9IFBhcnNlck5vZGVSZW5kZXJlci5jbG9uZUFuZENvbmZpZ3VyZU5vZGUoIG5vZGUsIGluZGV4RXhwcmVzc2lvbnMsIHRhZ3MsIG5vZGVEYXRhSWQgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpdFxyXG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIHRtcE5vZGUsIG5leHRTaWJsaW5nICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGl0XHJcbiAgICAgICAgICAgIGlmICggISBwcm9jZXNzRWxlbWVudCggdG1wTm9kZSwgYXR0cmlidXRlcywgYXV0b0RlZmluZUhlbHBlciApICkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuZW5kRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzY29wZS5lbmRFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25maWd1cmUgcmVwZWF0IG5vZGUgKHRoZSBvcmlnaW5hbCkgdG8gZW5hYmxlIGZ1dHVyZSByZWV2YWx1YXRpb25cclxuICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIHRhZ3MudGFsUmVwZWF0LCBhdHRyaWJ1dGVzLnRhbFJlcGVhdCApO1xyXG4gICAgICAgIGlmICggbm9kZUlkICE9PSAnJyAmJiBub2RlSWQgIT0gbnVsbCApe1xyXG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSggJ2lkJywgbm9kZUlkICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggbm9kZURhdGFJZCAhPT0gJycgJiYgbm9kZURhdGFJZCAhPSBudWxsICl7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCB0YWdzLmlkLCBub2RlRGF0YUlkICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCB0YWdzLnFkdXAgKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRyZWF0RXJyb3IgPSBmdW5jdGlvbiggbm9kZSwgZXhjZXB0aW9uICkge1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGVycm9yIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogZXhjZXB0aW9uLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXhjZXB0aW9uLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB0cmFjZWJhY2s6IGV4Y2VwdGlvbi5zdGFja1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzY29wZS5zZXQoIFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5nZXRDb25mKCkudGVtcGxhdGVFcnJvclZhck5hbWUsIFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVFcnJvciBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEV4aXQgaWYgdGhlcmUgaXMgbm8gb24tZXJyb3IgZXhwcmVzc2lvbiBkZWZpbmVkXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gc2NvcGUuZ2V0KCBjb250ZXh0LmdldENvbmYoKS5vbkVycm9yVmFyTmFtZSApO1xyXG4gICAgICAgICAgICBpZiAoIGNvbnRlbnQgPT0gbnVsbCApIHtcclxuICAgICAgICAgICAgICAgIGxvZy5mYXRhbCggZXhjZXB0aW9uICk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5lbmRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxvZy5lcnJvciggZXhjZXB0aW9uICk7XHJcbiAgICAgICAgICAgIHNjb3BlLmVuZEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnRlbnRIZWxwZXIudXBkYXRlTm9kZSggXHJcbiAgICAgICAgICAgICAgICBub2RlLCBcclxuICAgICAgICAgICAgICAgIHNjb3BlLmdldCggY29udGV4dC5nZXRDb25mKCkub25FcnJvclN0cnVjdHVyZVZhck5hbWUgKSwgXHJcbiAgICAgICAgICAgICAgICBjb250ZW50IFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gY2F0Y2ggKCBlICkge1xyXG4gICAgICAgICAgICBsb2cuZmF0YWwoIGUgKTtcclxuICAgICAgICAgICAgc2NvcGUuZW5kRWxlbWVudCgpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBwcm9jZXNzRWxlbWVudCA9IGZ1bmN0aW9uKCBub2RlLCBhdHRyaWJ1dGVzLCBfYXV0b0RlZmluZUhlbHBlciApIHtcclxuXHJcbiAgICAgICAgLy8gSWYgaXQgaXMgZGVmaW5lZCBhIG1ldGFsRmlsbFNsb3Qgb3IgYSBtZXRhbERlZmluZU1hY3JvIGRvIG5vdGhpbmdcclxuICAgICAgICBpZiAoIGF0dHJpYnV0ZXMubWV0YWxGaWxsU2xvdCB8fCAhIHByb2Nlc3NNRVRBTERlZmluZU1hY3JvKFxyXG4gICAgICAgICAgICBub2RlLCBcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5tZXRhbERlZmluZU1hY3JvIFxyXG4gICAgICAgICkgKSB7XHJcbiAgICAgICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyB0aGUgcmVzdCBvZiB0aGlzIG5vZGUgYXMgaXQgaXMgaW52aXNpYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGF1dG9EZWZpbmVIZWxwZXIgPSBfYXV0b0RlZmluZUhlbHBlciB8fCBuZXcgQXV0b0RlZmluZUhlbHBlciggbm9kZSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggISBwcm9jZXNzRGVjbGFyZSggXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudGFsRGVjbGFyZSxcclxuICAgICAgICAgICAgYXV0b0RlZmluZUhlbHBlclxyXG4gICAgICAgICkgKSB7XHJcbiAgICAgICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyB0aGUgcmVzdCBvZiB0aGlzIG5vZGUgYXMgaXQgaXMgaW52aXNpYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJvY2Vzc09uRXJyb3IoIFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnRhbE9uRXJyb3IsXHJcbiAgICAgICAgICAgIGF1dG9EZWZpbmVIZWxwZXJcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHByb2Nlc3NJMThuTGFuZ3VhZ2UoIFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmkxOG5MYW5ndWFnZSxcclxuICAgICAgICAgICAgYXV0b0RlZmluZUhlbHBlclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJvY2Vzc0kxOG5Eb21haW4oXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuaTE4bkRvbWFpbiwgXHJcbiAgICAgICAgICAgIGF1dG9EZWZpbmVIZWxwZXJcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHByb2Nlc3NBdXRvRGVmaW5lKCBcclxuICAgICAgICAgICAgbm9kZSwgXHJcbiAgICAgICAgICAgIGF1dG9EZWZpbmVIZWxwZXJcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFBhcnNlck5vZGVSZW5kZXJlci5wcm9jZXNzRGVmaW5lKCBcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50YWxEZWZpbmUsICBcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIHNjb3BlLFxyXG4gICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoICEgcHJvY2Vzc0NvbmRpdGlvbihcclxuICAgICAgICAgICAgICAgIG5vZGUsIFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy50YWxDb25kaXRpb24gXHJcbiAgICAgICAgKSApIHtcclxuICAgICAgICAgICAgLy8gU3RvcCBwcm9jZXNzaW5nIHRoZSByZXN0IG9mIHRoaXMgbm9kZSBhcyBpdCBpcyBpbnZpc2libGVcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG9taXR0ZWRUYWcgPSBwcm9jZXNzT21pdFRhZyhcclxuICAgICAgICAgICAgICAgIG5vZGUsIFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy50YWxPbWl0VGFnIFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHZhciByZXBsYWNlZCA9IHByb2Nlc3NSZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgbm9kZSwgXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnRhbFJlcGxhY2UgXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCAhIG9taXR0ZWRUYWcgJiYgISByZXBsYWNlZCApIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHByb2Nlc3NBdHRyaWJ1dGVzKFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsIFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMudGFsQXR0cmlidXRlcyBcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmICggISBwcm9jZXNzQ29udGVudChcclxuICAgICAgICAgICAgICAgICAgICBub2RlLCBcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnRhbENvbnRlbnQgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udGVudCggbm9kZSApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcm9jZXNzTUVUQUxVc2VNYWNybyhcclxuICAgICAgICAgICAgICAgIG5vZGUsIFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5tZXRhbFVzZU1hY3JvLCBcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMudGFsRGVmaW5lLFxyXG4gICAgICAgICAgICAgICAgYXV0b0RlZmluZUhlbHBlclxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBkZWZhdWx0Q29udGVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xyXG5cclxuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcztcclxuICAgICAgICBpZiAoICEgY2hpbGROb2RlcyApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKyApIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZE5vZGUgPSBjaGlsZE5vZGVzWyBpIF07XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBub2RlIGlzIEVMRU1FTlRfTk9ERSBhbmQgbm90IHBhcnNlZCB5ZXRcclxuICAgICAgICAgICAgaWYgKCBjdXJyZW50Q2hpbGROb2RlICYmIGN1cnJlbnRDaGlsZE5vZGUubm9kZVR5cGUgPT09IDFcclxuICAgICAgICAgICAgICAgICAgICAmJiAhIGN1cnJlbnRDaGlsZE5vZGUuZ2V0QXR0cmlidXRlKCB0YWdzLnFkdXAgKSApIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MoIGN1cnJlbnRDaGlsZE5vZGUgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBwcm9jZXNzT25FcnJvciA9IGZ1bmN0aW9uKCBub2RlLCBzdHJpbmcsIGF1dG9EZWZpbmVIZWxwZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBzdHJpbmcgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0YWxPbkVycm9yID0gYXR0cmlidXRlQ2FjaGUuZ2V0QnlBdHRyaWJ1dGVDbGFzcyggXHJcbiAgICAgICAgICAgIFRBTE9uRXJyb3IsIFxyXG4gICAgICAgICAgICBzdHJpbmcsIFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICBzY29wZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHRhbE9uRXJyb3IucHV0VG9BdXRvRGVmaW5lSGVscGVyKCBhdXRvRGVmaW5lSGVscGVyICk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcHJvY2Vzc0F1dG9EZWZpbmUgPSBmdW5jdGlvbiggbm9kZSwgYXV0b0RlZmluZUhlbHBlciApIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RyaW5nID0gYXV0b0RlZmluZUhlbHBlci51cGRhdGVOb2RlKCBub2RlICk7XHJcbiAgICAgICAgaWYgKCAhIHN0cmluZyApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGFsRGVmaW5lID0gYXR0cmlidXRlQ2FjaGUuZ2V0QnlBdHRyaWJ1dGVDbGFzcyggXHJcbiAgICAgICAgICAgIFRBTERlZmluZSwgXHJcbiAgICAgICAgICAgIHN0cmluZywgXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIGluZGV4RXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICAgIHNjb3BlXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGFsRGVmaW5lLnByb2Nlc3MoIHNjb3BlLCBmYWxzZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJvY2Vzc0kxOG5Eb21haW4gPSBmdW5jdGlvbiggbm9kZSwgc3RyaW5nLCBhdXRvRGVmaW5lSGVscGVyICkge1xyXG5cclxuICAgICAgICBpZiAoICEgc3RyaW5nICkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaTE4bkRvbWFpbiA9IGF0dHJpYnV0ZUNhY2hlLmdldEJ5QXR0cmlidXRlQ2xhc3MoIFxyXG4gICAgICAgICAgICBJMThORG9tYWluLCBcclxuICAgICAgICAgICAgc3RyaW5nLCBcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgaW5kZXhFeHByZXNzaW9ucyxcclxuICAgICAgICAgICAgc2NvcGVcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBpMThuRG9tYWluLnB1dFRvQXV0b0RlZmluZUhlbHBlciggc2NvcGUsIGF1dG9EZWZpbmVIZWxwZXIgKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBwcm9jZXNzSTE4bkxhbmd1YWdlID0gZnVuY3Rpb24oIG5vZGUsIHN0cmluZywgYXV0b0RlZmluZUhlbHBlciApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIHN0cmluZyApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkxOG5MYW5ndWFnZSA9IGF0dHJpYnV0ZUNhY2hlLmdldEJ5QXR0cmlidXRlQ2xhc3MoIFxyXG4gICAgICAgICAgICBJMThOTGFuZ3VhZ2UsIFxyXG4gICAgICAgICAgICBzdHJpbmcsIFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICBzY29wZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGkxOG5MYW5ndWFnZS5wdXRUb0F1dG9EZWZpbmVIZWxwZXIoIGF1dG9EZWZpbmVIZWxwZXIgKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBwcm9jZXNzRGVjbGFyZSA9IGZ1bmN0aW9uKCBub2RlLCBzdHJpbmcsIGF1dG9EZWZpbmVIZWxwZXIgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBzdHJpbmcgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhbERlY2xhcmUgPSBhdHRyaWJ1dGVDYWNoZS5nZXRCeUF0dHJpYnV0ZUNsYXNzKCBcclxuICAgICAgICAgICAgVEFMRGVjbGFyZSwgXHJcbiAgICAgICAgICAgIHN0cmluZywgXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIGluZGV4RXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICAgIHNjb3BlXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGFsRGVjbGFyZS5wcm9jZXNzKCBzY29wZSwgYXV0b0RlZmluZUhlbHBlciApO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3NNRVRBTERlZmluZU1hY3JvID0gZnVuY3Rpb24oIG5vZGUsIHN0cmluZyApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIHN0cmluZyApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBObyBzZW5zZSB0byBjYWNoZSBtYWNybyBkZWZpbml0aW9ucyFcclxuICAgICAgICB2YXIgbWV0YWxEZWZpbmVNYWNybyA9IE1FVEFMRGVmaW5lTWFjcm8uYnVpbGQoIHN0cmluZyApO1xyXG4gICAgICAgIHJldHVybiBtZXRhbERlZmluZU1hY3JvLnByb2Nlc3MoIHNjb3BlLCBub2RlICk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBwcm9jZXNzTUVUQUxVc2VNYWNybyA9IGZ1bmN0aW9uKCBub2RlLCBzdHJpbmcsIHN0cmluZ0RlZmluZSwgYXV0b0RlZmluZUhlbHBlciApIHtcclxuXHJcbiAgICAgICAgaWYgKCAhIHN0cmluZyApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBObyBzZW5zZSB0byBjYWNoZSBtYWNybyB1c2VzIVxyXG4gICAgICAgIHZhciBtZXRhbFVzZU1hY3JvID0gTUVUQUxVc2VNYWNyby5idWlsZCggc3RyaW5nLCBzdHJpbmdEZWZpbmUsIHNjb3BlICk7XHJcbiAgICAgICAgdmFyIG5ld05vZGUgPSBtZXRhbFVzZU1hY3JvLnByb2Nlc3MoIHNjb3BlLCBub2RlLCBhdXRvRGVmaW5lSGVscGVyLCBpbmRleEV4cHJlc3Npb25zICk7XHJcbiAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoIHRhZ3MucWR1cCwgMSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEluZGV4IG5vZGVcclxuICAgICAgICBpZiAoIGluZGV4RXhwcmVzc2lvbnMgKXtcclxuICAgICAgICAgICAgYXR0cmlidXRlSW5kZXguYWRkKCBub2RlLCBtZXRhbFVzZU1hY3JvLCBzY29wZSApO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIFByb2Nlc3MgbmV3IG5vZGVcclxuICAgICAgICByZXR1cm4gcHJvY2VzcyggbmV3Tm9kZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJvY2Vzc0NvbmRpdGlvbiA9IGZ1bmN0aW9uKCBub2RlLCBzdHJpbmcgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBzdHJpbmcgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhbENvbmRpdGlvbiA9IGF0dHJpYnV0ZUNhY2hlLmdldEJ5QXR0cmlidXRlQ2xhc3MoIFxyXG4gICAgICAgICAgICBUQUxDb25kaXRpb24sIFxyXG4gICAgICAgICAgICBzdHJpbmcsIFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICBzY29wZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHRhbENvbmRpdGlvbi5wcm9jZXNzKCBzY29wZSwgbm9kZSApO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3NSZXBsYWNlID0gZnVuY3Rpb24oIG5vZGUsIHN0cmluZyApIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoICEgc3RyaW5nICl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRhbFJlcGxhY2UgPSBhdHRyaWJ1dGVDYWNoZS5nZXRCeUF0dHJpYnV0ZUNsYXNzKCBcclxuICAgICAgICAgICAgVEFMUmVwbGFjZSwgXHJcbiAgICAgICAgICAgIHN0cmluZywgXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIGluZGV4RXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICAgIHNjb3BlXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGFsUmVwbGFjZS5wcm9jZXNzKCBzY29wZSwgbm9kZSApO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJvY2Vzc09taXRUYWcgPSBmdW5jdGlvbiggbm9kZSwgc3RyaW5nICkge1xyXG5cclxuICAgICAgICBpZiAoIHN0cmluZyA9PSBudWxsICkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdGFsT21pdFRhZyA9IGF0dHJpYnV0ZUNhY2hlLmdldEJ5QXR0cmlidXRlQ2xhc3MoIFxyXG4gICAgICAgICAgICBUQUxPbWl0VGFnLCBcclxuICAgICAgICAgICAgc3RyaW5nLCBcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgaW5kZXhFeHByZXNzaW9ucyxcclxuICAgICAgICAgICAgc2NvcGVcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB0YWxPbWl0VGFnLnByb2Nlc3MoIHNjb3BlLCBub2RlLCBzZWxmICk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcHJvY2Vzc0NvbnRlbnQgPSBmdW5jdGlvbiggbm9kZSwgc3RyaW5nICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggISBzdHJpbmcgKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhbENvbnRlbnQgPSBhdHRyaWJ1dGVDYWNoZS5nZXRCeUF0dHJpYnV0ZUNsYXNzKCBcclxuICAgICAgICAgICAgVEFMQ29udGVudCwgXHJcbiAgICAgICAgICAgIHN0cmluZywgXHJcbiAgICAgICAgICAgIG5vZGUsXHJcbiAgICAgICAgICAgIGluZGV4RXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICAgIHNjb3BlXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gdGFsQ29udGVudC5wcm9jZXNzKCBzY29wZSwgbm9kZSApO1xyXG4gICAgfTtcclxuICBcclxuICAgIHZhciBwcm9jZXNzQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBub2RlLCBzdHJpbmcgKSB7XHJcblxyXG4gICAgICAgIGlmICggISBzdHJpbmcgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB0YWxBdHRyaWJ1dGVzID0gYXR0cmlidXRlQ2FjaGUuZ2V0QnlBdHRyaWJ1dGVDbGFzcyggXHJcbiAgICAgICAgICAgIFRBTEF0dHJpYnV0ZXMsIFxyXG4gICAgICAgICAgICBzdHJpbmcsIFxyXG4gICAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICBzY29wZSBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB0YWxBdHRyaWJ1dGVzLnByb2Nlc3MoIHNjb3BlLCBub2RlICk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHtcclxuICAgICAgICBydW46IHJ1bixcclxuICAgICAgICBkZWZhdWx0Q29udGVudDogZGVmYXVsdENvbnRlbnRcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBzZWxmO1xyXG59O1xyXG5cclxuUGFyc2VyTm9kZVJlbmRlcmVyLnByb2Nlc3NEZWZpbmUgPSBmdW5jdGlvbiggbm9kZSwgc3RyaW5nLCBmb3JjZUdsb2JhbCwgc2NvcGUsIGluZGV4RXhwcmVzc2lvbnMgKSB7XHJcblxyXG4gICAgaWYgKCAhIHN0cmluZyApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRhbERlZmluZSA9IGF0dHJpYnV0ZUNhY2hlLmdldEJ5QXR0cmlidXRlQ2xhc3MoIFxyXG4gICAgICAgIFRBTERlZmluZSwgXHJcbiAgICAgICAgc3RyaW5nLCBcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIGluZGV4RXhwcmVzc2lvbnMsXHJcbiAgICAgICAgc2NvcGVcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGFsRGVmaW5lLnByb2Nlc3MoIHNjb3BlLCBmb3JjZUdsb2JhbCApO1xyXG59O1xyXG5cclxuUGFyc2VyTm9kZVJlbmRlcmVyLmNsb25lQW5kQ29uZmlndXJlTm9kZSA9IGZ1bmN0aW9uKCBub2RlLCBpbmRleEV4cHJlc3Npb25zLCB0YWdzLCBub2RlRGF0YUlkICkge1xyXG4gICAgXHJcbiAgICAvLyBDbG9uZSBub2RlXHJcbiAgICB2YXIgdG1wTm9kZSA9IG5vZGUuY2xvbmVOb2RlKCB0cnVlICk7XHJcbiAgICBpZiAoICdmb3JtJyBpbiB0bXBOb2RlICkge1xyXG4gICAgICAgIHRtcE5vZGUuY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBpZCBhbmQgcmVsYXRlZCBpZCBpZiBuZWVkZWRcclxuICAgIGlmICggaW5kZXhFeHByZXNzaW9ucyApe1xyXG4gICAgICAgIHRtcE5vZGUuc2V0QXR0cmlidXRlKCB0YWdzLmlkLCBjb250ZXh0Lm5leHRFeHByZXNzaW9uQ291bnRlcigpICk7XHJcbiAgICAgICAgdG1wTm9kZS5zZXRBdHRyaWJ1dGUoIHRhZ3MucmVsYXRlZElkLCBub2RlRGF0YUlkICk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0bXBOb2RlO1xyXG59O1xyXG5cclxuUGFyc2VyTm9kZVJlbmRlcmVyLmNvbmZpZ3VyZU5vZGVGb3JOZXdJdGVtID0gZnVuY3Rpb24oIHRtcE5vZGUsIHRhZ3MsIHBhcmVudE5vZGUsIGluZGV4SXRlbSwgaW5kZXhUb1VzZSApIHtcclxuICAgIFxyXG4gICAgLy8gUmVtb3ZlIGF0dHJpYnV0ZXNcclxuICAgIHRtcE5vZGUucmVtb3ZlQXR0cmlidXRlKCB0YWdzLnRhbFJlcGVhdCApO1xyXG4gICAgdG1wTm9kZS5yZW1vdmVBdHRyaWJ1dGUoICdzdHlsZScgKTtcclxuICAgIHRtcE5vZGUuc2V0QXR0cmlidXRlKCB0YWdzLnFkdXAsIDEgKTtcclxuICAgIFxyXG4gICAgLy8gQ29uZmlndXJlIGxvb3AgYXR0cmlidXRlc1xyXG4gICAgTG9vcC5zZXRBdXRvRGVmaW5lQXR0cmlidXRlKCBcclxuICAgICAgICB0bXBOb2RlLCBcclxuICAgICAgICBpbmRleEl0ZW0uYXR0cmlidXRlSW5zdGFuY2UuZ2V0VmFyTmFtZSgpLCBcclxuICAgICAgICBpbmRleFRvVXNlLFxyXG4gICAgICAgIGluZGV4SXRlbS5hdHRyaWJ1dGVJbnN0YW5jZS5nZXRFeHByZXNzaW9uU3RyaW5nKCksIFxyXG4gICAgICAgIHBhcmVudE5vZGUuY2hpbGRFbGVtZW50Q291bnQsIFxyXG4gICAgICAgIDBcclxuICAgICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlck5vZGVSZW5kZXJlcjtcclxuIiwiLyogXHJcbiAgICBDbGFzcyBQYXJzZXJQcmVsb2FkZXJcclxuKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi9jb250ZXh0LmpzJyApO1xyXG52YXIgbG9nID0gcmVxdWlyZSggJy4uL2xvZ0hlbHBlci5qcycgKTtcclxudmFyIG5vZGVSZW1vdmVyID0gcmVxdWlyZSggJy4vbm9kZVJlbW92ZXIuanMnICk7XHJcbnZhciBTY29wZSA9IHJlcXVpcmUoICcuLi9zY29wZXMvc2NvcGUuanMnICk7XHJcbnZhciBpMThuSGVscGVyID0gcmVxdWlyZSggJy4uL2kxOG4vaTE4bkhlbHBlci5qcycgKTtcclxudmFyIHJlc29sdmVyID0gcmVxdWlyZSggJy4uL3Jlc29sdmVyLmpzJyApO1xyXG52YXIgYXR0cmlidXRlSW5kZXggPSByZXF1aXJlKCAnLi4vYXR0cmlidXRlcy9hdHRyaWJ1dGVJbmRleC5qcycgKTtcclxuXHJcbnZhciBQYXJzZXJQcmVsb2FkZXIgPSBmdW5jdGlvbiggX3BhcnNlck9wdGlvbnMsIF9jYWxsYmFjaywgX2ZhaWxDYWxsYmFjaywgX2RlY2xhcmVkUmVtb3RlUGFnZVVybHMsIF9pMThuLCBfbm90UmVtb3ZlR2VuZXJhdGVkVGFncywgX21heEZvbGRlckRpY3Rpb25hcmllcyApIHtcclxuICAgIFxyXG4gICAgdmFyIHBhcnNlck9wdGlvbnMgPSBfcGFyc2VyT3B0aW9ucztcclxuICAgIHZhciBjYWxsYmFjayA9IF9jYWxsYmFjaztcclxuICAgIHZhciBmYWlsQ2FsbGJhY2sgPSBfZmFpbENhbGxiYWNrO1xyXG4gICAgdmFyIGRlY2xhcmVkUmVtb3RlUGFnZVVybHMgPSBfZGVjbGFyZWRSZW1vdGVQYWdlVXJscztcclxuICAgIHZhciBpMThuID0gX2kxOG47XHJcbiAgICB2YXIgbm90UmVtb3ZlR2VuZXJhdGVkVGFncyA9IF9ub3RSZW1vdmVHZW5lcmF0ZWRUYWdzO1xyXG4gICAgdmFyIG1heEZvbGRlckRpY3Rpb25hcmllcyA9IF9tYXhGb2xkZXJEaWN0aW9uYXJpZXM7XHJcbiAgICBcclxuICAgIHZhciBydW4gPSBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoICEgbm90UmVtb3ZlR2VuZXJhdGVkVGFncyApe1xyXG4gICAgICAgICAgICAgICAgbm9kZVJlbW92ZXIucmVtb3ZlR2VuZXJhdGVkTm9kZXMoIHBhcnNlck9wdGlvbnMucm9vdCApO1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluZGV4LnJlbW92ZU11bHRpcGxlTm9kZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlbW92ZXIucmVtb3ZlR2VuZXJhdGVkTm9kZXMoIHBhcnNlck9wdGlvbnMucm9vdCApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNjb3BlID0gbmV3IFNjb3BlKCBcclxuICAgICAgICAgICAgICAgIHBhcnNlck9wdGlvbnMuZGljdGlvbmFyeSwgXHJcbiAgICAgICAgICAgICAgICBwYXJzZXJPcHRpb25zLmRpY3Rpb25hcnlFeHRlbnNpb24sIFxyXG4gICAgICAgICAgICAgICAgdHJ1ZSBcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLmxvYWRGb2xkZXJEaWN0aW9uYXJpZXNBc3luYyggXHJcbiAgICAgICAgICAgICAgICBtYXhGb2xkZXJEaWN0aW9uYXJpZXMsIFxyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEZvbGRlckRpY3Rpb25hcmllcyggc2NvcGUuZm9sZGVyRGljdGlvbmFyaWVzICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGkxOG5IZWxwZXIubG9hZEFzeW5jQXV0byggXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlck9wdGlvbnMuZGljdGlvbmFyeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLmxvYWRSZW1vdGVQYWdlcyggXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWRSZW1vdGVQYWdlVXJscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsQ2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxDYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICB9IGNhdGNoKCBlICl7XHJcbiAgICAgICAgICAgIGxvZy5mYXRhbCggJ0V4aXRpbmcgaW5pdCBtZXRob2Qgb2YgWlBUIHdpdGggZXJyb3JzOiAnICsgZSApO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHtcclxuICAgICAgICBydW46IHJ1blxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclByZWxvYWRlcjtcclxuIiwiLyogXHJcbiAgICBDbGFzcyBQYXJzZXJSZW5kZXJlclxyXG4qL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4uL2NvbnRleHQuanMnICk7XHJcbnZhciBsb2cgPSByZXF1aXJlKCAnLi4vbG9nSGVscGVyLmpzJyApO1xyXG52YXIgYXR0cmlidXRlQ2FjaGUgPSByZXF1aXJlKCAnLi4vY2FjaGUvYXR0cmlidXRlQ2FjaGUuanMnICk7XHJcbnZhciBhdHRyaWJ1dGVJbmRleCA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVzL2F0dHJpYnV0ZUluZGV4LmpzJyApO1xyXG52YXIgbm9kZVJlbW92ZXIgPSByZXF1aXJlKCAnLi9ub2RlUmVtb3Zlci5qcycgKTtcclxudmFyIHNjb3BlQnVpbGRlciA9IHJlcXVpcmUoICcuLi9zY29wZXMvc2NvcGVCdWlsZGVyLmpzJyApO1xyXG52YXIgUGFyc2VyTm9kZVJlbmRlcmVyID0gcmVxdWlyZSggJy4vcGFyc2VyTm9kZVJlbmRlcmVyLmpzJyApO1xyXG5cclxudmFyIFBhcnNlclJlbmRlcmVyID0gZnVuY3Rpb24oIF9wYXJzZXJPcHRpb25zLCBfdGFyZ2V0LCBfZGljdGlvbmFyeUV4dGVuc2lvbiwgX25vdFJlbW92ZUdlbmVyYXRlZFRhZ3MsIF9yZXNldEluZGV4LCBfZ29Ub1VSTEhhc2ggKSB7XHJcbiAgICBcclxuICAgIHZhciBwYXJzZXJPcHRpb25zID0gX3BhcnNlck9wdGlvbnM7XHJcbiAgICB2YXIgdGFyZ2V0ID0gX3RhcmdldDtcclxuICAgIHZhciBkaWN0aW9uYXJ5RXh0ZW5zaW9uID0gX2RpY3Rpb25hcnlFeHRlbnNpb247XHJcbiAgICB2YXIgbm90UmVtb3ZlR2VuZXJhdGVkVGFncyA9IF9ub3RSZW1vdmVHZW5lcmF0ZWRUYWdzO1xyXG4gICAgdmFyIHJlc2V0SW5kZXggPSBfcmVzZXRJbmRleDtcclxuICAgIHZhciBnb1RvVVJMSGFzaCA9IF9nb1RvVVJMSGFzaDtcclxuICAgIFxyXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcHJvY2VzcygpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoICEgdGFyZ2V0ICl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnVW5hYmxlIHRvIHByb2Nlc3MgbnVsbCByb290IG9yIHRhcmdldCEnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgbm90UmVtb3ZlR2VuZXJhdGVkVGFncyApe1xyXG4gICAgICAgICAgICAgICAgbm9kZVJlbW92ZXIucmVtb3ZlR2VuZXJhdGVkTm9kZXMoIHRhcmdldCApO1xyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUluZGV4LnJlbW92ZU11bHRpcGxlTm9kZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlbW92ZXIucmVtb3ZlR2VuZXJhdGVkTm9kZXMoIHRhcmdldCApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCByZXNldEluZGV4ICl7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbmRleC5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlQ2FjaGUucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJvY2Vzc0FsbFRhcmdldEVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIGdvVG9VUkxIYXNoICl7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzR29Ub1VSTEhhc2goKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGNhdGNoKCBlICl7XHJcbiAgICAgICAgICAgIGxvZy5mYXRhbCggJ0V4aXRpbmcgcnVuIG1ldGhvZCBvZiBaUFQgd2l0aCBlcnJvcnM6ICcgKyBlICk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JGdW5jdGlvbiggZSApO1xyXG4gICAgICAgICAgICAvL3Rocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJvY2Vzc0FsbFRhcmdldEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8vIElzIG11bHRpcm9vdD9cclxuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHRhcmdldCApICl7IFxyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgc2V2ZXJhbCByb290c1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCB0YXJnZXQubGVuZ3RoOyBjKysgKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzMVRhcmdldCggdGFyZ2V0WyBjIF0gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIHJvb3RcclxuICAgICAgICAgICAgcHJvY2VzczFUYXJnZXQoIHRhcmdldCApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHByb2Nlc3MxVGFyZ2V0ID0gZnVuY3Rpb24oIGN1cnJlbnRUYXJnZXQgKSB7XHJcblxyXG4gICAgICAgIHZhciBwYXJzZXJOb2RlUmVuZGVyZXIgPSBuZXcgUGFyc2VyTm9kZVJlbmRlcmVyKCBcclxuICAgICAgICAgICAgY3VycmVudFRhcmdldCwgXHJcbiAgICAgICAgICAgIHNjb3BlQnVpbGRlci5idWlsZCggXHJcbiAgICAgICAgICAgICAgICBwYXJzZXJPcHRpb25zLCBcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQsIFxyXG4gICAgICAgICAgICAgICAgZGljdGlvbmFyeUV4dGVuc2lvbixcclxuICAgICAgICAgICAgICAgIHBhcnNlck9wdGlvbnMuY29tbWFuZCA9PT0gJ3BhcnRpYWxSZW5kZXInXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIHBhcnNlck9wdGlvbnMuaW5kZXhFeHByZXNzaW9uc1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHBhcnNlck5vZGVSZW5kZXJlci5ydW4oKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBwcm9jZXNzR29Ub1VSTEhhc2ggPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpZCA9IGRlY29kZVVSSSggd2luZG93LmxvY2F0aW9uLmhhc2ggKS5zdWJzdHIoIDEgKTtcclxuICAgICAgICBpZiAoICEgaWQgKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaWQgKTtcclxuICAgICAgICBpZiAoICEgZWxlbWVudCApe1xyXG4gICAgICAgICAgICBsb2cud2FybiggJ1VuYWJsZSB0byBnbyB0byBVUkwgaGFzaC4gRWxlbWVudCB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCEnICk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdvIHRvIGhhc2hcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcjJyArIGlkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHNlbGYgPSB7XHJcbiAgICAgICAgcnVuOiBydW5cclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBzZWxmO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJSZW5kZXJlcjtcclxuIiwiLyogXHJcbiAgICBDbGFzcyBQYXJzZXJVcGRhdGVyXHJcbiovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcclxudmFyIGxvZyA9IHJlcXVpcmUoICcuLi9sb2dIZWxwZXIuanMnICk7XHJcbnZhciBhdHRyaWJ1dGVJbmRleCA9IHJlcXVpcmUoICcuLi9hdHRyaWJ1dGVzL2F0dHJpYnV0ZUluZGV4LmpzJyApO1xyXG52YXIgc2NvcGVCdWlsZGVyID0gcmVxdWlyZSggJy4uL3Njb3Blcy9zY29wZUJ1aWxkZXIuanMnICk7XHJcbnZhciBQYXJzZXJOb2RlUmVuZGVyZXIgPSByZXF1aXJlKCAnLi9wYXJzZXJOb2RlUmVuZGVyZXIuanMnICk7XHJcbnZhciBub2RlUmVtb3ZlciA9IHJlcXVpcmUoICcuL25vZGVSZW1vdmVyLmpzJyApO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCAnLi4vdXRpbHMuanMnICk7XHJcbnZhciBkaWN0aW9uYXJ5QWN0aW9uQnVpbGRlciA9IHJlcXVpcmUoICcuL2RpY3Rpb25hcnlBY3Rpb25zL2RpY3Rpb25hcnlBY3Rpb25CdWlsZGVyLmpzJyApO1xyXG52YXIgQWJzdHJhY3RBcnJheUFjdGlvbiA9IHJlcXVpcmUoICcuL2RpY3Rpb25hcnlBY3Rpb25zL2Fic3RyYWN0QXJyYXlBY3Rpb24uanMnICk7XHJcblxyXG52YXIgUGFyc2VyVXBkYXRlciA9IGZ1bmN0aW9uKCBfZGljdGlvbmFyeUNoYW5nZXMsIF9kaWN0aW9uYXJ5QWN0aW9ucywgX3BhcnNlck9wdGlvbnMgKSB7XHJcbiAgICBcclxuICAgIHZhciBkaWN0aW9uYXJ5Q2hhbmdlcyA9IF9kaWN0aW9uYXJ5Q2hhbmdlcztcclxuICAgIHZhciBkaWN0aW9uYXJ5QWN0aW9ucyA9IF9kaWN0aW9uYXJ5QWN0aW9ucztcclxuICAgIHZhciBwYXJzZXJPcHRpb25zID0gX3BhcnNlck9wdGlvbnM7XHJcbiAgICBcclxuICAgIHZhciBzY29wZU1hcCA9IHt9O1xyXG4gICAgdmFyIG5vZGVBdHRyaWJ1dGVzLCBcclxuICAgICAgICBzdGF0aXN0aWNzO1xyXG4gICAgdmFyIGRpY3Rpb25hcnlBY3Rpb25zSW5zdGFuY2VzO1xyXG4gICAgXHJcbiAgICB2YXIgaW5pdGlhbGl6ZURpY3Rpb25hcnlBY3Rpb25zSW5zdGFuY2VzID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICBkaWN0aW9uYXJ5QWN0aW9uc0luc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggISBkaWN0aW9uYXJ5QWN0aW9ucyApe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGRpY3Rpb25hcnlBY3Rpb25zLmxlbmd0aDsgKytpICl7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBkaWN0aW9uYXJ5QWN0aW9uc1sgaSBdO1xyXG4gICAgICAgICAgICB2YXIgbmV3QWN0aW9uSW5zdGFuY2UgPSBkaWN0aW9uYXJ5QWN0aW9uQnVpbGRlci5idWlsZCggYWN0aW9uLCBwYXJzZXJPcHRpb25zLmRpY3Rpb25hcnkgKTtcclxuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBuZXdBY3Rpb25JbnN0YW5jZSApICl7XHJcbiAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5QWN0aW9uc0luc3RhbmNlcyA9IGRpY3Rpb25hcnlBY3Rpb25zSW5zdGFuY2VzLmNvbmNhdCggbmV3QWN0aW9uSW5zdGFuY2UgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpY3Rpb25hcnlBY3Rpb25zSW5zdGFuY2VzLnB1c2goIG5ld0FjdGlvbkluc3RhbmNlICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW5pdGlhbGl6ZURpY3Rpb25hcnlBY3Rpb25zSW5zdGFuY2VzKCk7XHJcbiAgICBcclxuICAgIHZhciBnZXRTdGF0aXN0aWNzID0gZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gc3RhdGlzdGljcztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHVwZGF0ZURpY3Rpb25hcnlGb3JEaWN0aW9uYXJ5Q2hhbmdlcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCBkaWN0aW9uYXJ5Q2hhbmdlcyApe1xyXG4gICAgICAgICAgICB1dGlscy5leHRlbmQoIHBhcnNlck9wdGlvbnMuZGljdGlvbmFyeSwgZGljdGlvbmFyeUNoYW5nZXMgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgYWRkVXBkYXRlZFRvU3RhdGlzdGljcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgKytzdGF0aXN0aWNzLnRvdGFsVXBkYXRlcztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBhZGRSZW1vdmVkVG9TdGF0aXN0aWNzID0gZnVuY3Rpb24oKXtcclxuICAgICAgICArK3N0YXRpc3RpY3MucmVtb3ZlZE5vZGVVcGRhdGVzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGluZGV4IHdhcyBidWlsdFxyXG4gICAgICAgICAgICBpZiAoICEgcGFyc2VyT3B0aW9ucy5pbmRleEV4cHJlc3Npb25zICl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnVW5hYmxlIHRvIHVwZGF0ZSwgbm8gaW5kZXggYnVpbHQhIFNldCBpbmRleEV4cHJlc3Npb25zIHRvIHRydWUhJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSW5pdCBzb21lIHZhcnNcclxuICAgICAgICAgICAgbm9kZUF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICAgICAgc3RhdGlzdGljcyA9IHtcclxuICAgICAgICAgICAgICAgIHRvdGFsVXBkYXRlczogMCxcclxuICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlVXBkYXRlczogMFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gYWxsIHJlcXVpcmVkIEhUTUwgdXBkYXRlc1xyXG4gICAgICAgICAgICB1cGRhdGVIVE1MKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gY2F0Y2goIGUgKXtcclxuICAgICAgICAgICAgbG9nLmZhdGFsKCAnRXhpdGluZyBydW4gbWV0aG9kIG9mIHVwZGF0ZSBjb21tYW5kIG9mIFpQVCB3aXRoIGVycm9yczogJyArIGUgKTtcclxuICAgICAgICAgICAgY29udGV4dC5lcnJvckZ1bmN0aW9uKCBlICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdXBkYXRlSFRNTCA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIGlmICggdXBkYXRlSFRNTEZyb21BY3Rpb25zKCAwICkgKXtcclxuICAgICAgICAgICAgdXBkYXRlSFRNTEZyb21WYXJDaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgdXBkYXRlSFRNTEZyb21BY3Rpb25zID0gZnVuY3Rpb24oIGluaXRpYWwgKXtcclxuXHJcbiAgICAgICAgZm9yICggdmFyIGkgPSBpbml0aWFsOyBpIDwgZGljdGlvbmFyeUFjdGlvbnNJbnN0YW5jZXMubGVuZ3RoOyArK2kgKXtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbkluc3RhbmNlID0gZGljdGlvbmFyeUFjdGlvbnNJbnN0YW5jZXNbIGkgXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkaWN0aW9uYXJ5IHVzaW5nIGFjdGlvblxyXG4gICAgICAgICAgICBhY3Rpb25JbnN0YW5jZS51cGRhdGVEaWN0aW9uYXJ5KCBwYXJzZXJPcHRpb25zLmRpY3Rpb25hcnkgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdCBvZiBjaGFuZ2VzIHJlbGF0ZWQgdG8gdmFyTmFtZVxyXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGF0dHJpYnV0ZUluZGV4LmdldFZhcnNMaXN0KCBhY3Rpb25JbnN0YW5jZS5pZCApO1xyXG4gICAgICAgICAgICBpZiAoICEgbGlzdCApe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgbGlzdCBhbmQgdXBkYXRlIEhUTUwgaWYgcmVxdWlyZWRcclxuICAgICAgICAgICAgaWYgKCAhIHVwZGF0ZUhUTUxGcm9tVmFyc0xpc3QoIGFjdGlvbkluc3RhbmNlLCBpLCAwLCBsaXN0ICkgKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBsaXN0Lmxlbmd0aDsgaisrICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4SXRlbSA9IGxpc3RbIGogXTtcclxuICAgICAgICAgICAgICAgIGlmICggISBhY3Rpb25JbnN0YW5jZS5hdHRyaWJ1dGVJbnN0YW5jZUlzUmVsYXRlZCggaW5kZXhJdGVtLmF0dHJpYnV0ZUluc3RhbmNlICkgKXtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICEgdXRpbHMuaXNGdW5jdGlvbiggaW5kZXhJdGVtLmF0dHJpYnV0ZUluc3RhbmNlLnVwZGF0YWJsZUZyb21BY3Rpb24gKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGluZGV4SXRlbS5hdHRyaWJ1dGVJbnN0YW5jZS51cGRhdGFibGVGcm9tQWN0aW9uKCBzZWxmLCBmaW5kTm9kZUJ5SWQoIGluZGV4SXRlbS5ub2RlSWQgKSApICl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkRGF0YUZyb21WYXJDaGFuZ2VFeGNsdWRpbmcoIGFjdGlvbkluc3RhbmNlLmlkICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoICEgYWN0aW9uSW5zdGFuY2UudXBkYXRlSFRNTCggXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhJdGVtLCBcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLCBcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JbnN0YW5jZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5zdGFuY2U6IGFjdGlvbkluc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpOiBpLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDogbGlzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEo6IGogXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKSApe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciB1cGRhdGVIVE1MRnJvbVZhcnNMaXN0ID0gZnVuY3Rpb24oIGFjdGlvbkluc3RhbmNlLCBpLCBpbml0aWFsSiwgbGlzdCApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEl0ZXJhdGUgbGlzdCBhbmQgdXBkYXRlIEhUTUwgaWYgcmVxdWlyZWRcclxuICAgICAgICBmb3IgKCB2YXIgaiA9IGluaXRpYWxKOyBqIDwgbGlzdC5sZW5ndGg7IGorKyApIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4SXRlbSA9IGxpc3RbIGogXTtcclxuICAgICAgICAgICAgaWYgKCAhIGFjdGlvbkluc3RhbmNlLmF0dHJpYnV0ZUluc3RhbmNlSXNSZWxhdGVkKCBpbmRleEl0ZW0uYXR0cmlidXRlSW5zdGFuY2UgKSApe1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhIHV0aWxzLmlzRnVuY3Rpb24oIGluZGV4SXRlbS5hdHRyaWJ1dGVJbnN0YW5jZS51cGRhdGFibGVGcm9tQWN0aW9uICkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGluZGV4SXRlbS5hdHRyaWJ1dGVJbnN0YW5jZS51cGRhdGFibGVGcm9tQWN0aW9uKCBzZWxmLCBmaW5kTm9kZUJ5SWQoIGluZGV4SXRlbS5ub2RlSWQgKSApICl7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGREYXRhRnJvbVZhckNoYW5nZUV4Y2x1ZGluZyggYWN0aW9uSW5zdGFuY2UuaWQgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoICEgYWN0aW9uSW5zdGFuY2UudXBkYXRlSFRNTCggXHJcbiAgICAgICAgICAgICAgICBpbmRleEl0ZW0sIFxyXG4gICAgICAgICAgICAgICAgc2VsZiwgXHJcbiAgICAgICAgICAgICAgICBhY3Rpb25JbnN0YW5jZSwgXHJcbiAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluc3RhbmNlOiBhY3Rpb25JbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBpOiBpLCBcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsSjogaixcclxuICAgICAgICAgICAgICAgICAgICBsaXN0OiBsaXN0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICkgKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBjb250aW51ZVVwZGF0ZUhUTUwgPSBmdW5jdGlvbiggY29udGludWVEYXRhICl7XHJcblxyXG4gICAgICAgIHVwZGF0ZUhUTUxGcm9tVmFyc0xpc3QoXHJcbiAgICAgICAgICAgIGNvbnRpbnVlRGF0YS5hY3Rpb25JbnN0YW5jZSwgXHJcbiAgICAgICAgICAgIGNvbnRpbnVlRGF0YS5pLCBcclxuICAgICAgICAgICAgY29udGludWVEYXRhLmluaXRpYWxKICsgMSwgXHJcbiAgICAgICAgICAgIGNvbnRpbnVlRGF0YS5saXN0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIHVwZGF0ZUhUTUxGcm9tQWN0aW9ucyggY29udGludWVEYXRhLmkgKyAxICkgKXtcclxuICAgICAgICAgICAgdXBkYXRlSFRNTEZyb21WYXJDaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgcnVuQW5pbWF0aW9uID0gZnVuY3Rpb24oIGFjdGlvbkluc3RhbmNlLCBub2RlLCBjYWxsYmFjayApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEJ1aWxkIGNvbWJpbmVkQ2FsbGJhY2sgY29tYmluaW5nIGNhbGxiYWNrIGFuZCBhY3Rpb25JbnN0YW5jZS5hbmltYXRpb25DYWxsYmFja1xyXG4gICAgICAgIHZhciBjb21iaW5lZENhbGxiYWNrID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIGlmICggY2FsbGJhY2sgKXtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldEFuaW1hdGlvbk1hbmFnZXIoKS5yZXNldCggbm9kZSApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCBhY3Rpb25JbnN0YW5jZS5hbmltYXRpb25DYWxsYmFjayApe1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluc3RhbmNlLmFuaW1hdGlvbkNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IGFuaW1hdGlvbiBtYW5hZ2VyIHRvIHJ1biBhbmltYXRpb25cclxuICAgICAgICBjb250ZXh0LmdldEFuaW1hdGlvbk1hbmFnZXIoKS5hbmltYXRlKCBhY3Rpb25JbnN0YW5jZSwgbm9kZSwgY29tYmluZWRDYWxsYmFjayApO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICB2YXIgcnVuQW5pbWF0aW9uID0gZnVuY3Rpb24oIGFjdGlvbkluc3RhbmNlLCBub2RlLCBjYWxsYmFjayApe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEJ1aWxkIGNvbWJpbmVkQ2FsbGJhY2sgY29tYmluaW5nIGNhbGxiYWNrIGFuZCBhY3Rpb25JbnN0YW5jZS5hbmltYXRpb25DYWxsYmFja1xyXG4gICAgICAgIHZhciBjb21iaW5lZENhbGxiYWNrID0gISBjYWxsYmFjayAmJiAhIGFjdGlvbkluc3RhbmNlLmFuaW1hdGlvbkNhbGxiYWNrPyBcclxuICAgICAgICAgICAgdW5kZWZpbmVkOlxyXG4gICAgICAgICAgICBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgaWYgKCBjYWxsYmFjayApe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIGFjdGlvbkluc3RhbmNlLmFuaW1hdGlvbkNhbGxiYWNrICl7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSW5zdGFuY2UuYW5pbWF0aW9uQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZXQgYW5pbWF0aW9uIG1hbmFnZXIgdG8gcnVuIGFuaW1hdGlvblxyXG4gICAgICAgIGNvbnRleHQuZ2V0QW5pbWF0aW9uTWFuYWdlcigpLmFuaW1hdGUoIGFjdGlvbkluc3RhbmNlLCBub2RlLCBjb21iaW5lZENhbGxiYWNrICk7XHJcbiAgICB9O1xyXG4gICAgKi9cclxuICAgIFxyXG4gICAgdmFyIHVwZGF0ZUhUTUxGcm9tVmFyQ2hhbmdlID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgZGljdGlvbmFyeVxyXG4gICAgICAgIHVwZGF0ZURpY3Rpb25hcnlGb3JEaWN0aW9uYXJ5Q2hhbmdlcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEJ1aWxkIGRhdGFcclxuICAgICAgICBmb3IgKCB2YXIgdmFyTmFtZSBpbiBkaWN0aW9uYXJ5Q2hhbmdlcyApe1xyXG4gICAgICAgICAgICBidWlsZERhdGFGcm9tVmFyQ2hhbmdlKCB2YXJOYW1lICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgZm9yICggdmFyIGkgaW4gbm9kZUF0dHJpYnV0ZXMgKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZUF0dHJpYnV0ZUxpc3QgPSBub2RlQXR0cmlidXRlc1sgaSBdO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaiBpbiBjdXJyZW50Tm9kZUF0dHJpYnV0ZUxpc3QgKXtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZSggY3VycmVudE5vZGVBdHRyaWJ1dGVMaXN0WyBqIF0gKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBidWlsZERhdGFGcm9tVmFyQ2hhbmdlID0gZnVuY3Rpb24oIHZhck5hbWUgKXtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgY2hhbmdlcyByZWxhdGVkIHRvIHZhck5hbWVcclxuICAgICAgICB2YXIgbGlzdCA9IGF0dHJpYnV0ZUluZGV4LmdldFZhcnNMaXN0KCB2YXJOYW1lICk7XHJcbiAgICAgICAgYnVpbGREYXRhRnJvbUxpc3QoIHZhck5hbWUsIGxpc3QgKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBidWlsZERhdGFGcm9tVmFyQ2hhbmdlRXhjbHVkaW5nID0gZnVuY3Rpb24oIHZhck5hbWUgKXtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgY2hhbmdlcyByZWxhdGVkIHRvIHZhck5hbWVcclxuICAgICAgICB2YXIgbGlzdCA9IGF0dHJpYnV0ZUluZGV4LmdldFZhcnNMaXN0KCB2YXJOYW1lICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZpbHRlcmVkID0gbGlzdC5maWx0ZXIoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBpbmRleEl0ZW0sIGluZGV4LCBhcnIgKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIEFic3RyYWN0QXJyYXlBY3Rpb24uc3RhdGljQXR0cmlidXRlSW5zdGFuY2VJc1JlbGF0ZWQoXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhJdGVtLmF0dHJpYnV0ZUluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBidWlsZERhdGFGcm9tTGlzdCggdmFyTmFtZSwgZmlsdGVyZWQgKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBidWlsZERhdGFGcm9tTGlzdCA9IGZ1bmN0aW9uKCB2YXJOYW1lLCBsaXN0ICl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCAhIGxpc3QgKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBCdWlsZCBkYXRhIGFib3V0IGFsbCBjaGFuZ2VzXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG4gICAgICAgICAgICBhZGROZXdOb2RlQXR0cmlidXRlKCB2YXJOYW1lLCBsaXN0WyBpIF0gKTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgaWYgKCAhIGFkZE5ld05vZGVBdHRyaWJ1dGUoIHZhck5hbWUsIGxpc3RbIGkgXSApICl7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbmRleC5yZW1vdmVWYXIoIHZhck5hbWUsIGxpc3RbIGkgXS5ub2RlSWQgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBmaW5kTm9kZUJ5SWQgPSBmdW5jdGlvbiAoIG5vZGVJZCApIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIFxyXG4gICAgICAgICAgICAnWycgKyBjb250ZXh0LmdldFRhZ3MoKS5pZCArICc9XCInICsgbm9kZUlkICsgJ1wiXScgXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGFkZE5ld05vZGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiggdmFyTmFtZSwgaW5kZXhJdGVtICl7XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVJbnN0YW5jZSA9IGluZGV4SXRlbS5hdHRyaWJ1dGVJbnN0YW5jZTtcclxuICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQnlJZCggaW5kZXhJdGVtLm5vZGVJZCApO1xyXG4gICAgICAgIGlmICggISBub2RlICl7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZWQgbm9kZSFcclxuICAgICAgICAgICAgKytzdGF0aXN0aWNzLnJlbW92ZWROb2RlVXBkYXRlcztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGRhdGEgdG8gbm9kZURhdGFcclxuICAgICAgICB2YXIgdGhpc05vZGVEYXRhID0gbm9kZUF0dHJpYnV0ZXNbIGluZGV4SXRlbS5ub2RlSWQgXTtcclxuICAgICAgICBpZiAoICEgdGhpc05vZGVEYXRhICl7XHJcbiAgICAgICAgICAgIHRoaXNOb2RlRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBub2RlQXR0cmlidXRlc1sgaW5kZXhJdGVtLm5vZGVJZCBdID0gdGhpc05vZGVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWxlbWVudElkID0gaW5kZXhJdGVtLmdyb3VwSWQ/IFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVJbnN0YW5jZS50eXBlICsgJy8nICsgaW5kZXhJdGVtLmdyb3VwSWQ6IFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVJbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIHRoaXNOb2RlRGF0YVsgZWxlbWVudElkIF0gPSBpbmRleEl0ZW07XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHVwZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBpbmRleEl0ZW0gKXtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYXR0cmlidXRlSW5zdGFuY2UgPSBpbmRleEl0ZW0uYXR0cmlidXRlSW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBmaW5kTm9kZUJ5SWQoIGluZGV4SXRlbS5ub2RlSWQgKTtcclxuICAgICAgICBpZiAoICEgbm9kZSApe1xyXG4gICAgICAgICAgICAvLyBSZW1vdmVkIG5vZGUhXHJcbiAgICAgICAgICAgICsrc3RhdGlzdGljcy5yZW1vdmVkTm9kZVVwZGF0ZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgKytzdGF0aXN0aWNzLnRvdGFsVXBkYXRlcztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2NvcGUgPSBnZXROb2RlU2NvcGUoIG5vZGUsIGluZGV4SXRlbS5ub2RlSWQgKTtcclxuICAgICAgICBcclxuICAgICAgICBhdHRyaWJ1dGVJbnN0YW5jZS51cGRhdGUoIHNlbGYsIG5vZGUsIHNjb3BlLCBpbmRleEl0ZW0gKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldE5vZGVTY29wZSA9IGZ1bmN0aW9uKCBub2RlLCBub2RlSWQgKXtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoICEgbm9kZUlkICl7XHJcbiAgICAgICAgICAgIG5vZGVJZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCBjb250ZXh0LmdldFRhZ3MoKS5pZCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGhpc1Njb3BlID0gc2NvcGVNYXBbIG5vZGVJZCBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICggISB0aGlzU2NvcGUgKXtcclxuICAgICAgICAgICAgdGhpc1Njb3BlID0gc2NvcGVCdWlsZGVyLmJ1aWxkKCBcclxuICAgICAgICAgICAgICAgIHBhcnNlck9wdGlvbnMsIFxyXG4gICAgICAgICAgICAgICAgbm9kZSwgXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHNjb3BlTWFwWyBub2RlSWQgXSA9IHRoaXNTY29wZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzU2NvcGU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgdXBkYXRlTm9kZSA9IGZ1bmN0aW9uKCBub2RlLCBtdXN0UmVtb3ZlR2VuZXJhdGVkTm9kZXMgKXtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSZW1vdmUgcmVsYXRlZCB0byBub2RlIG5vZGVzXHJcbiAgICAgICAgbm9kZVJlbW92ZXIucmVtb3ZlTXVsdGlwbGVOb2Rlcyggbm9kZSwgbXVzdFJlbW92ZUdlbmVyYXRlZE5vZGVzICk7XHJcbiAgICAgICAgLypcclxuICAgICAgICBhdHRyaWJ1dGVJbmRleC5yZW1vdmVNdWx0aXBsZU5vZGVzKFxyXG4gICAgICAgICAgICBub2RlUmVtb3Zlci5yZW1vdmVNdWx0aXBsZU5vZGVzKCBub2RlLCBtdXN0UmVtb3ZlR2VuZXJhdGVkTm9kZXMgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBcclxuICAgICAgICAvLyBJbnN0YW5jZSBhbmQgaW52b2tlIHBhcnNlck5vZGVSZW5kZXJlciB0byB1cGRhdGUgbm9kZVxyXG4gICAgICAgIHZhciBwYXJzZXJOb2RlUmVuZGVyZXIgPSBuZXcgUGFyc2VyTm9kZVJlbmRlcmVyKCBcclxuICAgICAgICAgICAgbm9kZSwgXHJcbiAgICAgICAgICAgIHNjb3BlQnVpbGRlci5idWlsZCggXHJcbiAgICAgICAgICAgICAgICBwYXJzZXJPcHRpb25zLCBcclxuICAgICAgICAgICAgICAgIG5vZGUsIFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKTtcclxuICAgICAgICBwYXJzZXJOb2RlUmVuZGVyZXIucnVuKCk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIHZhciBkZWxldGVOb2RlID0gZnVuY3Rpb24oIG5vZGUgKXtcclxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcclxuICAgIH07XHJcbiAgICAqL1xyXG4gICAgdmFyIHNlbGYgPSB7XHJcbiAgICAgICAgcnVuOiBydW4sXHJcbiAgICAgICAgdXBkYXRlTm9kZTogdXBkYXRlTm9kZSxcclxuICAgICAgICAvL2RlbGV0ZU5vZGU6IGRlbGV0ZU5vZGUsXHJcbiAgICAgICAgZmluZE5vZGVCeUlkOiBmaW5kTm9kZUJ5SWQsXHJcbiAgICAgICAgZ2V0Tm9kZVNjb3BlOiBnZXROb2RlU2NvcGUsXHJcbiAgICAgICAgZ2V0U3RhdGlzdGljczogZ2V0U3RhdGlzdGljcyxcclxuICAgICAgICBhZGRVcGRhdGVkVG9TdGF0aXN0aWNzOiBhZGRVcGRhdGVkVG9TdGF0aXN0aWNzLFxyXG4gICAgICAgIGFkZFJlbW92ZWRUb1N0YXRpc3RpY3M6IGFkZFJlbW92ZWRUb1N0YXRpc3RpY3MsXHJcbiAgICAgICAgcnVuQW5pbWF0aW9uOiBydW5BbmltYXRpb24sXHJcbiAgICAgICAgY29udGludWVVcGRhdGVIVE1MOiBjb250aW51ZVVwZGF0ZUhUTUxcclxuICAgIH07XHJcbiAgICBcclxuICAgIHJldHVybiBzZWxmO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJVcGRhdGVyO1xyXG4iLCIvKiBcbiAgICByZXNvbHZlciBzaW5nbGV0b24gY2xhc3NcbiovXG52YXIgdXRpbHMgPSByZXF1aXJlKCAnLi91dGlscy5qcycgKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSggJy4vY29udGV4dC5qcycgKTtcbnZhciBleHByZXNzaW9uQnVpbGRlciA9IHJlcXVpcmUoICcuL2V4cHJlc3Npb25zL2V4cHJlc3Npb25CdWlsZGVyLmpzJyApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiggKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgdmFyIG1hY3JvcyA9IHt9O1xuICAgIHZhciByZW1vdGVQYWdlcyA9IHt9O1xuICAgIFxuICAgIHZhciBnZXROb2RlID0gZnVuY3Rpb24oIG1hY3JvS2V5LCBzY29wZSApIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlID0gbWFjcm9zWyBtYWNyb0tleSBdO1xuICAgICAgICBcbiAgICAgICAgaWYgKCAhIG5vZGUgKXtcbiAgICAgICAgICAgIG5vZGUgPSBsb2FkTm9kZSggbWFjcm9LZXksIHNjb3BlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBub2RlPyBub2RlLmNsb25lTm9kZSggdHJ1ZSApOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKlxuICAgIHZhciBpc1JlbW90ZSA9IGZ1bmN0aW9uKCBtYWNyb0tleSApe1xuICAgICAgICByZXR1cm4gLTEgIT0gbWFjcm9LZXkuaW5kZXhPZiggY29udGV4dC5nZXRDb25mKCkubWFjcm9EZWxpbWl0ZXIgKTtcbiAgICB9OyovXG4gICAgXG4gICAgdmFyIGdldE1hY3JvRGF0YVVzaW5nRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICggbWFjcm9LZXlFeHByZXNzaW9uLCBzY29wZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIG1hY3JvS2V5ID0gbWFjcm9LZXlFeHByZXNzaW9uLmV2YWx1YXRlKCBzY29wZSApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCAhIG1hY3JvS2V5ICl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hY3JvSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdXJsOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZ2V0TWFjcm9EYXRhKCBtYWNyb0tleSwgc2NvcGUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRNYWNyb0RhdGFVc2luZ0V4cHJlc3Npb25TdHJpbmcgPSBmdW5jdGlvbiAoIG1hY3JvS2V5RXhwcmVzc2lvblN0cmluZywgc2NvcGUgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBtYWNyb0tleUV4cHJlc3Npb24gPSBleHByZXNzaW9uQnVpbGRlci5idWlsZCggbWFjcm9LZXlFeHByZXNzaW9uU3RyaW5nICk7XG4gICAgICAgIHJldHVybiBnZXRNYWNyb0RhdGFVc2luZ0V4cHJlc3Npb24oIG1hY3JvS2V5RXhwcmVzc2lvbiwgc2NvcGUgKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRNYWNyb0RhdGEgPSBmdW5jdGlvbiAoIG1hY3JvS2V5LCBzY29wZSApe1xuXG4gICAgICAgIHZhciBpbmRleCA9IG1hY3JvS2V5LmluZGV4T2YoIGNvbnRleHQuZ2V0Q29uZigpLm1hY3JvRGVsaW1pdGVyICk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaW5kZXggPT09IC0xP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hY3JvSWQ6IG1hY3JvS2V5LFxuICAgICAgICAgICAgICAgIHVybDogbnVsbFxuICAgICAgICAgICAgfTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYWNyb0lkOiBtYWNyb0tleS5zdWJzdHJpbmcoIDAsIGluZGV4ICksXG4gICAgICAgICAgICAgICAgdXJsOiBidWlsZFVSTCAoIG1hY3JvS2V5LnN1YnN0cmluZyggMSArIGluZGV4ICkgKVxuICAgICAgICAgICAgfTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBidWlsRGVmaW5lTWFjcm9TZWxlY3RvciA9IGZ1bmN0aW9uKCBtYWNyb0lkICl7XG4gICAgICAgIHJldHVybiBcIltcIiArIGZpbHRlclNlbGVjdG9yKCBjb250ZXh0LmdldFRhZ3MoKS5tZXRhbERlZmluZU1hY3JvICkgKyBcIj0nXCIgKyBtYWNyb0lkICsgXCInXVwiO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGxvYWROb2RlID0gZnVuY3Rpb24oIG1hY3JvS2V5LCBzY29wZSApe1xuXG4gICAgICAgIHZhciBtYWNyb0RhdGEgPSBnZXRNYWNyb0RhdGEoIG1hY3JvS2V5LCBzY29wZSApO1xuXG4gICAgICAgIGlmICggbWFjcm9EYXRhLnVybCApe1xuICAgICAgICAgICAgLy8gTm9kZSBpcyBpbiBhbm90aGVyIHBhZ2VcbiAgICAgICAgICAgIHJldHVybiBsb2FkUmVtb3RlTm9kZSggbWFjcm9LZXksIG1hY3JvRGF0YSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBObyB1cmwgc2V0XG4gICAgICAgIHZhciB1cmxJblNjb3BlID0gc2NvcGUuZ2V0KCBjb250ZXh0LmdldENvbmYoKS5leHRlcm5hbE1hY3JvVXJsVmFyTmFtZSApO1xuICAgICAgICBpZiAoIHVybEluU2NvcGUgKXtcbiAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIG5vZGUgaW4gYW5vdGhlciBwYWdlIGJ1dCB1c2luZyBhIHByZXZpb3VzbHkgZGVmaW5lZCB1cmxcbiAgICAgICAgICAgIG1hY3JvRGF0YS51cmwgPSB1cmxJblNjb3BlO1xuICAgICAgICAgICAgdmFyIHJlbW90ZU5vZGUgPSBsb2FkUmVtb3RlTm9kZSggbWFjcm9LZXksIG1hY3JvRGF0YSApO1xuICAgICAgICAgICAgaWYgKCByZW1vdGVOb2RlICl7XG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpcyBmb3VuZCBpbiBhbm90aGVyIHBhZ2VcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTm9kZSBpcyBpbiB0aGlzIHBhZ2VcbiAgICAgICAgdmFyIG1hY3JvSWQgPSBtYWNyb0RhdGEubWFjcm9JZDtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gYnVpbERlZmluZU1hY3JvU2VsZWN0b3IoIG1hY3JvSWQgKTtcbiAgICAgICAgdmFyIG5vZGUgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3Rvciggc2VsZWN0b3IgKTtcblxuICAgICAgICBpZiAoICEgbm9kZSApe1xuICAgICAgICAgICAgdGhyb3cgXCJOb2RlIHVzaW5nIHNlbGVjdG9yICdcIiArIHNlbGVjdG9yICsgXCInIGlzIG51bGwhXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlndXJlTm9kZSggXG4gICAgICAgICAgICBub2RlLmNsb25lTm9kZSggdHJ1ZSApLCBcbiAgICAgICAgICAgIG1hY3JvSWQsXG4gICAgICAgICAgICBtYWNyb0tleSApO1xuICAgICAgICBcbiAgICB9O1xuICAgIHZhciBsb2FkUmVtb3RlTm9kZSA9IGZ1bmN0aW9uKCBtYWNyb0tleSwgbWFjcm9EYXRhICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgZWxlbWVudCA9IHJlbW90ZVBhZ2VzWyBtYWNyb0RhdGEudXJsIF07XG4gICAgICAgIFxuICAgICAgICBpZiAoICEgZWxlbWVudCApe1xuICAgICAgICAgICAgdGhyb3cgJ01hY3JvcyBpbiBVUkwgJyArIG1hY3JvRGF0YS51cmwgKyAnIG5vdCBwcmVsb2FkZWQhJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gYnVpbERlZmluZU1hY3JvU2VsZWN0b3IoIG1hY3JvRGF0YS5tYWNyb0lkICk7XG4gICAgICAgIHZhciBub2RlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCBzZWxlY3RvciApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCAhIG5vZGUgKXtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb25maWd1cmVOb2RlKCBcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbG9uZU5vZGUoIHRydWUgKSwgXG4gICAgICAgICAgICAgICAgICAgIG1hY3JvRGF0YS5tYWNyb0lkLFxuICAgICAgICAgICAgICAgICAgICBtYWNyb0tleSApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIGJ1aWxkUmVtb3RlUGFnZVVybExpc3QgPSBmdW5jdGlvbiggc2NvcGUsIGRlY2xhcmVkUmVtb3RlUGFnZVVybHMgKXtcbiAgICAgICAgXG4gICAgICAgIHZhciByZW1vdGVQYWdlVXJscyA9IGRlY2xhcmVkUmVtb3RlUGFnZVVybHMuc2xpY2UoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCggXG4gICAgICAgICAgICBcIltcIiArIGZpbHRlclNlbGVjdG9yKCBjb250ZXh0LmdldFRhZ3MoKS5tZXRhbFVzZU1hY3JvICkgKyBcIl1cIlxuICAgICAgICApO1xuICAgICAgICB2YXIgY3VycmVudE1hY3JvVXNlO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgd2hpbGUgKCBjdXJyZW50TWFjcm9Vc2UgPSBsaXN0WyBwb3MrKyBdICkge1xuICAgICAgICAgICAgdmFyIG1hY3JvS2V5RXhwcmVzc2lvblN0cmluZyA9IGN1cnJlbnRNYWNyb1VzZS5nZXRBdHRyaWJ1dGUoIGNvbnRleHQuZ2V0VGFncygpLm1ldGFsVXNlTWFjcm8gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbWFjcm9EYXRhID0gZ2V0TWFjcm9EYXRhVXNpbmdFeHByZXNzaW9uU3RyaW5nKCBtYWNyb0tleUV4cHJlc3Npb25TdHJpbmcsIHNjb3BlICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gbWFjcm9EYXRhLnVybDtcbiAgICAgICAgICAgICAgICBpZiAoIHVybCAmJiByZW1vdGVQYWdlVXJscy5pbmRleE9mKCB1cmwgKSA9PT0gLTEgKXtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlUGFnZVVybHMucHVzaCggdXJsICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoIGV4Y2VwdGlvbiApe1xuICAgICAgICAgICAgICAgIC8vIE1hY3JvZGF0YSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlbW90ZVBhZ2VVcmxzO1xuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIHByZWZmaXggaWYgdGhlIFVSTCBpcyBub3QgYWJzb2x1dGVcbiAgICB2YXIgYnVpbGRVUkwgPSBmdW5jdGlvbiggVVJMICl7XG4gICAgICAgIHJldHVybiBVUkwuc3RhcnRzV2l0aCggJy8nICk/IFVSTDogY29udGV4dC5nZXRDb25mKCkuZXh0ZXJuYWxNYWNyb1ByZWZpeFVSTCArIFVSTDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBsb2FkUmVtb3RlUGFnZXMgPSBmdW5jdGlvbiggc2NvcGUsIGRlY2xhcmVkUmVtb3RlUGFnZVVybHMsIGNhbGxiYWNrLCBmYWlsQ2FsbGJhY2sgKXtcblxuICAgICAgICB2YXIgcmVtb3RlUGFnZVVybHMgPSBidWlsZFJlbW90ZVBhZ2VVcmxMaXN0KCBzY29wZSwgZGVjbGFyZWRSZW1vdGVQYWdlVXJscyApO1xuICAgICAgICB2YXIgcGVuZGluZyA9IHJlbW90ZVBhZ2VVcmxzLmxlbmd0aDtcbiAgICAgICAgcmVtb3RlUGFnZXMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBwZW5kaW5nICl7XG4gICAgICAgICAgICBpZiAoIGNhbGxiYWNrICYmIHV0aWxzLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgKXtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpOyAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCByZW1vdGVQYWdlVXJscy5sZW5ndGg7IGMrKyApIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UGFnZVVybCA9IGJ1aWxkVVJMKCByZW1vdGVQYWdlVXJsc1sgYyBdICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICAgICAgdXRpbHMuYWpheChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogY3VycmVudFBhZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgIC8vZGF0YVR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVQYWdlc1sgdGhpcy51cmwgXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIC0tcGVuZGluZyA9PSAwICYmIGNhbGxiYWNrICYmIHV0aWxzLmlzRnVuY3Rpb24oIGNhbGxiYWNrICkgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmYWlsOiBmdW5jdGlvbigganFYSFIsIHRleHRTdGF0dXMsIGVycm9yICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hc3luY0Vycm9yKCBjdXJyZW50UGFnZVVybCwgZXJyb3IsIGZhaWxDYWxsYmFjayApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogY3VycmVudFBhZ2VVcmwsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdodG1sJ1xuICAgICAgICAgICAgfSkuZG9uZSggZnVuY3Rpb24oIGh0bWwgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAkKCAnPGRpdj48L2Rpdj4nICk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKCBodG1sICk7XG4gICAgICAgICAgICAgICAgcmVtb3RlUGFnZXNbIHRoaXMudXJsIF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmICggLS1wZW5kaW5nID09IDAgJiYgY2FsbGJhY2sgJiYgdXRpbHMuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSApe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZhaWwoIGZ1bmN0aW9uKCBqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3IgKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hc3luY0Vycm9yKCBjdXJyZW50UGFnZVVybCwgZXJyb3IsIGZhaWxDYWxsYmFjayApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgfTtcbiAgICAgICAgICAgICAgICAgIFxuICAgIHZhciBjb25maWd1cmVOb2RlID0gZnVuY3Rpb24oIG5vZGUsIG1hY3JvSWQsIG1hY3JvS2V5ICl7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCBjb250ZXh0LmdldFRhZ3MoKS5tZXRhbERlZmluZU1hY3JvICk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCBjb250ZXh0LmdldFRhZ3MoKS5tZXRhbE1hY3JvLCBtYWNyb0lkICk7XG4gICAgICAgIFxuICAgICAgICBtYWNyb3NbIG1hY3JvS2V5IF0gPSBub2RlO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0TWFjcm9LZXkgPSBmdW5jdGlvbiggbWFjcm9LZXlFeHByZXNzaW9uLCBzY29wZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIG1hY3JvRGF0YSA9IGdldE1hY3JvRGF0YVVzaW5nRXhwcmVzc2lvbiggbWFjcm9LZXlFeHByZXNzaW9uLCBzY29wZSApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG1hY3JvRGF0YS51cmw/IG1hY3JvRGF0YS5tYWNyb0lkICsgY29udGV4dC5nZXRDb25mKCkubWFjcm9EZWxpbWl0ZXIgKyBtYWNyb0RhdGEudXJsOiBtYWNyb0RhdGEubWFjcm9JZDtcbiAgICB9O1xuICAgIFxuICAgIC8vIE11c3QgZmlsdGVyIHRvIHJlcGxhY2UgOiBieSBcXFxcOlxuICAgIHZhciBmaWx0ZXJTZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZSggLzovZ2ksICdcXFxcOicgKTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGdldE5vZGU6IGdldE5vZGUsXG4gICAgICAgIC8vaXNSZW1vdGU6IGlzUmVtb3RlLFxuICAgICAgICBsb2FkUmVtb3RlUGFnZXM6IGxvYWRSZW1vdGVQYWdlcyxcbiAgICAgICAgZ2V0TWFjcm9EYXRhOiBnZXRNYWNyb0RhdGEsXG4gICAgICAgIGdldE1hY3JvS2V5OiBnZXRNYWNyb0tleSxcbiAgICAgICAgZmlsdGVyU2VsZWN0b3I6IGZpbHRlclNlbGVjdG9yXG4gICAgfTtcbn0pKCk7XG4iLCIvKiBcbiAgICBSZWFjdGl2ZURpY3Rpb25hcnkgY2xhc3MgXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB6cHQgPSByZXF1aXJlKCAnLi4vbWFpbi5qcycgKTtcblxudmFyIFJlYWN0aXZlRGljdGlvbmFyeSA9IGZ1bmN0aW9uKCBfbm9uUmVhY3RpdmVEaWN0aW9uYXJ5LCBfaW5pdGlhbEF1dG9Db21taXQgKSB7XG4gICAgXG4gICAgLy8gSW5pdCBzb21lIHZhcnNcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcHJpdmF0ZVNjb3BlID0ge1xuICAgICAgICBub25SZWFjdGl2ZURpY3Rpb25hcnk6IF9ub25SZWFjdGl2ZURpY3Rpb25hcnksXG4gICAgICAgIGF1dG9Db21taXQ6IHRydWUsXG4gICAgICAgIGRpY3Rpb25hcnlDaGFuZ2VzOiB7fSxcbiAgICAgICAgZGljdGlvbmFyeUFjdGlvbnM6IFtdLFxuICAgICAgICBjb21taXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB6cHQucnVuKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5Q2hhbmdlczogc2VsZi5fcHJpdmF0ZVNjb3BlLmRpY3Rpb25hcnlDaGFuZ2VzLFxuICAgICAgICAgICAgICAgIGRpY3Rpb25hcnlBY3Rpb25zOiBzZWxmLl9wcml2YXRlU2NvcGUuZGljdGlvbmFyeUFjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5fcHJpdmF0ZVNjb3BlLmRpY3Rpb25hcnlDaGFuZ2VzID0ge307XG4gICAgICAgICAgICBzZWxmLl9wcml2YXRlU2NvcGUuZGljdGlvbmFyeUFjdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBEZWZpbmUgc29tZSBtZXRob2RzXG4gICAgdGhpcy5fZ2V0Tm9uUmVhY3RpdmVEaWN0aW9uYXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVTY29wZS5ub25SZWFjdGl2ZURpY3Rpb25hcnk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLl9pc0F1dG9Db21taXQgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZVNjb3BlLmF1dG9Db21taXQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLl9zZXRBdXRvQ29tbWl0ID0gZnVuY3Rpb24oIF9hdXRvQ29tbWl0ICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVTY29wZS5hdXRvQ29tbWl0ID0gX2F1dG9Db21taXQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLl9jb21taXQgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9wcml2YXRlU2NvcGUuY29tbWl0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuX2FkZEFjdGlvbnMgPSBmdW5jdGlvbiggZGljdGlvbmFyeUFjdGlvbnMgKXtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlY29yZCB0aGlzIGFjdGlvbnMgdG8gY29tbWl0IGl0IGxhdGVyXG4gICAgICAgIHNlbGYuX3ByaXZhdGVTY29wZS5kaWN0aW9uYXJ5QWN0aW9ucyA9IHNlbGYuX3ByaXZhdGVTY29wZS5kaWN0aW9uYXJ5QWN0aW9ucy5jb25jYXQoIGRpY3Rpb25hcnlBY3Rpb25zICk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb21taXQgdGhlIGNoYW5nZSBvbmx5IGlmIGF1dG9Db21taXQgaXMgb25cbiAgICAgICAgaWYgKCBzZWxmLl9pc0F1dG9Db21taXQoKSApe1xuICAgICAgICAgICAgc2VsZi5fcHJpdmF0ZVNjb3BlLmNvbW1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLl9hZGRWYXJpYWJsZSA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICl7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIGluIG5vblJlYWN0aXZlRGljdGlvbmFyeVxuICAgICAgICBzZWxmLl9wcml2YXRlU2NvcGUubm9uUmVhY3RpdmVEaWN0aW9uYXJ5WyBrZXkgXSA9IHZhbHVlO1xuICAgICAgICBcbiAgICAgICAgLy8gRGVmaW5lIGdldHRlciBhbmQgc2V0dGVyXG4gICAgICAgIHRoaXMuX2RlZmluZVByb3BlcnR5KCBcbiAgICAgICAgICAgIHRoaXMuX3ByaXZhdGVTY29wZS5ub25SZWFjdGl2ZURpY3Rpb25hcnksIFxuICAgICAgICAgICAga2V5IFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICB0aGlzLl9kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBkaWN0aW9uYXJ5LCBrZXkgKXtcblxuICAgICAgICAvLyBEZWZpbmUgcHJvcGVydHkgdG8gc2V0IGdldHRlciBhbmQgc2V0dGVyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIHNlbGYsIFxuICAgICAgICAgICAga2V5LCBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWN0aW9uYXJ5WyBrZXkgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRoaXMgY2hhbmdlIHRvIGNvbW1pdCBpdCBsYXRlclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcml2YXRlU2NvcGUuZGljdGlvbmFyeUNoYW5nZXNbIGtleSBdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSBjaGFuZ2Ugb25seSBpZiBhdXRvQ29tbWl0IGlzIG9uXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2VsZi5faXNBdXRvQ29tbWl0KCkgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3ByaXZhdGVTY29wZS5jb21taXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIEluaXRpYWxpemVcbiAgICB0aGlzLl9pbml0aWFsaXplID0gZnVuY3Rpb24oIGRpY3Rpb25hcnkgKXtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXV0b0NvbW1pdFxuICAgICAgICBpZiAoIF9pbml0aWFsQXV0b0NvbW1pdCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdXRvQ29tbWl0KCBfaW5pdGlhbEF1dG9Db21taXQgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSXRlcmF0ZSBwcm9wZXJ0aWVzIGluIGRpY3Rpb25hcnkgdG8gZGVmaW5lIHNldHRlcnMgYW5kIGdldHRlcnNcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyggZGljdGlvbmFyeSApO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1sgaSBdO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggZGljdGlvbmFyeSwga2V5ICk7XG4gICAgICAgICAgICBpZiAoIHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERlZmluZSBnZXR0ZXIgYW5kIHNldHRlclxuICAgICAgICAgICAgKGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGVmaW5lUHJvcGVydHkoIGRpY3Rpb25hcnksIGtleSApO1xuICAgICAgICAgICAgfSkoIGtleSApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9pbml0aWFsaXplKCB0aGlzLl9wcml2YXRlU2NvcGUubm9uUmVhY3RpdmVEaWN0aW9uYXJ5ICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0aXZlRGljdGlvbmFyeTtcbiIsIi8qIFxuICAgIENsYXNzIFNjb3BlIFxuKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoICcuLi9jb250ZXh0LmpzJyApO1xudmFyIHV0aWxzID0gcmVxdWlyZSggJy4uL3V0aWxzLmpzJyApO1xudmFyIGxvYWRqcyA9IHJlcXVpcmUoICdsb2FkanMnICk7XG5cbnZhciBTY29wZSA9IGZ1bmN0aW9uKCBfZGljdGlvbmFyeSwgX2RpY3Rpb25hcnlFeHRlbnNpb24sIGFkZENvbW1vblZhcnMsIF9mb2xkZXJEaWN0aW9uYXJpZXMgKSB7XG4gICAgXG4gICAgdGhpcy5kaWN0aW9uYXJ5ID0gX2RpY3Rpb25hcnkgfHwge307XG4gICAgdGhpcy5kaWN0aW9uYXJ5RXh0ZW5zaW9uID0gX2RpY3Rpb25hcnlFeHRlbnNpb24gfHwge307XG4gICAgdGhpcy52YXJzID0ge307XG4gICAgdGhpcy5jaGFuZ2VzU3RhY2sgPSBbXTtcbiAgICB0aGlzLm5vY2FsbFZhcnMgPSB7fTtcbiAgICB0aGlzLmZvbGRlckRpY3Rpb25hcmllcyA9IF9mb2xkZXJEaWN0aW9uYXJpZXMgfHwgW107XG4gICAgdGhpcy5nbG9iYWxWYXJzRXhwcmVzc2lvbnMgPSB7fTtcbiAgICBcbiAgICBpZiAoIGFkZENvbW1vblZhcnMgKXtcbiAgICAgICAgdGhpcy5zZXRDb21tb25WYXJzKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0TWFuZGF0b3J5VmFycygpO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnNldE1hbmRhdG9yeVZhcnMgPSBmdW5jdGlvbigpe1xuXG4gICAgLy8gUmVnaXN0ZXIgbm90aGluZyB2YXJcbiAgICB0aGlzLnNldFZhciggXG4gICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLm5vdGhpbmdWYXJOYW1lLCBcbiAgICAgICAgY29udGV4dC5nZXRDb25mKCkubm90aGluZ1ZhclZhbHVlIFxuICAgICk7XG4gICAgXG4gICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCB2YXJcbiAgICB0aGlzLnNldFZhciggXG4gICAgICAgIGNvbnRleHQuZ2V0Q29uZigpLmRlZmF1bHRWYXJOYW1lLCBcbiAgICAgICAgY29udGV4dC5nZXRDb25mKCkuZGVmYXVsdFZhclZhbHVlIFxuICAgICk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuc2V0Q29tbW9uVmFycyA9IGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgLy8gUmVnaXN0ZXIgd2luZG93IG9iamVjdCBpZiBpdCBleGlzdHNcbiAgICBpZiAoIHdpbmRvdyApe1xuICAgICAgICB0aGlzLnNldFZhciggXG4gICAgICAgICAgICBjb250ZXh0LmdldENvbmYoKS53aW5kb3dWYXJOYW1lLCBcbiAgICAgICAgICAgIHdpbmRvdyBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBjb250ZXh0XG4gICAgdGhpcy5zZXRWYXIoIFxuICAgICAgICBjb250ZXh0LmdldENvbmYoKS5jb250ZXh0VmFyTmFtZSwgXG4gICAgICAgIGNvbnRleHQgXG4gICAgKTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5zdGFydEVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgIFxuICAgIHZhciB2YXJzID0ge1xuICAgICAgICB2YXJzVG9VbnNldDogW10sXG4gICAgICAgIHZhcnNUb1NldDoge30sXG4gICAgICAgIGV4cHJlc3Npb25zOiB7fSxcbiAgICAgICAgaW1wbGllZERlY2xhcmVkVmFyczogW11cbiAgICB9O1xuXG4gICAgdGhpcy5jaGFuZ2VzU3RhY2sucHVzaCggdmFycyApO1xuXG4gICAgcmV0dXJuIHZhcnM7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuY3VycmVudFZhcnMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXNTdGFja1sgdGhpcy5jaGFuZ2VzU3RhY2subGVuZ3RoIC0gMSBdO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnNldFZhciA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcbiAgICB0aGlzLnZhcnNbIG5hbWUgXSA9IHZhbHVlO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmdldFdpdGhvdXRFdmFsdWF0aW5nID0gZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgXG4gICAgdmFyIHZhbHVlO1xuICAgIFxuICAgIHZhbHVlID0gdGhpcy52YXJzWyBuYW1lIF07XG4gICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFsdWUgPSB0aGlzLmRpY3Rpb25hcnlFeHRlbnNpb25bIG5hbWUgXTtcbiAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBcbiAgICB2YWx1ZSA9IHRoaXMuZGljdGlvbmFyeVsgbmFtZSBdO1xuICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIFxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZm9sZGVyRGljdGlvbmFyaWVzLmxlbmd0aDsgKytpICl7XG4gICAgICAgIHZhbHVlID0gdGhpcy5mb2xkZXJEaWN0aW9uYXJpZXNbIGkgXVsgbmFtZSBdO1xuICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCBuYW1lICkge1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRXaXRob3V0RXZhbHVhdGluZyggbmFtZSApO1xuICAgIFxuICAgIGlmICggISB0aGlzLm5vY2FsbFZhcnNbIG5hbWUgXSApe1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB2YWx1ZSAmJiB1dGlscy5pc0Z1bmN0aW9uKCB2YWx1ZS5ldmFsdWF0ZSApP1xuICAgICAgICB2YWx1ZS5ldmFsdWF0ZSggdGhpcyApOiBcbiAgICAgICAgJ0Vycm9yIGV2YWx1YXRpbmcgcHJvcGVydHkgXCInICsgbmFtZSArICdcIjogJyArIHZhbHVlO1xufTtcblxuU2NvcGUucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgZGVsZXRlIHRoaXMudmFyc1sgbmFtZSBdO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmVuZEVsZW1lbnQgPSBmdW5jdGlvbiAoICkge1xuXG4gICAgdmFyIHZhcnMgPSB0aGlzLmNoYW5nZXNTdGFjay5wb3AoKTsgXG5cbiAgICB2YXIgdmFyc1RvVW5zZXQgPSB2YXJzLnZhcnNUb1Vuc2V0O1xuICAgIHZhciB2YXJzVG9TZXQgPSB2YXJzLnZhcnNUb1NldDsgXG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB2YXJzVG9VbnNldC5sZW5ndGg7ICsraSApe1xuICAgICAgICB0aGlzLnVuc2V0KCB2YXJzVG9VbnNldFsgaSBdICk7XG4gICAgfVxuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gdmFyc1RvU2V0ICl7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhcnNUb1NldFsgbmFtZSBdO1xuICAgICAgICB0aGlzLnNldFZhciggbmFtZSwgdmFsdWUgKTtcbiAgICB9XG59O1xuXG5TY29wZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSwgaXNHbG9iYWwsIG5vY2FsbCwgX2V4cHJlc3Npb24gKSB7XG4gICAgXG4gICAgdmFyIGV4cHJlc3Npb24gPSBfZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkPyBudWxsOiBfZXhwcmVzc2lvbjtcbiAgICBcbiAgICBpZiAoICEgaXNHbG9iYWwgKXtcblxuICAgICAgICAvLyBMb2NhbCB2YXJzXG4gICAgICAgIHZhciB2YXJzID0gdGhpcy5jdXJyZW50VmFycygpO1xuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5nZXRXaXRob3V0RXZhbHVhdGluZyggbmFtZSApO1xuXG4gICAgICAgIGlmICggY3VycmVudFZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICAgIHZhcnMudmFyc1RvU2V0WyBuYW1lIF0gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhcnMudmFyc1RvVW5zZXQucHVzaCggbmFtZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXJzLmV4cHJlc3Npb25zWyBuYW1lIF0gPSBleHByZXNzaW9uO1xuICAgICAgICBcbiAgICAgICAgaWYgKCB0aGlzLmlzU3RyaWN0TW9kZSgpICl7XG4gICAgICAgICAgICB2YXJzLmltcGxpZWREZWNsYXJlZFZhcnMucHVzaCggbmFtZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICAvLyBHbG9iYWwgdmFyc1xuICAgICAgICB0aGlzLmdsb2JhbFZhcnNFeHByZXNzaW9uc1sgbmFtZSBdID0gZXhwcmVzc2lvbjsgXG4gICAgfVxuICAgIFxuICAgIC8vIENvbW1vbiB0byBnbG9iYWwgYW5kIGxvY2FsIHZhcnNcbiAgICB0aGlzLnNldFZhciggbmFtZSwgdmFsdWUgKTtcbiAgICBcbiAgICAvLyBBZGQgdG8gbm9jYWxsVmFycyBpZiBuZWVkZWRcbiAgICBpZiAoIG5vY2FsbCApe1xuICAgICAgICB0aGlzLm5vY2FsbFZhcnNbIG5hbWUgXSA9IHRydWU7XG4gICAgfVxufTtcblxuU2NvcGUucHJvdG90eXBlLmxvYWRGb2xkZXJEaWN0aW9uYXJpZXNBc3luYyA9IGZ1bmN0aW9uICggbWF4Rm9sZGVyRGljdGlvbmFyaWVzLCBsb2NhdGlvbiwgY2FsbGJhY2sgKSB7XG4gICAgXG4gICAgaWYgKCAhIG1heEZvbGRlckRpY3Rpb25hcmllcyApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgdXJsTGlzdCA9IHRoaXMuYnVpbGRVcmxMaXN0T2ZGb2xkZXJEaWN0aW9uYXJpZXMoIG1heEZvbGRlckRpY3Rpb25hcmllcywgbG9jYXRpb24gKTtcbiAgICB0aGlzLmxvYWRGb2xkZXJEaWN0aW9uYXJ5KFxuICAgICAgICBtYXhGb2xkZXJEaWN0aW9uYXJpZXMsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB1cmxMaXN0LCBcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUubG9hZEZvbGRlckRpY3Rpb25hcnkgPSBmdW5jdGlvbiAoIG1heEZvbGRlckRpY3Rpb25hcmllcywgY2FsbGJhY2ssIHVybExpc3QsIGkgKSB7XG4gICAgXG4gICAgdmFyIGluc3RhbmNlID0gdGhpcztcbiAgICBcbiAgICB2YXIgbG9hZGpzQ2FsbGJhY2sgPSBmdW5jdGlvbiggdXJsLCBzdWNjZXNzICl7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmVhdCBqcyBmaWxlIG9ubHkgaWYgbG9hZCBpcyBzdWNlc3NmdWxsXG4gICAgICAgIGlmICggc3VjY2VzcyAmJiB3aW5kb3cuZm9sZGVyRGljdGlvbmFyeSApe1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9sZGVyRGljdGlvbmFyaWVzLnB1c2goIHdpbmRvdy5mb2xkZXJEaWN0aW9uYXJ5ICk7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBSdW4gY2FsbGJhY2sgYW5kIHJldHVybiBpZiB0aGUgdXJsTGlzdCBpcyBvdmVyXG4gICAgICAgIGlmICggaSA9PT0gdXJsTGlzdC5sZW5ndGgpe1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRpbnVlLCB0aGUgdXJsTGlzdCBpcyBub3Qgb3ZlclxuICAgICAgICBpbnN0YW5jZS5sb2FkRm9sZGVyRGljdGlvbmFyeShcbiAgICAgICAgICAgIG1heEZvbGRlckRpY3Rpb25hcmllcywgXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIHVybExpc3QsIFxuICAgICAgICAgICAgaVxuICAgICAgICApO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHVybCA9IHVybExpc3RbIGkrKyBdO1xuICAgIGxvYWRqcyhcbiAgICAgICAgdXJsLCBcbiAgICAgICAge1xuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgIGxvYWRqc0NhbGxiYWNrKCB1cmwsIHRydWUgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgIGxvYWRqc0NhbGxiYWNrKCB1cmwsIGZhbHNlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuU2NvcGUucHJvdG90eXBlLmJ1aWxkVXJsTGlzdE9mRm9sZGVyRGljdGlvbmFyaWVzID0gZnVuY3Rpb24gKCBtYXhGb2xkZXJEaWN0aW9uYXJpZXMsIGxvY2F0aW9uICkge1xuICAgIFxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIHBhdGggPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgbGFzdEluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZiggJy8nICk7XG4gICAgd2hpbGUgKCBsYXN0SW5kZXggIT09IC0xICYmICsrYyA8PSBtYXhGb2xkZXJEaWN0aW9uYXJpZXMgKXtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBhdGguc3Vic3RyKCAwLCBsYXN0SW5kZXggKTtcbiAgICAgICAgcmVzdWx0LnB1c2goIFxuICAgICAgICAgICAgbG9jYXRpb24ub3JpZ2luICsgcGFyZW50ICsgJy8nICsgJ2ZvbGRlckRpY3Rpb25hcnkuanMnIFxuICAgICAgICApO1xuICAgICAgICBsYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4T2YoICcvJyApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuU2NvcGUucHJvdG90eXBlLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGNvbnRleHQuaXNTdHJpY3RNb2RlKCkgfHwgdGhpcy5nZXQoIGNvbnRleHQuZ2V0Q29uZigpLnN0cmljdE1vZGVWYXJOYW1lICk7XG59O1xuXG5TY29wZS5wcm90b3R5cGUuaXNWYWxpZFZhcmlhYmxlID0gZnVuY3Rpb24oIG5hbWUgKXtcbiAgICBcbiAgICAvLyBJZiBzdHJpY3QgbW9kZSBpcyBvZmYgYWxsIHZhcmlhYmxlIGFyZSB2YWxpZFxuICAgIGlmICggISB0aGlzLmlzU3RyaWN0TW9kZSgpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0aGUgdmFyaWFibGUgaXMgZGVjbGFyZWQgcmV0dXJuIHRydWVcbiAgICB2YXIgZGVjbGFyZWQgPSB0aGlzLmdldCggY29udGV4dC5nZXRDb25mKCkuZGVjbGFyZWRWYXJzVmFyTmFtZSApO1xuICAgIHZhciBpc0RlY2xhcmVkID0gZGVjbGFyZWQgJiYgZGVjbGFyZWQuaW5kZXhPZj8gXG4gICAgICAgIGRlY2xhcmVkLmluZGV4T2YoIG5hbWUgKSAhPT0gLTE6IFxuICAgICAgICBmYWxzZTtcbiAgICBpZiAoIGlzRGVjbGFyZWQgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSB2YXJpYWJsZSBpcyBpbXBsaWNpdGx5IGRlY2xhcmVkXG4gICAgZm9yICggdmFyIGkgPSB0aGlzLmNoYW5nZXNTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSApe1xuICAgICAgICB2YXIgdmFycyA9IHRoaXMuY2hhbmdlc1N0YWNrWyBpIF07XG4gICAgICAgIHZhciBpc0ltcGxpZWQgPSB2YXJzLmltcGxpZWREZWNsYXJlZFZhcnMuaW5kZXhPZiggbmFtZSApICE9PSAtMTtcbiAgICAgICAgaWYgKCBpc0ltcGxpZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5nZXRWYXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuICAgIFxuICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5nZXRFeHByZXNzaW9uRnJvbUxvY2FsKCBuYW1lICk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24gIT09IHVuZGVmaW5lZD8gZXhwcmVzc2lvbjogdGhpcy5nbG9iYWxWYXJzRXhwcmVzc2lvbnNbIG5hbWUgXTtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5nZXRFeHByZXNzaW9uRnJvbUxvY2FsID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgZm9yICggdmFyIGkgPSB0aGlzLmNoYW5nZXNTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSApe1xuICAgICAgICB2YXIgdmFycyA9IHRoaXMuY2hhbmdlc1N0YWNrWyBpIF07XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdmFycy5leHByZXNzaW9uc1sgbmFtZSBdO1xuICAgICAgICBpZiAoIGV4cHJlc3Npb24gIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cblNjb3BlLnByb3RvdHlwZS5pc0xvY2FsVmFyID0gZnVuY3Rpb24gKCBuYW1lICkge1xuICAgIHJldHVybiB0aGlzLnZhcnNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY29wZTtcbiIsIi8qIFxuICAgIHNjb3BlQnVpbGRlciBzaW5nbGV0b24gY2xhc3NcbiovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCAnLi4vY29udGV4dC5qcycgKTtcbnZhciBTY29wZSA9IHJlcXVpcmUoICcuL3Njb3BlLmpzJyApO1xudmFyIHV0aWxzID0gcmVxdWlyZSggJy4uL3V0aWxzLmpzJyApO1xudmFyIFBhcnNlck5vZGVSZW5kZXJlciA9IHJlcXVpcmUoICcuLi9wYXJzZXJzL3BhcnNlck5vZGVSZW5kZXJlci5qcycgKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIGtleUxlbmd0aCA9IDY7XG4gICAgXG4gICAgdmFyIGJ1aWxkID0gZnVuY3Rpb24oIHBhcnNlck9wdGlvbnMsIHRhcmdldCwgZGljdGlvbmFyeUV4dGVuc2lvbiwgbXVzdFVwZGF0ZSApIHtcblxuICAgICAgICB2YXIgc2NvcGUgPSBuZXcgU2NvcGUoIFxuICAgICAgICAgICAgcGFyc2VyT3B0aW9ucy5kaWN0aW9uYXJ5LCBcbiAgICAgICAgICAgIGRpY3Rpb25hcnlFeHRlbnNpb24sIFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0Rm9sZGVyRGljdGlvbmFyaWVzKClcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmICggbXVzdFVwZGF0ZSApe1xuICAgICAgICAgICAgdXBkYXRlKCBwYXJzZXJPcHRpb25zLCB0YXJnZXQsIHNjb3BlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiggcGFyc2VyT3B0aW9ucywgdGFyZ2V0LCBzY29wZSApIHtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCByb290IGtleVxuICAgICAgICB2YXIgcm9vdE1hcCA9IG1hcmtBbGxSb290cyggcGFyc2VyT3B0aW9ucyApO1xuICAgICAgICB2YXIgcm9vdEtleVRhZyA9IGdldFJvb3RLZXlUYWcoKTtcbiAgICAgICAgdmFyIHJvb3QgPSBnZXRSb290KCBwYXJzZXJPcHRpb25zLCB0YXJnZXQsIHJvb3RNYXAgKTtcbiAgICAgICAgdmFyIHJvb3RLZXkgPSAgcm9vdC5nZXRBdHRyaWJ1dGUoIHJvb3RLZXlUYWcgKTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0YWxEZWZpbmVUYWcgPSBjb250ZXh0LmdldFRhZ3MoKS50YWxEZWZpbmU7XG4gICAgICAgIHZhciB0YWxBdXRvRGVmaW5lVGFnID0gY29udGV4dC5nZXRUYWdzKCkudGFsQXV0b0RlZmluZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgdmFyIGl0ZW1zTGlzdCA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gQWRkIHRhbERlZmluZVxuICAgICAgICAgICAgdmFyIHRhbERlZmluZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCB0YWxEZWZpbmVUYWcgKTtcbiAgICAgICAgICAgIGlmICggdGFsRGVmaW5lICl7XG4gICAgICAgICAgICAgICAgaXRlbXNMaXN0LnB1c2goIHRhbERlZmluZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdGFsQXV0b0RlZmluZVxuICAgICAgICAgICAgdmFyIHRhbEF1dG9EZWZpbmUgPSBub2RlLmdldEF0dHJpYnV0ZSggdGFsQXV0b0RlZmluZVRhZyApO1xuICAgICAgICAgICAgaWYgKCB0YWxBdXRvRGVmaW5lICl7XG4gICAgICAgICAgICAgICAgaXRlbXNMaXN0LnB1c2goIHRhbEF1dG9EZWZpbmUgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG5vZGVLZXkgPSBub2RlLmdldEF0dHJpYnV0ZSggcm9vdEtleVRhZyApO1xuICAgICAgICAgICAgaWYgKCBub2RlS2V5ICYmIG5vZGVLZXkgPT09IHJvb3RLZXkgKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0xpc3RPZkRlZmluZXMoIFxuICAgICAgICAgICAgICAgICAgICBzY29wZSwgXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zTGlzdCwgXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlck9wdGlvbnMuaW5kZXhFeHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBcbiAgICAgICAgfSB3aGlsZSAoIG5vZGUubm9kZVR5cGUgIT09IDkgJiYgKytjIDwgMTAwICk7XG4gICAgICAgIFxuICAgICAgICB0aHJvdyAnRXJyb3IgdHJ5aW5nIHRvIHVwZGF0ZSBzY29wZTogcm9vdCBub3QgZm91bmQhJztcbiAgICB9O1xuICAgIFxuICAgIHZhciBwcm9jZXNzTGlzdE9mRGVmaW5lcyA9IGZ1bmN0aW9uKCBzY29wZSwgaXRlbXNMaXN0LCBub2RlLCBpbmRleEV4cHJlc3Npb25zICl7XG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgYyA9IGl0ZW1zTGlzdC5sZW5ndGggLSAxOyBjID49IDA7IGMtLSApIHtcbiAgICAgICAgICAgIHZhciB0YWxEZWZpbmUgPSBpdGVtc0xpc3RbIGMgXTtcbiAgICAgICAgICAgIFBhcnNlck5vZGVSZW5kZXJlci5wcm9jZXNzRGVmaW5lKFxuICAgICAgICAgICAgICAgIG5vZGUsIFxuICAgICAgICAgICAgICAgIHRhbERlZmluZSwgXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgICBpbmRleEV4cHJlc3Npb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0Um9vdCA9IGZ1bmN0aW9uKCBwYXJzZXJPcHRpb25zLCB0YXJnZXQsIHJvb3RNYXAgKXtcbiAgICAgICAgXG4gICAgICAgIGlmICggISBBcnJheS5pc0FycmF5KCBwYXJzZXJPcHRpb25zLnJvb3QgKSApeyBcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXJPcHRpb25zLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciByb290S2V5VGFnID0gZ2V0Um9vdEtleVRhZygpO1xuICAgICAgICB2YXIgbm9kZSA9IHRhcmdldDtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgcm9vdEtleSA9ICBub2RlLmdldEF0dHJpYnV0ZSggcm9vdEtleVRhZyApO1xuICAgICAgICAgICAgaWYgKCByb290S2V5ICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RNYXBbIHJvb3RLZXkgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICB9IHdoaWxlICggbm9kZS5ub2RlVHlwZSAhPT0gOSAmJiArK2MgPCAxMDAgKTtcbiAgICAgICAgXG4gICAgICAgIHRocm93ICdFcnJvciB0cnlpbmcgdG8gZ2V0IHJvb3Q6IG5vdCBmb3VuZCEnO1xuICAgIH07XG4gICAgXG4gICAgdmFyIG1hcmtBbGxSb290cyA9IGZ1bmN0aW9uKCBwYXJzZXJPcHRpb25zICl7XG5cbiAgICAgICAgdmFyIHJvb3RNYXAgPSB7fTtcbiAgICAgICAgdmFyIHJvb3QgPSBwYXJzZXJPcHRpb25zLnJvb3Q7XG5cbiAgICAgICAgLy8gSXMgbXVsdGlyb290P1xuICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoIHJvb3QgKSApeyBcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBzZXZlcmFsIHJvb3RzXG4gICAgICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCByb290Lmxlbmd0aDsgYysrICkge1xuICAgICAgICAgICAgICAgIG1hcmtBc1Jvb3QoIHJvb3RbIGMgXSwgcm9vdE1hcCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgcm9vdFxuICAgICAgICAgICAgbWFya0FzUm9vdCggcm9vdCwgcm9vdE1hcCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvb3RNYXA7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbWFya0FzUm9vdCA9IGZ1bmN0aW9uKCBub2RlLCByb290TWFwICl7XG4gICAgICAgIFxuICAgICAgICAvLyBCdWlsZCB0aGUga2V5XG4gICAgICAgIHZhciBrZXkgPSBidWlsZEtleSgpO1xuXG4gICAgICAgIC8vIFB1dCBhIGNvcHkgb2Ygc2NvcGUgaW50byB0aGUgY2FjaGVcbiAgICAgICAgcm9vdE1hcFsga2V5IF0gPSBub2RlO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIGtleSBhcyBhbiBhdHRyaWJ1dGUgb2YgdGhlIG5vZGVcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIGdldFJvb3RLZXlUYWcoKSwga2V5ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgYnVpbGRLZXkgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdXRpbHMuZ2VuZXJhdGVJZCgga2V5TGVuZ3RoICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZ2V0Um9vdEtleVRhZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmdldFRhZ3MoKS5yb290S2V5O1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVpbGQ6IGJ1aWxkXG4gICAgfTtcbn0pKCk7XG4iLCIvKlxuICAgIHV0aWxzIHNpbmdsZXRvbiBjbGFzc1xuKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBnZW5lcmF0ZUlkID0gZnVuY3Rpb24gKCBsZW4sIF9jaGFyU2V0ICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIGNoYXJTZXQgPSBfY2hhclNldCB8fCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0Lmxlbmd0aCApO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXJTZXQuc3Vic3RyaW5nKCBwb3MsIHBvcyArIDEgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgLy92YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgXG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIHZhciBwcm90bywgQ3RvcjtcblxuICAgICAgICAvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcbiAgICAgICAgLy8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG4gICAgICAgIGlmICggIW9iaiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuICAgICAgICBpZiAoICFwcm90byApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cbiAgICAgICAgQ3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcbiAgICB9O1xuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgY2xhc3MydHlwZSA9IHt9O1xuICAgIHZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuICAgIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuICAgIHZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG4gICAgXG4gICAgdmFyIGRlZXBFeHRlbmQgPSBmdW5jdGlvbiggb3V0ICkge1xuICAgICAgICBvdXQgPSBvdXQgfHwge307XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1sgaSBdO1xuXG4gICAgICAgICAgICBpZiAoICEgb2JqICl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gb2JqICkge1xuICAgICAgICAgICAgICAgIGlmICggb2JqLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygb2JqWyBrZXkgXSA9PT0gJ29iamVjdCcgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFsga2V5IF0gPSBkZWVwRXh0ZW5kKCBvdXRbIGtleSBdLCBvYmpbIGtleSBdICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbIGtleSBdID0gb2JqWyBrZXkgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgIG91dCA9IG91dCB8fCB7fTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBpZiAoICEgYXJndW1lbnRzWyBpIF0gKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggdmFyIGtleSBpbiBhcmd1bWVudHNbIGkgXSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGFyZ3VtZW50c1sgaSBdLmhhc093blByb3BlcnR5KCBrZXkgKSApe1xuICAgICAgICAgICAgICAgICAgICBvdXRbIGtleSBdID0gYXJndW1lbnRzWyBpIF1bIGtleSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgYWpheCA9IGZ1bmN0aW9uKCBjb25mICl7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBjb25mIG9iamVjdFxuICAgICAgICBpZiAoICEgY29uZiApe1xuICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHRyeWluZyB0byBwcm9jZXNzIGFqYXg6IG5vIGFyZ3VtZW50cyEnO1xuICAgICAgICB9XG4gICAgICAgIGlmICggISBjb25mLnVybCApe1xuICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHRyeWluZyB0byBwcm9jZXNzIGFqYXg6IG5vIFVSTCBkZWZpbmVkISc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIGNvbmYuZG9uZSApe1xuICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHRyeWluZyB0byBwcm9jZXNzIGFqYXg6IG5vIGRvbmUgY2FsbGJhY2sgZGVmaW5lZCEnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEbyBpdCFcbiAgICAgICAgdmFyIG9SZXEgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIG9SZXEuYWRkRXZlbnRMaXN0ZW5lciggXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgNDAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIVxuICAgICAgICAgICAgICAgICAgICBjb25mLmRvbmUoIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZi5wYXJzZUpTT04/XG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKCBvUmVxLnJlc3BvbnNlVGV4dCApOlxuICAgICAgICAgICAgICAgICAgICAgICAgb1JlcS5yZXNwb25zZVRleHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWFjaGVkIG91ciB0YXJnZXQgc2VydmVyLCBidXQgaXQgcmV0dXJuZWQgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgY29uZi5mYWlsKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5zdGF0dXNUZXh0ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAoIGNvbmYuZmFpbCApe1xuICAgICAgICAgICAgb1JlcS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBjb25mLmZhaWwgKTtcbiAgICAgICAgfVxuICAgICAgICBvUmVxLm9wZW4oICdHRVQnLCBjb25mLnVybCApO1xuICAgICAgICBvUmVxLnNlbmQoKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZXRKU09OID0gZnVuY3Rpb24oIGNvbmYgKXtcbiAgICAgICAgXG4gICAgICAgIGNvbmYucGFyc2VKU09OID0gdHJ1ZTtcbiAgICAgICAgYWpheCggY29uZiApO1xuICAgIH07XG4gICAgXG4gICAgLypcbiAgICB2YXIgZ2V0SlNPTiA9IGZ1bmN0aW9uKCBjb25mICl7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBjb25mIG9iamVjdFxuICAgICAgICBpZiAoICEgY29uZiApe1xuICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHRyeWluZyB0byBnZXRKU09OOiBubyBhcmd1bWVudHMhJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgY29uZi51cmwgKXtcbiAgICAgICAgICAgIHRocm93ICdFcnJvciB0cnlpbmcgdG8gZ2V0SlNPTjogbm8gVVJMIGRlZmluZWQhJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgY29uZi5kb25lICl7XG4gICAgICAgICAgICB0aHJvdyAnRXJyb3IgdHJ5aW5nIHRvIGdldEpTT046IG5vIGRvbmUgY2FsbGJhY2sgZGVmaW5lZCEnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEbyBpdCFcbiAgICAgICAgdmFyIG9SZXEgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIG9SZXEuYWRkRXZlbnRMaXN0ZW5lciggXG4gICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmICggdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgNDAwICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzIVxuICAgICAgICAgICAgICAgICAgICBjb25mLmRvbmUoIFxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZSggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb1JlcS5yZXNwb25zZVRleHQgXG4gICAgICAgICAgICAgICAgICAgICAgICApIFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgb3VyIHRhcmdldCBzZXJ2ZXIsIGJ1dCBpdCByZXR1cm5lZCBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBjb25mLmZhaWwoIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLnN0YXR1c1RleHQgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICggY29uZi5mYWlsICl7XG4gICAgICAgICAgICBvUmVxLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGNvbmYuZmFpbCApO1xuICAgICAgICB9XG4gICAgICAgIG9SZXEub3BlbiggJ0dFVCcsIGNvbmYudXJsICk7XG4gICAgICAgIG9SZXEuc2VuZCgpO1xuICAgIH07XG4gICAgKi9cbiAgICAvKlxuICAgIHZhciBnZXROb2RlSWQgPSBmdW5jdGlvbiAoIG5vZGUgKXtcbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKCBjb250ZXh0LmdldFRhZ3MoKS5pZCApO1xuICAgIH07XG4gICAgKi9cbiAgICB2YXIgZGVlcEVxdWFsID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gICAgICAgIHJldHVybiAoeCAmJiB5ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgeSA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgICAgIChPYmplY3Qua2V5cyh4KS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHkpLmxlbmd0aCkgJiYgT2JqZWN0LmtleXMoeCkucmVkdWNlKGZ1bmN0aW9uKGlzRXF1YWwsIGtleSkge3JldHVybiBpc0VxdWFsICYmIGRlZXBFcXVhbCh4W2tleV0sIHlba2V5XSk7fSwgdHJ1ZSk6XG4gICAgICAgICAgICAoeCA9PT0geSk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgY29weUFycmF5ID0gZnVuY3Rpb24oIGFycmF5VG9Db3B5ICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcnJheVRvQ29weS5sZW5ndGg7ICsraSApe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goIGFycmF5VG9Db3B5WyBpIF0gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBnZW5lcmljVG9TdHJpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApe1xuICAgIFxuICAgICAgICBpZiAoIGVsZW1lbnQgPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZWxlbWVudCApICl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJ0FycmF5WyAnO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7ICsraSApe1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBpID09PSAwPyAnJzogJywgJztcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2VwYXJhdG9yICsgZ2VuZXJpY1RvU3RyaW5nKCBlbGVtZW50WyBpIF0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnIF0nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCBpc1BsYWluT2JqZWN0KCBlbGVtZW50ICkgKXtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSggZWxlbWVudCApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBNdXN0IGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgICAgLy9pc0FycmF5OiBpc0FycmF5LFxuICAgICAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgICAgICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBkZWVwRXh0ZW5kOiBkZWVwRXh0ZW5kLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgZ2V0SlNPTjogZ2V0SlNPTixcbiAgICAgICAgYWpheDogYWpheCxcbiAgICAgICAgZGVlcEVxdWFsOiBkZWVwRXF1YWwsXG4gICAgICAgIGNvcHlBcnJheTogY29weUFycmF5LFxuICAgICAgICBnZW5lcmljVG9TdHJpbmc6IGdlbmVyaWNUb1N0cmluZ1xuICAgICAgICAvL2dldE5vZGVJZDogZ2V0Tm9kZUlkXG4gICAgfTtcbn0pKCk7XG4iLCIvLyBnZW5lcmF0ZWQgYnkgZ2VudmVyc2lvblxubW9kdWxlLmV4cG9ydHMgPSAnMC40MC4zJ1xuIiwiLyohIHp6ZG9tIC0gdjAuMi4wIC0gMjAyMC0xMS0xMiAxMzozMjo1MSAqL1xuLyoqXG4gKiBBIG5hbWVzcGFjZS5cbiAqIEBjb25zdFxuICovXG52YXIgenpET00gPSB7fTtcblxuLypcbiAgICB6eiBmdW5jdGlvblxuICAgIFxuICAgIHp6KCAnIycsICdpZCcgKTtcbiAgICB6eiggJy4nLCAnY2xhc3NOYW1lJyApO1xuICAgIHp6KCAndCcsICd0YWdOYW1lJyApO1xuICAgIHp6KCAndG4nLCAnbmFtZXNwYWNlJywgJ3RhZ05hbWUnICk7XG4gICAgenooICduJywgJ25hbWUnICk7XG4gICAgenooICdzJywgJ3N0cmluZyBzZWxlY3RvcicgKTtcbiAgICB6eiggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoICdpZCcgKSApOyAvLyBFbGVtZW50XG4gICAgenooIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoICdjbGFzc05hbWUnICkgKTsgLy8gSFRNTENvbGxlY3Rpb25cbiAgICB6eiggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoICduYW1lJyApICk7IC8vIE5vZGVMaXN0XG4gICAgenooICd0YWJsZS5jbGFzc05hbWUgdHIgdGQnICk7IC8vIFN0cmluZyBzZWxlY3RvclxuICAgIHp6KCAnPGRpdj5OZXcgZGl2PC9kaXY+JyApOyAvLyBIVE1MIGNvZGUgaW4gc3RyaW5nXG4qL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0fSB4XG4gKiBAcGFyYW0ge3N0cmluZz19IHMxXG4gKiBAcGFyYW0ge3N0cmluZz19IHMyIFxuICovXG56ekRPTS56eiA9IGZ1bmN0aW9uKCB4LCBzMSwgczIgKXtcbiAgICBcbiAgICAvLyBSZWRlZmluZSB4IGlmIGEgc2VsZWN0b3IgaWQgaXMgZm91bmRcbiAgICBpZiAoIHMxICl7XG4gICAgICAgIHN3aXRjaCAoIHggKXtcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICB4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIHMxICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICB4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggczEgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHggPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggczEgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0bic6XG4gICAgICAgICAgICB4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyggczEsIHMyIHx8ICcnICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICB4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIHMxICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICB4ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggczEgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIHNlbGVjdG9yIGlkIGZvdW5kIHJ1bm5pbmcgenogZnVuY3Rpb246ICcgKyB4O1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElzIGl0IGFuIEVsZW1lbnQ/XG4gICAgaWYgKCB4IGluc3RhbmNlb2YgRWxlbWVudCApe1xuICAgICAgICByZXR1cm4gbmV3IHp6RE9NLlNTKCB4ICk7XG4gICAgfVxuICAgIFxuICAgIC8vIElzIGl0IGFuIEhUTUxDb2xsZWN0aW9uIG9yIGEgTm9kZUxpc3Q/XG4gICAgaWYgKCB4IGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24gfHwgeCBpbnN0YW5jZW9mIE5vZGVMaXN0ICl7XG4gICAgICAgIHJldHVybiB6ekRPTS5fYnVpbGQoIHggKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCB0eXBlb2YgeCA9PT0gJ3N0cmluZycgKXtcbiAgICAgICAgeCA9IHgudHJpbSgpO1xuICAgICAgICByZXR1cm4genpET00uX2J1aWxkKFxuICAgICAgICAgICAgeC5jaGFyQXQoIDAgKSA9PT0gJzwnPyAvLyBJcyBpdCBIVE1MIGNvZGU/XG4gICAgICAgICAgICAgICAgenpET00uX2h0bWxUb0VsZW1lbnQoIHggKTpcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCB4ICkgLy8gTXVzdCBiZSBhIHN0YW5kYXJkIHNlbGVjdG9yXG4gICAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHRocm93ICdVbnN1cHBvcnRlZCBzZWxlY3RvciB0eXBlIGZvdW5kIHJ1bm5pbmcgenogZnVuY3Rpb24uJztcbn07XG5cbi8vIEJ1aWxkIGFyZ3MgYXJyYXkgd2l0aCB0b0luc2VydCBhcyBmaXJzdCBwb3NpdGlvbiBhbmQgdGhlbiB0aGUgYXJndW1lbnRzIG9mIHRoaXMgZnVuY3Rpb25cbnp6RE9NLl9hcmdzID0gZnVuY3Rpb24oIHByZXZpb3VzQXJncywgdG9JbnNlcnQgKXtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHByZXZpb3VzQXJncyApO1xuICAgIHJlc3VsdC5wdXNoKCB0b0luc2VydCApO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG56ekRPTS5fYnVpbGQgPSBmdW5jdGlvbiAoIHggKSB7XG4gICAgaWYgKCB4IGluc3RhbmNlb2YgRWxlbWVudCApe1xuICAgICAgICByZXR1cm4gbmV3IHp6RE9NLlNTKCB4ICk7XG4gICAgfVxuICAgIGlmICggeCBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uIHx8IHggaW5zdGFuY2VvZiBOb2RlTGlzdCApe1xuICAgICAgICB4ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHggKTtcbiAgICB9XG4gICAgcmV0dXJuIHgubGVuZ3RoID09PSAxPyBuZXcgenpET00uU1MoIHhbIDAgXSApOiBuZXcgenpET00uTU0oIHggKTtcbn07XG5cbnp6RE9NLl9nZXRFcnJvciA9IGZ1bmN0aW9uICggbWV0aG9kICkge1xuICAgIHJldHVybiAnTWV0aG9kIFwiJyArIG1ldGhvZCArICdcIiBub3QgcmVhZHkgZm9yIHRoYXQgdHlwZSEnO1xufTtcblxuenpET00uX2h0bWxUb0VsZW1lbnQgPSBmdW5jdGlvbiAoIGh0bWwgKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3RlbXBsYXRlJyApO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWwudHJpbSgpO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50ID09PSAxP1xuICAgICAgICB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQ6XG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2Rlcztcbn07XG5cbi8vIFJlZ2lzdGVyIHp6IGZ1bmN0aW9uXG52YXIgeno7XG4oZnVuY3Rpb24oKSB7IFxuICAgIHp6ID0genpET00ueno7IFxufSkoKTtcblxuenpET00uX2V2ZW50cyA9IHt9O1xuXG56ekRPTS5fYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCBzcywgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSApe1xuICAgIHZhciBlbCA9IHNzLmVsO1xuICAgIHZhciBlbElkID0gc3MuX2dldEVsSWQoKTtcbiAgICB2YXIgdGhpc0V2ZW50cyA9IHp6RE9NLl9ldmVudHNbIGVsSWQgXTtcbiAgICBpZiAoICEgdGhpc0V2ZW50cyApe1xuICAgICAgICB0aGlzRXZlbnRzID0ge307XG4gICAgICAgIHp6RE9NLl9ldmVudHNbIGVsSWQgXSA9IHRoaXNFdmVudHM7XG4gICAgfVxuICAgIHZhciB0aGlzTGlzdGVuZXJzID0gdGhpc0V2ZW50c1sgZXZlbnROYW1lIF07XG4gICAgaWYgKCAhIHRoaXNMaXN0ZW5lcnMgKXtcbiAgICAgICAgdGhpc0xpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzRXZlbnRzWyBldmVudE5hbWUgXSA9IHRoaXNMaXN0ZW5lcnM7XG4gICAgfVxuICAgIHRoaXNMaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgICBcbiAgICAvLyBhZGRFdmVudExpc3RlbmVyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lciggZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSApO1xufTtcblxuLy9UT0RPIG11c3QgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWRcbnp6RE9NLl9yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oIHNzLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlICl7XG4gICAgdmFyIGVsID0gc3MuZWw7XG4gICAgdmFyIGVsSWQgPSBzcy5fZ2V0RWxJZCgpO1xuICAgIHZhciB0aGlzRXZlbnRzID0genpET00uX2V2ZW50c1sgZWxJZCBdO1xuICAgIGlmICggISB0aGlzRXZlbnRzICl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKCAhIGV2ZW50TmFtZSApeyBcbiAgICAgICAgLy8gTXVzdCByZW1vdmUgYWxsIGV2ZW50c1xuICAgICAgICBmb3IgKCB2YXIgY3VycmVudEV2ZW50TmFtZSBpbiB0aGlzRXZlbnRzICl7XG4gICAgICAgICAgICB2YXIgY3VycmVudExpc3RlbmVycyA9IHRoaXNFdmVudHNbIGN1cnJlbnRFdmVudE5hbWUgXTtcbiAgICAgICAgICAgIHp6RE9NLl9yZW1vdmVMaXN0ZW5lcnMoIGVsLCBjdXJyZW50TGlzdGVuZXJzLCBudWxsLCB1c2VDYXB0dXJlLCBjdXJyZW50RXZlbnROYW1lICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBNdXN0IHJlbW92ZSBsaXN0ZW5lcnMgb2Ygb25seSBvbmUgZXZlbnRcbiAgICB2YXIgdGhpc0xpc3RlbmVycyA9IHRoaXNFdmVudHNbIGV2ZW50TmFtZSBdO1xuICAgIHp6RE9NLl9yZW1vdmVMaXN0ZW5lcnMoIGVsLCB0aGlzTGlzdGVuZXJzLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSwgZXZlbnROYW1lICk7XG59O1xuXG4vL1RPRE8gdGVzdCBhbGwgdGhlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZFxuenpET00uX3JlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCBlbCwgdGhpc0xpc3RlbmVycywgbGlzdGVuZXIsIHVzZUNhcHR1cmUsIGV2ZW50TmFtZSApe1xuICAgIGlmICggISB0aGlzTGlzdGVuZXJzICl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpc0xpc3RlbmVycy5sZW5ndGg7ICsraSApe1xuICAgICAgICB2YXIgY3VycmVudExpc3RlbmVyID0gdGhpc0xpc3RlbmVyc1sgaSBdO1xuICAgICAgICBpZiAoICEgbGlzdGVuZXIgfHwgY3VycmVudExpc3RlbmVyID09PSBsaXN0ZW5lciApe1xuICAgICAgICAgICAgdGhpc0xpc3RlbmVycy5zcGxpY2UoIGksIDEgKTsgLy8gRGVsZXRlIGxpc3RlbmVyIGF0IGkgcG9zaXRpb25cbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgY3VycmVudExpc3RlbmVyLCB1c2VDYXB0dXJlICk7XG4gICAgICAgICAgICBpZiAoIGxpc3RlbmVyICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBcbn07XG4vKiBFbmQgb2YgZXZlbnRzICovXG5cbnp6RE9NLl9kZCA9IHt9O1xuXG56ekRPTS5fZ2V0RGVmYXVsdERpc3BsYXkgPSBmdW5jdGlvbiggZWwgKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWwubm9kZU5hbWU7XG4gICAgdmFyIGRpc3BsYXkgPSB6ekRPTS5fZGRbIG5vZGVOYW1lIF07XG5cbiAgICBpZiAoIGRpc3BsYXkgKSB7XG4gICAgICAgIHJldHVybiBkaXNwbGF5O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICAgIHZhciB0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG4gICAgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoIHRlbXAgKVsgJ2Rpc3BsYXknIF07XG5cbiAgICB0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuICAgIGlmICggZGlzcGxheSA9PT0gJ25vbmUnICkge1xuICAgICAgICBkaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG4gICAgenpET00uX2RkWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuICAgIHJldHVybiBkaXNwbGF5O1xufTtcbi8qIEVuZCBvZiB2aXNpYmxlICovXG5cbi8qIEl0IGRlcGVuZHMgb24gZm9ybXMgcGx1Z2luISAqL1xuLy8gU2VyaWFsaXplIGEgc3MgaW5zdGFuY2UsIGEgbW0gaW5zdGFuY2Ugb3IgYW4gb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmdcbnp6RE9NLl9wYXJhbUl0ZW0gPSBmdW5jdGlvbiggciwga2V5LCB2YWx1ZSApIHtcbiAgICByLnB1c2goIFxuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsPyAnJzogdmFsdWUgKVxuICAgICk7XG59O1xuLyoqIEBub2NvbGxhcHNlICovXG56ekRPTS5wYXJhbSA9IGZ1bmN0aW9uKCB4ICkge1xuXHRcbiAgICBpZiAoIHggPT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciByID0gW107XG4gICAgXG4gICAgaWYgKCB4IGluc3RhbmNlb2YgenpET00uU1MgKXtcbiAgICAgICAgenpET00uX3BhcmFtSXRlbSggciwgeC5hdHRyKCAnbmFtZScgKSwgeC52YWwoKSApO1xuICAgIH0gZWxzZSBpZiAoIHggaW5zdGFuY2VvZiB6ekRPTS5NTSApe1xuICAgICAgICBmb3IgKCB2YXIgYyA9IDA7IGMgPCB4Lmxpc3QubGVuZ3RoOyArK2MgKXtcbiAgICAgICAgICAgIHZhciBzcyA9IHgubGlzdFsgYyBdO1xuICAgICAgICAgICAgenpET00uX3BhcmFtSXRlbSggciwgc3MuYXR0ciggJ25hbWUnICksIHNzLnZhbCgpICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgKXsgIFxuICAgICAgICBmb3IgKCB2YXIgaSBpbiB4ICkge1xuICAgICAgICAgICAgenpET00uX3BhcmFtSXRlbSggciwgaSwgeFsgaSBdICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB6ekRPTS5fZ2V0RXJyb3IoICdwYXJhbScgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gci5qb2luKCAnJicgKTtcbn07XG4vKiBlbmQgb2YgdXRpbHMgKi9cblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuenpET00uU1MgPSBmdW5jdGlvbiAoIF9lbCApIHtcbiAgICB0aGlzLmVsID0gX2VsO1xuICAgIHRoaXMubm9kZXMgPSBbIF9lbCBdO1xuICAgIFxuICAgIC8vIEFycmF5IGxpa2VcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpc1sgMCBdID0gX2VsO1xufTtcblxuLyogTWV0aG9kcyBOT1QgaW5jbHVkZWQgaW4ganF1ZXJ5ICovXG56ekRPTS5TUy5wcm90b3R5cGUuX2djcyA9IGZ1bmN0aW9uICggc2VsZiwgcHJvcGVydHkgKSB7XG4gICAgdmFyIHggPSBnZXRDb21wdXRlZFN0eWxlKCBzZWxmLmVsLCBudWxsIClbIHByb3BlcnR5IF0ucmVwbGFjZSggJ3B4JywgJycgKTtcbiAgICByZXR1cm4gaXNOYU4oIHggKT8geDogcGFyc2VGbG9hdCggeCApO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLl9nZXRFbElkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxJZCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKCAnZGF0YS1lbElkJyApO1xuICAgIGlmICggISBlbElkICl7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIHN0cmluZyB3aXRoIDQgY2hhcnNcbiAgICAgICAgZWxJZCA9IE1hdGguZmxvb3IoICggMSArIE1hdGgucmFuZG9tKCkgKSAqIDB4MTAwMDAgKVxuICAgICAgICAgICAgLnRvU3RyaW5nKCAxNiApXG4gICAgICAgICAgICAuc3Vic3RyaW5nKCAxICk7XG4gICAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCAnZGF0YS1lbElkJywgZWxJZCApO1xuICAgIH1cbiAgICByZXR1cm4gZWxJZDtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5faW5zZXJ0SGVscGVyID0gZnVuY3Rpb24gKCBwb3NpdGlvbiwgeCApIHtcbiAgICBpZiAoIHggaW5zdGFuY2VvZiBFbGVtZW50ICl7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCBwb3NpdGlvbiwgeCApO1xuICAgIH0gZWxzZSBpZiAoIHggaW5zdGFuY2VvZiB6ekRPTS5TUyApe1xuICAgICAgICB0aGlzLmVsLmluc2VydEFkamFjZW50RWxlbWVudCggcG9zaXRpb24sIHguZWwgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgeCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCBwb3NpdGlvbiwgeCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdJbnNlcnQgb3BlcmF0aW9uIG5vdCByZWFkeSBmb3IgdGhhdCB0eXBlISc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24oIHZhbHVlLCBmbiApe1xuICAgIGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApe1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSApe1xuICAgICAgICAgICAgZm4oIHRoaXMsIHZhbHVlWyBpIF0gKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZuKCB0aGlzLCB2YWx1ZSApOyAgIFxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5fb3V0ZXIgPSBmdW5jdGlvbiAoIHByb3BlcnR5LCBsaW5rZWQxLCBsaW5rZWQyLCB3aXRoTWFyZ2luICkge1xuICAgIGlmICggdGhpcy5lbFsgJ29mZnNldCcgKyBwcm9wZXJ0eSBdICkge1xuICAgICAgICByZXR1cm4genpET00uU1MuX291dGVyQ2FsYyggdGhpcywgcHJvcGVydHksIGxpbmtlZDEsIGxpbmtlZDIsIHdpdGhNYXJnaW4gKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9zd2FwKCBcbiAgICAgICAgdGhpcy5lbCwgXG4gICAgICAgIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4genpET00uU1MuX291dGVyQ2FsYyggc2VsZiwgcHJvcGVydHksIGxpbmtlZDEsIGxpbmtlZDIsIHdpdGhNYXJnaW4gKTtcbiAgICAgICAgfSBcbiAgICApO1xufTtcblxuenpET00uU1MuX291dGVyQ2FsYyA9IGZ1bmN0aW9uICggc3MsIHByb3BlcnR5LCBsaW5rZWQxLCBsaW5rZWQyLCB3aXRoTWFyZ2luICkge1xuICAgIHZhciB2YWx1ZSA9IHNzLl9nY3MoIHNzLCBwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpICk7XG4gICAgdmFyIHBhZGRpbmcgPSBzcy5fZ2NzKCBzcywgJ3BhZGRpbmcnICsgbGlua2VkMSApICsgc3MuX2djcyggc3MsICdwYWRkaW5nJyArIGxpbmtlZDIgKTtcbiAgICB2YXIgYm9yZGVyID0gc3MuX2djcyggc3MsICdib3JkZXInICsgbGlua2VkMSArICdXaWR0aCcgKSArIHNzLl9nY3MoIHNzLCAnYm9yZGVyJyArIGxpbmtlZDIgKyAnV2lkdGgnICk7XG4gICAgXG4gICAgdmFyIHRvdGFsID0gdmFsdWUgKyBwYWRkaW5nICsgYm9yZGVyO1xuICAgIFxuICAgIC8vIE5vIG1hcmdpblxuICAgIGlmICggISB3aXRoTWFyZ2luICl7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1hcmdpbiA9IHNzLl9nY3MoIHNzLCAnbWFyZ2luJyArIGxpbmtlZDEgKSArIHNzLl9nY3MoIHNzLCAnbWFyZ2luJyArIGxpbmtlZDIgKTtcbiAgICByZXR1cm4gdG90YWwgKyBtYXJnaW47XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuX3NldENzc1VzaW5nS2V5VmFsdWUgPSBmdW5jdGlvbiAoIGtleSwgdmFsdWUgKSB7XG4gICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCggdGhpcy5lbCwgdGhpcy5faSA9PT0gdW5kZWZpbmVkPyAwOiB0aGlzLl9pLCB0aGlzICk7XG4gICAgfVxuICAgIHRoaXMuZWwuc3R5bGVbIGtleSBdID0gXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgISAvXi0/XFxkK1xcLj9cXGQqJC8udGVzdCggdmFsdWUgKT8gLy8gaWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlzIG5vdCBhIGZsb2F0IG51bWJlclxuICAgICAgICAgICAgdmFsdWU6IFxuICAgICAgICAgICAgdmFsdWUgKyAncHgnO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLl9zZXRDc3NVc2luZ09iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuICAgIGZvciAoIHZhciBrZXkgaW4gb2JqZWN0ICkge1xuICAgICAgICB0aGlzLl9zZXRDc3NVc2luZ0tleVZhbHVlKCBrZXksIG9iamVjdFsga2V5IF0gKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb249fSB2YWx1ZVxuICovXG56ekRPTS5TUy5wcm90b3R5cGUuX3N0eWxlUHJvcGVydHkgPSBmdW5jdGlvbiAoIHByb3BlcnR5LCB2YWx1ZSApIHtcbiAgICAvLyBnZXRcbiAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2djcyggdGhpcywgcHJvcGVydHkgKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoIFxuICAgICAgICAgICAgdmFsdWUgIT09ICdhdXRvJz8gXG4gICAgICAgICAgICAgICAgdmFsdWU6IFxuICAgICAgICAgICAgICAgIHRoaXMuX3N3YXAoIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLCBcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nY3MoIHNlbGYsIHByb3BlcnR5ICk7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldFxuICAgIHRoaXMuX3NldENzc1VzaW5nS2V5VmFsdWUoIHByb3BlcnR5LCB2YWx1ZSApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24oIF9lbCwgY2FsbGJhY2sgKSB7XG4gICAgdmFyIG9sZCA9IHt9O1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgICB9O1xuXG4gICAgLy8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICBvbGRbIG5hbWUgXSA9IF9lbC5zdHlsZVsgbmFtZSBdO1xuICAgICAgICBfZWwuc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gY2FsbGJhY2suY2FsbCggX2VsICk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgIF9lbC5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8qIE1ldGhvZHMgaW5jbHVkZWQgaW4ganF1ZXJ5ICovXG56ekRPTS5TUy5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXJhdGUoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZ1bmN0aW9uKCBzZWxmLCB2ICl7XG4gICAgICAgICAgICBzZWxmLmVsLmNsYXNzTGlzdC5hZGQoIHYgKTsgXG4gICAgICAgIH1cbiAgICApO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmFmdGVyID0gZnVuY3Rpb24gKCB4ICkge1xuICAgIHJldHVybiB0aGlzLl9pbnNlcnRIZWxwZXIoICdhZnRlcmVuZCcsIHggKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoIHggKSB7XG4gICAgaWYgKCB4IGluc3RhbmNlb2YgRWxlbWVudCApe1xuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKCB4ICk7XG4gICAgfSBlbHNlIGlmICggeCBpbnN0YW5jZW9mIHp6RE9NLlNTICl7XG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoIHguZWwgKTtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgeCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCAnYmVmb3JlZW5kJywgeCApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHp6RE9NLl9nZXRFcnJvciggJ2FwcGVuZCcgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbiAoIHggKSB7XG4gICAgLy8gRG8gbm90aGluZyBhbmQgcmV0dXJuIHRoaXMgaWYgaXQgaXMgbnVsbFxuICAgIGlmICggeCA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gSXMgaXQgYSBFbGVtZW50P1xuICAgIGlmICggeCBpbnN0YW5jZW9mIEVsZW1lbnQgKXtcbiAgICAgICAgeC5hcHBlbmRDaGlsZCggdGhpcy5lbCApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgXG4gICAgLy8gSXMgaXQgYSBzdHJpbmc/XG4gICAgaWYgKCB0eXBlb2YgeCA9PT0gJ3N0cmluZycgKXtcbiAgICAgICAgeCA9IHp6RE9NLl9idWlsZChcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIHggKVxuICAgICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBJcyBpdCBhIHp6RE9NLlNTP1xuICAgIGlmICggeCBpbnN0YW5jZW9mIHp6RE9NLlNTICkge1xuICAgICAgICB4LmVsLmFwcGVuZENoaWxkKCB0aGlzLmVsICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBcbiAgICAvLyBJcyBpdCBhIHp6RE9NLk1NP1xuICAgIGlmICggeCBpbnN0YW5jZW9mIHp6RE9NLk1NICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB4Lm5vZGVzLmxlbmd0aDsgKytpICl7XG4gICAgICAgICAgICB4Lm5vZGVzWyBpIF0uYXBwZW5kQ2hpbGQoIHRoaXMuZWwuY2xvbmVOb2RlKCB0cnVlICkgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IFxuICAgIFxuICAgIHRocm93IHp6RE9NLl9nZXRFcnJvciggJ2lzJyApO1xufTtcblxuLy9UT0RPIGFkZCBzdXBwb3J0IG9mIGZ1bmN0aW9uIHR5cGUgaW4gdmFsdWVcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSB4XG4gKiBAcGFyYW0ge3N0cmluZz19IHZhbHVlXG4gKi9cbnp6RE9NLlNTLnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24gKCB4LCB2YWx1ZSApIHtcbiAgICAvLyBzZXQgdXNpbmcgb2JqZWN0XG4gICAgaWYgKCB0eXBlb2YgeCA9PT0gJ29iamVjdCcgKXtcbiAgICAgICAgZm9yICggdmFyIGtleSBpbiB4ICkge1xuICAgICAgICAgICAgdGhpcy5hdHRyKCBrZXksIHhbIGtleSBdICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFxuICAgIC8vIGdldFxuICAgIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoIHggKTtcbiAgICB9XG4gICAgXG4gICAgLy8gcmVtb3ZlIGF0dHJcbiAgICBpZiAoIHZhbHVlID09PSBudWxsICl7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUF0dHIoIHggKTsgICAgXG4gICAgfVxuICAgIFxuICAgIC8vIHNldFxuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCB4LCB2YWx1ZSApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uICggeCApIHtcbiAgICByZXR1cm4gdGhpcy5faW5zZXJ0SGVscGVyKCAnYmVmb3JlYmVnaW4nLCB4ICk7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuICAgIHJldHVybiB6ekRPTS5fYnVpbGQoIFxuICAgICAgICBzZWxlY3Rvcj9cbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmNoaWxkcmVuLCBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm1hdGNoZXMoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTpcbiAgICAgICAgICAgIHRoaXMuZWwuY2hpbGRyZW4gXG4gICAgKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggICkge1xuICAgIHJldHVybiBuZXcgenpET00uU1MoIHRoaXMuZWwuY2xvbmVOb2RlKCB0cnVlICkgKTtcbn07XG5cbi8vVE9ETyBhZGQgc3VwcG9ydCBvZiBmdW5jdGlvbiB0eXBlIGluIHZhbHVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0geDFcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IHgyXG4gKi9cbnp6RE9NLlNTLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoIHgxLCB4MiApIHtcbiAgICB2YXIgbnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBcbiAgICBpZiAoIG51bWJlciA9PT0gMSApe1xuICAgICAgICBpZiAoICEgeDEgKXtcbiAgICAgICAgICAgIHRocm93ICdOdWxsIHZhbHVlIG5vdCBhbGxvd2VkIGluIGNzcyBtZXRob2QhJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZ2V0XG4gICAgICAgIGlmICggdHlwZW9mIHgxID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsIClbIHgxIF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHNldCB1c2luZyBvYmplY3RcbiAgICAgICAgaWYgKCB0eXBlb2YgeDEgPT09ICdvYmplY3QnICl7XG4gICAgICAgICAgICB0aGlzLl9zZXRDc3NVc2luZ09iamVjdCggeDEgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aHJvdyAnV3JvbmcgdHlwZSBvciBhcmd1bWVudCBpbiBjc3MgbWV0aG9kISc7XG4gICAgfVxuICAgIFxuICAgIC8vIHNldCB1c2luZyBrZXkgdmFsdWUgcGFpclxuICAgIGlmICggbnVtYmVyID09PSAyICl7XG4gICAgICAgIHRoaXMuX3NldENzc1VzaW5nS2V5VmFsdWUoIHgxLCB4MiApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgaW4gY3NzIG1ldGhvZCEnO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoIGVhY2hGbiApIHtcbiAgICBlYWNoRm4uY2FsbCggdGhpcy5lbCwgMCwgdGhpcywgdGhpcy5ub2RlcyApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCAgKSB7XG4gICAgd2hpbGUoIHRoaXMuZWwuZmlyc3RDaGlsZCApe1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKCB0aGlzLmVsLmZpcnN0Q2hpbGQgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKCB4ICkge1xuICAgIGlmICggdHlwZW9mIHggPT09ICdzdHJpbmcnICl7IC8vIElzIGEgc3RyaW5nIHNlbGVjdG9yXG4gICAgICAgIHJldHVybiB6ekRPTS5fYnVpbGQoIFxuICAgICAgICAgICAgdGhpcy5lbC5tYXRjaGVzKCB4ICk/IFsgdGhpcy5lbCBdOiBbXVxuICAgICAgICApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICl7IC8vIElzIGEgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHp6RE9NLl9idWlsZChcbiAgICAgICAgICAgIHguY2FsbCggdGhpcy5lbCwgdGhpcy5faSA9PT0gdW5kZWZpbmVkPyAwOiB0aGlzLl9pLCB0aGlzICk/IFsgdGhpcy5lbCBdOiBbXVxuICAgICAgICApO1xuICAgIH0gIFxuICAgIFxuICAgIHRocm93IHp6RE9NLl9nZXRFcnJvciggJ2ZpbHRlcicgKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcbiAgICByZXR1cm4genpET00uX2J1aWxkKCBcbiAgICAgICAgdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApXG4gICAgKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICByZXR1cm4gdGhpcy5lbC5jbGFzc0xpc3QuY29udGFpbnMoIG5hbWUgKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZVByb3BlcnR5KCAnaGVpZ2h0JywgdmFsdWUgKTtcbn07XG5cbi8vVE9ETyBhZGQgc3VwcG9ydCBvZiBmdW5jdGlvbiB0eXBlIGluIHZhbHVlXG56ekRPTS5TUy5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgLy8gZ2V0XG4gICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmlubmVySFRNTDtcbiAgICB9XG5cbiAgICAvLyBzZXRcbiAgICB0aGlzLmVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggISB0aGlzLmVsICl7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjdXJyZW50RWwgPSB0aGlzLmVsO1xuICAgIGRvIHtcbiAgICAgICAgaSsrO1xuICAgIH0gd2hpbGUgKCBjdXJyZW50RWwgPSBjdXJyZW50RWwucHJldmlvdXNFbGVtZW50U2libGluZyApO1xuICAgIFxuICAgIHJldHVybiBpO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKCB4ICkge1xuICAgIGlmICggeCA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgICAgXG4gICAgfVxuICAgIFxuICAgIGlmICggeCBpbnN0YW5jZW9mIEVsZW1lbnQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwgPT09IHg7XG4gICAgfVxuICAgIFxuICAgIGlmICggeCBpbnN0YW5jZW9mIHp6RE9NLlNTICkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbCA9PT0geC5lbDtcbiAgICB9IFxuXG4gICAgaWYgKCB4IGluc3RhbmNlb2YgenpET00uTU0gKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHgubm9kZXMubGVuZ3RoOyArK2kgKXtcbiAgICAgICAgICAgIGlmICggdGhpcy5lbCA9PT0geC5ub2Rlc1sgaSBdICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gXG5cbiAgICBpZiAoIHR5cGVvZiB4ID09PSAnc3RyaW5nJyApe1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5tYXRjaGVzKCB4ICk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgenpET00uU1MoIHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nICk7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKCBjICkge1xuICAgIFxuICAgIC8vIHNldCB0b3AgYW5kIGxlZnQgdXNpbmcgY3NzXG4gICAgaWYgKCBjICl7XG4gICAgICAgIHRoaXMuX3N0eWxlUHJvcGVydHkoICd0b3AnLCBjLnRvcCApO1xuICAgICAgICB0aGlzLl9zdHlsZVByb3BlcnR5KCAnbGVmdCcsIGMubGVmdCApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgXG4gICAgLy8gZ2V0XG4gICAgdmFyIHJlY3QgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XG4gICAgfTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5vZmZzZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IHRoaXMuZWwub2Zmc2V0UGFyZW50O1xuICAgIHJldHVybiBvZmZzZXRQYXJlbnQ/IG5ldyB6ekRPTS5TUyggb2Zmc2V0UGFyZW50ICk6IHRoaXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHdpdGhNYXJnaW5cbiAqL1xuenpET00uU1MucHJvdG90eXBlLm91dGVySGVpZ2h0ID0gZnVuY3Rpb24gKCB3aXRoTWFyZ2luICkge1xuICAgIHJldHVybiB0aGlzLl9vdXRlciggJ0hlaWdodCcsICdUb3AnLCAnQm90dG9tJywgd2l0aE1hcmdpbiApO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB3aXRoTWFyZ2luXG4gKi9cbnp6RE9NLlNTLnByb3RvdHlwZS5vdXRlcldpZHRoID0gZnVuY3Rpb24gKCB3aXRoTWFyZ2luICkge1xuICAgIHJldHVybiB0aGlzLl9vdXRlciggJ1dpZHRoJywgJ0xlZnQnLCAnUmlnaHQnLCB3aXRoTWFyZ2luICk7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgenpET00uU1MoIHRoaXMuZWwucGFyZW50Tm9kZSApO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCByZWxhdGl2ZVRvVmlld3BvcnQgKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlVG9WaWV3cG9ydD9cbiAgICAgICAgdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTpcbiAgICAgICAgeyBcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuZWwub2Zmc2V0TGVmdCwgXG4gICAgICAgICAgICB0b3A6IHRoaXMuZWwub2Zmc2V0VG9wXG4gICAgICAgIH07XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uICggeCApIHtcbiAgICBpZiAoIHggaW5zdGFuY2VvZiBFbGVtZW50ICl7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QmVmb3JlKCB4LCB0aGlzLmVsLmZpcnN0Q2hpbGQgKTtcbiAgICB9IGVsc2UgaWYgKCB4IGluc3RhbmNlb2YgenpET00uU1MgKXtcbiAgICAgICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUoIHguZWwsIHRoaXMuZWwuZmlyc3RDaGlsZCApO1xuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB4ID09PSAnc3RyaW5nJyApe1xuICAgICAgICB0aGlzLmVsLmluc2VydEFkamFjZW50SFRNTCggJ2FmdGVyYmVnaW4nLCB4ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgenpET00uX2dldEVycm9yKCAncHJlcGVuZCcgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IHp6RE9NLlNTKCB0aGlzLmVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmVsICk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUucmVtb3ZlQXR0ciA9IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKCBuYW1lICkge1xuICAgIGlmICggISBuYW1lICl7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gJyc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGhpcy5faXRlcmF0ZShcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZnVuY3Rpb24oIHNlbGYsIHYgKXtcbiAgICAgICAgICAgIHNlbGYuZWwuY2xhc3NMaXN0LnJlbW92ZSggdiApO1xuICAgICAgICB9XG4gICAgKTtcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgdGhpcy5lbC5vdXRlckhUTUwgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS5zaWJsaW5ncyA9IGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCggXG4gICAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5jaGlsZHJlbiwgXG4gICAgICAgIHNlbGVjdG9yP1xuICAgICAgICAgICAgZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkICE9PSBzZWxmLmVsICYmIGNoaWxkLm1hdGNoZXMoIHNlbGVjdG9yICk7XG4gICAgICAgICAgICB9OlxuICAgICAgICAgICAgZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkICE9PSBzZWxmLmVsO1xuICAgICAgICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHp6RE9NLl9idWlsZCggbm9kZXMgKTtcbn07XG5cbi8vVE9ETyBhZGQgc3VwcG9ydCBvZiBmdW5jdGlvbiB0eXBlIGluIHZhbHVlXG56ekRPTS5TUy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgLy8gZ2V0XG4gICAgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50O1xuICAgIH1cblxuICAgIC8vIHNldFxuICAgIHRoaXMuZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uICggbmFtZSwgc3RhdGUgKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXJhdGUoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN0YXRlID09PSB1bmRlZmluZWQ/XG4gICAgICAgICAgICBmdW5jdGlvbiggc2VsZiwgdiApe1xuICAgICAgICAgICAgICAgIHNlbGYuZWwuY2xhc3NMaXN0LnRvZ2dsZSggdiApO1xuICAgICAgICAgICAgfTpcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBzZWxmLCB2ICl7XG4gICAgICAgICAgICAgICAgc2VsZi5lbC5jbGFzc0xpc3QudG9nZ2xlKCB2LCBzdGF0ZSApO1xuICAgICAgICAgICAgfVxuICAgICk7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIHJldHVybiB0aGlzLl9zdHlsZVByb3BlcnR5KCAnd2lkdGgnLCB2YWx1ZSApO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICggZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSApIHtcbiAgICB6ekRPTS5fcmVtb3ZlRXZlbnRMaXN0ZW5lciggdGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCBldmVudE5hbWUsIGxpc3RlbmVyLCBkYXRhLCB1c2VDYXB0dXJlICkge1xuICAgIHp6RE9NLl9hZGRFdmVudExpc3RlbmVyKCBcbiAgICAgICAgdGhpcywgXG4gICAgICAgIGV2ZW50TmFtZSwgXG4gICAgICAgIGRhdGE/IFxuICAgICAgICAgICAgZnVuY3Rpb24oIGUgKXtcbiAgICAgICAgICAgICAgICBlLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKCBlLmN1cnJlbnRUYXJnZXQsIGUgKTtcbiAgICAgICAgICAgIH06XG4gICAgICAgICAgICBsaXN0ZW5lciwgXG4gICAgICAgIHVzZUNhcHR1cmUgXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnp6RE9NLlNTLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKCBldmVudE5hbWUgKSB7XG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoICdIVE1MRXZlbnRzJyApO1xuICAgIGV2ZW50LmluaXRFdmVudCggZXZlbnROYW1lLCB0cnVlLCBmYWxzZSApO1xuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4vKiBFbmQgb2YgZXZlbnRzICovXG5cbnp6RE9NLlNTLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICggdGhpcy5pc1Zpc2libGUoKSApe1xuICAgICAgICB0aGlzLmF0dHIoIFxuICAgICAgICAgICAgJ2RhdGEtZGlzcGxheScsIFxuICAgICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbCwgbnVsbCApWyAnZGlzcGxheScgXVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEgdGhpcy5lbC5vZmZzZXRQYXJlbnQ7XG4gICAgLy9yZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbCwgbnVsbCApLmdldFByb3BlcnR5VmFsdWUoICdkaXNwbGF5JyApICE9PSAnbm9uZSc7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoICEgdGhpcy5pc1Zpc2libGUoKSApe1xuICAgICAgICB2YXIgZGlzcGxheSA9IHRoaXMuYXR0ciggJ2RhdGEtZGlzcGxheScgKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheT8gZGlzcGxheTogenpET00uX2dldERlZmF1bHREaXNwbGF5KCB0aGlzLmVsICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICggc3RhdGUgKSB7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUgIT09IHVuZGVmaW5lZD8gISBzdGF0ZTogdGhpcy5pc1Zpc2libGUoKTtcbiAgICByZXR1cm4gdmFsdWU/IHRoaXMuaGlkZSgpOiB0aGlzLnNob3coKTtcbn07XG4vKiBFbmQgb2YgdmlzaWJsZSAqL1xuXG56ekRPTS5TUy5wcm90b3R5cGUuY2hlY2tlZCA9IGZ1bmN0aW9uICggY2hlY2sgKSB7XG4gICAgaWYgKCB0aGlzLmVsLm5vZGVOYW1lICE9PSAnSU5QVVQnIHx8ICggdGhpcy5lbC50eXBlICE9PSAnY2hlY2tib3gnICYmIHRoaXMuZWwudHlwZSAhPT0gJ3JhZGlvJykgKSB7XG4gICAgICAgIHRocm93IHp6RE9NLl9nZXRFcnJvciggJ2NoZWNrZWQnICk7XG4gICAgfVxuICAgIFxuICAgIC8vIGdldFxuICAgIGlmICggY2hlY2sgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gISEgdGhpcy5lbC5jaGVja2VkO1xuICAgIH1cbiAgICBcbiAgICAvLyBzZXRcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBjaGVjaztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTw/PnxTdHJpbmc9fSB2YWx1ZVxuICovXG56ekRPTS5TUy5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICAvLyBnZXRcbiAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgc3dpdGNoICggdGhpcy5lbC5ub2RlTmFtZSApIHtcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICBjYXNlICdURVhUQVJFQSc6XG4gICAgICAgIGNhc2UgJ0JVVFRPTic6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC52YWx1ZTtcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZWwubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aGlzLmVsWyBpIF0uc2VsZWN0ZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmVsWyBpIF0udmFsdWUgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA+IDE/IHZhbHVlczogdmFsdWVzWyAwIF07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyB6ekRPTS5fZ2V0RXJyb3IoICd2YWwnICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gc2V0XG4gICAgc3dpdGNoICggdGhpcy5lbC5ub2RlTmFtZSApIHtcbiAgICBjYXNlICdJTlBVVCc6XG4gICAgY2FzZSAnVEVYVEFSRUEnOlxuICAgIGNhc2UgJ0JVVFRPTic6XG4gICAgICAgIHRoaXMuZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU0VMRUNUJzpcbiAgICAgICAgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFsgdmFsdWUgXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRoaXMuZWwubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7ICsraiApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsWyBpIF0uc2VsZWN0ZWQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoIHRoaXMuZWxbIGkgXS52YWx1ZSA9PT0gdmFsdWVbIGogXSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbFsgaSBdLnNlbGVjdGVkID0gJ3NlbGVjdGVkJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHp6RE9NLl9nZXRFcnJvciggJ3ZhbCcgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyogRW5kIG9mIGZvcm1zICovXG5cbnp6RE9NLlNTLnByb3RvdHlwZS5nZXRYQ2VudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gdGhpcy5vdXRlcldpZHRoKCkgKSAvIDI7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuZ2V0WUNlbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgLSB0aGlzLm91dGVySGVpZ2h0KCkgKSAvIDI7XG59O1xuXG56ekRPTS5TUy5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogdGhpcy5nZXRYQ2VudGVyKCksXG4gICAgICAgIHRvcDogdGhpcy5nZXRZQ2VudGVyKClcbiAgICB9O1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub2Zmc2V0KCBcbiAgICAgICAgdGhpcy5nZXRDZW50ZXIoKSBcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmNlbnRlclggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNzcyggJ2xlZnQnLCB0aGlzLmdldFhDZW50ZXIoKSApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuenpET00uU1MucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNzcyggJ3RvcCcsIHRoaXMuZ2V0WUNlbnRlcigpICk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyogRW5kIG9mIGNlbnRlciAqL1xuXG4vKiogQGNvbnN0cnVjdG9yICovXG56ekRPTS5NTSA9IGZ1bmN0aW9uICggX25vZGVzICkgeyAgICBcbiAgICB0aGlzLmxpc3QgPSBbXTtcbiAgICB0aGlzLm5vZGVzID0gX25vZGVzO1xuICAgIHRoaXMubGVuZ3RoID0gX25vZGVzLmxlbmd0aDtcbiAgICBcbiAgICAvLyBJbml0IG5vZGVzXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5ub2Rlc1sgaSBdO1xuICAgICAgICB0aGlzWyBpIF0gPSBlbDsgLy8gZm9yIGFycmF5IGxpa2VcbiAgICAgICAgdmFyIHNzID0gbmV3IHp6RE9NLlNTKCBlbCApO1xuICAgICAgICB0aGlzLmxpc3QucHVzaCggc3MgKTtcbiAgICAgICAgc3MuX2kgPSBpOyAvLyBmb3IgaW5kZXggaW4gZnVuY3Rpb25zXG4gICAgfVxufTtcblxuLypcblVuaWZ5IHRoZSBkZWZpbml0aW9uIG9mIGEgZnVuY3Rpb24gb2YgenpET00uU1MucHJvdG90eXBlIGFuZCBhIGRlZmluaXRpb24gb2YgenpET00uTU0ucHJvdG90eXBlLiBFeGFtcGxlOlxuXG4gICAgenpET00uYWRkKCBcbiAgICAgICAgenpET00uU1MucHJvdG90eXBlLm15Q3VzdG9tRnVuY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgenpET00uTU0uY29uc3RydWN0b3JzLmNvbmNhdFxuICAgICk7XG4pO1xuKi9cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3NQcm90b3R5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBjb25zdHJ1Y3RvclxuICovXG56ekRPTS5hZGQgPSBmdW5jdGlvbiggc3NQcm90b3R5cGUsIGNvbnN0cnVjdG9yICl7XG4gICAgZm9yICggdmFyIGlkIGluIHp6RE9NLlNTLnByb3RvdHlwZSApe1xuICAgICAgICB2YXIgY3VycmVudCA9IHp6RE9NLlNTLnByb3RvdHlwZVsgaWQgXTtcbiAgICAgICAgaWYgKCBzc1Byb3RvdHlwZSA9PT0gY3VycmVudCApe1xuICAgICAgICAgICAgdmFyIGNsb3N1cmUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbklkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yPyBjb25zdHJ1Y3RvciggZnVuY3Rpb25JZCApOiB6ekRPTS5NTS5jb25zdHJ1Y3RvcnMuZGVmYXVsdCggZnVuY3Rpb25JZCApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHp6RE9NLk1NLnByb3RvdHlwZVsgaWQgXSA9IGNsb3N1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aHJvdyAnRXJyb3IgcmVnaXN0ZXJpbmcgenpET00uTU06IHp6RE9NLlNTIG5vdCBmb3VuZC4nO1xufTtcblxuenpET00uTU0uY29uc3RydWN0b3JzID0ge307XG56ekRPTS5NTS5jb25zdHJ1Y3RvcnMuYm9vbGVhbk9yID0gZnVuY3Rpb24oIGZ1bmN0aW9uSWQgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHNzID0gdGhpcy5saXN0WyBpIF07XG4gICAgICAgICAgICB2YXIgeCA9IHNzWyBmdW5jdGlvbklkIF0uYXBwbHkoIHNzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIGlmICggeCApe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufTtcbnp6RE9NLk1NLmNvbnN0cnVjdG9ycy5jb25jYXQgPSBmdW5jdGlvbiggZnVuY3Rpb25JZCApe1xuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHNzID0gdGhpcy5saXN0WyBpIF07XG4gICAgICAgICAgICB2YXIgeCA9IHNzWyBmdW5jdGlvbklkIF0uYXBwbHkoIHNzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIG5ld05vZGVzID0gbmV3Tm9kZXMuY29uY2F0KCB4Lm5vZGVzICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHp6RE9NLl9idWlsZCggbmV3Tm9kZXMgKTtcbiAgICB9O1xufTtcbnp6RE9NLk1NLmNvbnN0cnVjdG9ycy5kZWZhdWx0ID0gZnVuY3Rpb24oIGZ1bmN0aW9uSWQgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIHNzID0gdGhpcy5saXN0WyBpIF07XG4gICAgICAgICAgICB2YXIgciA9IHNzWyBmdW5jdGlvbklkIF0uYXBwbHkoIHNzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIGlmICggaSA9PT0gMCAmJiAhICggciBpbnN0YW5jZW9mIHp6RE9NLlNTICkgKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufTtcblxuLy8gSW5pdCBwcm90b3R5cGUgZnVuY3Rpb25zIGZyb20genpET00uU1Ncbnp6RE9NLk1NLmluaXQgPSBmdW5jdGlvbigpe1xuICAgIC8vIENvbmNhdCBmdW5jdGlvbnNcbiAgICB2YXIgY29uY2F0RiA9IFtcbiAgICAgICAgJ2NoaWxkcmVuJyxcbiAgICAgICAgJ2Nsb25lJyxcbiAgICAgICAgJ2ZpbHRlcicsXG4gICAgICAgICdmaW5kJyxcbiAgICAgICAgJ25leHQnLFxuICAgICAgICAnb2Zmc2V0UGFyZW50JyxcbiAgICAgICAgJ3BhcmVudCcsXG4gICAgICAgICdwcmV2JyxcbiAgICAgICAgJ3NpYmxpbmdzJ1xuICAgIF07XG4gICAgLy8gQm9vbGVhbiBmdW5jdGlvbnNcbiAgICB2YXIgYm9vbGVhbk9yRiA9IFtcbiAgICAgICAgJ2hhc0NsYXNzJyxcbiAgICAgICAgJ2lzJ1xuICAgIF07XG4gICAgZm9yICggdmFyIGlkIGluIHp6RE9NLlNTLnByb3RvdHlwZSApe1xuICAgICAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25JZCA9IGlkO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIGNvbmNhdEYuaW5kZXhPZiggZnVuY3Rpb25JZCApICE9PSAtMSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB6ekRPTS5NTS5jb25zdHJ1Y3RvcnMuY29uY2F0KCBmdW5jdGlvbklkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGJvb2xlYW5PckYuaW5kZXhPZiggZnVuY3Rpb25JZCApICE9PSAtMSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB6ekRPTS5NTS5jb25zdHJ1Y3RvcnMuYm9vbGVhbk9yKCBmdW5jdGlvbklkICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4genpET00uTU0uY29uc3RydWN0b3JzLmRlZmF1bHQoIGZ1bmN0aW9uSWQgKTtcbiAgICAgICAgfTtcbiAgICAgICAgenpET00uTU0ucHJvdG90eXBlWyBpZCBdID0gY2xvc3VyZSgpO1xuICAgIH1cbn0oKTtcblxuLyogTWV0aG9kcyBpbmNsdWRlZCBpbiBqcXVlcnkgKi9cbnp6RE9NLk1NLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKCBlYWNoRm4gKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoIFxuICAgICAgICB0aGlzLmxpc3QsIFxuICAgICAgICBmdW5jdGlvbiggY3VycmVudFZhbHVlLCBpbmRleCApe1xuICAgICAgICAgICAgZWFjaEZuLmNhbGwoIGN1cnJlbnRWYWx1ZS5lbCwgaW5kZXgsIGN1cnJlbnRWYWx1ZSwgc2VsZi5ub2RlcyApO1xuICAgICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJlZ2lzdGVyIHp6RE9NIGlmIHdlIGFyZSB1c2luZyBOb2RlXG5pZiAoIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIG1vZHVsZS5leHBvcnRzID0genpET007XG59XG4iLCJ2YXIgenpET00gPSByZXF1aXJlKCcuL2J1aWxkL3p6RE9NLWNsb3N1cmVzLWZ1bGwuanMnKTtcbm1vZHVsZS5leHBvcnRzID0genpET00ueno7XG4iLCJ2YXIgUXVuaXQgPSByZXF1aXJlKCAncXVuaXQnICk7XG52YXIgenogPSByZXF1aXJlKCAnenpkb20nICk7XG52YXIgenB0ID0gcmVxdWlyZSggJ3pwdCcgKTtcbnZhciBibHVlUm91dGVyID0gcmVxdWlyZSggJy4uLy4uL2J1aWxkL2JsdWVSb3V0ZXIuanMnICk7XG5cbi8vIEluaXQgcm91dGVyXG5jb25zdCBpbml0Um91dGVyID0gKCkgPT4ge1xuICAgIC8vIEluaXRpYWxpemUgcGFnZXNcbiAgICBjb25zdCBwYWdlcyA9IHt9O1xuXG4gICAgLy8gTG9hZCBqcyBvZiBwYWdlc1xuICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB7fTtcbiAgICBwYWdlc1sgJ3JlbmRlcldpdGhvdXRXYWl0aW5nJyBdID0gcmVxdWlyZSggJy4vcGFnZXMvcmVuZGVyV2l0aG91dFdhaXRpbmcuanMnICkoIGRpY3Rpb25hcnkgKTtcbiAgICBwYWdlc1sgJ3JlbmRlcldhaXRpbmdGb3JTZXJ2ZXInIF0gPSByZXF1aXJlKCAnLi9wYWdlcy9yZW5kZXJXYWl0aW5nRm9yU2VydmVyLmpzJyApKCBkaWN0aW9uYXJ5ICk7XG5cbiAgICAvLyBJbml0aWFsaXplIG9wdGlvbnM6IG5vIGFuaW1hdGlvbnNcbiAgICBsZXQgaW5pdGlhbGl6ZVpQVCA9IHRydWU7XG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIGV2ZW50c0J5UGFnZTogcGFnZXMsXG4gICAgICAgIGFuaW1hdGlvbk91dDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbkluOiBmYWxzZSxcbiAgICAgICAgcm91dGVzOiByZXF1aXJlKCAnLi9yb3V0ZXNJbmxpbmVGb3JSZW5kZXIuanMnIClcbiAgICB9O1xuXG4gICAgLy8gQWRkIHJlbmRlckZ1bmN0aW9uXG4gICAgb3B0aW9ucy5yZW5kZXJGdW5jdGlvbiA9ICggcGFnZSApID0+IHtcbiAgICAgICAgaWYgKCBpbml0aWFsaXplWlBUICl7XG4gICAgICAgICAgICB6cHQucnVuKHtcbiAgICAgICAgICAgICAgICAncm9vdCc6IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgICAgJ2RpY3Rpb25hcnknOiBkaWN0aW9uYXJ5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluaXRpYWxpemVaUFQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHpwdC5ydW4oe1xuICAgICAgICAgICAgICAgICdjb21tYW5kJzogJ3BhcnRpYWxSZW5kZXInLFxuICAgICAgICAgICAgICAgICd0YXJnZXQnOiBwYWdlWyAnZWwnIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBuZXcgcm91dGVyIGluc3RhbmNlXG4gICAgcmV0dXJuIG5ldyBibHVlUm91dGVyLnJvdXRlciggb3B0aW9ucyApO1xufTtcblxuLy8gSW5pdCByb3V0ZXJcbmNvbnN0IHJvdXRlciA9IGluaXRSb3V0ZXIoKTtcblxuLy8gVW5pdCB0ZXN0c1xucmVxdWlyZSggJy4vcmVuZGVyLmpzJyApKCk7XG5cbiIsIi8qIHJlbmRlcldpdGhvdXRXYWl0aW5nIHBhZ2UgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBkaWN0aW9uYXJ5ICkge1xuICAgIFxuICAgIHZhciB6cHQgPSByZXF1aXJlKCAnenB0JyApO1xuXG4gICAgY29uc3QgcGFnZSA9IHt9O1xuXG4gICAgcGFnZVsgJ3ByZUluaXQnIF0gPSBmdW5jdGlvbiggZXZlbnQgKXtcblxuICAgICAgICBkaWN0aW9uYXJ5WyAnc3VjY2Vzc01lc3NhZ2VGcm9tU2VydmVyJyBdID0gJ0xvYWRpbmcuLi4nO1xuICAgIH07XG5cbiAgICBwYWdlWyAnaW5pdCcgXSA9IGZ1bmN0aW9uKCBldmVudCApe1xuXG4gICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGRpY3Rpb25hcnlbICdzdWNjZXNzTWVzc2FnZUZyb21TZXJ2ZXInIF0gPSAnSXQgd29ya3MhJztcbiAgICAgICAgICAgICAgICB6cHQucnVuKHtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbW1hbmQnOiAncGFydGlhbFJlbmRlcicsXG4gICAgICAgICAgICAgICAgICAgICd0YXJnZXQnOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggJ3JlbmRlcldhaXRpbmdGb3JTZXJ2ZXJfbWVzc2FnZScgKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDMwMFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gcGFnZTtcbn07XG4iLCIvKiByZW5kZXJXaXRob3V0V2FpdGluZyBwYWdlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCBkaWN0aW9uYXJ5ICkge1xuXG4gICAgY29uc3QgcGFnZSA9IHt9O1xuXG4gICAgcGFnZVsgJ3ByZUluaXQnIF0gPSBmdW5jdGlvbiggZXZlbnQgKXtcbiAgICAgICAgLy9hbGVydCggJ0VWRU5UX1BSRV9JTklUJyApO1xuXG4gICAgICAgIGRpY3Rpb25hcnlbICdzdWNjZXNzTWVzc2FnZScgXSA9ICdJdCB3b3JrcyEnO1xuICAgIH07XG5cbiAgICByZXR1cm4gcGFnZTtcbn07XG4iLCIvLyBUZXN0cyBmb3IgZXZlbnRzXG5cbnZhciB6eiA9IHJlcXVpcmUoICd6emRvbScgKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApO1xudmFyIFF1bml0ID0gcmVxdWlyZSggJ3F1bml0JyApO1xuXG4vLyBVbml0IHRlc3RzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIE5vbiB3YWl0aW5nIHJlbmRlciB0ZXN0XG4gICAgUVVuaXQudGVzdCggXCJOb24gd2FpdGluZyByZW5kZXIgdGVzdFwiLCBhc3luYyBmdW5jdGlvbiggYXNzZXJ0ICkge1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGEgcmVmZXJlbmNlIHRvIGZpbmlzaCB0aGUgcXVuaXQgdGVzdCBsYXRlclxuICAgICAgICB2YXIgZG9uZSA9IGFzc2VydC5hc3luYygpO1xuXG4gICAgICAgIC8vIEdvIHRvIHBhZ2UgcmVuZGVyV2l0aG91dFdhaXRpbmdcbiAgICAgICAgenooJyNob21lX3JlbmRlcldpdGhvdXRXYWl0aW5nTGluaycpLmVsLmNsaWNrKCk7XG4gICAgICAgIGF3YWl0IHV0aWxzLndhaXRTaG9ydCgpO1xuICAgICAgICBhc3NlcnQuZXF1YWwoIHp6KCcjcmVuZGVyV2l0aG91dFdhaXRpbmdfcCcpLnRleHQoKS50cmltKCkgLCBcIlRoaXMgaXMgUGFnZSByZW5kZXIgd2l0aG91dCB3YWl0aW5nXCIgKTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IHJlbmRlciBpcyBva1xuICAgICAgICBhc3NlcnQuZXF1YWwoIHp6KCcjcmVuZGVyV2l0aG91dFdhaXRpbmdfbWVzc2FnZScpLnRleHQoKS50cmltKCkgLCBcIkl0IHdvcmtzIVwiICk7XG5cbiAgICAgICAgLy8gR28gdG8gaG9tZSBwYWdlXG4gICAgICAgIHp6KCcjcmVuZGVyV2l0aG91dFdhaXRpbmdfaG9tZUxpbmsnKS5lbC5jbGljaygpO1xuICAgICAgICBhd2FpdCB1dGlscy53YWl0U2hvcnQoKTtcblxuICAgICAgICAvLyBGaW5pc2ggcXVuaXQgdGVzdFxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG5cbiAgICAvLyBXYWl0aW5nIGZvciBzZXJ2ZXIgcmVuZGVyIHRlc3RcbiAgICBRVW5pdC50ZXN0KCBcIldhaXRpbmcgZm9yIHNlcnZlciByZW5kZXIgdGVzdFwiLCBhc3luYyBmdW5jdGlvbiggYXNzZXJ0ICkge1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGEgcmVmZXJlbmNlIHRvIGZpbmlzaCB0aGUgcXVuaXQgdGVzdCBsYXRlclxuICAgICAgICB2YXIgZG9uZSA9IGFzc2VydC5hc3luYygpO1xuXG4gICAgICAgIC8vIEdvIHRvIHBhZ2UgcmVuZGVyV2l0aG91dFdhaXRpbmdcbiAgICAgICAgenooJyNob21lX3JlbmRlcldhaXRpbmdGb3JTZXJ2ZXJMaW5rJykuZWwuY2xpY2soKTtcbiAgICAgICAgYXdhaXQgdXRpbHMud2FpdFNob3J0KCk7XG4gICAgICAgIGFzc2VydC5lcXVhbCggenooJyNyZW5kZXJXYWl0aW5nRm9yU2VydmVyX3AnKS50ZXh0KCkudHJpbSgpICwgXCJUaGlzIGlzIFBhZ2UgcmVuZGVyIHdhaXRpbmcgZm9yIHNlcnZlclwiICk7XG4gICAgICAgIGF3YWl0IHV0aWxzLndhaXRTaG9ydCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZW5kZXIgaXMgb2tcbiAgICAgICAgYXNzZXJ0LmVxdWFsKCB6eignI3JlbmRlcldhaXRpbmdGb3JTZXJ2ZXJfbWVzc2FnZScpLnRleHQoKS50cmltKCkgLCBcIkl0IHdvcmtzIVwiICk7XG5cbiAgICAgICAgLy8gR28gdG8gaG9tZSBwYWdlXG4gICAgICAgIHp6KCcjcmVuZGVyV2FpdGluZ0ZvclNlcnZlcl9ob21lTGluaycpLmVsLmNsaWNrKCk7XG4gICAgICAgIGF3YWl0IHV0aWxzLndhaXRTaG9ydCgpO1xuXG4gICAgICAgIC8vIEZpbmlzaCBxdW5pdCB0ZXN0XG4gICAgICAgIGRvbmUoKTtcbiAgICB9KTtcblxufTtcbiIsIi8vIFJvdXRlcyBmb3IgaW5saW5lIGNvbnRlbnQgZm9yIHJlbmRlciB0ZXN0c1xuXG5jb25zdCByb3V0ZXMgPSBbXG4gICAgLy8gSG9tZSBwYWdlXG4gICAge1xuICAgICAgICBpZDogJ1tob21lXScsXG4gICAgICAgIGNvbnRlbnQ6IGBcbjxoMT5CbHVlIHJvdXRlciB0ZXN0PC9oMT5cblxuPGRpdiBjbGFzcz1cInBhZ2UtY29udGVudFwiPlxuPGgzPkhvbWUgcGFnZTwvaDM+XG48cD5cbiAgICBUaGlzIGlzIEhvbWUgcGFnZVxuPC9wPlxuXG48dWwgaWQ9XCJob21lX2xpbmtzXCI+XG4gICAgPGxpPlxuICAgICAgICA8YSBocmVmPVwiIXJlbmRlcldpdGhvdXRXYWl0aW5nXCIgaWQ9XCJob21lX3JlbmRlcldpdGhvdXRXYWl0aW5nTGlua1wiPlBhZ2UgcmVuZGVyIHdpdGhvdXQgd2FpdGluZzwvYT4uIEdvIHRvIHBhZ2UgcmVuZGVyIHdpdGhvdXQgd2FpdGluZy5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPGEgaHJlZj1cIiFyZW5kZXJXYWl0aW5nRm9yU2VydmVyXCIgaWQ9XCJob21lX3JlbmRlcldhaXRpbmdGb3JTZXJ2ZXJMaW5rXCI+UGFnZSByZW5kZXIgd2FpdGluZyBmb3Igc2VydmVyPC9hPi4gR28gdG8gcGFnZSByZW5kZXIgd2FpdGluZyBmb3Igc2VydmVyLlxuICAgIDwvbGk+XG48L3VsPlxuPC9kaXY+XG5gXG4gICAgfSxcbiAgICAvLyBwYWdlIHJlbmRlciB3aXRob3V0IHdhaXRpbmdcbiAgICB7XG4gICAgICAgIGlkOiAncmVuZGVyV2l0aG91dFdhaXRpbmcnLFxuICAgICAgICBjb250ZW50OiBgXG48aDE+Qmx1ZSByb3V0ZXIgdGVzdDwvaDE+XG5cbjxkaXY+XG48YSBocmVmPVwiIVwiIGlkPVwicmVuZGVyV2l0aG91dFdhaXRpbmdfaG9tZUxpbmtcIj5Ib21lPC9hPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cbjxoMz5QYWdlIHJlbmRlcjwvaDM+XG48cCBpZD1cInJlbmRlcldpdGhvdXRXYWl0aW5nX3BcIj5cbiAgICBUaGlzIGlzIFBhZ2UgcmVuZGVyIHdpdGhvdXQgd2FpdGluZ1xuPC9wPlxuXG48aDIgaWQ9XCJyZW5kZXJXaXRob3V0V2FpdGluZ19tZXNzYWdlXCIgZGF0YS1jb250ZW50PVwic3VjY2Vzc01lc3NhZ2VcIj5cbiAgICBOb3Qgd29ya2luZyFcbjwvaDI+XG48L2Rpdj5cbmBcbiAgICB9LFxuICAgIC8vIHBhZ2UgcmVuZGVyIHdhaXRpbmcgZm9yIHNlcnZlclxuICAgIHtcbiAgICAgICAgaWQ6ICdyZW5kZXJXYWl0aW5nRm9yU2VydmVyJyxcbiAgICAgICAgY29udGVudDogYFxuPGgxPkJsdWUgcm91dGVyIHRlc3Q8L2gxPlxuXG48ZGl2PlxuPGEgaHJlZj1cIiFcIiBpZD1cInJlbmRlcldhaXRpbmdGb3JTZXJ2ZXJfaG9tZUxpbmtcIj5Ib21lPC9hPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cbjxoMz5QYWdlIHJlbmRlcjwvaDM+XG48cCBpZD1cInJlbmRlcldhaXRpbmdGb3JTZXJ2ZXJfcFwiPlxuICAgIFRoaXMgaXMgUGFnZSByZW5kZXIgd2FpdGluZyBmb3Igc2VydmVyXG48L3A+XG5cbjxoMiBpZD1cInJlbmRlcldhaXRpbmdGb3JTZXJ2ZXJfbWVzc2FnZVwiIGRhdGEtY29udGVudD1cInN1Y2Nlc3NNZXNzYWdlRnJvbVNlcnZlclwiPlxuICAgIE5vdCB3b3JraW5nIVxuPC9oMj5cbjwvZGl2PlxuYFxuICAgIH0sXG4gICAgLy8gRGVmYXVsdCByb3V0ZSAoNDA0IHBhZ2UpXG4gICAge1xuICAgICAgICBpZDogJ1s0MDRdJyxcbiAgICAgICAgY29udGVudDogYFxuPGgxPkJsdWUgcm91dGVyIHRlc3Q8L2gxPlxuXG48ZGl2PlxuPGEgaHJlZj1cIiFcIiBpZD1cImU0MDRfaG9tZUxpbmtcIj5Ib21lPC9hPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJwYWdlLWNvbnRlbnRcIj5cbjxoMz40MDQgcGFnZTwvaDM+XG48cD5cbiAgICBTb3JyeVxuPC9wPlxuPHAgaWQ9XCJlNDA0X3BcIj5cbiAgICBSZXF1ZXN0ZWQgY29udGVudCBub3QgZm91bmQuXG48L3A+XG48L2Rpdj5cbmBcbiAgICB9XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvdXRlcztcblxuXG4iLCJjb25zdCB1dGlscyA9IHt9O1xuXG51dGlscy53YWl0U2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbHMud2FpdCggMTAwMCApO1xufTtcblxudXRpbHMud2FpdCA9IGZ1bmN0aW9uKCB0aW1lb3V0ICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoIHJlc29sdmUsIHRpbWVvdXQgKTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbHM7XG5cbiJdfQ==
